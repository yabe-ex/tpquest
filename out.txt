===== ./StartPlayerScripts/Minimap.client.lua =====
-- StarterPlayer/StarterPlayerScripts/Minimap.client.lua
-- ãƒŸãƒ‹ãƒãƒƒãƒ—ã‚·ã‚¹ãƒ†ãƒ ï¼ˆã‚ºãƒ¼ãƒ æ©Ÿèƒ½ãƒ»ãƒãƒ¼ã‚¿ãƒ«è¡¨ç¤ºå¯¾å¿œç‰ˆï¼‰

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

print("[Minimap] åˆæœŸåŒ–é–‹å§‹")

-- ã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«è¨­å®š
local ZOOM_LEVELS = {
	{
		name = "è©³ç´°",
		scale = 2,           -- 2ã‚¹ã‚¿ãƒƒãƒ‰/ãƒ”ã‚¯ã‚»ãƒ«
		terrainGrid = 45,    -- 60â†’45ã«å‰Šæ¸›ï¼ˆè² è·è»½æ¸›ï¼‰
		terrainUpdateInterval = 0.25,  -- 0.15ç§’ â†’ 0.25ç§’ï¼ˆæ›´æ–°é »åº¦ã‚’ä¸‹ã’ã‚‹ï¼‰
		iconUpdateInterval = 0.05,
		monsterIconSize = 7,
		portalIconSize = 9,
	},
	{
		name = "ä¸­é–“",
		scale = 4,           -- 4ã‚¹ã‚¿ãƒƒãƒ‰/ãƒ”ã‚¯ã‚»ãƒ«
		terrainGrid = 50,    -- 50x50ã‚°ãƒªãƒƒãƒ‰
		terrainUpdateInterval = 0.25,
		iconUpdateInterval = 0.05,
		monsterIconSize = 5,
		portalIconSize = 7,
	},
	{
		name = "åºƒåŸŸ",
		scale = 8,           -- 8ã‚¹ã‚¿ãƒƒãƒ‰/ãƒ”ã‚¯ã‚»ãƒ«
		terrainGrid = 40,    -- 40x40ã‚°ãƒªãƒƒãƒ‰ï¼ˆåºƒåŸŸã¯è² è·è»½æ¸›ï¼‰
		terrainUpdateInterval = 0.4,
		iconUpdateInterval = 0.08,
		monsterIconSize = 3,
		portalIconSize = 5,
	},
}

local currentZoomLevel = 1

-- ç¾åœ¨ã®è¨­å®šã‚’å–å¾—
local function getCurrentSettings()
	return ZOOM_LEVELS[currentZoomLevel]
end

-- åŸºæœ¬è¨­å®š
local MINIMAP_SIZE = 200
local WATER_LEVEL = -15

-- è‰²è¨­å®š
local LAND_COLOR = Color3.fromRGB(50, 70, 50)
local SEA_COLOR = Color3.fromRGB(30, 30, 30)
local PLAYER_COLOR = Color3.fromRGB(100, 200, 255)
local MONSTER_COLOR = Color3.fromRGB(255, 50, 50)
local PORTAL_TOWN_COLOR = Color3.fromRGB(255, 200, 100)
local PORTAL_OTHER_COLOR = Color3.fromRGB(200, 100, 255)

-- ScreenGuiä½œæˆ
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "MinimapUI"
screenGui.ResetOnSpawn = false
screenGui.IgnoreGuiInset = true
screenGui.Parent = playerGui

-- ãƒŸãƒ‹ãƒãƒƒãƒ—ã®èƒŒæ™¯ãƒ•ãƒ¬ãƒ¼ãƒ 
local minimapFrame = Instance.new("Frame")
minimapFrame.Name = "MinimapFrame"
minimapFrame.Size = UDim2.new(0, MINIMAP_SIZE, 0, MINIMAP_SIZE)
minimapFrame.Position = UDim2.new(0, 20, 1, -MINIMAP_SIZE - 20)
minimapFrame.BackgroundColor3 = SEA_COLOR
minimapFrame.BackgroundTransparency = 0.3
minimapFrame.BorderSizePixel = 2
minimapFrame.BorderColor3 = Color3.fromRGB(255, 255, 255)
minimapFrame.Parent = screenGui

local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(0, 8)
corner.Parent = minimapFrame

-- åœ°å½¢ãƒ¬ã‚¤ãƒ¤ãƒ¼
local terrainLayer = Instance.new("Frame")
terrainLayer.Name = "TerrainLayer"
terrainLayer.Size = UDim2.new(1, 0, 1, 0)
terrainLayer.BackgroundTransparency = 1
terrainLayer.ClipsDescendants = true
terrainLayer.ZIndex = 1
terrainLayer.Parent = minimapFrame

-- ã‚¿ã‚¤ãƒˆãƒ«ï¼ˆã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«è¡¨ç¤ºï¼‰
local titleLabel = Instance.new("TextLabel")
titleLabel.Name = "Title"
titleLabel.Size = UDim2.new(1, 0, 0, 20)
titleLabel.Position = UDim2.new(0, 0, 0, -25)
titleLabel.BackgroundTransparency = 1
titleLabel.Text = "MAP [Z: è©³ç´°]"
titleLabel.TextColor3 = Color3.new(1, 1, 1)
titleLabel.TextSize = 14
titleLabel.Font = Enum.Font.SourceSansBold
titleLabel.TextStrokeTransparency = 0.5
titleLabel.Parent = minimapFrame

-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¢ã‚¤ã‚³ãƒ³ï¼ˆç¸¦é•·ã®çŸ¢å°å‹ï¼‰
local playerIconContainer = Instance.new("Frame")
playerIconContainer.Name = "PlayerIconContainer"
playerIconContainer.Size = UDim2.new(0, 12, 0, 18)
playerIconContainer.AnchorPoint = Vector2.new(0.5, 0.5)
playerIconContainer.Position = UDim2.new(0.5, 0, 0.5, 0)
playerIconContainer.BackgroundTransparency = 1
playerIconContainer.ZIndex = 10
playerIconContainer.Parent = minimapFrame

-- çŸ¢å°ã®å…ˆç«¯ï¼ˆå°ã•ã„å››è§’ï¼‰
local arrowTip = Instance.new("Frame")
arrowTip.Name = "ArrowTip"
arrowTip.Size = UDim2.new(0, 2, 0, 4)
arrowTip.Position = UDim2.new(0.5, 0, 0, 0)
arrowTip.AnchorPoint = Vector2.new(0.5, 0)
arrowTip.BackgroundColor3 = PLAYER_COLOR
arrowTip.BorderSizePixel = 0
arrowTip.ZIndex = 10
arrowTip.Parent = playerIconContainer

-- çŸ¢å°ã®ä¸­å¤®éƒ¨åˆ†
local arrowMiddle = Instance.new("Frame")
arrowMiddle.Name = "ArrowMiddle"
arrowMiddle.Size = UDim2.new(0, 4, 0, 6)
arrowMiddle.Position = UDim2.new(0.5, 0, 0, 3)
arrowMiddle.AnchorPoint = Vector2.new(0.5, 0)
arrowMiddle.BackgroundColor3 = PLAYER_COLOR
arrowMiddle.BorderSizePixel = 0
arrowMiddle.ZIndex = 10
arrowMiddle.Parent = playerIconContainer

-- çŸ¢å°ã®ä¸‹éƒ¨ï¼ˆåºƒã„éƒ¨åˆ†ï¼‰
local arrowBottom = Instance.new("Frame")
arrowBottom.Name = "ArrowBottom"
arrowBottom.Size = UDim2.new(0, 6, 0, 4)
arrowBottom.Position = UDim2.new(0.5, 0, 0, 9)
arrowBottom.AnchorPoint = Vector2.new(0.5, 0)
arrowBottom.BackgroundColor3 = PLAYER_COLOR
arrowBottom.BorderSizePixel = 0
arrowBottom.ZIndex = 10
arrowBottom.Parent = playerIconContainer

local playerIcon = playerIconContainer

-- ã‚¢ã‚¤ã‚³ãƒ³ã‚’æ ¼ç´ã™ã‚‹ãƒ•ã‚©ãƒ«ãƒ€
local monstersFolder = Instance.new("Folder")
monstersFolder.Name = "MonsterIcons"
monstersFolder.Parent = minimapFrame

local portalsFolder = Instance.new("Folder")
portalsFolder.Name = "PortalIcons"
portalsFolder.Parent = minimapFrame

-- åœ°å½¢ã‚¿ã‚¤ãƒ«ã®ãƒ—ãƒ¼ãƒ«
local terrainTilePool = {}
local activeTiles = {}

local function getTerrainTile()
	for _, tile in ipairs(terrainTilePool) do
		if not tile.Visible then
			tile.Visible = true
			return tile
		end
	end

	local tile = Instance.new("Frame")
	tile.Name = "TerrainTile"
	tile.BackgroundColor3 = LAND_COLOR
	tile.BackgroundTransparency = 0.2
	tile.BorderSizePixel = 0
	tile.ZIndex = 2
	tile.Parent = terrainLayer

	table.insert(terrainTilePool, tile)
	return tile
end

local function hideAllTerrainTiles()
	for _, tile in ipairs(terrainTilePool) do
		tile.Visible = false
	end
	activeTiles = {}
end

-- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚¢ã‚¤ã‚³ãƒ³ã®ãƒ—ãƒ¼ãƒ«
local monsterIconPool = {}

local function getMonsterIcon(size)
	for _, icon in ipairs(monsterIconPool) do
		if not icon.Visible then
			icon.Visible = true
			icon.Size = UDim2.new(0, size, 0, size)
			return icon
		end
	end

	local icon = Instance.new("Frame")
	icon.Name = "MonsterIcon"
	icon.Size = UDim2.new(0, size, 0, size)
	icon.AnchorPoint = Vector2.new(0.5, 0.5)
	icon.BackgroundColor3 = MONSTER_COLOR
	icon.BorderSizePixel = 0
	icon.ZIndex = 5
	icon.Parent = monstersFolder

	local iconCorner = Instance.new("UICorner")
	iconCorner.CornerRadius = UDim.new(1, 0)
	iconCorner.Parent = icon

	table.insert(monsterIconPool, icon)
	return icon
end

local function hideAllMonsterIcons()
	for _, icon in ipairs(monsterIconPool) do
		icon.Visible = false
	end
end

-- ãƒãƒ¼ã‚¿ãƒ«ã‚¢ã‚¤ã‚³ãƒ³ã®ãƒ—ãƒ¼ãƒ«
local portalIconPool = {}

local function getPortalIcon(size)
	for _, icon in ipairs(portalIconPool) do
		if not icon.Visible then
			icon.Visible = true
			icon.Size = UDim2.new(0, size, 0, size)
			return icon
		end
	end

	local icon = Instance.new("Frame")
	icon.Name = "PortalIcon"
	icon.Size = UDim2.new(0, size, 0, size)
	icon.AnchorPoint = Vector2.new(0.5, 0.5)
	icon.BackgroundColor3 = PORTAL_OTHER_COLOR
	icon.BorderSizePixel = 0
	icon.ZIndex = 6
	icon.Parent = portalsFolder

	local iconCorner = Instance.new("UICorner")
	iconCorner.CornerRadius = UDim.new(1, 0)
	iconCorner.Parent = icon

	table.insert(portalIconPool, icon)
	return icon
end

local function hideAllPortalIcons()
	for _, icon in ipairs(portalIconPool) do
		icon.Visible = false
	end
end

-- ãƒ¬ã‚¤ã‚­ãƒ£ã‚¹ãƒˆã§åœ°å½¢ãƒã‚§ãƒƒã‚¯
local function isLand(worldX, worldZ)
	local params = RaycastParams.new()
	params.FilterType = Enum.RaycastFilterType.Include
	params.FilterDescendantsInstances = {workspace.Terrain}
	params.IgnoreWater = false

	local origin = Vector3.new(worldX, 200, worldZ)
	local direction = Vector3.new(0, -250, 0)

	local result = workspace:Raycast(origin, direction, params)

	if result then
		if result.Material == Enum.Material.Water then
			return false
		end
		if result.Position.Y > WATER_LEVEL then
			return true
		end
	end

	return false
end

-- åœ°å½¢ãƒãƒƒãƒ—ã‚’æ›´æ–°
local lastTerrainUpdate = 0
local lastPlayerPos = nil

local function updateTerrainMap()
	local settings = getCurrentSettings()
	local now = os.clock()

	if now - lastTerrainUpdate < settings.terrainUpdateInterval then
		return
	end

	local character = player.Character
	if not character then return end

	local hrp = character:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	local playerPos = hrp.Position

	-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒã‚ã¾ã‚Šå‹•ã„ã¦ã„ãªã‘ã‚Œã°ã‚¹ã‚­ãƒƒãƒ—
	if lastPlayerPos then
		local distance = (playerPos - lastPlayerPos).Magnitude
		-- è©³ç´°ãƒ¢ãƒ¼ãƒ‰ã¯ç§»å‹•è·é›¢ã®é–¾å€¤ã‚’ä¸Šã’ã‚‹ï¼ˆé »ç¹ã«æ›´æ–°ã—ãªã„ï¼‰
		local threshold = (settings.name == "è©³ç´°") and 8 or 5
		if distance < threshold then
			return
		end
	end

	lastTerrainUpdate = now
	lastPlayerPos = playerPos

	-- ãƒãƒ©ã¤ãé˜²æ­¢ï¼šå¤ã„ã‚¿ã‚¤ãƒ«ã¯æ®‹ã—ãŸã¾ã¾ã€æ–°ã—ã„ã‚¿ã‚¤ãƒ«ã‚’é…ç½®
	local tileSize = MINIMAP_SIZE / settings.terrainGrid
	local newActiveTiles = {}
	local usedTileIndex = 1

	-- ä¸€æ°—ã«å‡¦ç†ï¼ˆtask.wait()ãªã—ï¼‰
	for gridX = 0, settings.terrainGrid - 1 do
		for gridZ = 0, settings.terrainGrid - 1 do
			local mapX = (gridX + 0.5) / settings.terrainGrid
			local mapZ = (gridZ + 0.5) / settings.terrainGrid

			local relativeX = (mapX - 0.5) * MINIMAP_SIZE * settings.scale
			local relativeZ = -(mapZ - 0.5) * MINIMAP_SIZE * settings.scale

			local worldX = playerPos.X + relativeX
			local worldZ = playerPos.Z + relativeZ

			-- åœ°å½¢ãƒã‚§ãƒƒã‚¯
			if isLand(worldX, worldZ) then
				local tile = getTerrainTile()
				tile.Size = UDim2.new(0, tileSize + 1, 0, tileSize + 1)
				tile.Position = UDim2.new(0, gridX * tileSize, 0, gridZ * tileSize)
				table.insert(newActiveTiles, tile)
			end
		end
	end

	-- å¤ã„ã‚¿ã‚¤ãƒ«ã‚’éè¡¨ç¤ºï¼ˆæ–°ã—ã„ã‚¿ã‚¤ãƒ«ã‚’è¡¨ç¤ºã—ãŸå¾Œï¼‰
	for _, tile in ipairs(activeTiles) do
		local isStillActive = false
		for _, newTile in ipairs(newActiveTiles) do
			if tile == newTile then
				isStillActive = true
				break
			end
		end
		if not isStillActive then
			tile.Visible = false
		end
	end

	activeTiles = newActiveTiles

	-- print(("[Minimap] åœ°å½¢ãƒãƒƒãƒ—æ›´æ–°å®Œäº†: é™¸=%d"):format(#activeTiles))
end

-- ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ã‚’ãƒŸãƒ‹ãƒãƒƒãƒ—åº§æ¨™ã«å¤‰æ›
local function worldToMinimap(worldPos, playerPos)
	local settings = getCurrentSettings()

	local relativeX = worldPos.X - playerPos.X
	local relativeZ = worldPos.Z - playerPos.Z

	local minimapX = (relativeX / settings.scale)
	local minimapZ = -(relativeZ / settings.scale)

	local normalizedX = 0.5 + (minimapX / MINIMAP_SIZE)
	local normalizedZ = 0.5 + (minimapZ / MINIMAP_SIZE)

	return normalizedX, normalizedZ
end

local function isInRange(worldPos, playerPos)
	local settings = getCurrentSettings()
	local range = (MINIMAP_SIZE * settings.scale) / 2

	local dx = worldPos.X - playerPos.X
	local dz = worldPos.Z - playerPos.Z
	local distance = math.sqrt(dx * dx + dz * dz)
	return distance <= range
end

-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¢ã‚¤ã‚³ãƒ³ã®å‘ãã‚’æ›´æ–°
local function updatePlayerRotation()
	local character = player.Character
	if not character then return end

	local hrp = character:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å‘ãã‚’å–å¾—ï¼ˆCFrameã®LookVectorï¼‰
	local lookVector = hrp.CFrame.LookVector

	-- ãƒŸãƒ‹ãƒãƒƒãƒ—ä¸Šã®è§’åº¦ã«å¤‰æ›ï¼ˆä¸ŠãŒ0åº¦ã€æ™‚è¨ˆå›ã‚Šï¼‰
	-- LookVectorã®Xã¨Zã‹ã‚‰è§’åº¦ã‚’è¨ˆç®—
	local angle = math.atan2(lookVector.X, lookVector.Z)
	local degrees = math.deg(angle)

	-- ã‚³ãƒ³ãƒ†ãƒŠã®Rotationã‚’æ›´æ–°
	playerIcon.Rotation = degrees
end

-- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚¢ã‚¤ã‚³ãƒ³ã‚’æ›´æ–°
local lastIconUpdate = 0
local function updateMonsterIcons()
	local settings = getCurrentSettings()
	local now = os.clock()

	if now - lastIconUpdate < settings.iconUpdateInterval then
		return
	end
	lastIconUpdate = now

	local character = player.Character
	if not character then return end

	local hrp = character:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	local playerPos = hrp.Position

	hideAllMonsterIcons()

	-- Monstersãƒ•ã‚©ãƒ«ãƒ€ã‹ã‚‰å–å¾—
	local monstersWorkspace = workspace:FindFirstChild("Monsters")
	if monstersWorkspace then
		for _, model in ipairs(monstersWorkspace:GetChildren()) do
			if model:IsA("Model") then
				local monsterHrp = model:FindFirstChild("HumanoidRootPart")
				if monsterHrp then
					local monsterPos = monsterHrp.Position
					if isInRange(monsterPos, playerPos) then
						local mapX, mapZ = worldToMinimap(monsterPos, playerPos)
						if mapX >= 0 and mapX <= 1 and mapZ >= 0 and mapZ <= 1 then
							local icon = getMonsterIcon(settings.monsterIconSize)
							icon.Position = UDim2.new(mapX, 0, mapZ, 0)
						end
					end
				end
			end
		end
	end

	-- æ—§å½¢å¼ï¼ˆIsEnemyå±æ€§ï¼‰ã«ã‚‚å¯¾å¿œ
	for _, model in ipairs(workspace:GetChildren()) do
		if model:IsA("Model") and model:GetAttribute("IsEnemy") then
			local monsterHrp = model:FindFirstChild("HumanoidRootPart")
			if monsterHrp then
				local monsterPos = monsterHrp.Position
				if isInRange(monsterPos, playerPos) then
					local mapX, mapZ = worldToMinimap(monsterPos, playerPos)
					if mapX >= 0 and mapX <= 1 and mapZ >= 0 and mapZ <= 1 then
						local icon = getMonsterIcon(settings.monsterIconSize)
						icon.Position = UDim2.new(mapX, 0, mapZ, 0)
					end
				end
			end
		end
	end

	-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å‘ãã‚’æ›´æ–°
	updatePlayerRotation()
end

-- ãƒãƒ¼ã‚¿ãƒ«ã‚¢ã‚¤ã‚³ãƒ³ã‚’æ›´æ–°
local portalDebugDone = false
local function updatePortalIcons()
	local settings = getCurrentSettings()
	local character = player.Character
	if not character then return end

	local hrp = character:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	local playerPos = hrp.Position

	hideAllPortalIcons()

	-- ãƒ‡ãƒãƒƒã‚°: ãƒãƒ¼ã‚¿ãƒ«ã®é…ç½®å ´æ‰€ã‚’ç¢ºèª
	if not portalDebugDone then
		print("[Minimap DEBUG] ãƒãƒ¼ã‚¿ãƒ«æ¤œç´¢é–‹å§‹")

		-- workspace.Worldã®ä¸­èº«ã‚’ç¢ºèª
		local worldFolder = workspace:FindFirstChild("World")
		if worldFolder then
			print("[Minimap DEBUG] workspace.Worldç™ºè¦‹: " .. #worldFolder:GetChildren() .. "å€‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ")
			local portalCount = 0
			for _, obj in ipairs(worldFolder:GetChildren()) do
				local toZone = obj:GetAttribute("ToZone")
				if toZone then
					portalCount = portalCount + 1
					print("[Minimap DEBUG]   - " .. obj.Name .. " â†’ " .. toZone .. " (Pos: " .. tostring(obj.Position) .. ")")
				end
			end
			print("[Minimap DEBUG] ãƒãƒ¼ã‚¿ãƒ«ç·æ•°: " .. portalCount)
		else
			print("[Minimap DEBUG] workspace.WorldãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
		end

		portalDebugDone = true
	end

	-- workspace.Worldã‹ã‚‰ãƒãƒ¼ã‚¿ãƒ«ã‚’å–å¾—
	local worldFolder = workspace:FindFirstChild("World")
	if worldFolder then
		for _, portal in ipairs(worldFolder:GetChildren()) do
			-- ToZoneå±æ€§ãŒã‚ã‚‹ã‚‚ã®ã‚’ãƒãƒ¼ã‚¿ãƒ«ã¨ã—ã¦èªè­˜
			if portal:IsA("BasePart") and portal:GetAttribute("ToZone") then
				local portalPos = portal.Position
				if isInRange(portalPos, playerPos) then
					local mapX, mapZ = worldToMinimap(portalPos, playerPos)
					if mapX >= 0 and mapX <= 1 and mapZ >= 0 and mapZ <= 1 then
						local icon = getPortalIcon(settings.portalIconSize)
						icon.Position = UDim2.new(mapX, 0, mapZ, 0)

						-- Townã¸ã®ãƒãƒ¼ã‚¿ãƒ«ã‹ãã‚Œä»¥å¤–ã‹ã§è‰²åˆ†ã‘
						local toZone = portal:GetAttribute("ToZone")
						if toZone == "StartTown" then
							-- Townã¸ã®ãƒãƒ¼ã‚¿ãƒ« â†’ ã‚ªãƒ¬ãƒ³ã‚¸
							icon.BackgroundColor3 = PORTAL_TOWN_COLOR
						else
							-- ãã‚Œä»¥å¤–ï¼ˆä»–ã®å¤§é™¸ã¸ï¼‰ â†’ ãƒãƒ¼ã‚¿ãƒ«ã®è‰²ã¾ãŸã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆç´«
							icon.BackgroundColor3 = portal.Color or PORTAL_OTHER_COLOR
						end
					end
				end
			end
		end
	end
end

-- ã‚ºãƒ¼ãƒ åˆ‡ã‚Šæ›¿ãˆ
local function changeZoomLevel(delta)
	currentZoomLevel = math.clamp(currentZoomLevel + delta, 1, #ZOOM_LEVELS)
	local settings = getCurrentSettings()

	titleLabel.Text = "MAP [Z: " .. settings.name .. "]"

	-- åœ°å½¢ãƒãƒƒãƒ—ã‚’å³åº§ã«æ›´æ–°
	lastTerrainUpdate = 0
	lastPlayerPos = nil

	print("[Minimap] ã‚ºãƒ¼ãƒ å¤‰æ›´: " .. settings.name)
end

-- ãƒã‚¦ã‚¹ãƒ›ã‚¤ãƒ¼ãƒ«å…¥åŠ›
UserInputService.InputChanged:Connect(function(input, gameProcessed)
	if gameProcessed then return end

	if input.UserInputType == Enum.UserInputType.MouseWheel then
		local mousePos = UserInputService:GetMouseLocation()
		local framePos = minimapFrame.AbsolutePosition
		local frameSize = minimapFrame.AbsoluteSize

		if mousePos.X >= framePos.X and mousePos.X <= framePos.X + frameSize.X and
			mousePos.Y >= framePos.Y and mousePos.Y <= framePos.Y + frameSize.Y then
			if input.Position.Z > 0 then
				changeZoomLevel(-1)
			else
				changeZoomLevel(1)
			end
		end
	end
end)

-- Zã‚­ãƒ¼å…¥åŠ›
UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then return end

	if input.KeyCode == Enum.KeyCode.Z then
		local nextLevel = currentZoomLevel + 1
		if nextLevel > #ZOOM_LEVELS then
			nextLevel = 1
		end
		changeZoomLevel(nextLevel - currentZoomLevel)
	end
end)

-- ãƒ¡ã‚¤ãƒ³æ›´æ–°ãƒ«ãƒ¼ãƒ—
RunService.Heartbeat:Connect(function()
	updateTerrainMap()
	updateMonsterIcons()
end)

-- ãƒãƒ¼ã‚¿ãƒ«å°‚ç”¨ã®é«˜é€Ÿæ›´æ–°ãƒ«ãƒ¼ãƒ—ï¼ˆç‹¬ç«‹ï¼‰
task.spawn(function()
	while true do
		task.wait(0.1)  -- 0.1ç§’ã”ã¨ã«æ›´æ–°ï¼ˆé«˜é€Ÿï¼‰
		updatePortalIcons()
	end
end)

-- åˆæœŸåŒ–æ™‚ã«å³åº§ã«ãƒãƒ¼ã‚¿ãƒ«ã‚’æ¤œç´¢
task.spawn(function()
	task.wait(0.5)  -- å°‘ã—å¾…ã£ã¦ã‹ã‚‰ãƒãƒ¼ã‚¿ãƒ«æ¤œç´¢
	updatePortalIcons()
end)

-- workspace.Worldã®å¤‰åŒ–ã‚’ç›£è¦–ï¼ˆãƒãƒ¼ã‚¿ãƒ«è¿½åŠ æ™‚ã«å³åæ˜ ï¼‰
task.spawn(function()
	local worldFolder = workspace:WaitForChild("World", 10)
	if worldFolder then
		worldFolder.ChildAdded:Connect(function(child)
			if child:IsA("BasePart") and child:GetAttribute("ToZone") then
				print("[Minimap] æ–°ã—ã„ãƒãƒ¼ã‚¿ãƒ«æ¤œå‡º: " .. child.Name)
				task.wait(0.1)
				updatePortalIcons()
			end
		end)
	end
end)

print("[Minimap] åˆæœŸåŒ–å®Œäº†ï¼ˆã‚ºãƒ¼ãƒ æ©Ÿèƒ½ä»˜ãï¼‰")
===== ./StartPlayerScripts/MenuUI.client.lua =====
-- StarterPlayer/StarterPlayerScripts/MenuUI.client.lua
-- ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚·ã‚¹ãƒ†ãƒ ï¼ˆã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã€ã‚¢ã‚¤ãƒ†ãƒ ã€ã‚¹ã‚­ãƒ«ç­‰ï¼‰

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

print("[MenuUI] åˆæœŸåŒ–ä¸­...")

-- çŠ¶æ…‹ç®¡ç†
local currentModal = nil
local isInBattle = false

-- RemoteEventå–å¾—
local RequestStatusEvent = ReplicatedStorage:WaitForChild("RequestStatus", 10)

-- UIã‚³ãƒ³ãƒ†ãƒŠ
local menuGui = nil
local menuFrame = nil

-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚­ãƒ£ãƒƒã‚·ãƒ¥
local cachedStats = {
	Level = 1,
	MaxHP = 100,
	CurrentHP = 100,
	Speed = 10,
	Attack = 10,
	Defense = 10,
	Gold = 0,
	MonstersDefeated = 0
}

-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°ã‚’å—ä¿¡
local StatusUpdateEvent = ReplicatedStorage:FindFirstChild("StatusUpdate")
if StatusUpdateEvent then
	StatusUpdateEvent.OnClientEvent:Connect(function(hp, maxHP, level, exp, expToNext, gold)
		cachedStats.CurrentHP = hp or cachedStats.CurrentHP
		cachedStats.MaxHP = maxHP or cachedStats.MaxHP
		cachedStats.Level = level or cachedStats.Level
		cachedStats.Gold = gold or cachedStats.Gold
	end)
end

-- æˆ¦æ­´æ›´æ–°ã‚’å—ä¿¡ï¼ˆç¢ºå®Ÿã«æ¥ç¶šï¼‰
task.spawn(function()
	print("[MenuUI] StatsDetailã‚¤ãƒ™ãƒ³ãƒˆæ¥ç¶šã‚’é–‹å§‹...")

	local StatsDetailEvent = ReplicatedStorage:WaitForChild("StatsDetail", 30)
	if not StatsDetailEvent then
		warn("[MenuUI] StatsDetailã‚¤ãƒ™ãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ï¼")
		return
	end

	print("[MenuUI] StatsDetailã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºè¦‹ã—ã¾ã—ãŸ")

	StatsDetailEvent.OnClientEvent:Connect(function(stats)
		print("[MenuUI] ========================================")
		print("[MenuUI] ğŸ¯ StatsDetailå—ä¿¡ã‚¤ãƒ™ãƒ³ãƒˆç™ºç«ï¼")
		print("[MenuUI] å—ä¿¡ã—ãŸãƒ‡ãƒ¼ã‚¿:")
		if stats then
			print("[MenuUI] stats.MonstersDefeated =", stats.MonstersDefeated)
			print("[MenuUI] stats.Level =", stats.Level)
			print("[MenuUI] stats.Gold =", stats.Gold)

			for key, value in pairs(stats) do
				cachedStats[key] = value
			end

			print("[MenuUI] âœ… ã‚­ãƒ£ãƒƒã‚·ãƒ¥æ›´æ–°å®Œäº†")
			print("[MenuUI] cachedStats.MonstersDefeated =", cachedStats.MonstersDefeated)
		else
			warn("[MenuUI] âŒ statsãŒnilã§ã™ï¼")
		end
		print("[MenuUI] ========================================")
	end)

	print("[MenuUI] StatsDetailã‚¤ãƒ™ãƒ³ãƒˆæ¥ç¶šå®Œäº†")
end)

-- ãƒãƒˆãƒ«çŠ¶æ…‹ã‚’ç›£è¦–
local BattleStartEvent = ReplicatedStorage:FindFirstChild("BattleStart")
local BattleEndEvent = ReplicatedStorage:FindFirstChild("BattleEnd")

if BattleStartEvent then
	BattleStartEvent.OnClientEvent:Connect(function()
		isInBattle = true
		if menuFrame then
			for _, button in ipairs(menuFrame:GetChildren()) do
				if button:IsA("TextButton") then
					button.Active = false
					button.BackgroundTransparency = 0.7
					button.TextTransparency = 0.5
				end
			end
		end
		if currentModal then
			closeModal()
		end
	end)
end

if BattleEndEvent then
	BattleEndEvent.OnClientEvent:Connect(function()
		isInBattle = false
		if menuFrame then
			for _, button in ipairs(menuFrame:GetChildren()) do
				if button:IsA("TextButton") then
					button.Active = true
					button.BackgroundTransparency = 0.2
					button.TextTransparency = 0
				end
			end
		end
	end)
end

-- ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’é–‰ã˜ã‚‹
function closeModal()
	if currentModal then
		local background = currentModal:FindFirstChild("Background")
		if background then
			local tween = TweenService:Create(background, TweenInfo.new(0.2), {
				BackgroundTransparency = 1
			})
			tween:Play()
		end

		local panel = currentModal:FindFirstChild("Panel")
		if panel then
			local tween = TweenService:Create(panel, TweenInfo.new(0.2), {
				BackgroundTransparency = 1
			})
			tween:Play()

			for _, child in ipairs(panel:GetDescendants()) do
				if child:IsA("TextLabel") or child:IsA("TextButton") then
					TweenService:Create(child, TweenInfo.new(0.2), {
						TextTransparency = 1
					}):Play()
				end
			end
		end

		task.wait(0.2)
		currentModal:Destroy()
		currentModal = nil
	end
end

-- ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’ä½œæˆ
local function createModal(title, contentBuilder)
	if currentModal then
		closeModal()
	end

	local modal = Instance.new("ScreenGui")
	modal.Name = "ModalUI"
	modal.ResetOnSpawn = false
	modal.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	modal.Parent = playerGui

	-- èƒŒæ™¯ï¼ˆæš—è»¢ï¼‰
	local background = Instance.new("Frame")
	background.Name = "Background"
	background.Size = UDim2.fromScale(1, 1)
	background.BackgroundColor3 = Color3.new(0, 0, 0)
	background.BackgroundTransparency = 1
	background.BorderSizePixel = 0
	background.ZIndex = 50
	background.Parent = modal

	TweenService:Create(background, TweenInfo.new(0.2), {
		BackgroundTransparency = 0.5
	}):Play()

	-- ãƒ‘ãƒãƒ«
	local panel = Instance.new("Frame")
	panel.Name = "Panel"
	panel.Size = UDim2.new(0, 500, 0, 400)
	panel.Position = UDim2.fromScale(0.5, 0.5)
	panel.AnchorPoint = Vector2.new(0.5, 0.5)
	panel.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
	panel.BackgroundTransparency = 1
	panel.BorderSizePixel = 0
	panel.ZIndex = 51
	panel.Parent = modal

	TweenService:Create(panel, TweenInfo.new(0.2), {
		BackgroundTransparency = 0.1
	}):Play()

	local panelCorner = Instance.new("UICorner")
	panelCorner.CornerRadius = UDim.new(0, 12)
	panelCorner.Parent = panel

	-- ã‚¿ã‚¤ãƒˆãƒ«
	local titleLabel = Instance.new("TextLabel")
	titleLabel.Name = "Title"
	titleLabel.Size = UDim2.new(1, -20, 0, 40)
	titleLabel.Position = UDim2.new(0, 10, 0, 10)
	titleLabel.BackgroundTransparency = 1
	titleLabel.TextColor3 = Color3.fromRGB(255, 215, 0)
	titleLabel.TextStrokeTransparency = 0.5
	titleLabel.Font = Enum.Font.GothamBold
	titleLabel.TextSize = 24
	titleLabel.Text = title
	titleLabel.TextXAlignment = Enum.TextXAlignment.Left
	titleLabel.TextTransparency = 1
	titleLabel.ZIndex = 52
	titleLabel.Parent = panel

	TweenService:Create(titleLabel, TweenInfo.new(0.2), {
		TextTransparency = 0,
		TextStrokeTransparency = 0.5
	}):Play()

	-- é–‰ã˜ã‚‹ãƒœã‚¿ãƒ³
	local closeButton = Instance.new("TextButton")
	closeButton.Name = "CloseButton"
	closeButton.Size = UDim2.new(0, 40, 0, 40)
	closeButton.Position = UDim2.new(1, -50, 0, 10)
	closeButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
	closeButton.BackgroundTransparency = 1
	closeButton.BorderSizePixel = 0
	closeButton.Font = Enum.Font.GothamBold
	closeButton.TextSize = 24
	closeButton.Text = "âœ•"
	closeButton.TextColor3 = Color3.new(1, 1, 1)
	closeButton.TextTransparency = 1
	closeButton.ZIndex = 52
	closeButton.Parent = panel

	TweenService:Create(closeButton, TweenInfo.new(0.2), {
		BackgroundTransparency = 0.2,
		TextTransparency = 0
	}):Play()

	local closeCorner = Instance.new("UICorner")
	closeCorner.CornerRadius = UDim.new(0, 8)
	closeCorner.Parent = closeButton

	closeButton.MouseButton1Click:Connect(function()
		closeModal()
	end)

	closeButton.MouseEnter:Connect(function()
		closeButton.BackgroundColor3 = Color3.fromRGB(255, 70, 70)
	end)
	closeButton.MouseLeave:Connect(function()
		closeButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
	end)

	-- ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¨ãƒªã‚¢
	local contentFrame = Instance.new("Frame")
	contentFrame.Name = "Content"
	contentFrame.Size = UDim2.new(1, -20, 1, -70)
	contentFrame.Position = UDim2.new(0, 10, 0, 60)
	contentFrame.BackgroundTransparency = 1
	contentFrame.ZIndex = 52
	contentFrame.Parent = panel

	if contentBuilder then
		contentBuilder(contentFrame)
	end

	background.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			closeModal()
		end
	end)

	currentModal = modal
	return modal
end

-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ç”»é¢
local function showStatus()
	createModal("ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹", function(content)
		local stats = {
			{"ãƒ¬ãƒ™ãƒ«", cachedStats.Level},
			{"æœ€å¤§HP", cachedStats.MaxHP},
			{"æ”»æ’ƒåŠ›", cachedStats.Attack},
			{"é˜²å¾¡åŠ›", cachedStats.Defense},
			{"ç´ æ—©ã•", cachedStats.Speed},
		}

		for i, stat in ipairs(stats) do
			local label = Instance.new("TextLabel")
			label.Size = UDim2.new(1, 0, 0, 40)
			label.Position = UDim2.new(0, 0, 0, (i - 1) * 50)
			label.BackgroundTransparency = 1
			label.TextColor3 = Color3.fromRGB(255, 255, 255)
			label.TextStrokeTransparency = 0.7
			label.Font = Enum.Font.Gotham
			label.TextSize = 20
			label.Text = string.format("%s: %d", stat[1], stat[2])
			label.TextXAlignment = Enum.TextXAlignment.Left
			label.TextTransparency = 1
			label.ZIndex = 53
			label.Parent = content

			TweenService:Create(label, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, i * 0.05), {
				TextTransparency = 0,
				TextStrokeTransparency = 0.7
			}):Play()
		end
	end)
end

-- ã‚¢ã‚¤ãƒ†ãƒ ç”»é¢
local function showItems()
	createModal("ã‚¢ã‚¤ãƒ†ãƒ ", function(content)
		local emptyLabel = Instance.new("TextLabel")
		emptyLabel.Size = UDim2.fromScale(1, 1)
		emptyLabel.BackgroundTransparency = 1
		emptyLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
		emptyLabel.TextStrokeTransparency = 0.7
		emptyLabel.Font = Enum.Font.Gotham
		emptyLabel.TextSize = 18
		emptyLabel.Text = "ã‚¢ã‚¤ãƒ†ãƒ ãŒã‚ã‚Šã¾ã›ã‚“"
		emptyLabel.TextTransparency = 1
		emptyLabel.ZIndex = 53
		emptyLabel.Parent = content

		TweenService:Create(emptyLabel, TweenInfo.new(0.2), {
			TextTransparency = 0,
			TextStrokeTransparency = 0.7
		}):Play()
	end)
end

-- ã‚¹ã‚­ãƒ«ç”»é¢
local function showSkills()
	createModal("ã‚¹ã‚­ãƒ«", function(content)
		local emptyLabel = Instance.new("TextLabel")
		emptyLabel.Size = UDim2.fromScale(1, 1)
		emptyLabel.BackgroundTransparency = 1
		emptyLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
		emptyLabel.TextStrokeTransparency = 0.7
		emptyLabel.Font = Enum.Font.Gotham
		emptyLabel.TextSize = 18
		emptyLabel.Text = "ç¿’å¾—æ¸ˆã¿ã‚¹ã‚­ãƒ«ãªã—"
		emptyLabel.TextTransparency = 1
		emptyLabel.ZIndex = 53
		emptyLabel.Parent = content

		TweenService:Create(emptyLabel, TweenInfo.new(0.2), {
			TextTransparency = 0,
			TextStrokeTransparency = 0.7
		}):Play()
	end)
end

-- æˆ¦æ­´ç”»é¢
local function showRecords()
	createModal("æˆ¦æ­´", function(content)
		print("[MenuUI] ========================================")
		print("[MenuUI] æˆ¦æ­´ç”»é¢ã‚’é–‹ãã¾ã—ãŸ")
		print("[MenuUI] ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã•ã‚ŒãŸå€¤:", cachedStats.MonstersDefeated or 0)

		-- ãƒ©ãƒ™ãƒ«ã‚’å…ˆã«ä½œæˆ
		local label = Instance.new("TextLabel")
		label.Size = UDim2.new(1, 0, 0, 40)
		label.Position = UDim2.new(0, 0, 0, 0)
		label.BackgroundTransparency = 1
		label.TextColor3 = Color3.fromRGB(255, 255, 255)
		label.TextStrokeTransparency = 0.7
		label.Font = Enum.Font.Gotham
		label.TextSize = 20
		label.Text = string.format("å€’ã—ãŸãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æ•°: %d (å–å¾—ä¸­...)", cachedStats.MonstersDefeated or 0)
		label.TextXAlignment = Enum.TextXAlignment.Left
		label.TextTransparency = 1
		label.ZIndex = 53
		label.Parent = content

		TweenService:Create(label, TweenInfo.new(0.2), {
			TextTransparency = 0,
			TextStrokeTransparency = 0.7
		}):Play()

		-- ã‚µãƒ¼ãƒãƒ¼ã«æœ€æ–°ã®æˆ¦æ­´ã‚’ãƒªã‚¯ã‚¨ã‚¹ãƒˆ
		local RequestStatsDetailEvent = ReplicatedStorage:FindFirstChild("RequestStatsDetail")
		if RequestStatsDetailEvent then
			print("[MenuUI] ã‚µãƒ¼ãƒãƒ¼ã«è©³ç´°ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’ãƒªã‚¯ã‚¨ã‚¹ãƒˆä¸­...")
			RequestStatsDetailEvent:FireServer()

			-- 0.5ç§’å¾Œã«ãƒ©ãƒ™ãƒ«ã‚’æ›´æ–°ï¼ˆã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰ã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’å¾…ã¤ï¼‰
			task.delay(0.5, function()
				if label and label.Parent then
					label.Text = string.format("å€’ã—ãŸãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æ•°: %d", cachedStats.MonstersDefeated or 0)
					print("[MenuUI] ãƒ©ãƒ™ãƒ«æ›´æ–°: MonstersDefeated =", cachedStats.MonstersDefeated)
				end
			end)
		else
			warn("[MenuUI] RequestStatsDetailEventãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
		end

		print("[MenuUI] ========================================")
	end)
end

-- è¨­å®šç”»é¢
local function showSettings()
	createModal("è¨­å®š", function(content)
		local bgmLabel = Instance.new("TextLabel")
		bgmLabel.Size = UDim2.new(1, 0, 0, 30)
		bgmLabel.Position = UDim2.new(0, 0, 0, 20)
		bgmLabel.BackgroundTransparency = 1
		bgmLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
		bgmLabel.TextStrokeTransparency = 0.7
		bgmLabel.Font = Enum.Font.Gotham
		bgmLabel.TextSize = 18
		bgmLabel.Text = "BGMéŸ³é‡ï¼ˆæœªå®Ÿè£…ï¼‰"
		bgmLabel.TextXAlignment = Enum.TextXAlignment.Left
		bgmLabel.TextTransparency = 1
		bgmLabel.ZIndex = 53
		bgmLabel.Parent = content

		TweenService:Create(bgmLabel, TweenInfo.new(0.2), {
			TextTransparency = 0,
			TextStrokeTransparency = 0.7
		}):Play()

		local seLabel = Instance.new("TextLabel")
		seLabel.Size = UDim2.new(1, 0, 0, 30)
		seLabel.Position = UDim2.new(0, 0, 0, 80)
		seLabel.BackgroundTransparency = 1
		seLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
		seLabel.TextStrokeTransparency = 0.7
		seLabel.Font = Enum.Font.Gotham
		seLabel.TextSize = 18
		seLabel.Text = "SEéŸ³é‡ï¼ˆæœªå®Ÿè£…ï¼‰"
		seLabel.TextXAlignment = Enum.TextXAlignment.Left
		seLabel.TextTransparency = 1
		seLabel.ZIndex = 53
		seLabel.Parent = content

		TweenService:Create(seLabel, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0.05), {
			TextTransparency = 0,
			TextStrokeTransparency = 0.7
		}):Play()
	end)
end

-- ãƒ­ã‚°ã‚¢ã‚¦ãƒˆç¢ºèª
local function showLogout()
	createModal("ãƒ­ã‚°ã‚¢ã‚¦ãƒˆ", function(content)
		local warningLabel = Instance.new("TextLabel")
		warningLabel.Size = UDim2.new(1, 0, 0, 60)
		warningLabel.Position = UDim2.new(0, 0, 0, 20)
		warningLabel.BackgroundTransparency = 1
		warningLabel.TextColor3 = Color3.fromRGB(255, 200, 100)
		warningLabel.TextStrokeTransparency = 0.7
		warningLabel.Font = Enum.Font.Gotham
		warningLabel.TextSize = 18
		warningLabel.Text = "æœ¬å½“ã«ãƒ­ã‚°ã‚¢ã‚¦ãƒˆã—ã¾ã™ã‹ï¼Ÿ\n\nâ€» ç¾åœ¨ã€é€²è¡ŒçŠ¶æ³ã¯ä¿å­˜ã•ã‚Œã¾ã›ã‚“"
		warningLabel.TextWrapped = true
		warningLabel.TextTransparency = 1
		warningLabel.ZIndex = 53
		warningLabel.Parent = content

		TweenService:Create(warningLabel, TweenInfo.new(0.2), {
			TextTransparency = 0,
			TextStrokeTransparency = 0.7
		}):Play()

		local logoutButton = Instance.new("TextButton")
		logoutButton.Size = UDim2.new(0, 150, 0, 50)
		logoutButton.Position = UDim2.new(0.5, -160, 1, -70)
		logoutButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
		logoutButton.BackgroundTransparency = 1
		logoutButton.BorderSizePixel = 0
		logoutButton.Font = Enum.Font.GothamBold
		logoutButton.TextSize = 18
		logoutButton.Text = "ãƒ­ã‚°ã‚¢ã‚¦ãƒˆ"
		logoutButton.TextColor3 = Color3.new(1, 1, 1)
		logoutButton.TextTransparency = 1
		logoutButton.ZIndex = 53
		logoutButton.Parent = content

		TweenService:Create(logoutButton, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0.1), {
			BackgroundTransparency = 0.2,
			TextTransparency = 0
		}):Play()

		local logoutCorner = Instance.new("UICorner")
		logoutCorner.CornerRadius = UDim.new(0, 8)
		logoutCorner.Parent = logoutButton

		logoutButton.MouseButton1Click:Connect(function()
			player:Kick("ãƒ­ã‚°ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸ")
		end)

		local cancelButton = Instance.new("TextButton")
		cancelButton.Size = UDim2.new(0, 150, 0, 50)
		cancelButton.Position = UDim2.new(0.5, 10, 1, -70)
		cancelButton.BackgroundColor3 = Color3.fromRGB(52, 152, 219)
		cancelButton.BackgroundTransparency = 1
		cancelButton.BorderSizePixel = 0
		cancelButton.Font = Enum.Font.GothamBold
		cancelButton.TextSize = 18
		cancelButton.Text = "ã‚­ãƒ£ãƒ³ã‚»ãƒ«"
		cancelButton.TextColor3 = Color3.new(1, 1, 1)
		cancelButton.TextTransparency = 1
		cancelButton.ZIndex = 53
		cancelButton.Parent = content

		TweenService:Create(cancelButton, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0.15), {
			BackgroundTransparency = 0.2,
			TextTransparency = 0
		}):Play()

		local cancelCorner = Instance.new("UICorner")
		cancelCorner.CornerRadius = UDim.new(0, 8)
		cancelCorner.Parent = cancelButton

		cancelButton.MouseButton1Click:Connect(function()
			closeModal()
		end)
	end)
end

-- ãƒ¡ãƒ‹ãƒ¥ãƒ¼UIä½œæˆ
local function createMenuUI()
	menuGui = Instance.new("ScreenGui")
	menuGui.Name = "MenuUI"
	menuGui.ResetOnSpawn = false
	menuGui.Parent = playerGui

	menuFrame = Instance.new("Frame")
	menuFrame.Name = "MenuFrame"
	menuFrame.Size = UDim2.new(0, 250, 0, 120)
	menuFrame.Position = UDim2.new(1, -270, 1, -270)
	menuFrame.BackgroundTransparency = 1
	menuFrame.Parent = menuGui

	local menuButtons = {
		{name = "ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹", func = showStatus, row = 0, col = 0},
		{name = "ã‚¢ã‚¤ãƒ†ãƒ ", func = showItems, row = 0, col = 1},
		{name = "ã‚¹ã‚­ãƒ«", func = showSkills, row = 0, col = 2},
		{name = "æˆ¦æ­´", func = showRecords, row = 1, col = 0},
		{name = "è¨­å®š", func = showSettings, row = 1, col = 1},
		{name = "ãƒ­ã‚°ã‚¢ã‚¦ãƒˆ", func = showLogout, row = 1, col = 2},
	}

	local buttonWidth = 80
	local buttonHeight = 50
	local spacing = 5

	for _, btnData in ipairs(menuButtons) do
		local button = Instance.new("TextButton")
		button.Name = btnData.name .. "Button"
		button.Size = UDim2.new(0, buttonWidth, 0, buttonHeight)
		button.Position = UDim2.new(0, btnData.col * (buttonWidth + spacing), 0, btnData.row * (buttonHeight + spacing))
		button.BackgroundColor3 = Color3.fromRGB(50, 50, 60)
		button.BackgroundTransparency = 0.2
		button.BorderSizePixel = 0
		button.Font = Enum.Font.GothamBold
		button.TextSize = 14
		button.Text = btnData.name
		button.TextColor3 = Color3.new(1, 1, 1)
		button.TextStrokeTransparency = 0.7
		button.Parent = menuFrame

		local corner = Instance.new("UICorner")
		corner.CornerRadius = UDim.new(0, 8)
		corner.Parent = button

		button.MouseButton1Click:Connect(function()
			if not isInBattle then
				btnData.func()
			end
		end)

		button.MouseEnter:Connect(function()
			if not isInBattle then
				button.BackgroundColor3 = Color3.fromRGB(70, 70, 80)
			end
		end)
		button.MouseLeave:Connect(function()
			button.BackgroundColor3 = Color3.fromRGB(50, 50, 60)
		end)
	end

	print("[MenuUI] ãƒ¡ãƒ‹ãƒ¥ãƒ¼UIä½œæˆå®Œäº†")
end

createMenuUI()

if RequestStatusEvent then
	task.wait(1)
	RequestStatusEvent:FireServer()
end

print("[MenuUI] åˆæœŸåŒ–å®Œäº†")
===== ./StartPlayerScripts/LevelUpUI.client.lua =====
-- StarterPlayer/StarterPlayerScripts/LevelUpUI.client.lua
-- ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—æ¼”å‡º

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

print("[LevelUpUI] åˆæœŸåŒ–ä¸­...")

-- UIè¦ç´ 
local levelUpGui = nil

-- ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—æ¼”å‡ºã‚’è¡¨ç¤º
local function showLevelUp(level, maxHP, speed, attack, defense)
	print(("[LevelUpUI] ========================================"):format())
	print(("[LevelUpUI] ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—æ¼”å‡ºé–‹å§‹ï¼"):format())
	print(("[LevelUpUI] Lv.%d, HP:%d, ç´ æ—©ã•:%d, æ”»æ’ƒ:%d, å®ˆå‚™:%d"):format(
		level, maxHP, speed, attack, defense
		))
	print(("[LevelUpUI] ========================================"):format())

	-- æ—¢å­˜ã®GUIã‚’å‰Šé™¤
	if levelUpGui then
		levelUpGui:Destroy()
	end

	-- æ–°ã—ã„GUIã‚’ä½œæˆ
	levelUpGui = Instance.new("ScreenGui")
	levelUpGui.Name = "LevelUpUI"
	levelUpGui.ResetOnSpawn = false
	levelUpGui.Parent = playerGui

	-- èƒŒæ™¯ï¼ˆæš—ã„ï¼‰
	local background = Instance.new("Frame")
	background.Size = UDim2.fromScale(1, 1)
	background.Position = UDim2.fromScale(0, 0)
	background.BackgroundColor3 = Color3.new(0, 0, 0)
	background.BackgroundTransparency = 1
	background.BorderSizePixel = 0
	background.ZIndex = 100
	background.Parent = levelUpGui

	-- èƒŒæ™¯ã‚’æš—ãã™ã‚‹
	local bgTween = TweenService:Create(background, TweenInfo.new(0.3), {
		BackgroundTransparency = 0.5
	})
	bgTween:Play()

	-- ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ãƒ†ã‚­ã‚¹ãƒˆ
	local levelUpText = Instance.new("TextLabel")
	levelUpText.Size = UDim2.new(0, 600, 0, 100)
	levelUpText.Position = UDim2.new(0.5, -300, 0.35, -50)
	levelUpText.BackgroundTransparency = 1
	levelUpText.TextColor3 = Color3.fromRGB(255, 215, 0)
	levelUpText.TextStrokeTransparency = 0
	levelUpText.TextStrokeColor3 = Color3.new(0, 0, 0)
	levelUpText.Font = Enum.Font.GothamBold
	levelUpText.TextSize = 60
	levelUpText.Text = "LEVEL UP!"
	levelUpText.TextTransparency = 1
	levelUpText.ZIndex = 101
	levelUpText.Parent = levelUpGui

	-- ãƒ†ã‚­ã‚¹ãƒˆã‚’ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
	local textTween = TweenService:Create(levelUpText, TweenInfo.new(0.5), {
		TextTransparency = 0,
		TextStrokeTransparency = 0
	})
	textTween:Play()

	-- ãƒ¬ãƒ™ãƒ«è¡¨ç¤º
	local levelText = Instance.new("TextLabel")
	levelText.Size = UDim2.new(0, 600, 0, 60)
	levelText.Position = UDim2.new(0.5, -300, 0.45, 0)
	levelText.BackgroundTransparency = 1
	levelText.TextColor3 = Color3.fromRGB(255, 255, 255)
	levelText.TextStrokeTransparency = 0
	levelText.Font = Enum.Font.GothamBold
	levelText.TextSize = 40
	levelText.Text = string.format("Level %d", level)
	levelText.TextTransparency = 1
	levelText.ZIndex = 101
	levelText.Parent = levelUpGui

	-- ãƒ¬ãƒ™ãƒ«ãƒ†ã‚­ã‚¹ãƒˆã‚’ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
	local levelTextTween = TweenService:Create(levelText, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0.2), {
		TextTransparency = 0,
		TextStrokeTransparency = 0.5
	})
	levelTextTween:Play()

	-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤ºãƒ•ãƒ¬ãƒ¼ãƒ 
	local statsFrame = Instance.new("Frame")
	statsFrame.Size = UDim2.new(0, 400, 0, 150)
	statsFrame.Position = UDim2.new(0.5, -200, 0.55, 0)
	statsFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
	statsFrame.BackgroundTransparency = 1
	statsFrame.BorderSizePixel = 0
	statsFrame.ZIndex = 101
	statsFrame.Parent = levelUpGui

	-- è§’ã‚’ä¸¸ãã™ã‚‹
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 10)
	corner.Parent = statsFrame

	-- ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
	local frameTween = TweenService:Create(statsFrame, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0.3), {
		BackgroundTransparency = 0.2
	})
	frameTween:Play()

	-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ†ã‚­ã‚¹ãƒˆ
	local statsText = Instance.new("TextLabel")
	statsText.Size = UDim2.new(1, -40, 1, -40)
	statsText.Position = UDim2.new(0, 20, 0, 20)
	statsText.BackgroundTransparency = 1
	statsText.TextColor3 = Color3.fromRGB(200, 255, 200)
	statsText.TextStrokeTransparency = 0.5
	statsText.Font = Enum.Font.Gotham
	statsText.TextSize = 20
	statsText.Text = string.format(
		"HP: %d (+10)\nç´ æ—©ã•: %d (+2)\næ”»æ’ƒåŠ›: %d (+2)\nå®ˆå‚™åŠ›: %d (+2)",
		maxHP, speed, attack, defense
	)
	statsText.TextTransparency = 1
	statsText.TextYAlignment = Enum.TextYAlignment.Top
	statsText.ZIndex = 102
	statsText.Parent = statsFrame

	-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ†ã‚­ã‚¹ãƒˆã‚’ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
	local statsTween = TweenService:Create(statsText, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0.4), {
		TextTransparency = 0,
		TextStrokeTransparency = 0.5
	})
	statsTween:Play()

	-- 2.5ç§’å¾Œã«ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
	task.delay(2.5, function()
		local fadeOutTween = TweenService:Create(background, TweenInfo.new(0.5), {
			BackgroundTransparency = 1
		})
		fadeOutTween:Play()

		TweenService:Create(levelUpText, TweenInfo.new(0.5), {
			TextTransparency = 1,
			TextStrokeTransparency = 1
		}):Play()

		TweenService:Create(levelText, TweenInfo.new(0.5), {
			TextTransparency = 1,
			TextStrokeTransparency = 1
		}):Play()

		TweenService:Create(statsFrame, TweenInfo.new(0.5), {
			BackgroundTransparency = 1
		}):Play()

		TweenService:Create(statsText, TweenInfo.new(0.5), {
			TextTransparency = 1,
			TextStrokeTransparency = 1
		}):Play()

		-- 3ç§’å¾Œã«å‰Šé™¤
		task.wait(0.5)
		if levelUpGui then
			levelUpGui:Destroy()
			levelUpGui = nil
		end
	end)
end

-- RemoteEventã‚’å¾…æ©Ÿ
local LevelUpEvent = ReplicatedStorage:WaitForChild("LevelUp", 10)
if LevelUpEvent then
	LevelUpEvent.OnClientEvent:Connect(showLevelUp)
	print("[LevelUpUI] LevelUpã‚¤ãƒ™ãƒ³ãƒˆæ¥ç¶šå®Œäº†")
else
	warn("[LevelUpUI] LevelUpã‚¤ãƒ™ãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
end

print("[LevelUpUI] åˆæœŸåŒ–å®Œäº†")
===== ./StartPlayerScripts/BattleUI.client.lua =====
-- StarterPlayer/StarterPlayerScripts/BattleUI.client.lua
-- ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ãƒãƒˆãƒ«UIåˆ¶å¾¡ï¼ˆã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ï¼‰

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local StarterGui = game:GetService("StarterGui")
local ContextActionService = game:GetService("ContextActionService")
local LocalizationService = game:GetService("LocalizationService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

print("[BattleUI] ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆèµ·å‹•ä¸­...")

-- ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒ­ã‚±ãƒ¼ãƒ«ã‚’å–å¾—
local userLocale = string.lower(LocalizationService.RobloxLocaleId)
local localeCode = string.match(userLocale, "^(%a+)") or "en"  -- "ja-jp" â†’ "ja"

-- ã€é–‹ç™ºç”¨ã€‘å¼·åˆ¶çš„ã«æ—¥æœ¬èªè¡¨ç¤ºï¼ˆæœ¬ç•ªã§ã¯å‰Šé™¤å¯èƒ½ï¼‰
local FORCE_LOCALE = "ja"  -- ã“ã“ã‚’å¤‰æ›´ã™ã‚‹ã¨è¡¨ç¤ºè¨€èªãŒå¤‰ã‚ã‚‹ï¼ˆnil ã§è‡ªå‹•æ¤œå‡ºï¼‰
if FORCE_LOCALE then
	localeCode = FORCE_LOCALE
	print(("[BattleUI] è¨€èªã‚’å¼·åˆ¶è¨­å®š: %s"):format(localeCode))
end

print(("[BattleUI] ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ã‚±ãƒ¼ãƒ«: %s â†’ è¡¨ç¤ºè¨€èª: %s"):format(userLocale, localeCode))

-- RemoteEventsã‚’å¾…æ©Ÿ
local BattleStartEvent = ReplicatedStorage:WaitForChild("BattleStart", 30)
local BattleEndEvent = ReplicatedStorage:WaitForChild("BattleEnd", 30)
local BattleDamageEvent = ReplicatedStorage:WaitForChild("BattleDamage", 30)

if not BattleStartEvent or not BattleEndEvent or not BattleDamageEvent then
	warn("[BattleUI] RemoteEventã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ")
	return
end

-- å˜èªãƒªã‚¹ãƒˆã‚’èª­ã¿è¾¼ã¿
local TypingWords = require(ReplicatedStorage:WaitForChild("TypingWords"))

-- ãƒ‡ãƒãƒƒã‚°ï¼šå˜èªãƒªã‚¹ãƒˆã®å†…å®¹ã‚’ç¢ºèª
print("[BattleUI DEBUG] TypingWords.level_1[1]:")
if TypingWords.level_1 and TypingWords.level_1[1] then
	local firstWord = TypingWords.level_1[1]
	print("  Type:", type(firstWord))
	if type(firstWord) == "table" then
		print("  word:", firstWord.word)
		print("  ja:", firstWord.ja)
	else
		print("  Value:", firstWord)
	end
end

print("[BattleUI] RemoteEventså–å¾—å®Œäº†")

-- çŠ¶æ…‹
local inBattle = false
local currentWord = ""
local currentWordData = nil  -- ç¿»è¨³ãƒ‡ãƒ¼ã‚¿ã‚’å«ã‚€å˜èªæƒ…å ±
local lastWord = nil  -- å‰å›ã®å˜èªï¼ˆé€£ç¶šå›é¿ç”¨ï¼‰
local currentIndex = 1
local typingLevels = {}
local currentBattleTimeout = nil
local monsterHP = 0
local monsterMaxHP = 0
local playerHP = 0  -- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç¾åœ¨HP
local playerMaxHP = 0  -- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æœ€å¤§HP
local damagePerKey = 1

-- ã‚«ãƒ¡ãƒ©è¨­å®šä¿å­˜ç”¨
local originalCameraMaxZoom = nil
local originalCameraMinZoom = nil

-- UIè¦ç´ 
local battleGui = nil
local darkenFrame = nil
local wordFrame = nil
local wordLabel = nil
local translationLabel = nil  -- ç¿»è¨³è¡¨ç¤ºç”¨
local hpBarBackground = nil
local hpBarFill = nil
local hpLabel = nil

-- ã‚·ã‚¹ãƒ†ãƒ ã‚­ãƒ¼ã‚’ãƒ–ãƒ­ãƒƒã‚¯ã™ã‚‹é–¢æ•°
local function blockSystemKeys()
	-- ã‚«ãƒ¡ãƒ©ã‚ºãƒ¼ãƒ ã‚’å®Œå…¨ã«å›ºå®š
	originalCameraMaxZoom = player.CameraMaxZoomDistance
	originalCameraMinZoom = player.CameraMinZoomDistance

	-- ç¾åœ¨ã®ã‚ºãƒ¼ãƒ è·é›¢ã‚’å–å¾—ã—ã¦å›ºå®š
	local camera = workspace.CurrentCamera
	local currentZoom = (camera.CFrame.Position - player.Character.HumanoidRootPart.Position).Magnitude
	player.CameraMaxZoomDistance = currentZoom
	player.CameraMinZoomDistance = currentZoom

	print(("[BattleUI] ã‚«ãƒ¡ãƒ©ã‚’å›ºå®šã—ã¾ã—ãŸ (è·é›¢: %.1f)"):format(currentZoom))
end

-- ãƒ–ãƒ­ãƒƒã‚¯è§£é™¤
local function unblockSystemKeys()
	-- ã‚«ãƒ¡ãƒ©ã‚ºãƒ¼ãƒ ã‚’å¾©å…ƒ
	if originalCameraMaxZoom and originalCameraMinZoom then
		player.CameraMaxZoomDistance = originalCameraMaxZoom
		player.CameraMinZoomDistance = originalCameraMinZoom
		print("[BattleUI] ã‚«ãƒ¡ãƒ©è¨­å®šã‚’å¾©å…ƒã—ã¾ã—ãŸ")
	end
end

-- ã€forward declarationã€‘
local onBattleEnd
local updateDisplay
local setNextWord

-- HPãƒãƒ¼ã®è‰²ã‚’å–å¾—ï¼ˆHPå‰²åˆã«å¿œã˜ã¦å¤‰åŒ–ï¼‰
local function getHPColor(hpPercent)
	if hpPercent > 0.6 then
		-- ç·‘
		return Color3.fromRGB(46, 204, 113)
	elseif hpPercent > 0.3 then
		-- é»„è‰²
		return Color3.fromRGB(241, 196, 15)
	else
		-- èµ¤
		return Color3.fromRGB(231, 76, 60)
	end
end

-- è¡¨ç¤ºã‚’æ›´æ–°
updateDisplay = function()
	if not wordLabel then return end

	-- å…¥åŠ›æ¸ˆã¿æ–‡å­—ã‚’ç·‘ã€æœªå…¥åŠ›ã‚’ç™½ã§è¡¨ç¤º
	local typedPart = string.sub(currentWord, 1, currentIndex - 1)
	local remainingPart = string.sub(currentWord, currentIndex)

	wordLabel.Text = string.format('<font color="#00FF00">%s</font>%s', typedPart, remainingPart)

	-- æ•µHPãƒãƒ¼æ›´æ–°
	if hpBarFill and hpLabel then
		local hpPercent = monsterHP / monsterMaxHP

		-- ãƒãƒ¼ã®é•·ã•ã‚’ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
		local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
		local tween = TweenService:Create(hpBarFill, tweenInfo, {
			Size = UDim2.new(hpPercent, 0, 1, 0)
		})
		tween:Play()

		-- è‰²ã‚’å¤‰æ›´
		hpBarFill.BackgroundColor3 = getHPColor(hpPercent)

		-- ãƒ†ã‚­ã‚¹ãƒˆæ›´æ–°
		hpLabel.Text = string.format("Enemy HP: %d / %d", monsterHP, monsterMaxHP)
	end
end

-- å˜èªã‚’é¸æŠã™ã‚‹é–¢æ•°
local function selectWord()
	if #typingLevels == 0 then
		-- ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼šlevel_1ã®ã¿
		typingLevels = {{level = "level_1", weight = 100}}
	end

	-- é‡ã¿ä»˜ããƒ©ãƒ³ãƒ€ãƒ é¸æŠ
	local totalWeight = 0
	for _, config in ipairs(typingLevels) do
		totalWeight = totalWeight + config.weight
	end

	local randomValue = math.random(1, totalWeight)
	local cumulativeWeight = 0
	local selectedLevel = "level_1"

	for _, config in ipairs(typingLevels) do
		cumulativeWeight = cumulativeWeight + config.weight
		if randomValue <= cumulativeWeight then
			selectedLevel = config.level
			break
		end
	end

	-- é¸æŠã•ã‚ŒãŸãƒ¬ãƒ™ãƒ«ã‹ã‚‰å˜èªã‚’å–å¾—
	local wordList = TypingWords[selectedLevel]
	if wordList and #wordList > 0 then
		-- å‰å›ã¨åŒã˜å˜èªã‚’é¿ã‘ã‚‹ï¼ˆæœ€å¤§5å›ã¾ã§å†æŠ½é¸ï¼‰
		local wordData = nil
		local attempts = 0

		repeat
			wordData = wordList[math.random(1, #wordList)]
			attempts = attempts + 1

			-- æ–°å½¢å¼ï¼ˆãƒ†ãƒ¼ãƒ–ãƒ«ï¼‰ã‹æ—§å½¢å¼ï¼ˆæ–‡å­—åˆ—ï¼‰ã‹åˆ¤å®š
			local currentWordStr = type(wordData) == "table" and wordData.word or wordData

			-- å‰å›ã¨é•ã†å˜èªãŒå‡ºãŸã‚‰ã€ã¾ãŸã¯5å›è©¦ã—ãŸã‚‰ãƒ«ãƒ¼ãƒ—çµ‚äº†
			if currentWordStr ~= lastWord or attempts >= 5 or #wordList == 1 then
				break
			end
		until false

		-- æ–°å½¢å¼ï¼ˆãƒ†ãƒ¼ãƒ–ãƒ«ï¼‰ã‹æ—§å½¢å¼ï¼ˆæ–‡å­—åˆ—ï¼‰ã‹åˆ¤å®š
		if type(wordData) == "table" then
			return wordData
		else
			-- æ—§å½¢å¼ã®å ´åˆã¯äº’æ›æ€§ã®ãŸã‚ãƒ†ãƒ¼ãƒ–ãƒ«ã«å¤‰æ›
			return {word = wordData}
		end
	else
		return {word = "apple", ja = "ã‚Šã‚“ã”"}  -- ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
	end
end

-- æ¬¡ã®å˜èªã‚’è¨­å®š
setNextWord = function()
	currentWordData = selectWord()
	currentWord = currentWordData.word
	currentIndex = 1

	-- ä»Šå›ã®å˜èªã‚’è¨˜æ†¶ï¼ˆæ¬¡å›ã®é€£ç¶šå›é¿ç”¨ï¼‰
	lastWord = currentWord

	print(("[BattleUI DEBUG] currentWordData:"):format())
	print(currentWordData)
	print(("[BattleUI DEBUG] localeCode: %s"):format(localeCode))

	-- ç¿»è¨³ã‚’è¡¨ç¤ºï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ä»˜ãï¼‰
	if translationLabel then
		-- å„ªå…ˆé †ä½ï¼šæŒ‡å®šè¨€èª â†’ æ—¥æœ¬èª â†’ ã‚¹ãƒšã‚¤ãƒ³èª â†’ ãƒ•ãƒ©ãƒ³ã‚¹èª â†’ ç©º
		local translation = currentWordData[localeCode]
			or currentWordData.ja
			or currentWordData.es
			or currentWordData.fr
			or ""

		translationLabel.Text = translation
		translationLabel.Visible = translation ~= ""
		print(("[BattleUI DEBUG] translation: %s"):format(translation))
	else
		warn("[BattleUI DEBUG] translationLabel ãŒ nil ã§ã™ï¼")
	end

	updateDisplay()
	print(("[BattleUI] æ¬¡ã®å˜èª: %s (%s)"):format(currentWord, currentWordData[localeCode] or currentWordData.ja or ""))
end

-- UIä½œæˆ
local function createBattleUI()
	battleGui = Instance.new("ScreenGui")
	battleGui.Name = "BattleUI"
	battleGui.ResetOnSpawn = false
	battleGui.Enabled = false
	battleGui.Parent = playerGui

	-- æš—è»¢ç”¨ãƒ•ãƒ¬ãƒ¼ãƒ 
	darkenFrame = Instance.new("Frame")
	darkenFrame.Name = "DarkenFrame"
	darkenFrame.Size = UDim2.fromScale(1, 1)
	darkenFrame.Position = UDim2.fromScale(0, 0)
	darkenFrame.BackgroundColor3 = Color3.new(0, 0, 0)
	darkenFrame.BackgroundTransparency = 1
	darkenFrame.BorderSizePixel = 0
	darkenFrame.ZIndex = 1
	darkenFrame.Parent = battleGui

	-- æ•µHPãƒãƒ¼èƒŒæ™¯
	hpBarBackground = Instance.new("Frame")
	hpBarBackground.Name = "HPBarBackground"
	hpBarBackground.Size = UDim2.new(0, 500, 0, 40)
	hpBarBackground.Position = UDim2.new(0.5, -250, 0.25, 0)
	hpBarBackground.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
	hpBarBackground.BorderSizePixel = 0
	hpBarBackground.ZIndex = 2
	hpBarBackground.Parent = battleGui

	-- HPãƒãƒ¼èƒŒæ™¯ã®è§’ã‚’ä¸¸ãã™ã‚‹
	local hpBarCorner = Instance.new("UICorner")
	hpBarCorner.CornerRadius = UDim.new(0, 8)
	hpBarCorner.Parent = hpBarBackground

	-- HPãƒãƒ¼ï¼ˆå¡—ã‚Šã¤ã¶ã—éƒ¨åˆ†ï¼‰
	hpBarFill = Instance.new("Frame")
	hpBarFill.Name = "HPBarFill"
	hpBarFill.Size = UDim2.new(1, 0, 1, 0)
	hpBarFill.Position = UDim2.new(0, 0, 0, 0)
	hpBarFill.BackgroundColor3 = Color3.fromRGB(46, 204, 113)
	hpBarFill.BorderSizePixel = 0
	hpBarFill.ZIndex = 3
	hpBarFill.Parent = hpBarBackground

	-- HPãƒãƒ¼ã®è§’ã‚’ä¸¸ãã™ã‚‹
	local hpFillCorner = Instance.new("UICorner")
	hpFillCorner.CornerRadius = UDim.new(0, 8)
	hpFillCorner.Parent = hpBarFill

	-- HPãƒ†ã‚­ã‚¹ãƒˆï¼ˆãƒãƒ¼ã®ä¸Šã«è¡¨ç¤ºï¼‰
	hpLabel = Instance.new("TextLabel")
	hpLabel.Name = "HPLabel"
	hpLabel.Size = UDim2.new(1, 0, 1, 0)
	hpLabel.Position = UDim2.new(0, 0, 0, 0)
	hpLabel.BackgroundTransparency = 1
	hpLabel.TextColor3 = Color3.new(1, 1, 1)
	hpLabel.TextStrokeTransparency = 0.5
	hpLabel.Font = Enum.Font.GothamBold
	hpLabel.TextSize = 20
	hpLabel.Text = "HP: 10 / 10"
	hpLabel.ZIndex = 4
	hpLabel.Parent = hpBarBackground

	-- å˜èªè¡¨ç¤ºç”¨ãƒ•ãƒ¬ãƒ¼ãƒ ï¼ˆæ ï¼‰
	wordFrame = Instance.new("Frame")
	wordFrame.Name = "WordFrame"
	wordFrame.Size = UDim2.new(0, 700, 0, 150)
	wordFrame.Position = UDim2.new(0.5, -350, 0.5, -75)
	wordFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
	wordFrame.BorderSizePixel = 3
	wordFrame.BorderColor3 = Color3.fromRGB(100, 200, 255)
	wordFrame.ZIndex = 2
	wordFrame.Parent = battleGui

	-- æ ã®è§’ã‚’ä¸¸ãã™ã‚‹
	local wordFrameCorner = Instance.new("UICorner")
	wordFrameCorner.CornerRadius = UDim.new(0, 12)
	wordFrameCorner.Parent = wordFrame

	-- æ ã«å…‰ã‚‹ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆUIStrokeï¼‰
	local wordFrameStroke = Instance.new("UIStroke")
	wordFrameStroke.Color = Color3.fromRGB(100, 200, 255)
	wordFrameStroke.Thickness = 3
	wordFrameStroke.Transparency = 0
	wordFrameStroke.Parent = wordFrame

	-- å˜èªè¡¨ç¤ºï¼ˆRichTextå¯¾å¿œï¼‰
	wordLabel = Instance.new("TextLabel")
	wordLabel.Name = "WordLabel"
	wordLabel.Size = UDim2.new(1, -40, 0.6, 0)
	wordLabel.Position = UDim2.new(0, 20, 0, 10)
	wordLabel.BackgroundTransparency = 1
	wordLabel.TextColor3 = Color3.new(1, 1, 1)
	wordLabel.TextStrokeTransparency = 0
	wordLabel.Font = Enum.Font.GothamBold
	wordLabel.TextSize = 60
	wordLabel.Text = "apple"
	wordLabel.RichText = true
	wordLabel.ZIndex = 3
	wordLabel.Parent = wordFrame

	-- ç¿»è¨³è¡¨ç¤ºï¼ˆå˜èªã®ä¸‹ï¼‰
	translationLabel = Instance.new("TextLabel")
	translationLabel.Name = "TranslationLabel"
	translationLabel.Size = UDim2.new(1, -40, 0.35, 0)
	translationLabel.Position = UDim2.new(0, 20, 0.65, 0)
	translationLabel.BackgroundTransparency = 1
	translationLabel.TextColor3 = Color3.fromRGB(150, 200, 255)
	translationLabel.TextStrokeTransparency = 0.3
	translationLabel.Font = Enum.Font.Gotham
	translationLabel.TextSize = 28
	translationLabel.Text = "ãƒ†ã‚¹ãƒˆ"  -- ãƒ‡ãƒãƒƒã‚°ç”¨ã®åˆæœŸå€¤
	translationLabel.TextYAlignment = Enum.TextYAlignment.Top
	translationLabel.Visible = true
	translationLabel.ZIndex = 3
	translationLabel.Parent = wordFrame

	print("[BattleUI DEBUG] translationLabel ä½œæˆå®Œäº†")

	print("[BattleUI] UIä½œæˆå®Œäº†")
end

local Sounds = ReplicatedStorage:WaitForChild("Sounds", 10)
local TypingCorrectSound = Sounds and Sounds:WaitForChild("TypingCorrect", 5)
local TypingErrorSound = Sounds and Sounds:WaitForChild("TypingError", 5)

if not TypingCorrectSound then
	warn("[BattleUI] TypingCorrectåŠ¹æœéŸ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ (WaitForChild ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ)")
end
if not TypingErrorSound then
	warn("[BattleUI] TypingErroråŠ¹æœéŸ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ (WaitForChild ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ)")
end

-- ãƒãƒˆãƒ«é–‹å§‹å‡¦ç†
local function onBattleStart(monsterName, hp, maxHP, damage, levels, pHP, pMaxHP)
	print("[BattleUI] === onBattleStartå‘¼ã³å‡ºã— ===")

	-- nil ãƒã‚§ãƒƒã‚¯ã¨ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
	monsterName = monsterName or "Unknown"
	hp = hp or 10
	maxHP = maxHP or 10
	damage = damage or 1
	levels = levels or {{level = "level_1", weight = 100}}
	pHP = pHP or 100
	pMaxHP = pMaxHP or 100

	print(("[BattleUI] ãƒãƒˆãƒ«é–‹å§‹: vs %s (æ•µHP: %d, ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼HP: %d/%d, Damage: %d)"):format(
		monsterName, hp, pHP, pMaxHP, damage
		))

	if inBattle then
		print("[BattleUI DEBUG] ã™ã§ã«æˆ¦é—˜ä¸­")
		return
	end

	inBattle = true
	monsterHP = hp
	monsterMaxHP = maxHP
	playerHP = pHP
	playerMaxHP = pMaxHP
	damagePerKey = damage
	typingLevels = levels

	-- ã‚·ã‚¹ãƒ†ãƒ ã‚­ãƒ¼ã‚’ãƒ–ãƒ­ãƒƒã‚¯
	blockSystemKeys()

	print("[BattleUI] ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åœæ­¢å‡¦ç†é–‹å§‹")

	-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å…¥åŠ›ã‚’å®Œå…¨ã«ãƒ–ãƒ­ãƒƒã‚¯
	local character = player.Character
	if character then
		local humanoid = character:FindFirstChildOfClass("Humanoid")
		if humanoid then
			humanoid.WalkSpeed = 0
			humanoid.JumpPower = 0
			humanoid.JumpHeight = 0
		end
	end

	print("[BattleUI] Robloxã®UIã‚’ç„¡åŠ¹åŒ–")

	-- Robloxã®UIã‚’ç„¡åŠ¹åŒ–
	pcall(function()
		StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Chat, false)
		StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, false)
		StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, false)
		StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.EmotesMenu, false)
	end)

	print("[BattleUI] UIã‚’è¡¨ç¤º")

	battleGui.Enabled = true

	-- ã€é‡è¦ã€‘RichTextã‚’ç¢ºå®Ÿã«æœ‰åŠ¹åŒ–ã€å…¨ãƒ©ãƒ™ãƒ«ã‚’ãƒªã‚»ãƒƒãƒˆ
	print("[BattleUI] UIè¦ç´ ã‚’ãƒªã‚»ãƒƒãƒˆ")
	if wordLabel then
		wordLabel.RichText = true
		wordLabel.TextColor3 = Color3.new(1, 1, 1)
		wordLabel.Text = ""
		wordLabel.TextTransparency = 0  -- è¿½åŠ 
		wordLabel.TextStrokeTransparency = 0  -- è¿½åŠ 
	end
	if translationLabel then
		translationLabel.TextColor3 = Color3.fromRGB(150, 200, 255)
		translationLabel.Text = ""
		translationLabel.Visible = true
		translationLabel.TextTransparency = 0  -- è¿½åŠ 
		translationLabel.TextStrokeTransparency = 0.3  -- è¿½åŠ 
	end
	if hpLabel then
		hpLabel.TextColor3 = Color3.new(1, 1, 1)
		hpLabel.Text = ""
		hpLabel.TextTransparency = 0  -- è¿½åŠ 
		hpLabel.TextStrokeTransparency = 0.5  -- è¿½åŠ 
	end
	if hpBarFill then
		hpBarFill.Size = UDim2.new(1, 0, 1, 0)
		hpBarFill.BackgroundColor3 = Color3.fromRGB(46, 204, 113)
		hpBarFill.BackgroundTransparency = 0  -- è¿½åŠ 
	end
	if hpBarBackground then
		hpBarBackground.BackgroundTransparency = 0  -- è¿½åŠ 
	end
	if playerHPBarFill then
		playerHPBarFill.Size = UDim2.new(1, 0, 1, 0)
		playerHPBarFill.BackgroundColor3 = Color3.fromRGB(46, 204, 113)
	end

	-- æ ã®è‰²ã‚’ãƒªã‚»ãƒƒãƒˆï¼ˆé’ã«æˆ»ã™ï¼‰
	if wordFrame then
		wordFrame.BorderColor3 = Color3.fromRGB(100, 200, 255)
		wordFrame.BackgroundTransparency = 0.2  -- è¿½åŠ 
		local frameStroke = wordFrame:FindFirstChildOfClass("UIStroke")
		if frameStroke then
			frameStroke.Color = Color3.fromRGB(100, 200, 255)
			frameStroke.Transparency = 0  -- è¿½åŠ 
		end
	end

	-- èƒŒæ™¯ã®é€æ˜åº¦ã‚’ãƒªã‚»ãƒƒãƒˆ
	if darkenFrame then
		darkenFrame.BackgroundTransparency = 0.4  -- è¿½åŠ 
	end
	print("[BattleUI] æš—è»¢å‡¦ç†")

	-- ç”»é¢ã‚’è–„æš—ãã™ã‚‹
	darkenFrame.BackgroundTransparency = 0.4

	print("[BattleUI] å˜èªè¨­å®š")

	-- æœ€åˆã®å˜èªã‚’è¨­å®š
	setNextWord()

	print("[BattleUI] ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆè¨­å®š")

	-- ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆæ©Ÿèƒ½ï¼š30ç§’çµŒéã—ãŸã‚‰å¼·åˆ¶çµ‚äº†
	currentBattleTimeout = task.delay(30, function()
		if inBattle then
			warn("[BattleUI] ãƒãƒˆãƒ«ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆï¼å¼·åˆ¶çµ‚äº†ã—ã¾ã™")
			onBattleEnd(false)
		end
	end)

	print("[BattleUI] === ãƒãƒˆãƒ«é–‹å§‹å‡¦ç†å®Œäº† ===")
end

-- ãƒãƒˆãƒ«çµ‚äº†å‡¦ç†
onBattleEnd = function(victory)
	print("[BattleUI] === ãƒãƒˆãƒ«çµ‚äº†é–‹å§‹: " .. tostring(victory) .. " ===")

	-- æ—¢ã«ãƒãƒˆãƒ«ãŒçµ‚äº†ã—ã¦ã„ã‚‹å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
	if not inBattle and not battleGui.Enabled then
		print("[BattleUI] æ—¢ã«ãƒãƒˆãƒ«çµ‚äº†æ¸ˆã¿")
		return
	end

	-- ã€æœ€å„ªå…ˆã€‘ãƒãƒˆãƒ«çŠ¶æ…‹ã‚’å³åº§ã«ã‚¯ãƒªã‚¢ï¼ˆã‚­ãƒ¼å…¥åŠ›ã‚’åœæ­¢ï¼‰
	inBattle = false
	currentWord = ""
	currentWordData = nil
	currentIndex = 1
	playerHP = 0
	playerMaxHP = 0

	-- ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«
	if currentBattleTimeout then
		task.cancel(currentBattleTimeout)
		currentBattleTimeout = nil
	end

	-- å‹åˆ©æ™‚ã®å‡¦ç†
	-- å‹åˆ©æ™‚ã®å‡¦ç†
	if victory then
		-- ã‚·ã‚¹ãƒ†ãƒ ã‚­ãƒ¼ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’è§£é™¤
		unblockSystemKeys()

		print("[BattleUI] Roblox UIå†æœ‰åŠ¹åŒ–")

		-- Roblox UIã‚’å†æœ‰åŠ¹åŒ–
		pcall(function()
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Chat, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.EmotesMenu, true)
		end)

		-- å‹åˆ©ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
		if wordLabel then
			wordLabel.RichText = false
			wordLabel.Text = "VICTORY!"
			wordLabel.TextColor3 = Color3.fromRGB(255, 215, 0)
			wordLabel.TextTransparency = 0
			wordLabel.TextStrokeTransparency = 0

			-- 0.5ç§’ã‹ã‘ã¦ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
			TweenService:Create(wordLabel, TweenInfo.new(0.5), {
				TextTransparency = 1,
				TextStrokeTransparency = 1
			}):Play()
		end

		-- ç¿»è¨³ãƒ©ãƒ™ãƒ«ã‚’éè¡¨ç¤º
		if translationLabel then
			translationLabel.Visible = false
		end

		-- æ ã‚’é‡‘è‰²ã«ã—ã¦ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
		if wordFrame then
			wordFrame.BorderColor3 = Color3.fromRGB(255, 215, 0)
			local frameStroke = wordFrame:FindFirstChildOfClass("UIStroke")
			if frameStroke then
				frameStroke.Color = Color3.fromRGB(255, 215, 0)
				TweenService:Create(frameStroke, TweenInfo.new(0.5), {
					Transparency = 1
				}):Play()
			end

			TweenService:Create(wordFrame, TweenInfo.new(0.5), {
				BackgroundTransparency = 1
			}):Play()
		end

		-- HPãƒãƒ¼ã‚’ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
		if hpBarBackground then
			TweenService:Create(hpBarBackground, TweenInfo.new(0.5), {
				BackgroundTransparency = 1
			}):Play()
		end

		if hpBarFill then
			TweenService:Create(hpBarFill, TweenInfo.new(0.5), {
				BackgroundTransparency = 1
			}):Play()
		end

		if hpLabel then
			TweenService:Create(hpLabel, TweenInfo.new(0.5), {
				TextTransparency = 1,
				TextStrokeTransparency = 1
			}):Play()
		end

		-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å…¥åŠ›ãƒ–ãƒ­ãƒƒã‚¯ã‚’è§£é™¤
		local character = player.Character
		if character then
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			if humanoid then
				humanoid.WalkSpeed = 16
				humanoid.JumpPower = 50
				humanoid.JumpHeight = 7.2
			end
		end

		-- ç”»é¢ã‚’æ˜ã‚‹ãæˆ»ã™
		TweenService:Create(darkenFrame, TweenInfo.new(0.5), {
			BackgroundTransparency = 1
		}):Play()

		-- UIã‚’éè¡¨ç¤ºã«ã™ã‚‹ãŸã‚ã®é…å»¶å®Ÿè¡Œï¼ˆåˆ¥ã‚¹ãƒ¬ãƒƒãƒ‰ã§ï¼‰
		task.spawn(function()
			task.wait(0.6)  -- ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº†ã‚’å¾…ã¤
			if not inBattle then  -- ã¾ã æ¬¡ã®ãƒãƒˆãƒ«ãŒå§‹ã¾ã£ã¦ã„ãªã„ã“ã¨ã‚’ç¢ºèª
				battleGui.Enabled = false
			end
		end)
	else
		-- æ•—åŒ—æ™‚ï¼šUIã‚’ç¶­æŒã—ãŸã¾ã¾æ­»äº¡é¸æŠUIã‚’å¾…ã¤
		print("[BattleUI] æ•—åŒ— - UIã‚’ç¶­æŒã—ã¾ã™")

		-- æ•—åŒ—ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
		if wordLabel then
			wordLabel.RichText = false
			wordLabel.Text = "DEFEAT..."
			wordLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
		end

		-- ç¿»è¨³ãƒ©ãƒ™ãƒ«ã‚’éè¡¨ç¤º
		if translationLabel then
			translationLabel.Visible = false
		end

		-- æ ã®è‰²ã‚‚å¤‰æ›´
		if wordFrame then
			local frameStroke = wordFrame:FindFirstChildOfClass("UIStroke")
			if frameStroke then
				frameStroke.Color = Color3.fromRGB(255, 100, 100)
			end
		end

		-- ã‚·ã‚¹ãƒ†ãƒ ã‚­ãƒ¼ã®ãƒ–ãƒ­ãƒƒã‚¯ã¨Roblox UIã¯ç¶­æŒ
		-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç§»å‹•åˆ¶é™ã‚‚ç¶­æŒ
		-- æ­»äº¡é¸æŠUIã§é¸ã‚“ã å¾Œã«è§£é™¤ã™ã‚‹
	end

	print("[BattleUI] === ãƒãƒˆãƒ«çµ‚äº†å®Œäº† ===")
end

-- HPæ›´æ–°å‡¦ç†ï¼ˆæ•µï¼‰
local function onHPUpdate(newHP)
	monsterHP = newHP

	print(("[BattleUI] ========================================"):format())
	print(("[BattleUI] æ•µHPæ›´æ–°"):format())
	print(("  æ–°HP: %d"):format(newHP))
	print(("  æœ€å¤§HP: %d"):format(monsterMaxHP))
	print(("  HPå‰²åˆ: %.1f%%"):format((newHP / monsterMaxHP) * 100))
	print(("[BattleUI] ========================================"):format())

	updateDisplay()

	-- HPãŒ0ã«ãªã£ãŸã‚‰å‹åˆ©ï¼ˆã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰ã®é€šçŸ¥ã‚‚æ¥ã‚‹ãŒå¿µã®ãŸã‚ï¼‰
	if monsterHP <= 0 then
		print("[BattleUI] âš ï¸ æ•µHPãŒ0ã«ãªã‚Šã¾ã—ãŸï¼ˆã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã§æ¤œå‡ºï¼‰")
	end
end

-- HPæ›´æ–°å‡¦ç†ï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼‰
local function onPlayerHPUpdate(newHP, newMaxHP)
	playerHP = newHP
	playerMaxHP = newMaxHP or playerMaxHP
	updateDisplay()

	print(("[BattleUI] ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼HPæ›´æ–°: %d / %d"):format(playerHP, playerMaxHP))

	-- HPãŒ0ã«ãªã£ãŸã‚‰æ•—åŒ—ï¼ˆã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰ã®é€šçŸ¥ã‚‚æ¥ã‚‹ãŒå¿µã®ãŸã‚ï¼‰
	if playerHP <= 0 then
		print("[BattleUI] ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼HPãŒ0ã«ãªã‚Šã¾ã—ãŸ")
	end
end

-- ã‚·ã‚¹ãƒ†ãƒ ã‚­ãƒ¼ã‚’ãƒ–ãƒ­ãƒƒã‚¯ã™ã‚‹å…¥åŠ›å‡¦ç†ï¼ˆæœ€å„ªå…ˆï¼‰
UserInputService.InputBegan:Connect(function(input, gameProcessed)
	-- ãƒãƒˆãƒ«ä¸­ã«ã‚·ã‚¹ãƒ†ãƒ ã‚­ãƒ¼ãŒæŠ¼ã•ã‚ŒãŸå ´åˆã€å…ˆã«å‡¦ç†ã—ã¦æ¶ˆè²»ã™ã‚‹
	if inBattle and input.UserInputType == Enum.UserInputType.Keyboard then
		local blockedKeys = {
			[Enum.KeyCode.I] = true,
			[Enum.KeyCode.O] = true,
			[Enum.KeyCode.Slash] = true,
			[Enum.KeyCode.Backquote] = true,
			[Enum.KeyCode.Tab] = true,
			[Enum.KeyCode.BackSlash] = true,
			[Enum.KeyCode.Equals] = true,
			[Enum.KeyCode.Minus] = true,
		}

		if blockedKeys[input.KeyCode] then
			-- ã“ã®ã‚­ãƒ¼ã¯ã‚¿ã‚¤ãƒ”ãƒ³ã‚°å‡¦ç†ã«å›ã™ï¼ˆã‚ºãƒ¼ãƒ ãªã©ã¯ç™ºå‹•ã•ã›ãªã„ï¼‰
			return
		end
	end
end)

-- ã‚­ãƒ¼å…¥åŠ›å‡¦ç†
local function onKeyPress(input, gameProcessed)
	if not inBattle then return end

	if input.UserInputType == Enum.UserInputType.Keyboard then
		local keyCode = input.KeyCode
		local keyString = UserInputService:GetStringForKeyCode(keyCode):lower()

		-- è‹±å­—ã®ã¿å—ã‘ä»˜ã‘
		if #keyString == 1 and keyString:match("%a") then
			local expectedChar = string.sub(currentWord, currentIndex, currentIndex):lower()

			if keyString == expectedChar then
				-- æ­£è§£
				currentIndex = currentIndex + 1

				-- æ­£è§£éŸ³ã‚’å†ç”Ÿ
				if TypingCorrectSound then
					TypingCorrectSound:Play()
				end

				-- ã‚µãƒ¼ãƒãƒ¼ã«ãƒ€ãƒ¡ãƒ¼ã‚¸é€šçŸ¥
				BattleDamageEvent:FireServer(damagePerKey)

				-- å˜èªå®Œæˆãƒã‚§ãƒƒã‚¯
				if currentIndex > #currentWord then
					task.wait(0.3)
					if inBattle then
						setNextWord()
					end
				else
					updateDisplay()
				end
			else
				-- ã‚¿ã‚¤ãƒ—ãƒŸã‚¹
				if TypingErrorSound then
					TypingErrorSound:Play()
				end

				-- æ ã‚’èµ¤ãå…‰ã‚‰ã›ã‚‹ï¼ˆç‚¹æ»…ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼‰
				if wordFrame then
					-- èƒŒæ™¯ã‚’èµ¤ã
					wordFrame.BackgroundColor3 = Color3.fromRGB(255, 50, 50)
					wordFrame.BackgroundTransparency = 0.3  -- å°‘ã—æ¿ƒã

					-- æ ç·šã‚‚èµ¤ã
					local frameStroke = wordFrame:FindFirstChildOfClass("UIStroke")
					if frameStroke then
						frameStroke.Color = Color3.fromRGB(255, 50, 50)
					end

					-- 0.3ç§’ã‹ã‘ã¦å…ƒã«æˆ»ã™
					TweenService:Create(wordFrame, TweenInfo.new(0.3), {
						BackgroundColor3 = Color3.fromRGB(30, 30, 40),
						BackgroundTransparency = 0.2
					}):Play()

					if frameStroke then
						TweenService:Create(frameStroke, TweenInfo.new(0.3), {
							Color = Color3.fromRGB(100, 200, 255)
						}):Play()
					end
				end

				-- ã‚¿ã‚¤ãƒ—ãƒŸã‚¹æ™‚ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ã‚µãƒ¼ãƒãƒ¼ã«é€šçŸ¥
				local TypingMistakeEvent = ReplicatedStorage:FindFirstChild("TypingMistake")
				if TypingMistakeEvent then
					TypingMistakeEvent:FireServer()
				end
			end
		end
	end
end

-- åˆæœŸåŒ–
createBattleUI()

print("[BattleUI] ã‚¤ãƒ™ãƒ³ãƒˆæ¥ç¶šä¸­...")
BattleStartEvent.OnClientEvent:Connect(onBattleStart)
BattleEndEvent.OnClientEvent:Connect(onBattleEnd)

-- HPæ›´æ–°ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆæ•µï¼‰
local HPUpdateEvent = ReplicatedStorage:FindFirstChild("BattleHPUpdate")
if HPUpdateEvent then
	HPUpdateEvent.OnClientEvent:Connect(onHPUpdate)
end

-- HPæ›´æ–°ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼‰
local PlayerHPUpdateEvent = ReplicatedStorage:FindFirstChild("PlayerHPUpdate")

if PlayerHPUpdateEvent then
	PlayerHPUpdateEvent.OnClientEvent:Connect(onPlayerHPUpdate)
else
	warn("[BattleUI] PlayerHPUpdate ã‚¤ãƒ™ãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
end

UserInputService.InputBegan:Connect(onKeyPress)

-- ç·Šæ€¥è„±å‡ºç”¨ï¼šEscã‚­ãƒ¼ã§å¼·åˆ¶çµ‚äº†
UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if input.KeyCode == Enum.KeyCode.Escape and battleGui.Enabled then
		warn("[BattleUI] Escã‚­ãƒ¼ã§å¼·åˆ¶çµ‚äº†")

		-- ã‚·ã‚¹ãƒ†ãƒ ã‚­ãƒ¼ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’è§£é™¤
		unblockSystemKeys()

		-- Roblox UIã‚’å†æœ‰åŠ¹åŒ–
		pcall(function()
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Chat, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.EmotesMenu, true)
		end)

		darkenFrame.BackgroundTransparency = 1
		battleGui.Enabled = false
		inBattle = false
		currentWord = ""
		currentWordData = nil
		currentIndex = 1
		playerHP = 0
		playerMaxHP = 0

		local character = player.Character
		if character then
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			if humanoid then
				humanoid.WalkSpeed = 16
				humanoid.JumpPower = 50
				humanoid.JumpHeight = 7.2
			end
		end
	end
end)

print("[BattleUI] ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆåˆæœŸåŒ–å®Œäº†ï¼ˆã‚¿ã‚¤ãƒ”ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ï¼‰")
===== ./StartPlayerScripts/StatusUI.client.lua =====
-- StarterPlayer/StarterPlayerScripts/StatusUI.client.lua
-- ç”»é¢å·¦ä¸‹ã«å¸¸æ™‚è¡¨ç¤ºã™ã‚‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

print("[StatusUI] åˆæœŸåŒ–ä¸­...")

-- ç¾åœ¨ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
local currentHP = 100
local currentMaxHP = 100
local currentLevel = 1
local currentExp = 0
local currentExpToNext = 100
local currentGold = 0

-- UIè¦ç´ 
local statusGui = nil
local hpBarBackground = nil
local hpBarFill = nil
local hpLabel = nil
local levelLabel = nil
local expLabel = nil
local goldLabel = nil

-- HPã®è‰²ã‚’å–å¾—
local function getHPColor(hpPercent)
	if hpPercent > 0.6 then
		return Color3.fromRGB(46, 204, 113)  -- ç·‘
	elseif hpPercent > 0.3 then
		return Color3.fromRGB(241, 196, 15)  -- é»„è‰²
	else
		return Color3.fromRGB(231, 76, 60)  -- èµ¤
	end
end

-- è¡¨ç¤ºã‚’æ›´æ–°
local function updateDisplay()
	if hpBarFill and hpLabel then
		local hpPercent = currentHP / currentMaxHP

		-- ãƒãƒ¼ã®é•·ã•ã‚’ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
		local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
		local tween = TweenService:Create(hpBarFill, tweenInfo, {
			Size = UDim2.new(hpPercent, 0, 1, 0)
		})
		tween:Play()

		-- è‰²ã‚’å¤‰æ›´
		hpBarFill.BackgroundColor3 = getHPColor(hpPercent)

		-- ãƒ†ã‚­ã‚¹ãƒˆæ›´æ–°
		hpLabel.Text = string.format("%d / %d", currentHP, currentMaxHP)
	end

	if levelLabel then
		levelLabel.Text = string.format("Lv.%d", currentLevel)
	end

	if expLabel then
		expLabel.Text = string.format("EXP: %d / %d", currentExp, currentExpToNext)
	end

	if goldLabel then
		goldLabel.Text = string.format("ğŸ’° %d G", currentGold)
	end
end

-- UIä½œæˆ
local function createStatusUI()
	statusGui = Instance.new("ScreenGui")
	statusGui.Name = "StatusUI"
	statusGui.ResetOnSpawn = false
	statusGui.Parent = playerGui

	-- èƒŒæ™¯ãƒ•ãƒ¬ãƒ¼ãƒ 
	local backgroundFrame = Instance.new("Frame")
	backgroundFrame.Name = "StatusBackground"
	backgroundFrame.Size = UDim2.new(0, 250, 0, 120)
	backgroundFrame.Position = UDim2.new(1, -270, 1, -140)
	backgroundFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
	backgroundFrame.BackgroundTransparency = 0.3
	backgroundFrame.BorderSizePixel = 0
	backgroundFrame.Parent = statusGui

	-- è§’ã‚’ä¸¸ãã™ã‚‹
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 10)
	corner.Parent = backgroundFrame

	-- ãƒ¬ãƒ™ãƒ«è¡¨ç¤º
	levelLabel = Instance.new("TextLabel")
	levelLabel.Name = "LevelLabel"
	levelLabel.Size = UDim2.new(0, 80, 0, 25)
	levelLabel.Position = UDim2.new(0, 10, 0, 10)
	levelLabel.BackgroundTransparency = 1
	levelLabel.TextColor3 = Color3.fromRGB(255, 215, 0)
	levelLabel.TextStrokeTransparency = 0.5
	levelLabel.Font = Enum.Font.GothamBold
	levelLabel.TextSize = 20
	levelLabel.Text = "Lv.1"
	levelLabel.TextXAlignment = Enum.TextXAlignment.Left
	levelLabel.Parent = backgroundFrame

	-- HPãƒãƒ¼èƒŒæ™¯
	hpBarBackground = Instance.new("Frame")
	hpBarBackground.Name = "HPBarBackground"
	hpBarBackground.Size = UDim2.new(1, -20, 0, 20)
	hpBarBackground.Position = UDim2.new(0, 10, 0, 40)
	hpBarBackground.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
	hpBarBackground.BorderSizePixel = 0
	hpBarBackground.Parent = backgroundFrame

	-- HPãƒãƒ¼èƒŒæ™¯ã®è§’ã‚’ä¸¸ãã™ã‚‹
	local hpBarCorner = Instance.new("UICorner")
	hpBarCorner.CornerRadius = UDim.new(0, 5)
	hpBarCorner.Parent = hpBarBackground

	-- HPãƒãƒ¼ï¼ˆå¡—ã‚Šã¤ã¶ã—ï¼‰
	hpBarFill = Instance.new("Frame")
	hpBarFill.Name = "HPBarFill"
	hpBarFill.Size = UDim2.new(1, 0, 1, 0)
	hpBarFill.Position = UDim2.new(0, 0, 0, 0)
	hpBarFill.BackgroundColor3 = Color3.fromRGB(46, 204, 113)
	hpBarFill.BorderSizePixel = 0
	hpBarFill.Parent = hpBarBackground

	-- HPãƒãƒ¼ã®è§’ã‚’ä¸¸ãã™ã‚‹
	local hpFillCorner = Instance.new("UICorner")
	hpFillCorner.CornerRadius = UDim.new(0, 5)
	hpFillCorner.Parent = hpBarFill

	-- HPãƒ†ã‚­ã‚¹ãƒˆ
	hpLabel = Instance.new("TextLabel")
	hpLabel.Name = "HPLabel"
	hpLabel.Size = UDim2.new(1, 0, 1, 0)
	hpLabel.Position = UDim2.new(0, 0, 0, 0)
	hpLabel.BackgroundTransparency = 1
	hpLabel.TextColor3 = Color3.new(1, 1, 1)
	hpLabel.TextStrokeTransparency = 0.5
	hpLabel.Font = Enum.Font.GothamBold
	hpLabel.TextSize = 14
	hpLabel.Text = "100 / 100"
	hpLabel.Parent = hpBarBackground

	-- çµŒé¨“å€¤è¡¨ç¤º
	expLabel = Instance.new("TextLabel")
	expLabel.Name = "ExpLabel"
	expLabel.Size = UDim2.new(1, -20, 0, 18)
	expLabel.Position = UDim2.new(0, 10, 0, 65)
	expLabel.BackgroundTransparency = 1
	expLabel.TextColor3 = Color3.fromRGB(150, 200, 255)
	expLabel.TextStrokeTransparency = 0.7
	expLabel.Font = Enum.Font.Gotham
	expLabel.TextSize = 14
	expLabel.Text = "EXP: 0 / 100"
	expLabel.TextXAlignment = Enum.TextXAlignment.Left
	expLabel.Parent = backgroundFrame

	-- ã‚´ãƒ¼ãƒ«ãƒ‰è¡¨ç¤º
	goldLabel = Instance.new("TextLabel")
	goldLabel.Name = "GoldLabel"
	goldLabel.Size = UDim2.new(1, -20, 0, 18)
	goldLabel.Position = UDim2.new(0, 10, 0, 88)
	goldLabel.BackgroundTransparency = 1
	goldLabel.TextColor3 = Color3.fromRGB(255, 215, 0)
	goldLabel.TextStrokeTransparency = 0.7
	goldLabel.Font = Enum.Font.GothamBold
	goldLabel.TextSize = 14
	goldLabel.Text = "ğŸ’° 0 G"
	goldLabel.TextXAlignment = Enum.TextXAlignment.Left
	goldLabel.Parent = backgroundFrame

	print("[StatusUI] UIä½œæˆå®Œäº†")
end

-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°ã‚¤ãƒ™ãƒ³ãƒˆ
local function onStatusUpdate(hp, maxHP, level, exp, expToNext, gold)
	print(("[StatusUI] ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°å—ä¿¡: HP=%d/%d, Lv=%d, EXP=%d/%d, Gold=%d"):format(
		hp or 0, maxHP or 0, level or 0, exp or 0, expToNext or 0, gold or 0
		))

	currentHP = hp or currentHP
	currentMaxHP = maxHP or currentMaxHP
	currentLevel = level or currentLevel
	currentExp = exp or currentExp
	currentExpToNext = expToNext or currentExpToNext
	currentGold = gold or currentGold

	updateDisplay()
end

-- åˆæœŸåŒ–
createStatusUI()

print("[StatusUI] RemoteEventã‚’å¾…æ©Ÿä¸­...")

-- RemoteEventã‚’å¾…æ©Ÿï¼ˆæœ€å¤§30ç§’ï¼‰
task.spawn(function()
	local StatusUpdateEvent = ReplicatedStorage:WaitForChild("StatusUpdate", 30)
	if StatusUpdateEvent then
		StatusUpdateEvent.OnClientEvent:Connect(onStatusUpdate)
		print("[StatusUI] StatusUpdateã‚¤ãƒ™ãƒ³ãƒˆæ¥ç¶šå®Œäº†")

		-- åˆå›ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¦æ±‚
		task.wait(1)  -- 1ç§’å¾…ã£ã¦ã‹ã‚‰è¦æ±‚
		local RequestStatusEvent = ReplicatedStorage:FindFirstChild("RequestStatus")
		if RequestStatusEvent then
			print("[StatusUI] åˆå›ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’è¦æ±‚")
			RequestStatusEvent:FireServer()
		else
			warn("[StatusUI] RequestStatusã‚¤ãƒ™ãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
		end
	else
		warn("[StatusUI] StatusUpdateã‚¤ãƒ™ãƒ³ãƒˆã®å¾…æ©ŸãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸ")
	end
end)

print("[StatusUI] åˆæœŸåŒ–å®Œäº†")
===== ./StartPlayerScripts/WarpUI.client.lua =====
-- StarterPlayer/StarterPlayerScripts/WarpUI.client.lua
-- ãƒ¯ãƒ¼ãƒ—æ™‚ã®ãƒ­ãƒ¼ãƒ‰ç”»é¢

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- RemoteEventã‚’å–å¾—
local warpEvent = ReplicatedStorage:WaitForChild("WarpEvent")

print("[WarpUI] åˆæœŸåŒ–å®Œäº†")

-- ãƒ­ãƒ¼ãƒ‰ç”»é¢ã®UI
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "WarpLoadingUI"
screenGui.ResetOnSpawn = false
screenGui.IgnoreGuiInset = true
screenGui.Parent = playerGui

local frame = Instance.new("Frame")
frame.Name = "LoadingFrame"
frame.Size = UDim2.new(1, 0, 1, 0)
frame.BackgroundColor3 = Color3.new(0, 0, 0)
frame.BackgroundTransparency = 1
frame.Visible = false
frame.Parent = screenGui

local label = Instance.new("TextLabel")
label.Size = UDim2.new(0.6, 0, 0.2, 0)
label.Position = UDim2.new(0.2, 0, 0.4, 0)
label.BackgroundTransparency = 1
label.Text = "Loading..."
label.TextColor3 = Color3.new(1, 1, 1)
label.TextScaled = true
label.Font = Enum.Font.SourceSansBold
label.Parent = frame

-- RemoteEventã‚’å—ä¿¡
warpEvent.OnClientEvent:Connect(function(action, zoneName)
	if action == "StartLoading" then
		print("[WarpUI] ãƒ­ãƒ¼ãƒ‰ç”»é¢è¡¨ç¤º:", zoneName)
		label.Text = "Warping to " .. (zoneName or "???") .. "..."
		frame.BackgroundTransparency = 0.3
		frame.Visible = true

		-- ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
		for i = 0.3, 0.7, 0.1 do
			frame.BackgroundTransparency = 1 - i
			task.wait(0.05)
		end

	elseif action == "EndLoading" then
		print("[WarpUI] ãƒ­ãƒ¼ãƒ‰ç”»é¢éè¡¨ç¤º")

		-- ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
		for i = 0.7, 0, -0.1 do
			frame.BackgroundTransparency = 1 - i
			task.wait(0.05)
		end

		frame.Visible = false
	end
end)
===== ./StartPlayerScripts/DeathUI.client.lua =====
-- StarterPlayer/StarterPlayerScripts/DeathUI.client.lua
-- æ­»äº¡æ™‚ã®é¸æŠUIï¼ˆè¡—ã«æˆ»ã‚‹ / ã‚´ãƒ¼ãƒ«ãƒ‰ãƒ­ã‚¹ãƒˆã§å¾©æ´»ï¼‰

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

print("[DeathUI] åˆæœŸåŒ–ä¸­...")

-- UIè¦ç´ 
local deathGui = nil

-- æ­»äº¡UIã‚’è¡¨ç¤º
local function showDeathUI(currentGold, reviveCost)
	print(("[DeathUI] ========================================"):format())
	print(("[DeathUI] æ­»äº¡UIè¡¨ç¤º"):format())
	print(("[DeathUI] æ‰€æŒé‡‘: %d G, å¾©æ´»ã‚³ã‚¹ãƒˆ: %d G"):format(currentGold, reviveCost))
	print(("[DeathUI] ========================================"):format())

	-- æ—¢å­˜ã®GUIã‚’å‰Šé™¤
	if deathGui then
		deathGui:Destroy()
	end

	-- æ–°ã—ã„GUIã‚’ä½œæˆ
	deathGui = Instance.new("ScreenGui")
	deathGui.Name = "DeathUI"
	deathGui.ResetOnSpawn = false
	deathGui.Parent = playerGui

	-- èƒŒæ™¯ï¼ˆæš—ã„ï¼‰
	local background = Instance.new("Frame")
	background.Size = UDim2.fromScale(1, 1)
	background.Position = UDim2.fromScale(0, 0)
	background.BackgroundColor3 = Color3.new(0, 0, 0)
	background.BackgroundTransparency = 0.3
	background.BorderSizePixel = 0
	background.ZIndex = 200
	background.Parent = deathGui

	-- ã‚¿ã‚¤ãƒˆãƒ«
	local titleText = Instance.new("TextLabel")
	titleText.Size = UDim2.new(0, 600, 0, 80)
	titleText.Position = UDim2.new(0.5, -300, 0.3, 0)
	titleText.BackgroundTransparency = 1
	titleText.TextColor3 = Color3.fromRGB(255, 100, 100)
	titleText.TextStrokeTransparency = 0
	titleText.Font = Enum.Font.GothamBold
	titleText.TextSize = 50
	titleText.Text = "YOU DIED"
	titleText.ZIndex = 201
	titleText.Parent = deathGui

	-- é¸æŠãƒ•ãƒ¬ãƒ¼ãƒ 
	local choiceFrame = Instance.new("Frame")
	choiceFrame.Size = UDim2.new(0, 600, 0, 200)
	choiceFrame.Position = UDim2.new(0.5, -300, 0.45, 0)
	choiceFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
	choiceFrame.BackgroundTransparency = 0.2
	choiceFrame.BorderSizePixel = 0
	choiceFrame.ZIndex = 201
	choiceFrame.Parent = deathGui

	-- è§’ã‚’ä¸¸ãã™ã‚‹
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 10)
	corner.Parent = choiceFrame

	-- èª¬æ˜ãƒ†ã‚­ã‚¹ãƒˆ
	local descText = Instance.new("TextLabel")
	descText.Size = UDim2.new(1, -40, 0, 60)
	descText.Position = UDim2.new(0, 20, 0, 20)
	descText.BackgroundTransparency = 1
	descText.TextColor3 = Color3.fromRGB(255, 255, 255)
	descText.TextStrokeTransparency = 0.5
	descText.Font = Enum.Font.Gotham
	descText.TextSize = 18
	descText.Text = "æ•—åŒ—ã—ã¾ã—ãŸã€‚ã©ã†ã—ã¾ã™ã‹ï¼Ÿ"
	descText.TextWrapped = true
	descText.ZIndex = 202
	descText.Parent = choiceFrame

	-- ã€Œè¡—ã«æˆ»ã‚‹ã€ãƒœã‚¿ãƒ³
	local returnButton = Instance.new("TextButton")
	returnButton.Size = UDim2.new(0, 250, 0, 50)
	returnButton.Position = UDim2.new(0.5, -260, 0, 100)
	returnButton.BackgroundColor3 = Color3.fromRGB(52, 152, 219)
	returnButton.BorderSizePixel = 0
	returnButton.Font = Enum.Font.GothamBold
	returnButton.TextSize = 20
	returnButton.Text = "ğŸ  è¡—ã«æˆ»ã‚‹"
	returnButton.TextColor3 = Color3.new(1, 1, 1)
	returnButton.ZIndex = 202
	returnButton.Parent = choiceFrame

	-- ãƒœã‚¿ãƒ³ã®è§’ã‚’ä¸¸ãã™ã‚‹
	local returnCorner = Instance.new("UICorner")
	returnCorner.CornerRadius = UDim.new(0, 8)
	returnCorner.Parent = returnButton

	-- ã€Œã‚´ãƒ¼ãƒ«ãƒ‰ã§å¾©æ´»ã€ãƒœã‚¿ãƒ³
	local reviveButton = Instance.new("TextButton")
	reviveButton.Size = UDim2.new(0, 250, 0, 50)
	reviveButton.Position = UDim2.new(0.5, 10, 0, 100)
	reviveButton.BorderSizePixel = 0
	reviveButton.Font = Enum.Font.GothamBold
	reviveButton.TextSize = 20
	reviveButton.TextColor3 = Color3.new(1, 1, 1)
	reviveButton.ZIndex = 202
	reviveButton.Parent = choiceFrame

	-- ãƒœã‚¿ãƒ³ã®è§’ã‚’ä¸¸ãã™ã‚‹
	local reviveCorner = Instance.new("UICorner")
	reviveCorner.CornerRadius = UDim.new(0, 8)
	reviveCorner.Parent = reviveButton

	-- ã‚´ãƒ¼ãƒ«ãƒ‰ãŒè¶³ã‚Šã‚‹ã‹ãƒã‚§ãƒƒã‚¯
	if currentGold >= reviveCost then
		reviveButton.BackgroundColor3 = Color3.fromRGB(46, 204, 113)
		reviveButton.Text = string.format("ğŸ’° å¾©æ´» (%d G)", reviveCost)
	else
		reviveButton.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
		reviveButton.Text = string.format("ğŸ’° å¾©æ´» (%d G) - ä¸è¶³", reviveCost)
		reviveButton.Active = false
	end

	-- ãƒœã‚¿ãƒ³ã®ãƒ›ãƒãƒ¼ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
	returnButton.MouseEnter:Connect(function()
		returnButton.BackgroundColor3 = Color3.fromRGB(62, 172, 239)
	end)
	returnButton.MouseLeave:Connect(function()
		returnButton.BackgroundColor3 = Color3.fromRGB(52, 152, 219)
	end)

	if currentGold >= reviveCost then
		reviveButton.MouseEnter:Connect(function()
			reviveButton.BackgroundColor3 = Color3.fromRGB(56, 224, 133)
		end)
		reviveButton.MouseLeave:Connect(function()
			reviveButton.BackgroundColor3 = Color3.fromRGB(46, 204, 113)
		end)
	end

	-- ã€Œè¡—ã«æˆ»ã‚‹ã€ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯
	returnButton.MouseButton1Click:Connect(function()
		print("[DeathUI] è¡—ã«æˆ»ã‚‹ã‚’é¸æŠ")

		-- ã‚µãƒ¼ãƒãƒ¼ã«é€šçŸ¥
		local DeathChoiceEvent = ReplicatedStorage:FindFirstChild("DeathChoice")
		if DeathChoiceEvent then
			DeathChoiceEvent:FireServer("return")
		end

		-- ãƒãƒˆãƒ«UIã‚’é–‰ã˜ã‚‹
		local battleUI = playerGui:FindFirstChild("BattleUI")
		if battleUI then
			battleUI.Enabled = false
		end

		-- ã‚·ã‚¹ãƒ†ãƒ ã‚­ãƒ¼ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’è§£é™¤
		local ContextActionService = game:GetService("ContextActionService")
		ContextActionService:UnbindAction("BlockSystemKeys")

		-- Roblox UIã‚’å†æœ‰åŠ¹åŒ–
		local StarterGui = game:GetService("StarterGui")
		pcall(function()
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Chat, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.EmotesMenu, true)
		end)

		-- UIã‚’é–‰ã˜ã‚‹
		if deathGui then
			deathGui:Destroy()
			deathGui = nil
		end
	end)

	-- ã€Œã‚´ãƒ¼ãƒ«ãƒ‰ã§å¾©æ´»ã€ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯
	reviveButton.MouseButton1Click:Connect(function()
		if currentGold < reviveCost then
			print("[DeathUI] ã‚´ãƒ¼ãƒ«ãƒ‰ä¸è¶³")
			return
		end

		print("[DeathUI] ã‚´ãƒ¼ãƒ«ãƒ‰ã§å¾©æ´»ã‚’é¸æŠ")

		-- ã‚µãƒ¼ãƒãƒ¼ã«é€šçŸ¥
		local DeathChoiceEvent = ReplicatedStorage:FindFirstChild("DeathChoice")
		if DeathChoiceEvent then
			DeathChoiceEvent:FireServer("revive")
		end

		-- ãƒãƒˆãƒ«UIã‚’é–‰ã˜ã‚‹
		local battleUI = playerGui:FindFirstChild("BattleUI")
		if battleUI then
			battleUI.Enabled = false
		end

		-- ã‚·ã‚¹ãƒ†ãƒ ã‚­ãƒ¼ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’è§£é™¤
		local ContextActionService = game:GetService("ContextActionService")
		ContextActionService:UnbindAction("BlockSystemKeys")

		-- Roblox UIã‚’å†æœ‰åŠ¹åŒ–
		local StarterGui = game:GetService("StarterGui")
		pcall(function()
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Chat, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.EmotesMenu, true)
		end)

		-- UIã‚’é–‰ã˜ã‚‹
		if deathGui then
			deathGui:Destroy()
			deathGui = nil
		end
	end)
end

-- RemoteEventã‚’å¾…æ©Ÿ
local ShowDeathUIEvent = ReplicatedStorage:WaitForChild("ShowDeathUI", 10)
if ShowDeathUIEvent then
	ShowDeathUIEvent.OnClientEvent:Connect(showDeathUI)
	print("[DeathUI] ShowDeathUIã‚¤ãƒ™ãƒ³ãƒˆæ¥ç¶šå®Œäº†")
else
	warn("[DeathUI] ShowDeathUIã‚¤ãƒ™ãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
end

print("[DeathUI] åˆæœŸåŒ–å®Œäº†")
===== ./StartPlayerScripts/BGMManager.client.lua =====
-- StarterPlayer/StarterPlayerScripts/BGMManager.client.lua
-- å¤§é™¸BGMç®¡ç†ã‚·ã‚¹ãƒ†ãƒ  (ãƒãƒˆãƒ«ä¸­ã®éŸ³é‡èª¿æ•´å¯¾å¿œç‰ˆ)

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local SoundService = game:GetService("SoundService")
local TweenService = game:GetService("TweenService") -- TweenServiceã‚’è¿½åŠ 

local player = Players.LocalPlayer

-- å¤§é™¸æƒ…å ±ã‚’èª­ã¿è¾¼ã¿
local ContinentsRegistry = require(ReplicatedStorage.Continents.Registry)
local Continents = {}
for _, continent in ipairs(ContinentsRegistry) do
	Continents[continent.name] = continent
end

-- BGMçŠ¶æ…‹
local currentBGM = nil
local currentZone = nil
local isBattleActive = false
local bgmSound = nil
local originalVolume = 0.3 -- ã€è¿½åŠ ãƒ»ä¿®æ­£1ã€‘å…ƒã®éŸ³é‡ã‚’ä¿æŒã™ã‚‹å¤‰æ•°ã‚’è¿½åŠ ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ 0.3ï¼‰

-- BGMã‚µã‚¦ãƒ³ãƒ‰ã‚’ä½œæˆ
local function createBGMSound(assetId, volume)
	if bgmSound then
		bgmSound:Stop()
		bgmSound:Destroy()
	end

	bgmSound = Instance.new("Sound")
	bgmSound.Name = "BGM"
	bgmSound.SoundId = assetId

	-- ã€ä¿®æ­£2ã€‘éŸ³é‡ã‚’è¨­å®šã—ã€originalVolumeã‚’æ›´æ–°
	local finalVolume = volume or 0.3
	bgmSound.Volume = finalVolume
	originalVolume = finalVolume -- å–å¾—ã—ãŸéŸ³é‡ã‚’ä¿å­˜

	bgmSound.Looped = true
	bgmSound.Parent = SoundService

	return bgmSound
end

-- BGMã‚’å†ç”Ÿ
local function playBGM(assetId, volume)
	if currentBGM == assetId and bgmSound and bgmSound.IsPlaying and not isBattleActive then
		-- æ—¢ã«åŒã˜BGMãŒå†ç”Ÿä¸­ã§ã€æˆ¦é—˜ä¸­ã§ãªã‘ã‚Œã°ä½•ã‚‚ã—ãªã„
		return
	end

	print(("[BGMManager] BGMå†ç”Ÿ: %s, Volume: %.2f"):format(assetId, volume or 0.3))

	currentBGM = assetId
	local sound = createBGMSound(assetId, volume)
	sound:Play()

	-- æ–°ã—ãå†ç”Ÿã™ã‚‹BGMãŒæˆ¦é—˜ä¸­ã«åˆ‡ã‚Šæ›¿ã‚ã£ãŸå ´åˆã€éŸ³é‡ã‚’ä¸‹ã’ã‚‹
	if isBattleActive and bgmSound then
		bgmSound.Volume = originalVolume * 0.3
	end
end

-- BGMã‚’åœæ­¢
local function stopBGM()
	if bgmSound then
		print("[BGMManager] BGMåœæ­¢")

        -- ã€ä¿®æ­£3ã€‘Tweenã‚’ä½¿ã£ã¦ã‚¹ãƒ ãƒ¼ã‚ºã«åœæ­¢
        TweenService:Create(bgmSound, TweenInfo.new(0.5), {
            Volume = 0
        }):Play()

        task.delay(0.5, function()
            -- 0.5ç§’å¾Œã€éŸ³é‡ãŒ0ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¦åœæ­¢ãƒ»å‰Šé™¤
            if bgmSound and bgmSound.Volume == 0 then
                bgmSound:Stop()
                bgmSound:Destroy()
                bgmSound = nil -- å‚ç…§ã‚’ã‚¯ãƒªã‚¢
            end
        end)
	end
	currentBGM = nil
end

-- ã‚¾ãƒ¼ãƒ³å¤‰æ›´æ™‚ã®BGMå‡¦ç†
local function onZoneChange(zoneName, isActive)
	if isActive then
		-- ã‚¾ãƒ¼ãƒ³ã«å…¥ã£ãŸ
		currentZone = zoneName

		-- å¤§é™¸ã®BGMè¨­å®šã‚’å–å¾—
		local continent = Continents[zoneName]
		if continent and continent.BGM then
			-- BGMVolumeã‚’playBGMã«æ¸¡ã—ã¦ã€originalVolumeã«ä¿å­˜ã•ã›ã‚‹
			playBGM(continent.BGM, continent.BGMVolume or 0.3)
		else
			-- BGMè¨­å®šãŒãªã„å ´åˆã¯åœæ­¢
			stopBGM()
		end
	else
		-- ã‚¾ãƒ¼ãƒ³ã‹ã‚‰å‡ºãŸå ´åˆã‚‚BGMã‚’åœæ­¢
		if currentZone == zoneName then
			stopBGM()
			currentZone = nil
		end
	end
end

-- ãƒãƒˆãƒ«é–‹å§‹ã‚¤ãƒ™ãƒ³ãƒˆ
local BattleStartEvent = ReplicatedStorage:WaitForChild("BattleStart", 10)
if BattleStartEvent then
	BattleStartEvent.OnClientEvent:Connect(function()
		print("[BGMManager] ãƒãƒˆãƒ«é–‹å§‹ã‚’æ¤œçŸ¥")
		isBattleActive = true

		-- ã€ä¿®æ­£4ã€‘BGMã‚’åœæ­¢ã›ãšã€éŸ³é‡ã‚’50%ã«ä¸‹ã’ã‚‹
		if bgmSound and bgmSound.IsPlaying then
			local targetVolume = originalVolume * 0.3 -- å…ƒã®éŸ³é‡ã®50%
			print(("[BGMManager] BGMéŸ³é‡ã‚’ %.2f ã‹ã‚‰ %.2f ã«èª¿æ•´"):format(bgmSound.Volume, targetVolume))
			TweenService:Create(bgmSound, TweenInfo.new(0.5), {
				Volume = targetVolume
			}):Play()
		end

	end)
end

-- ãƒãƒˆãƒ«çµ‚äº†ã‚¤ãƒ™ãƒ³ãƒˆ
local BattleEndEvent = ReplicatedStorage:WaitForChild("BattleEnd", 10)
if BattleEndEvent then
	BattleEndEvent.OnClientEvent:Connect(function()
		print("[BGMManager] ãƒãƒˆãƒ«çµ‚äº†ã‚’æ¤œçŸ¥")
		isBattleActive = false

		-- ã€ä¿®æ­£5ã€‘BGMã‚’å…ƒã®éŸ³é‡ã«æˆ»ã™
		if bgmSound and bgmSound.IsPlaying then
			print(("[BGMManager] BGMéŸ³é‡ã‚’ %.2f ã«æˆ»ã™"):format(originalVolume))
			TweenService:Create(bgmSound, TweenInfo.new(0.5), {
				Volume = originalVolume
			}):Play()
		end
	end)
end

-- ã‚¾ãƒ¼ãƒ³å¤‰æ›´ã‚’ç›£è¦–
task.spawn(function()
	local ZoneChangeEvent = ReplicatedStorage:FindFirstChild("ZoneChange")
	if not ZoneChangeEvent then
		warn("[BGMManager] ZoneChangeã‚¤ãƒ™ãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
		return
	end

	ZoneChangeEvent.OnClientEvent:Connect(function(zoneName, isActive)
		print(("[BGMManager] ã‚¾ãƒ¼ãƒ³å¤‰æ›´: %s - %s"):format(zoneName, isActive and "å…¥ã£ãŸ" or "å‡ºãŸ"))
		onZoneChange(zoneName, isActive)
	end)

	print("[BGMManager] ZoneChangeã‚¤ãƒ™ãƒ³ãƒˆæ¥ç¶šå®Œäº†")
end)

print("[BGMManager] åˆæœŸåŒ–å®Œäº†")
===== ./ServerScriptService/ZoneManager.lua =====
-- ServerScriptService/ZoneManager.lua (Islandã¨Continentã®ä¸¡æ–¹ã«å¯¾å¿œã—ãŸå®‰å®šç‰ˆ)
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local FieldGen = require(ReplicatedStorage:WaitForChild("FieldGen"))
local Players = game:GetService("Players")
local ZoneManager = {}

ZoneManager.ActiveZones = {}
ZoneManager.PlayerZones = {}

-- å³¶ã¨å¤§é™¸ã®è¨­å®šã‚’èª­ã¿è¾¼ã¿
local IslandsRegistry = require(ReplicatedStorage.Islands.Registry)
local ContinentsRegistry = require(ReplicatedStorage.Continents.Registry)

-- å³¶ã®è¨­å®šã‚’ãƒãƒƒãƒ—åŒ–
local Islands = {}
for _, island in ipairs(IslandsRegistry) do
    Islands[island.name] = island
end

-- å¤§é™¸ã®è¨­å®šã‚’ãƒãƒƒãƒ—åŒ–
local Continents = {}
for _, continent in ipairs(ContinentsRegistry) do
    if continent and continent.name then
        Continents[continent.name] = continent
    else
        warn("[ZoneManager] åå‰ãŒè¨­å®šã•ã‚Œã¦ã„ãªã„å¤§é™¸å®šç¾©ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã—ãŸ")
    end
end

print("[ZoneManager] åˆæœŸåŒ–å®Œäº†ã€‚å³¶æ•°:", #IslandsRegistry, "å¤§é™¸æ•°:", #ContinentsRegistry)

-- ZoneChangeã‚¤ãƒ™ãƒ³ãƒˆã‚’ä½œæˆï¼ˆã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¸ã®é€šçŸ¥ç”¨ï¼‰
local ZoneChangeEvent = ReplicatedStorage:FindFirstChild("ZoneChange")
if not ZoneChangeEvent then
    ZoneChangeEvent = Instance.new("RemoteEvent")
    ZoneChangeEvent.Name = "ZoneChange"
    ZoneChangeEvent.Parent = ReplicatedStorage
    print("[ZoneManager] ZoneChangeã‚¤ãƒ™ãƒ³ãƒˆã‚’ä½œæˆã—ã¾ã—ãŸ")
end

-- ã‚¾ãƒ¼ãƒ³ãŒå¤§é™¸ã‹ãƒã‚§ãƒƒã‚¯
local function isContinent(zoneName)
    return Continents[zoneName] ~= nil
end

-- ã‚¾ãƒ¼ãƒ³ãŒå³¶ã‹ãƒã‚§ãƒƒã‚¯
local function isIsland(zoneName)
    -- StartTown (Island)ã¯å¤§é™¸ã§ã¯ãªã„ãŒã€å³¶ã¨ã—ã¦ã¯å­˜åœ¨ã™ã‚‹
    return Islands[zoneName] ~= nil and not isContinent(zoneName)
end

-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¾ãƒ¼ãƒ³ã‚’æ›´æ–° (ãƒ¯ãƒ¼ãƒ—ãƒãƒ¼ã‚¿ãƒ«ã§ä½¿ç”¨)
local function updatePlayerZone(player, newZone)
    local oldZone = ZoneManager.PlayerZones[player]

    if oldZone == newZone then
        return
    end

    -- å¤ã„ã‚¾ãƒ¼ãƒ³ã‹ã‚‰å‡ºãŸ
    if oldZone then
        print(("[ZoneManager] %s ãŒ %s ã‹ã‚‰å‡ºã¾ã—ãŸ"):format(player.Name, oldZone))
        ZoneChangeEvent:FireClient(player, oldZone, false)
    end

    -- æ–°ã—ã„ã‚¾ãƒ¼ãƒ³ã«å…¥ã£ãŸ
    if newZone then
        print(("[ZoneManager] %s ãŒ %s ã«å…¥ã‚Šã¾ã—ãŸ"):format(player.Name, newZone))
        ZoneManager.PlayerZones[player] = newZone
        ZoneChangeEvent:FireClient(player, newZone, true)
    else
        ZoneManager.PlayerZones[player] = nil
    end
end

-- å¤§é™¸ã‚’ãƒ­ãƒ¼ãƒ‰ï¼ˆè¤‡æ•°ã®å³¶ã¨æ©‹ã‚’ç”Ÿæˆï¼‰
local function loadContinent(continentName)
    local continent = Continents[continentName]
    if not continent then
        warn(("[ZoneManager] å¤§é™¸ '%s' ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"):format(continentName))
        return false
    end

    print(("[ZoneManager] å¤§é™¸ç”Ÿæˆé–‹å§‹: %s"):format(continentName))

    -- å«ã¾ã‚Œã‚‹å…¨ã¦ã®å³¶ã‚’ç”Ÿæˆ
    for _, islandName in ipairs(continent.islands) do
        local islandConfig = Islands[islandName]
        if islandConfig then
            print(("[ZoneManager]   - å³¶ã‚’ç”Ÿæˆ: %s"):format(islandName))
            FieldGen.generateIsland(islandConfig)
        else
            warn(("[ZoneManager]   - å³¶ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: %s (Island/Registryã‚’ç¢ºèªã—ã¦ãã ã•ã„)"):format(islandName))
        end
    end

    -- æ©‹ã‚’ç”Ÿæˆ
    if continent.bridges then
        for _, bridgeConfig in ipairs(continent.bridges) do
            local fromIsland = Islands[bridgeConfig.fromIsland]
            local toIsland = Islands[bridgeConfig.toIsland]

            if fromIsland and toIsland then
                print(("[ZoneManager]   - æ©‹ã‚’ç”Ÿæˆ: %s"):format(bridgeConfig.name))
                FieldGen.generateBridge(fromIsland, toIsland, bridgeConfig)
            else
                warn(("[ZoneManager]   - æ©‹ã®ç”Ÿæˆå¤±æ•—: %s"):format(bridgeConfig.name))
            end
        end
    end

    ZoneManager.ActiveZones[continentName] = {
        config = continent,
        loadedAt = os.time(),
    }

    print(("[ZoneManager] å¤§é™¸ç”Ÿæˆå®Œäº†: %s"):format(continentName))
    return true
end

-- ã‚¾ãƒ¼ãƒ³ã‚’ãƒ­ãƒ¼ãƒ‰ï¼ˆå³¶ã¾ãŸã¯å¤§é™¸ã‚’ãƒ­ãƒ¼ãƒ‰ï¼‰
function ZoneManager.LoadZone(zoneName)
    if ZoneManager.ActiveZones[zoneName] then
        print(("[ZoneManager] %s ã¯æ—¢ã«ç”Ÿæˆæ¸ˆã¿ã§ã™"):format(zoneName))
        return true
    end

    if isIsland(zoneName) then
        -- ã€å¾©å…ƒã€‘å³¶ã®å ´åˆ (StartTown)
        local islandConfig = Islands[zoneName]
        if islandConfig then
            print(("[ZoneManager] å³¶ç”Ÿæˆé–‹å§‹: %s"):format(zoneName))
            FieldGen.generateIsland(islandConfig)
            ZoneManager.ActiveZones[zoneName] = {
                config = islandConfig,
                loadedAt = os.time(),
            }
            print(("[ZoneManager] å³¶ç”Ÿæˆå®Œäº†: %s"):format(zoneName))
            return true
        else
            warn(("[ZoneManager] å³¶ '%s' ã®è¨­å®šãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"):format(zoneName))
            return false
        end
    elseif isContinent(zoneName) then
        -- ã€ç¶­æŒã€‘å¤§é™¸ã®å ´åˆ (ContinentHokkaido)
        return loadContinent(zoneName)
    else
        warn(("[ZoneManager] ã‚¾ãƒ¼ãƒ³ '%s' ã¯å³¶ã§ã‚‚å¤§é™¸ã§ã‚‚ã‚ã‚Šã¾ã›ã‚“ã€‚"):format(zoneName))
        return false
    end
end

-- ã‚¾ãƒ¼ãƒ³ã‚’ã‚¢ãƒ³ãƒ­ãƒ¼ãƒ‰ï¼ˆçœç•¥ï¼‰
function ZoneManager.UnloadZone(zoneName)
    if not ZoneManager.ActiveZones[zoneName] then
        return
    end

    print(("[ZoneManager] ã‚¾ãƒ¼ãƒ³å‰Šé™¤é–‹å§‹: %s"):format(zoneName))

    local terrain = workspace.Terrain
    local configsToUnload = {}

    if isIsland(zoneName) then
        -- å³¶ã®å ´åˆ
        table.insert(configsToUnload, Islands[zoneName])
    elseif isContinent(zoneName) then
        -- å¤§é™¸ã®å ´åˆã¯å«ã¾ã‚Œã‚‹å…¨ã¦ã®å³¶ã‚’å‰Šé™¤
        local continent = Continents[zoneName]
        for _, islandName in ipairs(continent.islands) do
            table.insert(configsToUnload, Islands[islandName])
        end
    end

    -- å„å³¶ã®åœ°å½¢ã‚’å‰Šé™¤
    for _, config in ipairs(configsToUnload) do
        if config then
            local halfSize = config.sizeXZ / 2 + 50
            local region = Region3.new(
                Vector3.new(config.centerX - halfSize, config.baseY - 50, config.centerZ - halfSize),
                Vector3.new(config.centerX + halfSize, config.baseY + 100, config.centerZ + halfSize)
            )
            region = region:ExpandToGrid(4)
            terrain:FillRegion(region, 4, Enum.Material.Air)

            -- ãƒãƒ¼ã‚«å‰Šé™¤ã¯ FieldGen.lua ã§è¡Œã†ãŸã‚ZoneManagerã‹ã‚‰ã¯å‰Šé™¤
        end
    end

    -- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼å‰Šé™¤
    for _, model in ipairs(workspace:GetChildren()) do
        if model:IsA("Model") and model:GetAttribute("IsEnemy") then
            local spawnZone = model:GetAttribute("SpawnZone")
            if spawnZone == zoneName then
                model:Destroy()
            end
        end
    end

    ZoneManager.ActiveZones[zoneName] = nil
    print(("[ZoneManager] ã‚¾ãƒ¼ãƒ³å‰Šé™¤å®Œäº†: %s"):format(zoneName))
end


-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ãƒ¯ãƒ¼ãƒ—
function ZoneManager.WarpPlayerToZone(player, zoneName)
    print(("[ZoneManager] %s ã‚’ %s ã«ãƒ¯ãƒ¼ãƒ—ä¸­..."):format(player.Name, zoneName))

    -- ãƒ¯ãƒ¼ãƒ—å…ˆã«åœ°å½¢ãŒãªã„å ´åˆã¯ãƒ­ãƒ¼ãƒ‰
    ZoneManager.LoadZone(zoneName)

    local character = player.Character
    if not character then
        warn(("[ZoneManager] %s ã®ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"):format(player.Name))
        return false
    end

    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end

    -- ãƒ¯ãƒ¼ãƒ—å…ˆã®åº§æ¨™ã‚’æ±ºå®š
    local targetX, targetZ, baseY, hillAmplitude

    if isIsland(zoneName) then
        -- ã€å¾©å…ƒã€‘å³¶ã®å ´åˆ (StartTown)
        local island = Islands[zoneName]
        targetX = island.centerX
        targetZ = island.centerZ
        baseY = island.baseY
        hillAmplitude = island.hillAmplitude or 20
    elseif isContinent(zoneName) then
        -- ã€ç¶­æŒã€‘å¤§é™¸ã®å ´åˆ (ContinentHokkaido)
        local continent = Continents[zoneName]
        local firstIslandName = continent.islands[1]
        local firstIsland = Islands[firstIslandName]
        targetX = firstIsland.centerX
        targetZ = firstIsland.centerZ
        baseY = firstIsland.baseY
        hillAmplitude = firstIsland.hillAmplitude or 20
    else
        warn(("[ZoneManager] ã‚¾ãƒ¼ãƒ³ '%s' ã¯å³¶ã§ã‚‚å¤§é™¸ã§ã‚‚ãªã„ãŸã‚ãƒ¯ãƒ¼ãƒ—ã§ãã¾ã›ã‚“ã€‚"):format(zoneName))
        return false
    end

    -- ååˆ†ã«é«˜ã„ä½ç½®ã‹ã‚‰ãƒ¬ã‚¤ã‚­ãƒ£ã‚¹ãƒˆ
    local FieldGen = require(ReplicatedStorage:WaitForChild("FieldGen"))
    local rayStartY = baseY + hillAmplitude + 100
    local groundY = FieldGen.raycastGroundY(targetX, targetZ, rayStartY)

    local spawnY
    if groundY then
        spawnY = groundY + 5
        print(("[ZoneManager] åœ°é¢æ¤œå‡ºæˆåŠŸ: Y=%.1f"):format(groundY))
    else
        -- å®‰å…¨ãªé«˜åº¦ï¼šbaseY + hillAmplitude * 0.6 + 10 ã«å›ºå®š
        spawnY = baseY + (hillAmplitude * 0.6) + 10
        warn(("[ZoneManager] åœ°é¢æ¤œå‡ºå¤±æ•—ã€äºˆæƒ³é«˜åº¦ä½¿ç”¨: Y=%.1f"):format(spawnY))
    end

    hrp.CFrame = CFrame.new(targetX, spawnY, targetZ)

    updatePlayerZone(player, zoneName)

    print(("[ZoneManager] %s ã‚’ %s ã«ãƒ¯ãƒ¼ãƒ—å®Œäº† (%.1f, %.1f, %.1f)"):format(
        player.Name, zoneName, targetX, spawnY, targetZ
        ))
    return true
end

function ZoneManager.GetPlayerZone(player)
    return ZoneManager.PlayerZones[player]
end

-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒé€€å‡ºã—ãŸæ™‚ã®å‡¦ç† (çœç•¥)
Players.PlayerRemoving:Connect(function(player)
    local oldZone = ZoneManager.PlayerZones[player]
    if oldZone then
        print(("[ZoneManager] %s ãŒé€€å‡ºã—ã¾ã—ãŸã€‚ã‚¾ãƒ¼ãƒ³: %s"):format(player.Name, oldZone))
        ZoneManager.PlayerZones[player] = nil
    end
end)

return ZoneManager
===== ./ServerScriptService/PlayerStats.lua =====
-- ServerScriptService/PlayerStats.lua
-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’ç®¡ç†ã™ã‚‹ModuleScript

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local PlayerStats = {}

-- RemoteEventã‚’å–å¾—ã™ã‚‹é–¢æ•°
local function getRemoteEvent(name)
	return ReplicatedStorage:WaitForChild(name, 10)
end

-- ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
local DEFAULT_STATS = {
	Level = 1,
	Experience = 0,
	Gold = 100,  -- åˆæœŸã‚´ãƒ¼ãƒ«ãƒ‰100G

	MaxHP = 100,
	CurrentHP = 100,

	Speed = 10,      -- ç´ æ—©ã•
	Attack = 10,     -- æ”»æ’ƒåŠ›
	Defense = 10,    -- å®ˆå‚™åŠ›
	MonstersDefeated = 0,
}

-- ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ã«å¿…è¦ãªçµŒé¨“å€¤ï¼ˆãƒ¬ãƒ™ãƒ« * 100ï¼‰
local function getRequiredExp(level)
	return level * 100
end

-- å„ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’ä¿å­˜
local PlayerData = {}

-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’åˆæœŸåŒ–
function PlayerStats.initPlayer(player: Player)
	if PlayerData[player] then
		warn(("[PlayerStats] %s ã¯æ—¢ã«åˆæœŸåŒ–æ¸ˆã¿ã§ã™"):format(player.Name))
		return
	end

	-- ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã§ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’ä½œæˆ
	PlayerData[player] = {}
	for key, value in pairs(DEFAULT_STATS) do
		PlayerData[player][key] = value
	end

	print(("[PlayerStats] %s ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’åˆæœŸåŒ–ã—ã¾ã—ãŸ"):format(player.Name))

	-- TODO: DataStoreã‹ã‚‰èª­ã¿è¾¼ã¿
end

-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’å–å¾—
function PlayerStats.getStats(player: Player)
	return PlayerData[player]
end

-- ç‰¹å®šã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’å–å¾—
function PlayerStats.getStat(player: Player, statName: string)
	local stats = PlayerData[player]
	if not stats then
		warn(("[PlayerStats] %s ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"):format(player.Name))
		return nil
	end
	return stats[statName]
end

-- ç‰¹å®šã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’è¨­å®š
function PlayerStats.setStat(player: Player, statName: string, value)
	local stats = PlayerData[player]
	if not stats then
		warn(("[PlayerStats] %s ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"):format(player.Name))
		return
	end

	stats[statName] = value
	print(("[PlayerStats] %s ã® %s ã‚’ %s ã«è¨­å®š"):format(player.Name, statName, tostring(value)))
end

-- HPã‚’å›å¾©
function PlayerStats.healHP(player: Player, amount: number)
	local stats = PlayerData[player]
	if not stats then return end

	stats.CurrentHP = math.min(stats.CurrentHP + amount, stats.MaxHP)
	print(("[PlayerStats] %s ã®HPã‚’ %d å›å¾©ï¼ˆç¾åœ¨: %d/%dï¼‰"):format(
		player.Name, amount, stats.CurrentHP, stats.MaxHP
		))
end

-- HPã‚’å…¨å›å¾©
function PlayerStats.fullHeal(player: Player)
	local stats = PlayerData[player]
	if not stats then return end

	stats.CurrentHP = stats.MaxHP
	print(("[PlayerStats] %s ã®HPã‚’å…¨å›å¾©"):format(player.Name))
end

-- ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ã‚‹
function PlayerStats.takeDamage(player: Player, damage: number): boolean
	local stats = PlayerData[player]
	if not stats then return false end

	stats.CurrentHP = math.max(0, stats.CurrentHP - damage)
	print(("[PlayerStats] %s ãŒ %d ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ãŸï¼ˆæ®‹ã‚ŠHP: %d/%dï¼‰"):format(
		player.Name, damage, stats.CurrentHP, stats.MaxHP
		))

	-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°ã‚’é€ä¿¡
	local StatusUpdateEvent = getRemoteEvent("StatusUpdate")
	if StatusUpdateEvent then
		local expToNext = getRequiredExp(stats.Level)
		StatusUpdateEvent:FireClient(
			player,
			stats.CurrentHP,
			stats.MaxHP,
			stats.Level,
			stats.Experience,
			expToNext,
			stats.Gold
		)
	end

	-- æ­»äº¡åˆ¤å®š
	if stats.CurrentHP <= 0 then
		print(("[PlayerStats] %s ã¯å€’ã‚ŒãŸï¼"):format(player.Name))
		return true  -- æ­»äº¡
	end

	return false  -- ç”Ÿå­˜
end

-- çµŒé¨“å€¤ã‚’è¿½åŠ 
function PlayerStats.addExperience(player: Player, exp: number)
	local stats = PlayerData[player]
	if not stats then return end

	stats.Experience = stats.Experience + exp
	print(("[PlayerStats] %s ãŒçµŒé¨“å€¤ %d ã‚’ç²å¾—ï¼ˆåˆè¨ˆ: %dï¼‰"):format(
		player.Name, exp, stats.Experience
		))

	-- ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ãƒã‚§ãƒƒã‚¯
	local requiredExp = getRequiredExp(stats.Level)
	while stats.Experience >= requiredExp do
		PlayerStats.levelUp(player)
		requiredExp = getRequiredExp(stats.Level)
	end

	-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°ã‚’é€ä¿¡
	local StatusUpdateEvent = getRemoteEvent("StatusUpdate")
	if StatusUpdateEvent then
		local expToNext = getRequiredExp(stats.Level)
		StatusUpdateEvent:FireClient(
			player,
			stats.CurrentHP,
			stats.MaxHP,
			stats.Level,
			stats.Experience,
			expToNext,
			stats.Gold
		)
	end
end

-- ã‚´ãƒ¼ãƒ«ãƒ‰ã‚’è¿½åŠ 
function PlayerStats.addGold(player: Player, gold: number)
	local stats = PlayerData[player]
	if not stats then return end

	stats.Gold = stats.Gold + gold
	print(("[PlayerStats] %s ãŒã‚´ãƒ¼ãƒ«ãƒ‰ %d ã‚’ç²å¾—ï¼ˆåˆè¨ˆ: %dï¼‰"):format(
		player.Name, gold, stats.Gold
		))

	-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°ã‚’é€ä¿¡
	local StatusUpdateEvent = getRemoteEvent("StatusUpdate")
	if StatusUpdateEvent then
		local expToNext = getRequiredExp(stats.Level)
		StatusUpdateEvent:FireClient(
			player,
			stats.CurrentHP,
			stats.MaxHP,
			stats.Level,
			stats.Experience,
			expToNext,
			stats.Gold
		)
	end
end

-- ã‚´ãƒ¼ãƒ«ãƒ‰ã‚’æ¸›ã‚‰ã™
function PlayerStats.removeGold(player: Player, gold: number): boolean
	local stats = PlayerData[player]
	if not stats then return false end

	if stats.Gold < gold then
		print(("[PlayerStats] %s ã®ã‚´ãƒ¼ãƒ«ãƒ‰ãŒä¸è¶³ã—ã¦ã„ã¾ã™"):format(player.Name))
		return false
	end

	stats.Gold = stats.Gold - gold
	print(("[PlayerStats] %s ãŒã‚´ãƒ¼ãƒ«ãƒ‰ %d ã‚’å¤±ã£ãŸï¼ˆæ®‹ã‚Š: %dï¼‰"):format(
		player.Name, gold, stats.Gold
		))
	return true
end

-- å€’ã—ãŸãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æ•°ã‚’è¿½åŠ 
function PlayerStats.addMonstersDefeated(player: Player, count: number)
	print(("[PlayerStats] ========================================"):format())
	print(("[PlayerStats] addMonstersDefeated å‘¼ã³å‡ºã—"):format())
	print(("  ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼: %s"):format(player.Name))
	print(("  è¿½åŠ æ•°: %d"):format(count or 1))

	local stats = PlayerData[player]
	if not stats then
		warn(("[PlayerStats] âŒ %s ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ï¼ˆãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚«ã‚¦ãƒ³ãƒˆå¤±æ•—ï¼‰"):format(player.Name))
		print(("[PlayerStats] ========================================"):format())
		return
	end

	local oldCount = stats.MonstersDefeated
	count = count or 1
	stats.MonstersDefeated = stats.MonstersDefeated + count

	print(("  å¤‰æ›´å‰: %d"):format(oldCount))
	print(("  å¤‰æ›´å¾Œ: %d"):format(stats.MonstersDefeated))
	print(("[PlayerStats] âœ… ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æ’ƒç ´æ•°æ›´æ–°æˆåŠŸ"):format())
	print(("[PlayerStats] ========================================"):format())
end

-- ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—
function PlayerStats.levelUp(player: Player)
	local stats = PlayerData[player]
	if not stats then return end

	local oldLevel = stats.Level
	stats.Level = stats.Level + 1

	-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚¢ãƒƒãƒ—
	stats.MaxHP = stats.MaxHP + 10
	stats.CurrentHP = stats.MaxHP  -- å…¨å›å¾©
	stats.Speed = stats.Speed + 2
	stats.Attack = stats.Attack + 2
	stats.Defense = stats.Defense + 2

	print(("[PlayerStats] ğŸ‰ %s ãŒãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ï¼ %d â†’ %d"):format(
		player.Name, oldLevel, stats.Level
		))
	print(("  HP: %d, ç´ æ—©ã•: %d, æ”»æ’ƒ: %d, å®ˆå‚™: %d"):format(
		stats.MaxHP, stats.Speed, stats.Attack, stats.Defense
		))

	-- ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—æ¼”å‡ºã‚’é€šçŸ¥
	local LevelUpEvent = getRemoteEvent("LevelUp")
	if LevelUpEvent then
		LevelUpEvent:FireClient(player, stats.Level, stats.MaxHP, stats.Speed, stats.Attack, stats.Defense)
	end

	-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°ã‚’é€ä¿¡
	local StatusUpdateEvent = getRemoteEvent("StatusUpdate")
	if StatusUpdateEvent then
		local expToNext = stats.Level * 100
		StatusUpdateEvent:FireClient(
			player,
			stats.CurrentHP,
			stats.MaxHP,
			stats.Level,
			stats.Experience,
			expToNext,
			stats.Gold
		)
	end
end

-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒé€€å‡ºã—ãŸã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¯ãƒªã‚¢
function PlayerStats.removePlayer(player: Player)
	-- TODO: DataStoreã«ä¿å­˜
	PlayerData[player] = nil
	print(("[PlayerStats] %s ã®ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã—ã¾ã—ãŸ"):format(player.Name))
end

-- åˆæœŸåŒ–
function PlayerStats.init()
	-- æ—¢å­˜ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’åˆæœŸåŒ–
	for _, player in ipairs(Players:GetPlayers()) do
		PlayerStats.initPlayer(player)
	end

	-- æ–°è¦å‚åŠ ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’åˆæœŸåŒ–
	Players.PlayerAdded:Connect(function(player)
		PlayerStats.initPlayer(player)
	end)

	-- é€€å‡ºæ™‚ã«ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¯ãƒªã‚¢
	Players.PlayerRemoving:Connect(function(player)
		PlayerStats.removePlayer(player)
	end)

	-- è©³ç´°ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒªã‚¯ã‚¨ã‚¹ãƒˆç”¨RemoteEvent
	local RequestStatsDetailEvent = ReplicatedStorage:FindFirstChild("RequestStatsDetail")
	if not RequestStatsDetailEvent then
		RequestStatsDetailEvent = Instance.new("RemoteEvent")
		RequestStatsDetailEvent.Name = "RequestStatsDetail"
		RequestStatsDetailEvent.Parent = ReplicatedStorage
	end

	RequestStatsDetailEvent.OnServerEvent:Connect(function(player)
		local stats = PlayerStats.getStats(player)
		if stats then
			-- StatsDetailEventã‚’å–å¾—ã¾ãŸã¯ä½œæˆ
			local StatsDetailEvent = ReplicatedStorage:FindFirstChild("StatsDetail")
			if not StatsDetailEvent then
				StatsDetailEvent = Instance.new("RemoteEvent")
				StatsDetailEvent.Name = "StatsDetail"
				StatsDetailEvent.Parent = ReplicatedStorage
				print("[PlayerStats] StatsDetailã‚¤ãƒ™ãƒ³ãƒˆã‚’ä½œæˆã—ã¾ã—ãŸ")
			end

			print(("[PlayerStats] è©³ç´°ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’é€ä¿¡: MonstersDefeated=%d"):format(stats.MonstersDefeated or 0))
			StatsDetailEvent:FireClient(player, stats)
		end
	end)

	print("[PlayerStats] åˆæœŸåŒ–å®Œäº†")
end

return PlayerStats
===== ./ServerScriptService/Bootstrap.server.lua =====
-- ServerScriptService/Bootstrap.server.lua
-- ã‚²ãƒ¼ãƒ åˆæœŸåŒ–ã‚¹ã‚¯ãƒªãƒ—ãƒˆï¼ˆæœ€çµ‚å®‰å®šç‰ˆï¼‰

local ServerScriptService = game:GetService("ServerScriptService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

print("[Bootstrap] === ã‚²ãƒ¼ãƒ åˆæœŸåŒ–é–‹å§‹ ===")

-- ZoneManagerã‚’èª­ã¿è¾¼ã¿
local ZoneManager = require(script.Parent.ZoneManager)
local PlayerStats = require(ServerScriptService:WaitForChild("PlayerStats"))

PlayerStats.init()

print("[Bootstrap] è¡—ã‚’ç”Ÿæˆä¸­...")
ZoneManager.LoadZone("StartTown") -- StartTown (Island) ã‚’ãƒ­ãƒ¼ãƒ‰

task.wait(5)
print("[Bootstrap] åœ°å½¢ç”Ÿæˆã®å¾…æ©Ÿå®Œäº†ï¼ˆ5ç§’ï¼‰")

-- è¡—ã®è¨­å®šã‚’å–å¾—
local IslandsRegistry = require(ReplicatedStorage.Islands.Registry)
local townConfig = nil
for _, island in ipairs(IslandsRegistry) do
	if island.name == "StartTown" then
		townConfig = island
		break
	end
end

if not townConfig then
	warn("[Bootstrap] StartTown ã®è¨­å®šãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ï¼")
	return
end

-- ã€ä¿®æ­£ç‚¹ Aï¼šãƒãƒ¼ã‚¿ãƒ«ç”Ÿæˆã®å‘¼ã³å‡ºã—ã‚’ã‚°ãƒ­ãƒ¼ãƒãƒ«é–¢æ•°ã«åˆ‡ã‚Šæ›¿ãˆã€‘
-- FindFirstChildã®ã‚¨ãƒ©ãƒ¼ã‚’å›é¿ã—ã€WarpPortal.server.luaã§å…¬é–‹ã•ã‚ŒãŸé–¢æ•°ã‚’ç›´æ¥åˆ©ç”¨ã—ã¾ã™ã€‚
if _G.createPortalsForZone then
    print("[Bootstrap] StartTownã®ãƒãƒ¼ã‚¿ãƒ«ã‚’ç”Ÿæˆä¸­...")
    _G.createPortalsForZone("StartTown")
else
    warn("[Bootstrap] âš ï¸ ã‚¨ãƒ©ãƒ¼å›é¿: WarpPortal.server.luaãŒã¾ã åˆæœŸåŒ–ã•ã‚Œã¦ã„ãªã„ã‹ã€ã‚°ãƒ­ãƒ¼ãƒãƒ«é–¢æ•°ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã›ã‚“ã€‚ãƒãƒ¼ã‚¿ãƒ«ç”Ÿæˆã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™ã€‚")
end


-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¹ãƒãƒ¼ãƒ³ä½ç½®ã‚’è¡—ã«è¨­å®š
local function setupPlayerSpawn(player)
	player.CharacterAdded:Connect(function(character)
		-- ã€é‡è¦ã€‘ç‰©ç†ã‚¨ãƒ³ã‚¸ãƒ³å®‰å®šã®ãŸã‚å¾…æ©Ÿ
		task.wait(0.5)

		local hrp = character:FindFirstChild("HumanoidRootPart")
		if not hrp then return end

		local currentZone = ZoneManager.GetPlayerZone(player)
		-- ã‚¾ãƒ¼ãƒ³ãŒè¨­å®šæ¸ˆã¿ï¼ˆï¼ä¸€åº¦ç§»å‹•ã—ãŸï¼‰ã®å ´åˆã¯ã€äºŒé‡ã‚¹ãƒãƒ¼ãƒ³ã‚’é˜²ããŸã‚ã‚¹ã‚­ãƒƒãƒ—
		if currentZone then
			return
		end

		local spawnX = townConfig.centerX
		local spawnZ = townConfig.centerZ
		local spawnY = townConfig.baseY + 50

		print(("[Bootstrap] %s ã‚’è¡—ã«ã‚¹ãƒãƒ¼ãƒ³: (%.0f, %.0f, %.0f)"):format(
			player.Name, spawnX, spawnY, spawnZ
			))

		-- CFrameè¨­å®šã¯ä¸€åº¦ã ã‘
		hrp.CFrame = CFrame.new(spawnX, spawnY, spawnZ)

		ZoneManager.PlayerZones[player] = "StartTown"
	end)
end

-- æ—¢å­˜ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨æ–°è¦ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«é©ç”¨
for _, player in ipairs(Players:GetPlayers()) do
	setupPlayerSpawn(player)

    -- ã€ä¿®æ­£ç‚¹ Bï¼šäºŒé‡è½ä¸‹é˜²æ­¢ã€‘
    -- æ—¢å­˜ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¸ã®å³åº§ã®CFrameè¨­å®šã‚’å®Œå…¨ã«å‰Šé™¤ã—ã¾ã™ã€‚
end

Players.PlayerAdded:Connect(setupPlayerSpawn)

task.spawn(function()
	local ReplicatedStorage = game:GetService("ReplicatedStorage")

	local soundsFolder = ReplicatedStorage:FindFirstChild("Sounds")
	if not soundsFolder then
		soundsFolder = Instance.new("Folder")
		soundsFolder.Name = "Sounds"
		soundsFolder.Parent = ReplicatedStorage
	end

	if not soundsFolder:FindFirstChild("TypingCorrect") then
		local typingCorrect = Instance.new("Sound")
		typingCorrect.Name = "TypingCorrect"
		typingCorrect.SoundId = "rbxassetid://159534615"
		typingCorrect.Volume = 0.4
		typingCorrect.Parent = soundsFolder
	end

	if not soundsFolder:FindFirstChild("TypingError") then
		local typingError = Instance.new("Sound")
		typingError.Name = "TypingError"
		typingError.SoundId = "rbxassetid://113721818600044"
		typingError.Volume = 0.5
		typingError.Parent = soundsFolder
	end

	print("[Bootstrap] Soundsãƒ•ã‚©ãƒ«ãƒ€ã‚’åˆæœŸåŒ–ã—ã¾ã—ãŸ")
end)

print("[Bootstrap] === ã‚²ãƒ¼ãƒ åˆæœŸåŒ–å®Œäº† ===")
print("[Bootstrap] ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯è¡—ï¼ˆStartTownï¼‰ã‹ã‚‰ã‚¹ã‚¿ãƒ¼ãƒˆã—ã¾ã™")
===== ./ServerScriptService/LoadTest.server.lua =====
-- ServerScriptService/LoadTest (Script)
local startTime = os.clock()
local startMemory = gcinfo()

-- ã‚²ãƒ¼ãƒ é–‹å§‹ã‚’å¾…ã¤
task.wait(5)

local endTime = os.clock()
local endMemory = gcinfo()

print("=== è² è·ãƒ†ã‚¹ãƒˆçµæœ ===")
print(("åœ°å½¢ç”Ÿæˆæ™‚é–“: %.2fç§’"):format(endTime - startTime))
print(("ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡: %.2f MB"):format((endMemory - startMemory) / 1024))
print(("ç·ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæ•°: %d"):format(#workspace:GetDescendants()))

-- ç¶™ç¶šãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°
task.spawn(function()
	while true do
		task.wait(5)
		local fps = 1 / game:GetService("RunService").Heartbeat:Wait()
		print(("FPS: %.1f | ãƒ¡ãƒ¢ãƒª: %.1f MB"):format(fps, gcinfo() / 1024))
	end
end)
===== ./ServerScriptService/OceanSafety.server.lua =====
-- ServerScriptService/OceanSafety.server.lua
-- æµ·ã«è½ã¡ãŸæ™‚ã®å‡¦ç†

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- è¨­å®š
local WATER_LEVEL = -25  -- ã“ã®é«˜ã•ã‚ˆã‚Šä¸‹ã«è½ã¡ãŸã‚‰å‡¦ç†
local CHECK_INTERVAL = 0.5  -- ãƒã‚§ãƒƒã‚¯é–“éš”ï¼ˆç§’ï¼‰

-- å³¶ã®ä¸­å¿ƒï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ãƒªã‚¹ãƒãƒ¼ãƒ³ä½ç½®ï¼‰
local Islands = require(ReplicatedStorage.Islands.Registry)
local firstIsland = Islands[1]
local SPAWN_X = firstIsland.centerX
local SPAWN_Z = firstIsland.centerZ
local SPAWN_Y = firstIsland.baseY + 25  -- å³¶ã®ä¸Šç©º

print("[OceanSafety] åˆæœŸåŒ–å®Œäº†")

-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç›£è¦–
local function monitorPlayer(player)
	player.CharacterAdded:Connect(function(character)
		local hrp = character:WaitForChild("HumanoidRootPart")
		local humanoid = character:WaitForChild("Humanoid")

		local lastCheck = 0

		RunService.Heartbeat:Connect(function()
			if not character.Parent or not hrp.Parent then return end

			local now = os.clock()
			if now - lastCheck < CHECK_INTERVAL then return end
			lastCheck = now

			-- æ°´é¢ã‚ˆã‚Šä¸‹ã«è½ã¡ãŸã‹ãƒã‚§ãƒƒã‚¯
			if hrp.Position.Y < WATER_LEVEL then
				print(("[OceanSafety] %s ãŒæµ·ã«è½ã¡ã¾ã—ãŸã€‚ãƒªã‚¹ãƒãƒ¼ãƒ³ä¸­..."):format(player.Name))

				-- é€Ÿåº¦ã‚’ã‚¼ãƒ­ã«
				hrp.AssemblyLinearVelocity = Vector3.zero
				hrp.AssemblyAngularVelocity = Vector3.zero

				-- å³¶ã®ä¸­å¿ƒã«æˆ»ã™
				hrp.CFrame = CFrame.new(SPAWN_X, SPAWN_Y, SPAWN_Z)

				-- ä½“åŠ›ã‚’å°‘ã—æ¸›ã‚‰ã™ï¼ˆãƒšãƒŠãƒ«ãƒ†ã‚£ï¼‰
				if humanoid.Health > 10 then
					humanoid.Health = humanoid.Health - 10
				end
			end
		end)
	end)
end

-- æ—¢å­˜ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨æ–°è¦ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«é©ç”¨
for _, player in ipairs(Players:GetPlayers()) do
	monitorPlayer(player)
end
Players.PlayerAdded:Connect(monitorPlayer)

-- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã®ç›£è¦–
RunService.Heartbeat:Connect(function()
	for _, model in ipairs(workspace:GetChildren()) do
		if model:IsA("Model") and model:GetAttribute("IsEnemy") then
			local hrp = model:FindFirstChild("HumanoidRootPart")

			if hrp and hrp.Position.Y < WATER_LEVEL then
				-- print(("[OceanSafety] %s ãŒæµ·ã«è½ã¡ã¾ã—ãŸã€‚æ¶ˆå»ä¸­..."):format(model.Name))
				model:Destroy()
			end
		end
	end
end)
===== ./ServerScriptService/WarpPortal.server.lua =====
-- ServerScriptService/WarpPortal.server.lua
-- ãƒ¯ãƒ¼ãƒ—ä¸­ã®ãƒãƒˆãƒ«é–‹å§‹ã‚’é˜²æ­¢ã™ã‚‹ä¿®æ­£ç‰ˆ

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local ZoneManager = require(script.Parent.ZoneManager)
local BattleSystem = require(script.Parent.BattleSystem)

print("[WarpPortal] åˆæœŸåŒ–é–‹å§‹")

local warpEvent = ReplicatedStorage:FindFirstChild("WarpEvent")
if not warpEvent then
	warpEvent = Instance.new("RemoteEvent")
	warpEvent.Name = "WarpEvent"
	warpEvent.Parent = ReplicatedStorage
end

local warpingPlayers = {}
local activePortals = {}

local IslandsRegistry = require(ReplicatedStorage.Islands.Registry)
local ContinentsRegistry = require(ReplicatedStorage.Continents.Registry)

local Islands = {}
for _, island in ipairs(IslandsRegistry) do
	Islands[island.name] = island
end

local Continents = {}
for _, continent in ipairs(ContinentsRegistry) do
	Continents[continent.name] = continent
end

local function resolveTemplate(pathArray: {string}): Model?
	local node: Instance = game
	for _, seg in ipairs(pathArray) do
		node = node:FindFirstChild(seg)
		if not node then return nil end
	end
	return (node and node:IsA("Model")) and node or nil
end

local function ensureHRP(model: Model): BasePart?
	local hrp = model:FindFirstChild("HumanoidRootPart")
	if hrp and hrp:IsA("BasePart") then
		if not model.PrimaryPart then model.PrimaryPart = hrp end
		return hrp
	end
	return nil
end

local function attachLabel(model: Model, maxDist: number)
	local hrp = model.PrimaryPart or model:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	local _, bboxSize = model:GetBoundingBox()
	local labelOffset = math.min(bboxSize.Y * 0.5 + 2, 15)

	local gui = Instance.new("BillboardGui")
	gui.Name = "DebugInfo"
	gui.Adornee = hrp
	gui.AlwaysOnTop = true
	gui.Size = UDim2.new(0, 150, 0, 50)
	gui.StudsOffset = Vector3.new(0, labelOffset, 0)
	gui.MaxDistance = maxDist
	gui.Parent = hrp

	local lb = Instance.new("TextLabel")
	lb.Name = "InfoText"
	lb.BackgroundTransparency = 1
	lb.TextScaled = true
	lb.Font = Enum.Font.GothamBold
	lb.TextColor3 = Color3.new(1, 1, 1)
	lb.TextStrokeTransparency = 0.5
	lb.Size = UDim2.fromScale(1, 1)
	lb.Text = "Ready"
	lb.Parent = gui
end

local function placeOnGround(model: Model, x: number, z: number)
	local hrp = model.PrimaryPart or model:FindFirstChild("HumanoidRootPart")
	if not hrp then
		warn("[MonsterSpawner] HumanoidRootPart ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: " .. model.Name)
		return
	end

	local groundY = FieldGen.raycastGroundY(x, z, 100)
		or FieldGen.raycastGroundY(x, z, 200)
		or FieldGen.raycastGroundY(x, z, 50)
		or 10

	local _, yaw = hrp.CFrame:ToOrientation()
	model:PivotTo(CFrame.new(x, groundY + 20, z) * CFrame.Angles(0, yaw, 0))

	local bboxCFrame, bboxSize = model:GetBoundingBox()
	local bottomY = bboxCFrame.Position.Y - (bboxSize.Y * 0.5)
	local offset = hrp.Position.Y - bottomY

	model:PivotTo(CFrame.new(x, groundY + offset, z) * CFrame.Angles(0, yaw, 0))
end

local function nearestPlayer(position: Vector3)
	local best, bestDist = nil, math.huge
	for _, pl in ipairs(Players:GetPlayers()) do
		local ch = pl.Character
		local hrp = ch and ch:FindFirstChild("HumanoidRootPart")
		if hrp then
			local d = (position - hrp.Position).Magnitude
			if d < bestDist then
				best, bestDist = pl, d
			end
		end
	end
	return best, bestDist
end

-- ã€ä¿®æ­£ã€‘ãƒãƒ¼ã‚¿ãƒ«ã‚¿ãƒƒãƒæ™‚ã€å³åº§ã«ãƒ¯ãƒ¼ãƒ—ä¸­ãƒ•ãƒ©ã‚°ã‚’è¨­å®š
local function createPortal(config, fromZone)
	local zoneConfig = Islands[fromZone]
	if not zoneConfig then
		warn(("[WarpPortal] ã‚¾ãƒ¼ãƒ³ '%s' ã®è¨­å®šãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"):format(fromZone))
		return nil
	end

	local portalX = zoneConfig.centerX + (config.offsetX or 0)
	local portalZ = zoneConfig.centerZ + (config.offsetZ or 0)

	local FieldGen = require(ReplicatedStorage:WaitForChild("FieldGen"))
	local groundY = nil
	local maxRetries = 2

	for attempt = 1, maxRetries do
		groundY = FieldGen.raycastGroundY(portalX, portalZ, zoneConfig.baseY + 100)
		if groundY then break end
		task.wait(0.05)
	end

	local portalY
	if groundY then
		portalY = groundY + 1
	else
		local estimatedHeight = zoneConfig.baseY + ((zoneConfig.hillAmplitude or 20) * 0.5)
		portalY = estimatedHeight
	end

	local portalPosition = Vector3.new(portalX, portalY, portalZ)

	local portal = Instance.new("Part")
	portal.Name = config.name
	portal.Size = config.size or Vector3.new(8, 12, 8)
	portal.Position = portalPosition
	portal.Anchored = true
	portal.CanCollide = false
	portal.Transparency = 0.3
	portal.Color = config.color or Color3.fromRGB(255, 255, 255)
	portal.Material = Enum.Material.Neon

	portal:SetAttribute("FromZone", fromZone)
	portal:SetAttribute("ToZone", config.toZone)

	local bodyAngularVelocity = Instance.new("BodyAngularVelocity")
	bodyAngularVelocity.AngularVelocity = Vector3.new(0, 2, 0)
	bodyAngularVelocity.MaxTorque = Vector3.new(0, math.huge, 0)
	bodyAngularVelocity.P = 1000
	bodyAngularVelocity.Parent = portal

	local billboard = Instance.new("BillboardGui")
	billboard.Name = "PortalLabel"
	billboard.Size = UDim2.new(0, 200, 0, 50)
	billboard.StudsOffset = Vector3.new(0, 7, 0)
	billboard.AlwaysOnTop = true
	billboard.Parent = portal

	local label = Instance.new("TextLabel")
	label.Size = UDim2.new(1, 0, 1, 0)
	label.BackgroundTransparency = 1
	label.Text = config.label or ("â†’ " .. config.toZone)
	label.TextColor3 = Color3.new(1, 1, 1)
	label.TextScaled = true
	label.Font = Enum.Font.SourceSansBold
	label.TextStrokeTransparency = 0.5
	label.Parent = billboard

	local worldFolder = workspace:FindFirstChild("World")
	if not worldFolder then
		worldFolder = Instance.new("Folder")
		worldFolder.Name = "World"
		worldFolder.Parent = workspace
	end

	portal.Parent = worldFolder

	task.spawn(function()
		task.wait(0.05)

		local params = RaycastParams.new()
		params.FilterType = Enum.RaycastFilterType.Include
		params.FilterDescendantsInstances = {workspace.Terrain}

		local rayOrigin = portal.Position
		local rayDirection = Vector3.new(0, -200, 0)
		local rayResult = workspace:Raycast(rayOrigin, rayDirection, params)

		if rayResult and portal.Parent then
			local adjustedY = rayResult.Position.Y + (portal.Size.Y / 2) + 0.5
			portal.Position = Vector3.new(portal.Position.X, adjustedY, portal.Position.Z)
		end
	end)

	-- ã€é‡è¦ã€‘ãƒãƒ¼ã‚¿ãƒ«ã‚¿ãƒƒãƒå‡¦ç†
	portal.Touched:Connect(function(hit)
		local character = hit.Parent
		if not character then return end

		local player = Players:GetPlayerFromCharacter(character)
		if not player then return end

		-- ã€ä¿®æ­£1ã€‘ãƒ¯ãƒ¼ãƒ—ä¸­ãƒã‚§ãƒƒã‚¯
		if warpingPlayers[player.UserId] then
			return
		end

		-- ã€ä¿®æ­£2ã€‘ãƒãƒˆãƒ«ä¸­ãƒã‚§ãƒƒã‚¯
		if BattleSystem and BattleSystem.isInBattle and BattleSystem.isInBattle(player) then
			return
		end

		local actualFromZone = portal:GetAttribute("FromZone")
		local currentZone = ZoneManager.GetPlayerZone(player)

		if currentZone ~= actualFromZone then
			if not currentZone then
				ZoneManager.PlayerZones[player] = actualFromZone
			else
				return
			end
		end

		print(("[WarpPortal] %s ãŒ %s ã«å…¥ã‚Šã¾ã—ãŸ"):format(player.Name, config.name))

		-- ã€ä¿®æ­£3ã€‘å³åº§ã«ãƒ¯ãƒ¼ãƒ—ä¸­ãƒ•ãƒ©ã‚°ã‚’è¨­å®šï¼ˆæœ€å„ªå…ˆï¼‰
		warpingPlayers[player.UserId] = true
		character:SetAttribute("IsWarping", true)

		-- ã€ä¿®æ­£4-æ”¹3ã€‘ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚’å³åº§ã«é€æ˜åŒ–ï¼ˆä¸Šç©ºç§»å‹•ãªã—ï¼‰
		local originalTransparencies = {}
		for _, part in ipairs(character:GetDescendants()) do
			if part:IsA("BasePart") then
				originalTransparencies[part] = part.Transparency
				part.Transparency = 1
			elseif part:IsA("Decal") or part:IsA("Texture") then
				originalTransparencies[part] = part.Transparency
				part.Transparency = 1
			end
		end

		-- ç”»é¢ã‚’æš—è»¢
		warpEvent:FireClient(player, "StartLoading", config.toZone)
		task.wait(0.5)

		-- ãƒãƒˆãƒ«ã‚·ã‚¹ãƒ†ãƒ ãƒªã‚»ãƒƒãƒˆ
		if BattleSystem and BattleSystem.resetAllBattles then
			BattleSystem.resetAllBattles()
		end

		destroyPortalsForZone(actualFromZone)

		-- å‰ã®ã‚¾ãƒ¼ãƒ³ã®ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’å‰Šé™¤
		if actualFromZone ~= "StartTown" and _G.DespawnMonstersForZone then
			_G.DespawnMonstersForZone(actualFromZone)
		end

		-- ã‚¾ãƒ¼ãƒ³åˆ‡ã‚Šæ›¿ãˆ
		local success = ZoneManager.WarpPlayerToZone(player, config.toZone)

		if success then
			-- é€æ˜åº¦ã‚’å…ƒã«æˆ»ã™
			for part, transparency in pairs(originalTransparencies) do
				if part and part.Parent then
					part.Transparency = transparency
				end
			end

			-- æ–°ã—ã„ã‚¾ãƒ¼ãƒ³ã®ãƒãƒ¼ã‚¿ãƒ«ã‚’ä½œæˆ
			createPortalsForZone(config.toZone)

			-- æ–°ã—ã„ã‚¾ãƒ¼ãƒ³ã®ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’ã‚¹ãƒãƒ¼ãƒ³
			if config.toZone ~= "StartTown" and _G.SpawnMonstersForZone then
				_G.SpawnMonstersForZone(config.toZone)
			end

			task.wait(0.5)
			warpEvent:FireClient(player, "EndLoading")
		else
			warn(("[WarpPortal] %s ã®ãƒ¯ãƒ¼ãƒ—ã«å¤±æ•—"):format(player.Name))
			warpEvent:FireClient(player, "EndLoading")
		end

		-- ã€ä¿®æ­£5ã€‘ãƒ¯ãƒ¼ãƒ—ä¸­ãƒ•ãƒ©ã‚°ã‚’è§£é™¤
		task.wait(1)  -- è¿½åŠ ã®å®‰å…¨ãƒãƒ¼ã‚¸ãƒ³
		warpingPlayers[player.UserId] = nil
		if character and character.Parent then
			character:SetAttribute("IsWarping", false)
		end
	end)

	return portal
end

function createPortalsForZone(zoneName)
	if activePortals[zoneName] then
		print(("[WarpPortal] %s ã®ãƒãƒ¼ã‚¿ãƒ«ã¯æ—¢ã«å­˜åœ¨ã—ã¾ã™"):format(zoneName))
		return
	end

	activePortals[zoneName] = {}

	if zoneName == "StartTown" then
		print(("[WarpPortal] %s ã®ãƒãƒ¼ã‚¿ãƒ«ã‚’ä¸¦åˆ—ç”Ÿæˆä¸­..."):format(zoneName))

		local townPortalConfigs = {
			-- {name = "Town_to_ContinentA", toZone = "ContinentA", offsetX = 50, offsetZ = 0, size = Vector3.new(8, 12, 8), color = Color3.fromRGB(100, 255, 100), label = "â†’ Grassland"},
			-- {name = "Town_to_ContinentB", toZone = "ContinentB", offsetX = -50, offsetZ = 0, size = Vector3.new(8, 12, 8), color = Color3.fromRGB(150, 150, 255), label = "â†’ Wilderness"},
			-- {name = "Town_to_ContinentT", toZone = "ContinentT", offsetX = 0, offsetZ = 50, size = Vector3.new(8, 12, 8), color = Color3.fromRGB(255, 255, 100), label = "â†’ T-Continent"},
			{name = "Town_to_Hokkaido", toZone = "ContinentHokkaido", offsetX = 0, offsetZ = -50, size = Vector3.new(8, 12, 8), color = Color3.fromRGB(200, 200, 255), label = "â†’ Hokkaido"},
		}

		for _, config in ipairs(townPortalConfigs) do
			task.spawn(function()
				local portal = createPortal(config, zoneName)
				if portal then
					table.insert(activePortals[zoneName], portal)
					print(("[WarpPortal] ãƒãƒ¼ã‚¿ãƒ«ä½œæˆ: %s"):format(config.name))
				end
			end)
		end
		return
	end

	local continent = Continents[zoneName]
	if continent and continent.portals then
		print(("[WarpPortal] %s ã®ãƒãƒ¼ã‚¿ãƒ«ã‚’ä¸¦åˆ—ç”Ÿæˆä¸­..."):format(zoneName))

		for _, portalConfig in ipairs(continent.portals) do
			task.spawn(function()
				local islandName = portalConfig.islandName
				if not Islands[islandName] then
					warn(("[WarpPortal] å³¶ '%s' ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"):format(islandName))
				else
					local portal = createPortal(portalConfig, islandName)
					if portal then
						portal:SetAttribute("FromZone", zoneName)
						table.insert(activePortals[zoneName], portal)
						print(("[WarpPortal] ãƒãƒ¼ã‚¿ãƒ«ä½œæˆ: %s (é…ç½®: %s)"):format(portalConfig.name, islandName))
					end
				end
			end)
		end
	else
		print(("[WarpPortal] %s ã®ãƒãƒ¼ã‚¿ãƒ«è¨­å®šãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"):format(zoneName))
	end
end

function destroyPortalsForZone(zoneName)
	if not activePortals[zoneName] then return end

	for _, portal in ipairs(activePortals[zoneName]) do
		if portal and portal.Parent then
			portal:Destroy()
		end
	end

	activePortals[zoneName] = nil
	print(("[WarpPortal] %s ã®ãƒãƒ¼ã‚¿ãƒ«ã‚’å‰Šé™¤ã—ã¾ã—ãŸ"):format(zoneName))
end

task.spawn(function()
	local maxWait = 10
	local waited = 0

	while not _G.SpawnMonstersForZone and waited < maxWait do
		task.wait(0.5)
		waited = waited + 0.5
	end

	if _G.SpawnMonstersForZone then
		print("[WarpPortal] MonsterSpawneré–¢æ•°æ¤œå‡ºæˆåŠŸ")
	else
		warn("[WarpPortal] MonsterSpawneré–¢æ•°ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
	end
end)

task.wait(0.3)
createPortalsForZone("StartTown")

Players.PlayerRemoving:Connect(function(player)
	warpingPlayers[player.UserId] = nil
	ZoneManager.PlayerZones[player] = nil
end)

_G.CreatePortalsForZone = createPortalsForZone
_G.DestroyPortalsForZone = destroyPortalsForZone

print("[WarpPortal] åˆæœŸåŒ–å®Œäº†")
===== ./ServerScriptService/BattleSystem.lua =====
-- ServerScriptService/BattleSystem.lua
-- ãƒãƒˆãƒ«ã‚·ã‚¹ãƒ†ãƒ ã®ç®¡ç†ï¼ˆæ•µã®å®šæœŸæ”»æ’ƒå¯¾å¿œç‰ˆï¼‰

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")

local BattleSystem = {}

-- PlayerStatsãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ãƒ­ãƒ¼ãƒ‰
local PlayerStats = require(ServerScriptService:WaitForChild("PlayerStats"))

-- æˆ¦é—˜ä¸­ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’è¿½è·¡
local ActiveBattles = {}

-- ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒãƒˆãƒ«ãƒ•ãƒ©ã‚°
local GlobalBattleActive = false

-- ãƒãƒˆãƒ«çµ‚äº†ç›´å¾Œã®ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³
local LastBattleEndTime = 0
local BATTLE_COOLDOWN = 0.5

-- ãƒãƒˆãƒ«çµ‚äº†å‡¦ç†ä¸­ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼ˆäºŒé‡çµ‚äº†é˜²æ­¢ï¼‰
local EndingBattles = {}

-- æ•—åŒ—æ™‚ã®ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼è¨˜éŒ²ï¼ˆæ¶ˆå»ç”¨ï¼‰
local DefeatedByMonster = {}

-- RemoteEvent ã®ä½œæˆ/å–å¾—
local function getOrCreateRemoteEvent(name)
	local event = ReplicatedStorage:FindFirstChild(name)
	if not event then
		event = Instance.new("RemoteEvent")
		event.Name = name
		event.Parent = ReplicatedStorage
		print(("[BattleSystem] RemoteEventä½œæˆ: %s"):format(name))
	end
	return event
end

-- RemoteEventsã‚’ä½œæˆ
local BattleStartEvent = getOrCreateRemoteEvent("BattleStart")
local BattleEndEvent = getOrCreateRemoteEvent("BattleEnd")
local BattleVictoryEvent = getOrCreateRemoteEvent("BattleVictory")
local BattleDamageEvent = getOrCreateRemoteEvent("BattleDamage")
local BattleHPUpdateEvent = getOrCreateRemoteEvent("BattleHPUpdate")
local PlayerHPUpdateEvent = getOrCreateRemoteEvent("PlayerHPUpdate")
local StatusUpdateEvent = getOrCreateRemoteEvent("StatusUpdate")
local RequestStatusEvent = getOrCreateRemoteEvent("RequestStatus")
local LevelUpEvent = getOrCreateRemoteEvent("LevelUp")
local ShowDeathUIEvent = getOrCreateRemoteEvent("ShowDeathUI")
local DeathChoiceEvent = getOrCreateRemoteEvent("DeathChoice")
local TypingMistakeEvent = getOrCreateRemoteEvent("TypingMistake")

print("[BattleSystem] RemoteEventsæº–å‚™å®Œäº†")

-- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼å®šç¾©ã‚’å–å¾—
local MonstersRegistry = require(ReplicatedStorage:WaitForChild("Monsters"):WaitForChild("Registry"))

-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«é€ä¿¡
local function sendStatusUpdate(player: Player)
	local stats = PlayerStats.getStats(player)
	if not stats then return end

	local expToNext = stats.Level * 100  -- ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ã«å¿…è¦ãªçµŒé¨“å€¤

	StatusUpdateEvent:FireClient(
		player,
		stats.CurrentHP,
		stats.MaxHP,
		stats.Level,
		stats.Experience,
		expToNext,
		stats.Gold
	)
end

-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒæˆ¦é—˜ä¸­ã‹ãƒã‚§ãƒƒã‚¯
function BattleSystem.isInBattle(player: Player): boolean
	return ActiveBattles[player] ~= nil
end

-- ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªãƒãƒˆãƒ«çŠ¶æ…‹ã‚’å–å¾—
function BattleSystem.isAnyBattleActive(): boolean
	return GlobalBattleActive
end

-- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼å®šç¾©ã‚’åå‰ã‹ã‚‰å–å¾—
local function getMonsterDef(monsterName)
	for _, def in ipairs(MonstersRegistry) do
		if def.Name == monsterName then
			return def
		end
	end
	return nil
end

-- ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’è¨ˆç®—ï¼ˆæ•µâ†’ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼‰
local function calculateDamage(attackerAttack: number, defenderDefense: number): number
	-- åŸºæœ¬ãƒ€ãƒ¡ãƒ¼ã‚¸ = æ”»æ’ƒåŠ› * 0.5 - å®ˆå‚™åŠ› * 0.25
	local baseDamage = attackerAttack * 0.5 - defenderDefense * 0.25
	baseDamage = math.max(1, baseDamage)  -- æœ€ä½1ãƒ€ãƒ¡ãƒ¼ã‚¸

	-- Â±10%ã®ãƒ©ãƒ³ãƒ€ãƒ å¹…
	local randomMultiplier = 0.9 + math.random() * 0.2  -- 0.9 ~ 1.1
	local finalDamage = baseDamage * randomMultiplier

	return math.floor(finalDamage)  -- æ•´æ•°ã«ä¸¸ã‚ã‚‹
end

-- æ”»æ’ƒé–“éš”ã‚’è¨ˆç®—
local function calculateAttackInterval(playerSpeed: number, enemySpeed: number): number
	-- æ”»æ’ƒé–“éš” = 1 + (ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç´ æ—©ã• / æ•µç´ æ—©ã• - 1) * 0.5
	local interval = 1 + (playerSpeed / enemySpeed - 1) * 0.5
	return math.max(0.5, interval)  -- æœ€ä½0.5ç§’
end

-- æ•µã®æ”»æ’ƒå‡¦ç†
local function enemyAttack(player: Player, battleData)
	if not ActiveBattles[player] or EndingBattles[player] then
		return  -- ãƒãƒˆãƒ«çµ‚äº†æ¸ˆã¿
	end

	local monsterDef = battleData.monsterDef
	local playerStats = PlayerStats.getStats(player)

	if not playerStats then
		warn(("[BattleSystem] %s ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"):format(player.Name))
		return
	end

	-- ãƒ€ãƒ¡ãƒ¼ã‚¸è¨ˆç®—
	local damage = calculateDamage(monsterDef.Attack, playerStats.Defense)

	print(("[BattleSystem] %s ãŒ %s ã‹ã‚‰ %d ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ãŸ"):format(
		player.Name, battleData.monster.Name, damage
		))

	-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ãƒ€ãƒ¡ãƒ¼ã‚¸
	local isDead = PlayerStats.takeDamage(player, damage)

	-- HPã‚’ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«é€šçŸ¥
	PlayerHPUpdateEvent:FireClient(player, playerStats.CurrentHP, playerStats.MaxHP)

	-- æ­»äº¡åˆ¤å®š
	if isDead then
		print(("[BattleSystem] %s ã¯å€’ã‚ŒãŸï¼"):format(player.Name))
		BattleSystem.endBattle(player, false)  -- æ•—åŒ—
		return
	end

	-- æ¬¡ã®æ”»æ’ƒã‚’ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«
	local attackInterval = calculateAttackInterval(playerStats.Speed, monsterDef.Speed)
	battleData.nextAttackTime = tick() + attackInterval

	print(("[BattleSystem] æ¬¡ã®æ”»æ’ƒã¾ã§ %.1f ç§’"):format(attackInterval))
end

-- ãƒãƒˆãƒ«é–‹å§‹
function BattleSystem.startBattle(player: Player, monster: Model)
	print(("[BattleSystem] startBattleå‘¼ã³å‡ºã—: %s vs %s"):format(player.Name, monster.Name))

	-- ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ãƒã‚§ãƒƒã‚¯
	local timeSinceLastBattle = tick() - LastBattleEndTime
	if timeSinceLastBattle < BATTLE_COOLDOWN then
		return false
	end

	-- äºŒé‡ãƒã‚§ãƒƒã‚¯
	if GlobalBattleActive then
		return false
	end

	if BattleSystem.isInBattle(player) then
		return false
	end

	-- çµ‚äº†å‡¦ç†ä¸­ãƒã‚§ãƒƒã‚¯
	if EndingBattles[player] then
		print(("[BattleSystem] %s ã¯çµ‚äº†å‡¦ç†ä¸­ã§ã™"):format(player.Name))
		return false
	end

	local character = player.Character
	if not character then
		return false
	end

	local humanoid = character:FindFirstChildOfClass("Humanoid")
	local hrp = character:FindFirstChild("HumanoidRootPart")
	local monsterHumanoid = monster:FindFirstChildOfClass("Humanoid")
	local monsterHrp = monster.PrimaryPart

	if not humanoid or not hrp or not monsterHumanoid or not monsterHrp then
		return false
	end

	-- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã®ç¨®é¡ã‚’å–å¾—
	local monsterKind = monster:GetAttribute("MonsterKind") or "Unknown"
	local monsterDef = getMonsterDef(monsterKind)

	if not monsterDef then
		warn(("[BattleSystem] ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼å®šç¾©ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: %s"):format(monsterKind))
		return false
	end

	-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’å–å¾—
	local playerStats = PlayerStats.getStats(player)
	if not playerStats then
		warn(("[BattleSystem] %s ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"):format(player.Name))
		return false
	end

	print(("[BattleSystem] ãƒãƒˆãƒ«é–‹å§‹: %s vs %s"):format(player.Name, monster.Name))
	print(("  ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼: HP %d/%d, ç´ æ—©ã• %d, æ”»æ’ƒ %d, å®ˆå‚™ %d"):format(
		playerStats.CurrentHP, playerStats.MaxHP,
		playerStats.Speed, playerStats.Attack, playerStats.Defense
		))
	print(("  ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼: HP %d, ç´ æ—©ã• %d, æ”»æ’ƒ %d, å®ˆå‚™ %d"):format(
		monsterDef.HP, monsterDef.Speed, monsterDef.Attack, monsterDef.Defense
		))

	-- ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒãƒˆãƒ«ãƒ•ãƒ©ã‚°ã‚’ON
	GlobalBattleActive = true

	-- å…ƒã®é€Ÿåº¦ã‚’ä¿å­˜
	local originalPlayerSpeed = humanoid.WalkSpeed
	local originalJumpPower = humanoid.JumpPower
	local originalMonsterSpeed = monsterHumanoid.WalkSpeed

	-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å®Œå…¨åœæ­¢
	humanoid.WalkSpeed = 0
	humanoid.JumpPower = 0
	humanoid.JumpHeight = 0

	-- ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Œå…¨åœæ­¢
	for _, track in pairs(humanoid:GetPlayingAnimationTracks()) do
		track:Stop(0)
	end

	humanoid:ChangeState(Enum.HumanoidStateType.Physics)
	task.wait(0.05)
	humanoid:ChangeState(Enum.HumanoidStateType.Running)
	hrp.Anchored = true
	hrp.AssemblyLinearVelocity = Vector3.zero
	hrp.AssemblyAngularVelocity = Vector3.zero

	-- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’å®Œå…¨åœæ­¢
	monsterHumanoid.WalkSpeed = 0
	monsterHumanoid.JumpPower = 0
	monsterHumanoid:MoveTo(monsterHrp.Position)

	-- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã®å…¨ãƒ‘ãƒ¼ãƒ„ã‚’Anchor
	for _, part in ipairs(monster:GetDescendants()) do
		if part:IsA("BasePart") then
			part.Anchored = true
		end
	end

	-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®1æ–‡å­—ã‚ãŸã‚Šã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’è¨ˆç®—
	local damagePerKey = math.floor(playerStats.Attack * 0.8)
	damagePerKey = math.max(1, damagePerKey)  -- æœ€ä½1ãƒ€ãƒ¡ãƒ¼ã‚¸

	-- æ•µã®æœ€åˆã®æ”»æ’ƒã‚¿ã‚¤ãƒŸãƒ³ã‚°ã‚’è¨ˆç®—
	local attackInterval = calculateAttackInterval(playerStats.Speed, monsterDef.Speed)
	local nextAttackTime = tick() + attackInterval

	-- æˆ¦é—˜ãƒ‡ãƒ¼ã‚¿ã‚’è¨˜éŒ²
	ActiveBattles[player] = {
		monster = monster,
		monsterDef = monsterDef,
		monsterHP = monsterDef.HP,
		monsterMaxHP = monsterDef.HP,
		damagePerKey = damagePerKey,
		nextAttackTime = nextAttackTime,
		startTime = tick(),
		originalPlayerSpeed = originalPlayerSpeed,
		originalJumpPower = originalJumpPower,
		originalMonsterSpeed = originalMonsterSpeed
	}

	-- ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«ãƒãƒˆãƒ«é–‹å§‹ã‚’é€šçŸ¥
	BattleStartEvent:FireClient(
		player,
		monster.Name,
		monsterDef.HP,
		monsterDef.HP,
		damagePerKey,
		monsterDef.TypingLevels or {{level = "level_1", weight = 100}},
		playerStats.CurrentHP,
		playerStats.MaxHP
	)

	-- æ•µã®æ”»æ’ƒãƒ«ãƒ¼ãƒ—ã‚’é–‹å§‹
	task.spawn(function()
		while ActiveBattles[player] and not EndingBattles[player] do
			local battleData = ActiveBattles[player]
			if not battleData then break end

			-- æ”»æ’ƒã‚¿ã‚¤ãƒŸãƒ³ã‚°ã‚’ãƒã‚§ãƒƒã‚¯
			if tick() >= battleData.nextAttackTime then
				enemyAttack(player, battleData)
			end

			task.wait(0.1)  -- 0.1ç§’ã”ã¨ã«ãƒã‚§ãƒƒã‚¯
		end
	end)

	return true
end

-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‹ã‚‰ã®ãƒ€ãƒ¡ãƒ¼ã‚¸å‡¦ç†
local function onDamageReceived(player, damageAmount)
	-- ãƒãƒˆãƒ«çµ‚äº†å‡¦ç†ä¸­ã¯ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ç„¡è¦–
	if EndingBattles[player] then
		print(("[BattleSystem] %s ã¯çµ‚äº†å‡¦ç†ä¸­ã®ãŸã‚ã€ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ç„¡è¦–"):format(player.Name))
		return
	end

	local battleData = ActiveBattles[player]
	if not battleData then
		warn(("[BattleSystem] %s ã¯ãƒãƒˆãƒ«ä¸­ã§ã¯ã‚ã‚Šã¾ã›ã‚“ï¼ˆãƒ€ãƒ¡ãƒ¼ã‚¸ç„¡è¦–ï¼‰"):format(player.Name))
		return
	end

	-- HPã‚’æ¸›ã‚‰ã™
	local oldHP = battleData.monsterHP
	battleData.monsterHP = math.max(0, battleData.monsterHP - damageAmount)

	print(("[BattleSystem] ========================================"):format())
	print(("[BattleSystem] ãƒ€ãƒ¡ãƒ¼ã‚¸å‡¦ç†"):format())
	print(("  ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼: %s"):format(player.Name))
	print(("  ãƒ€ãƒ¡ãƒ¼ã‚¸é‡: %d"):format(damageAmount))
	print(("  HPå¤‰åŒ–: %d â†’ %d"):format(oldHP, battleData.monsterHP))
	print(("  æœ€å¤§HP: %d"):format(battleData.monsterMaxHP))
	print(("[BattleSystem] ========================================"):format())

	-- ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«HPæ›´æ–°ã‚’é€šçŸ¥
	BattleHPUpdateEvent:FireClient(player, battleData.monsterHP)

	-- HPãŒ0ã«ãªã£ãŸã‚‰å‹åˆ©
	if battleData.monsterHP <= 0 then
		print(("[BattleSystem] ========================================"):format())
		print(("[BattleSystem] ğŸ‰ å‹åˆ©æ¡ä»¶é”æˆï¼"):format())
		print(("  %s ãŒ %s ã‚’å€’ã—ã¾ã—ãŸï¼"):format(player.Name, battleData.monster.Name))
		print(("  ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼HP: %d"):format(battleData.monsterHP))
		print(("[BattleSystem] endBattle(true) ã‚’å‘¼ã³å‡ºã—ã¾ã™"):format())
		print(("[BattleSystem] ========================================"):format())

		BattleSystem.endBattle(player, true)

		print(("[BattleSystem] endBattle(true) å‘¼ã³å‡ºã—å®Œäº†"):format())
	end
end

-- ãƒãƒˆãƒ«çµ‚äº†
function BattleSystem.endBattle(player: Player, victory: boolean)
	print(("[BattleSystem] ãƒãƒˆãƒ«çµ‚äº†: %s - %s"):format(
		player.Name, victory and "å‹åˆ©" or "æ•—åŒ—"
		))

	-- äºŒé‡çµ‚äº†ãƒã‚§ãƒƒã‚¯
	if EndingBattles[player] then
		warn(("[BattleSystem] %s ã¯æ—¢ã«çµ‚äº†å‡¦ç†ä¸­ã§ã™"):format(player.Name))
		return
	end

	-- çµ‚äº†å‡¦ç†ä¸­ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹
	EndingBattles[player] = true

	-- ã€é‡è¦ã€‘å‹åˆ©æ™‚ã®ã¿ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒãƒˆãƒ«ãƒ•ãƒ©ã‚°ã‚’OFF
	-- æ•—åŒ—æ™‚ã¯æ­»äº¡é¸æŠãŒå®Œäº†ã™ã‚‹ã¾ã§ç¶­æŒ
	if victory then
		GlobalBattleActive = false
	end

	-- ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³é–‹å§‹
	LastBattleEndTime = tick()

	local battleData = ActiveBattles[player]
	if not battleData then
		warn("[BattleSystem] battleDataãŒå­˜åœ¨ã—ã¾ã›ã‚“ï¼")

		-- æœ€ä½é™ã®å¾©å…ƒ
		local character = player.Character
		if character then
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			local hrp = character:FindFirstChild("HumanoidRootPart")
			if humanoid then
				humanoid.WalkSpeed = 16
				humanoid.JumpPower = 50
				humanoid.JumpHeight = 7.2
			end
			if hrp then
				hrp.Anchored = false
			end
		end

		BattleEndEvent:FireClient(player, victory)
		ActiveBattles[player] = nil

		-- çµ‚äº†å‡¦ç†å®Œäº†å¾Œã«ãƒ•ãƒ©ã‚°ã‚’è§£é™¤
		task.delay(1, function()
			EndingBattles[player] = nil
		end)

		return
	end

	local character = player.Character
	local monster = battleData.monster
	local monsterDef = battleData.monsterDef

	-- å‹åˆ©æ™‚ã®å‡¦ç†
	if victory then
		-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç§»å‹•ã‚’å¾©å…ƒ
		if character then
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			local hrp = character:FindFirstChild("HumanoidRootPart")
			if humanoid then
				humanoid.WalkSpeed = battleData.originalPlayerSpeed or 16
				humanoid.JumpPower = battleData.originalJumpPower or 50
				humanoid.JumpHeight = 7.2
			end
			if hrp then
				hrp.Anchored = false
			end
		end

		-- çµŒé¨“å€¤ã¨ã‚´ãƒ¼ãƒ«ãƒ‰ã‚’ä»˜ä¸
		if monsterDef.Experience then
			print(("[BattleSystem] çµŒé¨“å€¤ %d ã‚’ä»˜ä¸"):format(monsterDef.Experience))
			PlayerStats.addExperience(player, monsterDef.Experience)
		end
		if monsterDef.Gold then
			print(("[BattleSystem] ã‚´ãƒ¼ãƒ«ãƒ‰ %d ã‚’ä»˜ä¸"):format(monsterDef.Gold))
			PlayerStats.addGold(player, monsterDef.Gold)
		end

		print(("[BattleSystem] ========================================"):format())
		print(("[BattleSystem] ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æ’ƒç ´ã‚«ã‚¦ãƒ³ãƒˆå‡¦ç†é–‹å§‹"):format())
		print(("[BattleSystem] ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼: %s"):format(player.Name))
		print(("[BattleSystem] ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼: %s"):format(battleData.monster.Name))


		PlayerStats.addMonstersDefeated(player, 1)

		print(("[BattleSystem] ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æ’ƒç ´ã‚«ã‚¦ãƒ³ãƒˆå‡¦ç†å®Œäº†"):format())
		print(("[BattleSystem] ========================================"):format())


		-- å°‘ã—å¾…ã£ã¦ã‹ã‚‰ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°ã‚’é€ä¿¡ï¼ˆå¿µã®ãŸã‚ï¼‰
		task.wait(0.1)
		sendStatusUpdate(player)

		-- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’éè¡¨ç¤º
		monster:SetAttribute("Defeated", true)

		for _, part in ipairs(monster:GetDescendants()) do
			if part:IsA("BasePart") then
				part.Transparency = 1
			end
		end

		local hrp = monster:FindFirstChild("HumanoidRootPart")
		if hrp then
			local gui = hrp:FindFirstChild("DebugInfo")
			if gui then
				gui.Enabled = false
			end
		end

		-- 1ç§’å¾Œã«å‰Šé™¤
		task.delay(1, function()
			if monster and monster.Parent then
				monster:Destroy()
			end
		end)
	else
		-- æ•—åŒ—æ™‚ï¼šãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯ç§»å‹•åˆ¶é™ã‚’ç¶­æŒï¼ˆæ­»äº¡é¸æŠUIã§é¸ã‚“ã å¾Œã«å¾©å…ƒï¼‰
		-- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’å¾©å…ƒ
		monster:SetAttribute("InBattle", false)

		local monsterHumanoid = monster:FindFirstChildOfClass("Humanoid")
		if monsterHumanoid then
			monsterHumanoid.WalkSpeed = battleData.originalMonsterSpeed or 14
		end

		-- Anchorè§£é™¤
		local partsToUnanchor = {}
		for _, part in ipairs(monster:GetDescendants()) do
			if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
				table.insert(partsToUnanchor, part)
			end
		end

		for _, part in ipairs(partsToUnanchor) do
			part.Anchored = false
		end

		if monster.PrimaryPart then
			task.wait(0.1)
			monster.PrimaryPart.Anchored = false
		end

		-- æ­»äº¡æ™‚ã®é¸æŠUIã‚’è¡¨ç¤º
		local playerStats = PlayerStats.getStats(player)
		if playerStats then
			local reviveCost = math.floor(playerStats.Level * 50)  -- ãƒ¬ãƒ™ãƒ« * 50ã‚´ãƒ¼ãƒ«ãƒ‰
			print(("[BattleSystem] ========================================"):format())
			print(("[BattleSystem] æ­»äº¡UIè¡¨ç¤ºã‚’é€ä¿¡"):format())
			print(("[BattleSystem] æ‰€æŒé‡‘: %d G, å¾©æ´»ã‚³ã‚¹ãƒˆ: %d G"):format(playerStats.Gold, reviveCost))
			print(("[BattleSystem] ========================================"):format())

			-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«æ­»äº¡ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹ï¼ˆãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ãŒæ¥è§¦ã—ãªã„ã‚ˆã†ã«ï¼‰
			if character then
				character:SetAttribute("IsDead", true)
				print(("[BattleSystem] %s ã«æ­»äº¡ãƒ•ãƒ©ã‚°ã‚’è¨­å®š"):format(player.Name))
			end

			-- ã€é‡è¦ã€‘å€’ã—ãŸãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’è¨˜éŒ²ï¼ˆé¸æŠå¾Œã«æ¶ˆå»ã™ã‚‹ãŸã‚ï¼‰
			DefeatedByMonster[player] = monster
			print(("[BattleSystem] å€’ã—ãŸãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ %s ã‚’è¨˜éŒ²"):format(monster.Name))

			ShowDeathUIEvent:FireClient(player, playerStats.Gold, reviveCost)
		else
			warn("[BattleSystem] ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ï¼")
		end
	end

	-- ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«é€šçŸ¥
	BattleEndEvent:FireClient(player, victory)

	-- å‹åˆ©æ™‚ã¯æˆ¦é—˜ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¯ãƒªã‚¢ã—ã¦çµ‚äº†å‡¦ç†ãƒ•ãƒ©ã‚°ã‚‚è§£é™¤
	if victory then
		ActiveBattles[player] = nil

		-- çµ‚äº†å‡¦ç†å®Œäº†å¾Œã«ãƒ•ãƒ©ã‚°ã‚’è§£é™¤ï¼ˆ1ç§’å¾Œï¼‰
		task.delay(1, function()
			EndingBattles[player] = nil
			print(("[BattleSystem] %s ã®çµ‚äº†å‡¦ç†ãƒ•ãƒ©ã‚°ã‚’è§£é™¤"):format(player.Name))
		end)
	else
		-- æ•—åŒ—æ™‚ã¯æˆ¦é—˜ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¯ãƒªã‚¢ã™ã‚‹ãŒã€çµ‚äº†å‡¦ç†ãƒ•ãƒ©ã‚°ã¯ç¶­æŒ
		-- ï¼ˆæ­»äº¡é¸æŠUIã§é¸ã‚“ã å¾Œã«è§£é™¤ã™ã‚‹ï¼‰
		ActiveBattles[player] = nil
		print(("[BattleSystem] æ•—åŒ— - çµ‚äº†å‡¦ç†ãƒ•ãƒ©ã‚°ã‚’ç¶­æŒã—ã¾ã™ï¼ˆé¸æŠã¾ã§ï¼‰"))
	end
end

-- åˆæœŸåŒ–
function BattleSystem.init()
	-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¦æ±‚ã‚¤ãƒ™ãƒ³ãƒˆ
	RequestStatusEvent.OnServerEvent:Connect(function(player)
		print(("[BattleSystem] %s ãŒã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’è¦æ±‚ã—ã¾ã—ãŸ"):format(player.Name))
		sendStatusUpdate(player)
	end)

	-- ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚¤ãƒ™ãƒ³ãƒˆ
	BattleDamageEvent.OnServerEvent:Connect(function(player, damageAmount)
		print(("[BattleSystem] ãƒ€ãƒ¡ãƒ¼ã‚¸é€šçŸ¥å—ä¿¡: %s -> %d"):format(player.Name, damageAmount))
		onDamageReceived(player, damageAmount)
	end)

	-- å‹åˆ©ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆå¿µã®ãŸã‚æ®‹ã—ã¦ãŠãï¼‰
	BattleVictoryEvent.OnServerEvent:Connect(function(player)
		print(("[BattleSystem] å‹åˆ©é€šçŸ¥å—ä¿¡: %s"):format(player.Name))

		if BattleSystem.isInBattle(player) then
			BattleSystem.endBattle(player, true)
		end
	end)

	-- æ­»äº¡æ™‚ã®é¸æŠã‚¤ãƒ™ãƒ³ãƒˆ
	DeathChoiceEvent.OnServerEvent:Connect(function(player, choice)
		print(("[BattleSystem] %s ãŒé¸æŠ: %s"):format(player.Name, choice))

		-- ã€é‡è¦ã€‘ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒãƒˆãƒ«ãƒ•ãƒ©ã‚°ã‚’è§£é™¤ï¼ˆæ•—åŒ—æ™‚ã«ç¶­æŒã—ã¦ã„ãŸï¼‰
		GlobalBattleActive = false
		print("[BattleSystem] ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒãƒˆãƒ«ãƒ•ãƒ©ã‚°ã‚’è§£é™¤")

		-- ã€é‡è¦ã€‘çµ‚äº†å‡¦ç†ãƒ•ãƒ©ã‚°ã‚’è§£é™¤ï¼ˆãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ãŒæ¥è§¦ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ï¼‰
		EndingBattles[player] = nil
		print(("[BattleSystem] %s ã®çµ‚äº†å‡¦ç†ãƒ•ãƒ©ã‚°ã‚’è§£é™¤"):format(player.Name))

		local playerStats = PlayerStats.getStats(player)
		if not playerStats then return end

		-- æ­»äº¡ãƒ•ãƒ©ã‚°ã‚’è§£é™¤
		local character = player.Character
		if character then
			character:SetAttribute("IsDead", false)
			print(("[BattleSystem] %s ã®æ­»äº¡ãƒ•ãƒ©ã‚°ã‚’è§£é™¤"):format(player.Name))
		end

		-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç§»å‹•åˆ¶é™ã‚’è§£é™¤
		if character then
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			local hrp = character:FindFirstChild("HumanoidRootPart")
			if humanoid then
				humanoid.WalkSpeed = 16
				humanoid.JumpPower = 50
				humanoid.JumpHeight = 7.2
			end
			if hrp then
				hrp.Anchored = false
			end
		end

		-- ã€é‡è¦ã€‘å€’ã—ãŸãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’æ¶ˆå»ï¼ˆä¸¡æ–¹ã®é¸æŠè‚¢ã§æ¶ˆå»ï¼‰
		local defeatedMonster = DefeatedByMonster[player]
		if defeatedMonster and defeatedMonster.Parent then
			print(("[BattleSystem] å€’ã—ãŸãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ %s ã‚’æ¶ˆå»"):format(defeatedMonster.Name))

			-- éè¡¨ç¤ºåŒ–
			defeatedMonster:SetAttribute("Defeated", true)
			for _, part in ipairs(defeatedMonster:GetDescendants()) do
				if part:IsA("BasePart") then
					part.Transparency = 1
				end
			end

			-- ãƒ©ãƒ™ãƒ«éè¡¨ç¤º
			local hrp = defeatedMonster:FindFirstChild("HumanoidRootPart")
			if hrp then
				local gui = hrp:FindFirstChild("DebugInfo")
				if gui then
					gui.Enabled = false
				end
			end

			-- å‰Šé™¤
			task.delay(0.5, function()
				if defeatedMonster and defeatedMonster.Parent then
					defeatedMonster:Destroy()
				end
			end)
		end

		-- è¨˜éŒ²ã‚’ã‚¯ãƒªã‚¢
		DefeatedByMonster[player] = nil

		if choice == "return" then
			-- è¡—ã«æˆ»ã‚‹
			print(("[BattleSystem] %s ã‚’è¡—ã«æˆ»ã—ã¾ã™"):format(player.Name))

			-- HPã‚’å…¨å›å¾©
			PlayerStats.fullHeal(player)

			-- StartTownã®åº§æ¨™ã‚’å–å¾—
			print("[BattleSystem] StartTownã®åº§æ¨™ã‚’å–å¾—ä¸­...")
			local IslandsRegistry = require(ReplicatedStorage:WaitForChild("Islands"):WaitForChild("Registry"))
			print(("[BattleSystem] IslandsRegistryå–å¾—å®Œäº†ã€‚å³¶ã®æ•°: %d"):format(#IslandsRegistry))

			local townConfig = nil
			for i, island in ipairs(IslandsRegistry) do
				print(("[BattleSystem] å³¶ %d: name=%s"):format(i, tostring(island.name)))
				if island.name == "StartTown" then
					townConfig = island
					print("[BattleSystem] StartTownã‚’ç™ºè¦‹ï¼")
					break
				end
			end

			-- è¡—ã«ãƒ†ãƒ¬ãƒãƒ¼ãƒˆ
			if character and townConfig then
				local hrp = character:FindFirstChild("HumanoidRootPart")
				if hrp then
					local spawnX = townConfig.centerX
					local spawnZ = townConfig.centerZ
					local spawnY = townConfig.baseY + 50  -- é«˜ã‚ã«è¨­å®š
					print(("[BattleSystem] ãƒ†ãƒ¬ãƒãƒ¼ãƒˆåº§æ¨™: X=%.0f, Y=%.0f, Z=%.0f"):format(
						spawnX, spawnY, spawnZ
						))

					-- ãƒ†ãƒ¬ãƒãƒ¼ãƒˆå®Ÿè¡Œ
					hrp.CFrame = CFrame.new(spawnX, spawnY, spawnZ)

					-- å°‘ã—å¾…ã£ã¦ã‹ã‚‰å†åº¦è¨­å®šï¼ˆä»–ã®ã‚·ã‚¹ãƒ†ãƒ ã®å¹²æ¸‰ã‚’é˜²ãï¼‰
					task.wait(0.1)
					hrp.CFrame = CFrame.new(spawnX, spawnY, spawnZ)

					print(("[BattleSystem] %s ã‚’è¡—ã«ãƒ†ãƒ¬ãƒãƒ¼ãƒˆå®Œäº†"):format(player.Name))

					-- ZoneManagerã«ã‚‚é€šçŸ¥
					local ZoneManager = require(ServerScriptService:WaitForChild("ZoneManager"))
					ZoneManager.PlayerZones[player] = "StartTown"
					print("[BattleSystem] ZoneManagerã«StartTownã‚’è¨˜éŒ²")

					-- ã€é‡è¦ã€‘StartTownã®ãƒãƒ¼ã‚¿ãƒ«ã‚’å†ç”Ÿæˆ
					if _G.CreatePortalsForZone then
						print("[BattleSystem] StartTownã®ãƒãƒ¼ã‚¿ãƒ«ã‚’å†ç”Ÿæˆ")
						_G.CreatePortalsForZone("StartTown")
					else
						warn("[BattleSystem] CreatePortalsForZoneé–¢æ•°ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
					end
				end
			elseif character then
				-- ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼štownConfigãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆ
				warn("[BattleSystem] StartTownãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ï¼")
				print("[BattleSystem] ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼šåŸç‚¹ã«ãƒ†ãƒ¬ãƒãƒ¼ãƒˆ")
				local hrp = character:FindFirstChild("HumanoidRootPart")
				if hrp then
					hrp.CFrame = CFrame.new(0, 50, 0)
				end
			end

			-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°
			sendStatusUpdate(player)

		elseif choice == "revive" then
			-- ã‚´ãƒ¼ãƒ«ãƒ‰ã§å¾©æ´»
			local reviveCost = math.floor(playerStats.Level * 50)

			if PlayerStats.removeGold(player, reviveCost) then
				print(("[BattleSystem] %s ãŒã‚´ãƒ¼ãƒ«ãƒ‰ %d ã§å¾©æ´»"):format(player.Name, reviveCost))

				-- HPã‚’å…¨å›å¾©
				PlayerStats.fullHeal(player)

				-- ã€é‡è¦ã€‘å¾©æ´»å¾Œã®ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ã‚’è¨­å®šï¼ˆ3ç§’é–“ãƒãƒˆãƒ«ä¸å¯ï¼‰
				LastBattleEndTime = tick()
				print("[BattleSystem] å¾©æ´»å¾Œã®ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³é–‹å§‹")

				-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°
				sendStatusUpdate(player)
			else
				warn(("[BattleSystem] %s ã®ã‚´ãƒ¼ãƒ«ãƒ‰ãŒä¸è¶³ã—ã¦ã„ã¾ã™"):format(player.Name))
			end
		end
	end)

	-- ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚¤ãƒ™ãƒ³ãƒˆ
	BattleDamageEvent.OnServerEvent:Connect(function(player, damageAmount)
		print(("[BattleSystem] ãƒ€ãƒ¡ãƒ¼ã‚¸é€šçŸ¥å—ä¿¡: %s -> %d"):format(player.Name, damageAmount))
		onDamageReceived(player, damageAmount)
	end)

	-- ã‚¿ã‚¤ãƒ—ãƒŸã‚¹ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆæ–°è¦è¿½åŠ ï¼‰
	TypingMistakeEvent.OnServerEvent:Connect(function(player)
		print(("[BattleSystem] ã‚¿ã‚¤ãƒ—ãƒŸã‚¹å—ä¿¡: %s"):format(player.Name))

		local battleData = ActiveBattles[player]
		if not battleData then
			warn(("[BattleSystem] %s ã¯ãƒãƒˆãƒ«ä¸­ã§ã¯ã‚ã‚Šã¾ã›ã‚“ï¼ˆã‚¿ã‚¤ãƒ—ãƒŸã‚¹ç„¡è¦–ï¼‰"):format(player.Name))
			return
		end

		local monsterDef = battleData.monsterDef
		local playerStats = PlayerStats.getStats(player)

		if not playerStats then
			warn(("[BattleSystem] %s ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"):format(player.Name))
			return
		end

		-- ã‚¿ã‚¤ãƒ—ãƒŸã‚¹ãƒ€ãƒ¡ãƒ¼ã‚¸ = æ•µã®é€šå¸¸æ”»æ’ƒã®åŠåˆ†
		local normalDamage = calculateDamage(monsterDef.Attack, playerStats.Defense)
		local mistakeDamage = math.floor(normalDamage * 0.5)
		mistakeDamage = math.max(1, mistakeDamage)  -- æœ€ä½1ãƒ€ãƒ¡ãƒ¼ã‚¸

		print(("[BattleSystem] %s ãŒã‚¿ã‚¤ãƒ—ãƒŸã‚¹ã§ %d ãƒ€ãƒ¡ãƒ¼ã‚¸"):format(player.Name, mistakeDamage))

		-- ãƒ€ãƒ¡ãƒ¼ã‚¸å‡¦ç†
		local isDead = PlayerStats.takeDamage(player, mistakeDamage)

		-- HPã‚’ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«é€šçŸ¥
		PlayerHPUpdateEvent:FireClient(player, playerStats.CurrentHP, playerStats.MaxHP)

		-- æ­»äº¡åˆ¤å®š
		if isDead then
			print(("[BattleSystem] %s ã¯ã‚¿ã‚¤ãƒ—ãƒŸã‚¹ã§å€’ã‚ŒãŸï¼"):format(player.Name))
			BattleSystem.endBattle(player, false)  -- æ•—åŒ—
		end
	end)

	-- å‹åˆ©ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆå¿µã®ãŸã‚æ®‹ã—ã¦ãŠãï¼‰

	-- ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯æ¤œå‡º
	task.spawn(function()
		while true do
			task.wait(5)

			for player, battleData in pairs(ActiveBattles) do
				local duration = tick() - battleData.startTime

				if duration > 60 then
					warn(("[BattleSystem] ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯æ¤œå‡ºï¼ %s ã®ãƒãƒˆãƒ«ã‚’å¼·åˆ¶çµ‚äº†"):format(player.Name))
					BattleSystem.endBattle(player, false)
				end
			end
		end
	end)

	print("[BattleSystem] åˆæœŸåŒ–å®Œäº†ï¼ˆæ•µæ”»æ’ƒã‚·ã‚¹ãƒ†ãƒ å¯¾å¿œï¼‰")
end

-- ãƒãƒˆãƒ«çŠ¶æ…‹ã‚’å¼·åˆ¶ãƒªã‚»ãƒƒãƒˆ
function BattleSystem.resetAllBattles()
	print("[BattleSystem] å…¨ãƒãƒˆãƒ«çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ")

	GlobalBattleActive = false

	for player, _ in pairs(ActiveBattles) do
		ActiveBattles[player] = nil
		EndingBattles[player] = nil

		if player.Character then
			player.Character:SetAttribute("InBattle", false)

			local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
			local hrp = player.Character:FindFirstChild("HumanoidRootPart")
			if humanoid then
				humanoid.WalkSpeed = 16
				humanoid.JumpPower = 50
				humanoid.JumpHeight = 7.2
			end
			if hrp then
				hrp.Anchored = false
			end
		end
	end

	local monstersFolder = workspace:FindFirstChild("Monsters")
	if monstersFolder then
		for _, model in ipairs(monstersFolder:GetChildren()) do
			if model:IsA("Model") then
				model:SetAttribute("InBattle", false)
				model:SetAttribute("Defeated", false)
			end
		end
	end

	for _, model in ipairs(workspace:GetChildren()) do
		if model:IsA("Model") and model:GetAttribute("IsEnemy") then
			model:SetAttribute("InBattle", false)
			model:SetAttribute("Defeated", false)
		end
	end

	print("[BattleSystem] ãƒªã‚»ãƒƒãƒˆå®Œäº†")
end

return BattleSystem
===== ./ServerScriptService/MonsterSpawner.server.lua =====
-- ServerScriptService/MonsterSpawner.server.lua
-- ã‚¾ãƒ¼ãƒ³å¯¾å¿œç‰ˆãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼é…ç½®ã‚·ã‚¹ãƒ†ãƒ ï¼ˆãƒãƒˆãƒ«é«˜é€ŸåŒ–ç‰ˆã€å¾˜å¾ŠAIä¿®æ­£ç‰ˆï¼‰

local ServerStorage = game:GetService("ServerStorage")
local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local FieldGen = require(ReplicatedStorage:WaitForChild("FieldGen"))
local ZoneManager = require(script.Parent.ZoneManager)

-- BattleSystemèª­è¾¼ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒŠãƒ«ï¼‰
local BattleSystem = nil
local battleSystemScript = script.Parent:FindFirstChild("BattleSystem")
if battleSystemScript then
	local success, result = pcall(function()
		return require(battleSystemScript)
	end)
	if success then
		BattleSystem = result
		print("[MonsterSpawner] BattleSystemèª­ã¿è¾¼ã¿æˆåŠŸ")
	else
		warn("[MonsterSpawner] BattleSystemèª­ã¿è¾¼ã¿å¤±æ•—:", result)
	end
else
	warn("[MonsterSpawner] BattleSystemãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ - ãƒãƒˆãƒ«æ©Ÿèƒ½ã¯ç„¡åŠ¹ã§ã™")
end

-- Registryèª­è¾¼
local MonstersFolder = ReplicatedStorage:WaitForChild("Monsters")
local Registry = require(MonstersFolder:WaitForChild("Registry"))

-- å³¶ã®è¨­å®šã‚’èª­ã¿è¾¼ã¿
local IslandsRegistry = require(ReplicatedStorage.Islands.Registry)
local Islands = {}
for _, island in ipairs(IslandsRegistry) do
	Islands[island.name] = island
end

-- ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
local ActiveMonsters = {}
local UpdateInterval = 0.05
local MonsterCounts = {}
local TemplateCache = {}
local RespawnQueue = {}

-- å®‰å…¨åœ°å¸¯ãƒã‚§ãƒƒã‚¯
local function isSafeZone(zoneName)
	local island = Islands[zoneName]
	if island and island.safeZone then
		return true
	end
	return false
end

-- ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°
local function resolveTemplate(pathArray: {string}): Model?
	local node: Instance = game
	for _, seg in ipairs(pathArray) do
		node = node:FindFirstChild(seg)
		if not node then return nil end
	end
	return (node and node:IsA("Model")) and node or nil
end

local function ensureHRP(model: Model): BasePart?
	local hrp = model:FindFirstChild("HumanoidRootPart")
	if hrp and hrp:IsA("BasePart") then
		if not model.PrimaryPart then model.PrimaryPart = hrp end
		return hrp
	end
	return nil
end

local function attachLabel(model: Model, maxDist: number)
	local hrp = model.PrimaryPart or model:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	local _, bboxSize = model:GetBoundingBox()
	local labelOffset = math.min(bboxSize.Y * 0.5 + 2, 15)

	local gui = Instance.new("BillboardGui")
	gui.Name = "DebugInfo"
	gui.Adornee = hrp
	gui.AlwaysOnTop = true
	gui.Size = UDim2.new(0, 150, 0, 50)
	gui.StudsOffset = Vector3.new(0, labelOffset, 0)
	gui.MaxDistance = maxDist
	gui.Parent = hrp

	local lb = Instance.new("TextLabel")
	lb.Name = "InfoText"
	lb.BackgroundTransparency = 1
	lb.TextScaled = true
	lb.Font = Enum.Font.GothamBold
	lb.TextColor3 = Color3.new(1, 1, 1)
	lb.TextStrokeTransparency = 0.5
	lb.Size = UDim2.fromScale(1, 1)
	lb.Text = "Ready"
	lb.Parent = gui
end

local function placeOnGround(model: Model, x: number, z: number)
	local hrp = model.PrimaryPart or model:FindFirstChild("HumanoidRootPart")
	if not hrp then
		warn("[MonsterSpawner] HumanoidRootPart ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: " .. model.Name)
		return
	end

	local groundY = FieldGen.raycastGroundY(x, z, 100)
		or FieldGen.raycastGroundY(x, z, 200)
		or FieldGen.raycastGroundY(x, z, 50)
		or 10

	local _, yaw = hrp.CFrame:ToOrientation()
	model:PivotTo(CFrame.new(x, groundY + 20, z) * CFrame.Angles(0, yaw, 0))

	local bboxCFrame, bboxSize = model:GetBoundingBox()
	local bottomY = bboxCFrame.Position.Y - (bboxSize.Y * 0.5)
	local offset = hrp.Position.Y - bottomY

	model:PivotTo(CFrame.new(x, groundY + offset, z) * CFrame.Angles(0, yaw, 0))
end

local function nearestPlayer(position: Vector3)
	local best, bestDist = nil, math.huge
	for _, pl in ipairs(Players:GetPlayers()) do
		local ch = pl.Character
		local hrp = ch and ch:FindFirstChild("HumanoidRootPart")
		if hrp then
			local d = (position - hrp.Position).Magnitude
			if d < bestDist then
				best, bestDist = pl, d
			end
		end
	end
	return best, bestDist
end

-- AIçŠ¶æ…‹ç®¡ç†ï¼ˆé«˜é€ŸåŒ–ç‰ˆï¼‰
local AIState = {}
AIState.__index = AIState

function AIState.new(monster, def)
	local self = setmetatable({}, AIState)
	self.monster = monster
	self.def = def
	self.humanoid = monster:FindFirstChildOfClass("Humanoid")
	self.root = monster.PrimaryPart
	self.courage = math.random()
	self.brave = (self.courage > 0.5)
	self.wanderGoal = nil
	self.nextWanderAt = 0
	self.lastUpdateTime = 0
	self.lastDistanceLog = 0
	self.updateRate = def.AiTickRate or 0.3
	self.nearUpdateRate = 0.05  -- 0.2 â†’ 0.05ç§’ã«é«˜é€ŸåŒ–ï¼ˆãƒãƒˆãƒ«åˆ¤å®šãŒé€Ÿããªã‚‹ï¼‰
	self.farUpdateRate = 0.5    -- 1.0 â†’ 0.5ç§’ã«é«˜é€ŸåŒ–

	self.originalSpeed = self.humanoid.WalkSpeed
	self.wasInBattle = false

    -- ã€ä¿®æ­£ç‚¹1ã€‘å¾˜å¾Šã‚¹ãƒ†ãƒ¼ãƒˆç®¡ç†ã‚’è¿½åŠ 
    self.isWaiting = false  -- å¾…æ©ŸçŠ¶æ…‹ã‹ (åœæ­¢çŠ¶æ…‹)
    self.waitEndTime = 0    -- å¾…æ©Ÿçµ‚äº†æ™‚åˆ»
    -- ã€ä¿®æ­£ç‚¹1 çµ‚ã‚ã‚Šã€‘

	return self
end

function AIState:shouldUpdate(currentTime)
	local _, dist = nearestPlayer(self.root.Position)
	-- è¿‘è·é›¢åˆ¤å®šã‚’150ã‚¹ã‚¿ãƒƒãƒ‰ã«æ‹¡å¤§ï¼ˆãƒãƒˆãƒ«åˆ¤å®šã‚’ã‚ˆã‚Šé »ç¹ã«ï¼‰
	local rate = dist < 150 and self.nearUpdateRate or self.farUpdateRate
	return (currentTime - self.lastUpdateTime) >= rate
end

function AIState:update()
	if not self.monster.Parent or not self.humanoid or not self.root then
		return false
	end

	if self.monster:GetAttribute("Defeated") then
		if not self.loggedDefeated then
			-- print(("[AI DEBUG] %s - DefeatedçŠ¶æ…‹ã®ãŸã‚ã‚¹ã‚­ãƒƒãƒ—"):format(self.monster.Name))
			self.loggedDefeated = true
		end
		return false
	end

	-- ãƒãƒˆãƒ«çŠ¶æ…‹ã‚’ç¢ºèª
	local isGlobalBattle = BattleSystem and BattleSystem.isAnyBattleActive and BattleSystem.isAnyBattleActive()
	local isThisMonsterInBattle = self.monster:GetAttribute("InBattle")
	local isAnyBattle = isGlobalBattle or isThisMonsterInBattle

	-- ã„ãšã‚Œã‹ã®ãƒãƒˆãƒ«ãŒé€²è¡Œä¸­ãªã‚‰åœæ­¢
	if isAnyBattle then
		self.humanoid.WalkSpeed = 0
		self.humanoid:MoveTo(self.root.Position)
		self.wasInBattle = true
		return true
	end

	-- ãƒãƒˆãƒ«ãŒçµ‚äº†ã—ãŸã‚‰é€Ÿåº¦ã‚’å¾©å…ƒ
	if self.wasInBattle and not isAnyBattle then
		-- print(("[AI DEBUG] %s - ãƒãƒˆãƒ«çµ‚äº†ã€é€Ÿåº¦å¾©å…ƒ: %.1f"):format(self.monster.Name, self.originalSpeed))
		self.humanoid.WalkSpeed = self.originalSpeed
		self.wasInBattle = false
		self.loggedDefeated = false
	end

	local p, dist = nearestPlayer(self.root.Position)
	local chaseRange = self.def.ChaseDistance or 60
	local now = os.clock()

	-- ãƒãƒˆãƒ«åˆ¤å®šï¼ˆé«˜é€ŸåŒ–ãƒ»è·é›¢æ‹¡å¤§ï¼‰
	if BattleSystem and p and dist <= 7 then  -- 5 â†’ 7ã‚¹ã‚¿ãƒƒãƒ‰ã«æ‹¡å¤§
		-- print(("[AI DEBUG] %s - æ¥è§¦æ¤œå‡ºï¼è·é›¢=%.1f"):format(self.monster.Name, dist))

		if BattleSystem.isInBattle(p) then
			self.humanoid:MoveTo(self.root.Position)
			return true
		end

		if BattleSystem.isAnyBattleActive and BattleSystem.isAnyBattleActive() then
			self.humanoid:MoveTo(self.root.Position)
			return true
		end

		if self.monster:GetAttribute("InBattle") then
			return true
		end

		local character = p.Character
		if character then
			-- ã€é‡è¦ã€‘å³åº§ã«ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’åœæ­¢ï¼ˆãƒãƒˆãƒ«é–‹å§‹å‰ï¼‰
			local playerHumanoid = character:FindFirstChildOfClass("Humanoid")
			local playerHrp = character:FindFirstChild("HumanoidRootPart")

			if playerHumanoid and playerHrp then
				-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å³åº§ã«åœæ­¢
				playerHumanoid.WalkSpeed = 0
				playerHumanoid.JumpPower = 0
				playerHrp.Anchored = true
			end

			self.monster:SetAttribute("InBattle", true)
			self.humanoid.WalkSpeed = 0
			self.humanoid:MoveTo(self.root.Position)

			-- task.wait(0.1) ã‚’å‰Šé™¤ã—ã¦å³åº§ã«ãƒãƒˆãƒ«é–‹å§‹

			local battleStarted = BattleSystem.startBattle(p, self.monster)
			-- print(("[AI DEBUG] ãƒãƒˆãƒ«é–‹å§‹çµæœ: %s"):format(tostring(battleStarted)))

			if not battleStarted then
				-- ãƒãƒˆãƒ«é–‹å§‹å¤±æ•—æ™‚ã¯ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚‚è§£æ”¾
				self.monster:SetAttribute("InBattle", false)
				self.humanoid.WalkSpeed = self.originalSpeed

				if playerHumanoid and playerHrp then
					playerHumanoid.WalkSpeed = 16
					playerHumanoid.JumpPower = 50
					playerHrp.Anchored = false
				end
			end

			return true
		else
			self.monster:SetAttribute("InBattle", false)
		end
	end

	-- æµ·ãƒã‚§ãƒƒã‚¯
	local isInWater = self.root.Position.Y < 0 or self.humanoid:GetState() == Enum.HumanoidStateType.Swimming

	-- ãƒ©ãƒ™ãƒ«æ›´æ–°
	local label = self.root:FindFirstChild("DebugInfo")
		and self.root.DebugInfo:FindFirstChild("InfoText")
	if label then
		local behavior = self.brave and "CHASE" or "FLEE"
		label.Text = string.format("%s\n%s | %.1fm", self.monster.Name, behavior, dist or 999)
	end

	local gui = self.root:FindFirstChild("DebugInfo")
	if gui then
		gui.Enabled = not isInWater
	end

    -- ã€ä¿®æ­£ç‚¹2ã€‘å¾˜å¾Šãƒ­ã‚¸ãƒƒã‚¯ã‚’ãƒ­ãƒ¼ã‚«ãƒ«é–¢æ•°ã¨ã—ã¦å®šç¾©
    local function wanderLogic()
        local w = self.def.Wander or {}
        -- Defã«è¨­å®šãŒãªã‘ã‚Œã°ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’ä½¿ç”¨
        local minWait = w.MinWait or 2
        local maxWait = w.MaxWait or 5
        local minRadius = w.MinRadius or 20
        local maxRadius = w.MaxRadius or 60

        -- ç›®æ¨™åˆ°é”åˆ¤å®šï¼š5ã‚¹ã‚¿ãƒƒãƒ‰ä»¥å†…
        local isGoalReached = self.wanderGoal and (self.root.Position - self.wanderGoal).Magnitude < 5
        local isWaitFinished = self.isWaiting and now >= self.waitEndTime

        if self.isWaiting then
            -- ã‚¹ãƒ†ãƒ¼ãƒˆ: å¾…æ©Ÿä¸­ï¼ˆåœæ­¢ï¼‰
            self.humanoid:MoveTo(self.root.Position) -- åœæ­¢ã‚’ç¶­æŒ

            if isWaitFinished then
                -- print(("[AI DEBUG] %s - å¾…æ©Ÿçµ‚äº†ã€‚æ¬¡ã®ç›®æ¨™è¨­å®šã€‚"):format(self.monster.Name))
                self.isWaiting = false
                self.wanderGoal = nil -- ç›®æ¨™ã‚’ãƒªã‚»ãƒƒãƒˆã—ã€æ¬¡ã®ãƒ–ãƒ­ãƒƒã‚¯ã§æ–°ã—ã„ç›®æ¨™ã‚’è¨­å®š
                self.nextWanderAt = 0 -- å³åº§ã«æ–°ã—ã„ç›®æ¨™ã‚’è¨­å®š
            end
        elseif isGoalReached or now >= self.nextWanderAt or not self.wanderGoal then
            -- ã‚¹ãƒ†ãƒ¼ãƒˆ: ç§»å‹•å®Œäº†/ç›®æ¨™ãŒå¤ã„/ç›®æ¨™ãªã—

            if isGoalReached then
                -- ç›®æ¨™ã«åˆ°é”ã—ãŸã‚‰å¾…æ©Ÿãƒ¢ãƒ¼ãƒ‰ã«ç§»è¡Œ
                -- print(("[AI DEBUG] %s - ç›®æ¨™åˆ°é”ã€‚å¾…æ©Ÿé–‹å§‹ã€‚"):format(self.monster.Name))
                self.isWaiting = true
                -- å¾…æ©Ÿæ™‚é–“ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«è¨­å®šï¼ˆå°æ•°ç‚¹ä»¥ä¸‹ã‚’è¨±å®¹ã™ã‚‹ãŸã‚ * 10 ã—ã¦ã‹ã‚‰ / 10ï¼‰
                self.waitEndTime = now + math.random(minWait * 10, maxWait * 10) / 10
                self.humanoid:MoveTo(self.root.Position) -- åœæ­¢
                return
            end

            -- ç›®æ¨™ãŒå¤ã„ã€ã¾ãŸã¯ç„¡ã‘ã‚Œã°æ–°ã—ã„ç›®æ¨™ã‚’è¨­å®š
            local ang = math.random() * math.pi * 2
            local rad = math.random(minRadius, maxRadius)
            local gx = self.root.Position.X + math.cos(ang) * rad
            local gz = self.root.Position.Z + math.sin(ang) * rad

            local gy = FieldGen.raycastGroundY(gx, gz, 100) or self.root.Position.Y

            self.wanderGoal = Vector3.new(gx, gy, gz)

            -- ç§»å‹•ä¸­ã¯ç›®æ¨™ã‚’ç´„10ç§’é–“å¤‰æ›´ã—ãªã„ï¼ˆç§»å‹•ä¸­ã®ã€Œã¡ã‚‡ã“ã¾ã‹ã€ã‚’é˜²ãï¼‰
            self.nextWanderAt = now + 10

            -- print(("[AI DEBUG] %s - æ–°ç›®æ¨™è¨­å®šã€‚ç§»å‹•é–‹å§‹ã€‚"):format(self.monster.Name))
            self.humanoid:MoveTo(self.wanderGoal)

        else
            -- ã‚¹ãƒ†ãƒ¼ãƒˆ: ç§»å‹•ä¸­ï¼ˆç¶™ç¶šï¼‰
            self.humanoid:MoveTo(self.wanderGoal)
        end
    end
    -- ã€ä¿®æ­£ç‚¹2 çµ‚ã‚ã‚Šã€‘

	-- è¡Œå‹•æ±ºå®š
	if not p then
		-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒã„ãªã„ï¼šå¾˜å¾Šã®ã¿
		self.wanderGoal = nil -- è¿½è·¡ç›®æ¨™ã‚’ãƒªã‚»ãƒƒãƒˆ
        self.isWaiting = false -- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒã„ãªã„å ´åˆã€è¿½è·¡ç›®æ¨™ãŒãªã„ãŸã‚å¾…æ©Ÿã‚’è§£é™¤ã—ã¦æ–°ã—ã„å¾˜å¾Šã‚’é–‹å§‹
		wanderLogic()
	elseif dist < chaseRange then
		-- è¿½è·¡ or é€ƒèµ°
		self.wanderGoal = nil
        self.isWaiting = false -- è¿½è·¡ä¸­ã¯å¾…æ©Ÿã‚’å¼·åˆ¶è§£é™¤
		if self.brave then
			self.humanoid:MoveTo(p.Character.HumanoidRootPart.Position)
		else
			local away = (self.root.Position - p.Character.HumanoidRootPart.Position).Unit
			self.humanoid:MoveTo(self.root.Position + away * 80)
		end
	else
		-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒé ã„ï¼šå¾˜å¾Š
		wanderLogic()
	end

	self.lastUpdateTime = now
	return true
end

-- ã‚¹ãƒãƒ¼ãƒ³å‡¦ç†ï¼ˆå³¶æŒ‡å®šç‰ˆï¼‰
local function spawnMonster(template: Model, index: number, def, islandName)
	local m = template:Clone()
	m.Name = (def.Name or template.Name) .. "_" .. index

	local hum = m:FindFirstChildOfClass("Humanoid")
	local hrp = ensureHRP(m)

	if not hum or not hrp then
		warn("[MonsterSpawner] Humanoid ã¾ãŸã¯ HRP ãŒã‚ã‚Šã¾ã›ã‚“: " .. m.Name)
		m:Destroy()
		return
	end

	m:SetAttribute("IsEnemy", true)
	m:SetAttribute("MonsterKind", def.Name or "Monster")
	m:SetAttribute("ChaseDistance", def.ChaseDistance or 60)
	m:SetAttribute("SpawnZone", islandName)
	m:SetAttribute("SpawnIsland", islandName)

	local speedMin = def.SpeedMin or 0.7
	local speedMax = def.SpeedMax or 1.3
	local speedMult = speedMin + math.random() * (speedMax - speedMin)
	hum.WalkSpeed = (def.WalkSpeed or 14) * speedMult
	hum.HipHeight = 0

	hrp.Anchored = true
	hrp.CanCollide = false
	hrp.Transparency = 1

	for _, descendant in ipairs(m:GetDescendants()) do
		if descendant:IsA("BasePart") and descendant ~= hrp then
			descendant.CanCollide = true
			descendant.Anchored = false

			for _, child in ipairs(descendant:GetChildren()) do
				if child:IsA("WeldConstraint") or child:IsA("Weld") then
					child:Destroy()
				end
			end

			local weld = Instance.new("WeldConstraint")
			weld.Part0 = hrp
			weld.Part1 = descendant
			weld.Parent = descendant
		end
	end

	m.Parent = Workspace

	local island = Islands[islandName]
	if not island then
		warn(("[MonsterSpawner] å³¶ '%s' ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"):format(islandName))
		m:Destroy()
		return
	end

	local spawnRadius
	if def.radiusPercent then
		spawnRadius = (island.sizeXZ / 2) * (def.radiusPercent / 100)
	else
		spawnRadius = def.spawnRadius or 50
	end

	local rx = island.centerX + math.random(-spawnRadius, spawnRadius)
	local rz = island.centerZ + math.random(-spawnRadius, spawnRadius)

	placeOnGround(m, rx, rz)
	-- attachLabel(m, def.LabelMaxDistance or 250)

	task.wait(0.05)
	hrp.Anchored = false

	local aiState = AIState.new(m, def)
	table.insert(ActiveMonsters, aiState)

	local monsterName = def.Name or "Monster"
	if not MonsterCounts[islandName] then
		MonsterCounts[islandName] = {}
	end
	MonsterCounts[islandName][monsterName] = (MonsterCounts[islandName][monsterName] or 0) + 1

	-- print(("[MonsterSpawner] %s ã‚’ %s ã«ã‚¹ãƒãƒ¼ãƒ³"):format(m.Name, islandName))
end

-- ã‚¾ãƒ¼ãƒ³ã«ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’ã‚¹ãƒãƒ¼ãƒ³ã™ã‚‹ï¼ˆå¤§é™¸å¯¾å¿œç‰ˆï¼‰
function spawnMonstersForZone(zoneName)
	if isSafeZone(zoneName) then
		print(("[MonsterSpawner] %s ã¯å®‰å…¨åœ°å¸¯ã§ã™ã€‚ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’ã‚¹ãƒãƒ¼ãƒ³ã—ã¾ã›ã‚“"):format(zoneName))
		return
	end

	print(("[MonsterSpawner] %s ã«ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’é…ç½®ä¸­..."):format(zoneName))

	local islandsInZone = {}

	local ContinentsRegistry = require(ReplicatedStorage.Continents.Registry)
	local Continents = {}
	for _, continent in ipairs(ContinentsRegistry) do
		Continents[continent.name] = continent
	end

	if Continents[zoneName] then
		local continent = Continents[zoneName]
		for _, islandName in ipairs(continent.islands) do
			islandsInZone[islandName] = true
		end
		print(("[MonsterSpawner] å¤§é™¸ %s ã®å³¶: %s"):format(zoneName, table.concat(continent.islands, ", ")))
	else
		islandsInZone[zoneName] = true
	end

	for _, def in ipairs(Registry) do
		local monsterName = def.Name or "Monster"
		local template = TemplateCache[monsterName]

		if template then
			if def.SpawnLocations then
				for _, location in ipairs(def.SpawnLocations) do
					local islandName = location.islandName

					if islandsInZone[islandName] then
						local radiusText = location.radiusPercent or 100
						print(("[MonsterSpawner] %s ã‚’ %s ã«é…ç½®ä¸­ (æ•°: %d, ç¯„å›²: %d%%)"):format(
							monsterName, islandName, location.count, radiusText
							))

						if not MonsterCounts[islandName] then
							MonsterCounts[islandName] = {}
						end
						MonsterCounts[islandName][monsterName] = 0

						for i = 1, (location.count or 0) do
							local spawnDef = {}
							for k, v in pairs(def) do
								spawnDef[k] = v
							end
							spawnDef.radiusPercent = location.radiusPercent
							spawnDef.spawnRadius = location.spawnRadius

							spawnMonster(template, i, spawnDef, islandName)
							if i % 5 == 0 then task.wait() end
						end
					end
				end
			else
				warn(("[MonsterSpawner] %s ã¯æ—§å½¢å¼ã§ã™ã€‚SpawnLocationså½¢å¼ã«ç§»è¡Œã—ã¦ãã ã•ã„"):format(monsterName))
			end
		end
	end
end

-- ãƒªã‚¹ãƒãƒ¼ãƒ³å‡¦ç†ï¼ˆå³¶å¯¾å¿œç‰ˆï¼‰
local function scheduleRespawn(monsterName, def, islandName)
	local respawnTime = def.RespawnTime or 10
	if respawnTime <= 0 then return end

	local respawnData = {
		monsterName = monsterName,
		def = def,
		islandName = islandName,
		respawnAt = os.clock() + respawnTime
	}
	table.insert(RespawnQueue, respawnData)
end

local function processRespawnQueue()
	task.spawn(function()
		while true do
			local now = os.clock()

			for i = #RespawnQueue, 1, -1 do
				local data = RespawnQueue[i]
				if now >= data.respawnAt then
					local isActive = false
					for zoneName, _ in pairs(ZoneManager.ActiveZones) do
						isActive = true
						break
					end

					if isActive then
						local template = TemplateCache[data.monsterName]
						if template and MonsterCounts[data.islandName] then
							local nextIndex = (MonsterCounts[data.islandName][data.monsterName] or 0) + 1
							spawnMonster(template, nextIndex, data.def, data.islandName)
							-- print(("[MonsterSpawner] %s ãŒ %s ã«ãƒªã‚¹ãƒãƒ¼ãƒ³"):format(data.monsterName, data.islandName))
						end
					end
					table.remove(RespawnQueue, i)
				end
			end

			task.wait(1)
		end
	end)
end

-- AIæ›´æ–°ãƒ«ãƒ¼ãƒ—ï¼ˆé«˜é€ŸåŒ–ï¼‰
local function startGlobalAILoop()
	print("[MonsterSpawner] AIæ›´æ–°ãƒ«ãƒ¼ãƒ—é–‹å§‹ï¼ˆé«˜é€ŸåŒ–ç‰ˆï¼‰")

	task.spawn(function()
		while true do
			if #ActiveMonsters > 0 then
				local currentTime = os.clock()

				for i = #ActiveMonsters, 1, -1 do
					local state = ActiveMonsters[i]

					if state:shouldUpdate(currentTime) then
						local success, result = pcall(function()
							return state:update()
						end)

						if not success then
							warn(("[MonsterSpawner ERROR] AIæ›´æ–°ã‚¨ãƒ©ãƒ¼: %s - %s"):format(
								state.monster.Name, tostring(result)
								))
						elseif not result then
							local monsterDef = state.def
							local monsterName = monsterDef.Name or "Unknown"
							local zoneName = state.monster:GetAttribute("SpawnZone") or "Unknown"

							if MonsterCounts[zoneName] and MonsterCounts[zoneName][monsterName] then
								MonsterCounts[zoneName][monsterName] = MonsterCounts[zoneName][monsterName] - 1
							end

							table.remove(ActiveMonsters, i)
							scheduleRespawn(monsterName, monsterDef, zoneName)
						end
					end
				end
			end

			task.wait(UpdateInterval)
		end
	end)
end

-- ã‚¾ãƒ¼ãƒ³ã®ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’å‰Šé™¤ã™ã‚‹
function despawnMonstersForZone(zoneName)
	print(("[MonsterSpawner] %s ã®ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’å‰Šé™¤ä¸­..."):format(zoneName))

	local removedCount = 0

	for i = #ActiveMonsters, 1, -1 do
		local state = ActiveMonsters[i]
		local monsterZone = state.monster:GetAttribute("SpawnZone")

		if monsterZone == zoneName then
			state.monster:Destroy()
			table.remove(ActiveMonsters, i)
			removedCount = removedCount + 1
		end
	end

	for i = #RespawnQueue, 1, -1 do
		if RespawnQueue[i].zoneName == zoneName then
			table.remove(RespawnQueue, i)
		end
	end

	MonsterCounts[zoneName] = nil

	print(("[MonsterSpawner] %s ã®ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’ %dä½“ å‰Šé™¤ã—ã¾ã—ãŸ"):format(zoneName, removedCount))
end

-- åˆæœŸåŒ–
print("[MonsterSpawner] === ã‚¹ã‚¯ãƒªãƒ—ãƒˆé–‹å§‹ï¼ˆãƒãƒˆãƒ«é«˜é€ŸåŒ–ç‰ˆï¼‰===")

if BattleSystem then
	BattleSystem.init()
	print("[MonsterSpawner] BattleSystemåˆæœŸåŒ–å®Œäº†")
else
	print("[MonsterSpawner] BattleSystemãªã—ã§èµ·å‹•")
end

Workspace:WaitForChild("World", 10)
print("[MonsterSpawner] World ãƒ•ã‚©ãƒ«ãƒ€æ¤œå‡º")

task.wait(1)

print("[MonsterSpawner] ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥ä¸­...")
for _, def in ipairs(Registry) do
	local template = resolveTemplate(def.TemplatePath)
	if template then
		local monsterName = def.Name or "Monster"
		TemplateCache[monsterName] = template
		print(("[MonsterSpawner] ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚­ãƒ£ãƒƒã‚·ãƒ¥: %s"):format(monsterName))
	else
		warn(("[MonsterSpawner] ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆæœªç™ºè¦‹: %s"):format(def.Name or "?"))
	end
end

startGlobalAILoop()
processRespawnQueue()

print("[MonsterSpawner] === åˆæœŸåŒ–å®Œäº†ï¼ˆãƒãƒˆãƒ«å³åº§é–‹å§‹å¯¾å¿œï¼‰===")

_G.SpawnMonstersForZone = spawnMonstersForZone
_G.DespawnMonstersForZone = despawnMonstersForZone
===== ./ServerScriptService/TowerPlacement.server.lua =====
-- ServerScriptService/TowerPlacement.server.lua
-- StartTownã«ã‚¿ãƒ¯ãƒ¼ã‚’é…ç½®

local ServerStorage = game:GetService("ServerStorage")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

print("[TowerPlacement] ã‚¿ãƒ¯ãƒ¼é…ç½®é–‹å§‹")

-- StartTownã®è¨­å®šã‚’å–å¾—
local IslandsRegistry = require(ReplicatedStorage.Islands.Registry)
local townConfig = nil
for _, island in ipairs(IslandsRegistry) do
	if island.name == "StartTown" then
		townConfig = island
		break
	end
end

if not townConfig then
	warn("[TowerPlacement] StartTownã®è¨­å®šãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
	return
end

-- é…ç½®ä½ç½®ï¼ˆStartTownã®ä¸­å¿ƒã‹ã‚‰æ±ã«50ã‚¹ã‚¿ãƒƒãƒ‰ï¼‰
local TOWER_OFFSET_X = 300
local TOWER_OFFSET_Z = 0

-- åœ°å½¢ç”Ÿæˆã‚’å¾…ã¤
task.wait(3)

-- ServerStorage/Buildingsã‹ã‚‰ã‚¿ãƒ¯ãƒ¼ã®ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’å–å¾—
local buildingsFolder = ServerStorage:FindFirstChild("Buildings")
if not buildingsFolder then
	warn("[TowerPlacement] ServerStorage ã« 'Buildings' ãƒ•ã‚©ãƒ«ãƒ€ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
	return
end

local towerTemplate = buildingsFolder:FindFirstChild("Tower")
if not towerTemplate then
	warn("[TowerPlacement] ServerStorage/Buildings ã« 'Tower' ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
	warn("[TowerPlacement] Toolboxã‹ã‚‰ Asset ID 12127172596 ã‚’ ServerStorage/Buildings ã«é…ç½®ã—ã¦ãã ã•ã„")
	return
end

-- ã‚¿ãƒ¯ãƒ¼ã‚’è¤‡è£½
local tower = towerTemplate:Clone()
tower.Parent = workspace

print("[TowerPlacement] ã‚¿ãƒ¯ãƒ¼ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ:", tower.Name)

-- é…ç½®ä½ç½®ã‚’è¨ˆç®—
local towerX = townConfig.centerX + TOWER_OFFSET_X
local towerZ = townConfig.centerZ + TOWER_OFFSET_Z

-- åœ°é¢ã®é«˜ã•ã‚’å–å¾—
local FieldGen = require(ReplicatedStorage:WaitForChild("FieldGen"))
local groundY = FieldGen.raycastGroundY(towerX, towerZ, townConfig.baseY + 100)

if not groundY then
	-- ãƒ¬ã‚¤ã‚­ãƒ£ã‚¹ãƒˆãŒå¤±æ•—ã—ãŸå ´åˆã¯æ¨å®šé«˜åº¦ã‚’ä½¿ç”¨
	groundY = townConfig.baseY + 5
	warn("[TowerPlacement] åœ°é¢æ¤œå‡ºå¤±æ•—ã€æ¨å®šé«˜åº¦ã‚’ä½¿ç”¨:", groundY)
end

-- ã‚¿ãƒ¯ãƒ¼ã®åº•é¢ã‚’åœ°é¢ã«åˆã‚ã›ã‚‹
if tower:IsA("Model") then
	-- Modelã®å ´åˆï¼šæœ€ä¸‹ç‚¹ã‚’åœ°é¢ã«åˆã‚ã›ã‚‹
	local primaryPart = tower.PrimaryPart
	if not primaryPart then
		for _, part in ipairs(tower:GetDescendants()) do
			if part:IsA("BasePart") then
				tower.PrimaryPart = part
				primaryPart = part
				print("[TowerPlacement] PrimaryPartã‚’è‡ªå‹•è¨­å®š:", part.Name)
				break
			end
		end
	end

	if primaryPart then
		-- ã¾ãšç›®æ¨™ä½ç½®ã«é…ç½®
		tower:SetPrimaryPartCFrame(CFrame.new(towerX, groundY, towerZ))

		-- æœ€ä¸‹ç‚¹ã‚’æ¢ã™
		local lowestY = math.huge
		local lowestPartName = ""
		for _, part in ipairs(tower:GetDescendants()) do
			if part:IsA("BasePart") then
				local partBottom = part.Position.Y - (part.Size.Y / 2)
				if partBottom < lowestY then
					lowestY = partBottom
					lowestPartName = part.Name
				end
			end
		end

		print(("[TowerPlacement] ãƒ‡ãƒãƒƒã‚°æƒ…å ±:"):format())
		print(("  åœ°é¢ã®é«˜ã• (groundY): %.1f"):format(groundY))
		print(("  æœ€ä¸‹ç‚¹ãƒ‘ãƒ¼ãƒ„: %s"):format(lowestPartName))
		print(("  æœ€ä¸‹ç‚¹ã®é«˜ã• (é…ç½®å‰): %.1f"):format(lowestY))

		-- æœ€ä¸‹ç‚¹ãŒåœ°é¢ã«ãªã‚‹ã‚ˆã†èª¿æ•´
		local adjustment = groundY - lowestY
		local currentCFrame = tower:GetPrimaryPartCFrame()
		tower:SetPrimaryPartCFrame(currentCFrame + Vector3.new(0, adjustment, 0))

		-- èª¿æ•´å¾Œã®æœ€ä¸‹ç‚¹ã‚’ç¢ºèª
		local newLowestY = math.huge
		for _, part in ipairs(tower:GetDescendants()) do
			if part:IsA("BasePart") then
				local partBottom = part.Position.Y - (part.Size.Y / 2)
				if partBottom < newLowestY then
					newLowestY = partBottom
				end
			end
		end

		local _, size = tower:GetBoundingBox()
		print("[TowerPlacement] ã‚¿ãƒ¯ãƒ¼ã‚’é…ç½®ã—ã¾ã—ãŸ (Model):")
		print(("  ä½ç½®: X=%.1f, Y=%.1f, Z=%.1f"):format(towerX, groundY, towerZ))
		print(("  ã‚µã‚¤ã‚º: %.1f x %.1f x %.1f"):format(size.X, size.Y, size.Z))
		print(("  èª¿æ•´: %.1f ã‚¹ã‚¿ãƒƒãƒ‰ä¸Šã«ç§»å‹•"):format(adjustment))
		print(("  èª¿æ•´å¾Œã®æœ€ä¸‹ç‚¹: %.1f (ç›®æ¨™: %.1f)"):format(newLowestY, groundY))
	else
		local cf, size = tower:GetBoundingBox()
		local lowestY = cf.Position.Y - (size.Y / 2)
		local adjustment = groundY - lowestY
		tower:PivotTo(CFrame.new(towerX, groundY + adjustment, towerZ))
		print("[TowerPlacement] PivotToã§é…ç½®ã—ã¾ã—ãŸ:")
		print(("  ä½ç½®: X=%.1f, Y=%.1f, Z=%.1f"):format(towerX, groundY, towerZ))
	end
elseif tower:IsA("BasePart") then
	-- MeshPartãªã©å˜ä¸€ãƒ‘ãƒ¼ãƒ„ã®å ´åˆ
	local size = tower.Size
	local offsetY = size.Y / 2
	tower.CFrame = CFrame.new(towerX, groundY + offsetY, towerZ)
	print("[TowerPlacement] ã‚¿ãƒ¯ãƒ¼ã‚’é…ç½®ã—ã¾ã—ãŸ (BasePart):")
	print(("  ä½ç½®: X=%.1f, Y=%.1f, Z=%.1f"):format(towerX, groundY + offsetY, towerZ))
	print(("  ã‚µã‚¤ã‚º: %.1f x %.1f x %.1f"):format(size.X, size.Y, size.Z))
else
	warn("[TowerPlacement] æœªå¯¾å¿œã®å‹:", tower.ClassName)
	return
end

-- ã‚¿ãƒ¯ãƒ¼ã‚’å›ºå®š
for _, part in ipairs(tower:GetDescendants()) do
	if part:IsA("BasePart") then
		part.Anchored = true
	end
end

print("[TowerPlacement] é…ç½®å®Œäº†")
===== ./ReplicatedStorage/Continents/Registry.lua =====
-- ReplicatedStorage/Continents/Registry.lua
local RS = game:GetService("ReplicatedStorage")
local ContinentsFolder = RS:WaitForChild("Continents")

return {
    -- require(ContinentsFolder.Town),             -- ã€å‰Šé™¤ã€‘Townå¤§é™¸ã®å‚ç…§
    require(ContinentsFolder.ContinentHokkaido),
}
===== ./ReplicatedStorage/Continents/ContinentHokkaido.lua =====
return {
	name = "ContinentHokkaido",
	displayName = "Hokkaido Continent",

	islands = {
		"Hokkaido_W1", "Hokkaido_C1", "Hokkaido_C2", "Hokkaido_C3",
		"Hokkaido_C4", "Hokkaido_C5", "Hokkaido_E1",
		"Hokkaido_N1", "Hokkaido_N2", "Hokkaido_N3", "Hokkaido_N4",
		"Hokkaido_NE1", "Hokkaido_NE2",
		"Hokkaido_S1", "Hokkaido_S2",
		"Hokkaido_SW1", "Hokkaido_SW2",
	},

	bridges = {},

ports = {
        {
            name = "Hokkaido_to_Town",
            toZone = "StartTown",
            islandName = "Hokkaido_C3",
            offsetX = 0,
            offsetZ = 0,
            label = "â†’ Town",
            color = Color3.fromRGB(255, 200, 100),
        },
    },

	BGM = "rbxassetid://115666507179769",  -- å¾Œã§ã‚¢ã‚»ãƒƒãƒˆIDã«å¤‰æ›´
	BGMVolume = 0.2,  -- éŸ³é‡ï¼ˆ0.0-1.0ï¼‰
}
===== ./ReplicatedStorage/Continents/ContientTown.lua =====
return {
	name = "ContinentTown",
	displayName = "Start Town",

	-- StartTownã‚’ã“ã®å¤§é™¸ã®å”¯ä¸€ã®å³¶ã¨ã—ã¦å«ã‚ã‚‹
	islands = {
		"StartTown",
	},

	bridges = {},

	-- ä»–ã®å¤§é™¸ã¸ã®ãƒãƒ¼ã‚¿ãƒ«ã¯StartTownå³¶ã«é…ç½®ã•ã‚Œã‚‹
	portals = {
		-- Town_to_Hokkaidoãƒãƒ¼ã‚¿ãƒ«ã¯WarpPortal.server.luaã§ç›´æ¥ä½œæˆã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€
		-- ã“ã“ã«ã¯ç”ºã®å¤–ã‹ã‚‰ç”ºã«æˆ»ã‚‹ãƒãƒ¼ã‚¿ãƒ«ã®ã¿ã‚’å®šç¾©ã—ã¾ã™ã€‚
	},

	BGM = "rbxassetid://15666507179769",  -- é©å½“ãªBGM ID
	BGMVolume = 0.4,
}
===== ./ReplicatedStorage/Islands/Bridges.lua =====
return {
	{
		name = "Bridge_Start_to_Forest",
		fromIsland = 1,
		toIsland = 2,
		width = 15,  -- 20ã‹ã‚‰15ã«å¤‰æ›´ï¼ˆæ©‹ã‚‚å°‘ã—ç´°ãï¼‰
		height = 5,
	},
}
===== ./ReplicatedStorage/Islands/Town.lua =====
-- ReplicatedStorage/Islands/Town.lua (å†…å®¹ã‚’ç½®ãæ›ãˆ)
return {
    name = "StartTown", -- å³¶åã‚’ã€ŒStartTownã€ã«æˆ»ã™
    centerX = 0,
    centerZ = 0,
    sizeXZ = 400,
    baseY = 50, -- å®‰å®šåŒ–ã®ãŸã‚é«˜ã•ã‚’ç¶­æŒ
    thickness = 8,
    grid = 10,
    hillAmplitude = 3,
    hillScale = 80,
    seed = 77777,
    generateOcean = false,
    safeZone = true,
    baseMaterial = Enum.Material.Slate,
}
===== ./ReplicatedStorage/Islands/HokkaidoIslands.lua =====
-- ReplicatedStorage/Islands/HokkaidoIslands
return {
	-- ä¸­å¤®éƒ¨
	{name = "Hokkaido_W1", centerX = 3000, centerZ = 0, sizeXZ = 160, baseY = 0, thickness = 10, grid = 10, hillAmplitude = 25, hillScale = 160, seed = 50000, generateOcean = false, baseMaterial = Enum.Material.Grass, },
	{name = "Hokkaido_C1", centerX = 3080, centerZ = 0, sizeXZ = 160, baseY = 0, thickness = 10, grid = 10, hillAmplitude = 25, hillScale = 160, seed = 50000, generateOcean = false, baseMaterial = Enum.Material.Grass, },
	{name = "Hokkaido_C2", centerX = 3160, centerZ = 0, sizeXZ = 160, baseY = 0, thickness = 10, grid = 10, hillAmplitude = 25, hillScale = 160, seed = 50000, generateOcean = false, baseMaterial = Enum.Material.Grass, },
	{name = "Hokkaido_C3", centerX = 3240, centerZ = 0, sizeXZ = 160, baseY = 0, thickness = 10, grid = 10, hillAmplitude = 25, hillScale = 160, seed = 50000, generateOcean = false, baseMaterial = Enum.Material.Grass, },
	{name = "Hokkaido_C4", centerX = 3320, centerZ = 0, sizeXZ = 160, baseY = 0, thickness = 10, grid = 10, hillAmplitude = 25, hillScale = 160, seed = 50000, generateOcean = false, baseMaterial = Enum.Material.Grass, },
	{name = "Hokkaido_C5", centerX = 3400, centerZ = 0, sizeXZ = 160, baseY = 0, thickness = 10, grid = 10, hillAmplitude = 25, hillScale = 160, seed = 50000, generateOcean = false, baseMaterial = Enum.Material.Grass, },
	{name = "Hokkaido_E1", centerX = 3480, centerZ = 0, sizeXZ = 160, baseY = 0, thickness = 10, grid = 10, hillAmplitude = 25, hillScale = 160, seed = 50000, generateOcean = false, baseMaterial = Enum.Material.Grass, },

	-- åŒ—éƒ¨
	{name = "Hokkaido_N1", centerX = 3080, centerZ = 80, sizeXZ = 160, baseY = 0, thickness = 10, grid = 10, hillAmplitude = 25, hillScale = 160, seed = 50000, generateOcean = false, baseMaterial = Enum.Material.Grass, },
	{name = "Hokkaido_N2", centerX = 3160, centerZ = 80, sizeXZ = 160, baseY = 0, thickness = 10, grid = 10, hillAmplitude = 25, hillScale = 160, seed = 50000, generateOcean = false, baseMaterial = Enum.Material.Grass, },
	{name = "Hokkaido_N3", centerX = 3240, centerZ = 80, sizeXZ = 160, baseY = 0, thickness = 10, grid = 10, hillAmplitude = 25, hillScale = 160, seed = 50000, generateOcean = false, baseMaterial = Enum.Material.Grass, },
	{name = "Hokkaido_N4", centerX = 3320, centerZ = 80, sizeXZ = 160, baseY = 0, thickness = 10, grid = 10, hillAmplitude = 25, hillScale = 160, seed = 50000, generateOcean = false, baseMaterial = Enum.Material.Grass, },

	-- åŒ—æ±éƒ¨ï¼ˆçŸ¥åºŠï¼‰
	{name = "Hokkaido_NE1", centerX = 3320, centerZ = 160, sizeXZ = 160, baseY = 0, thickness = 10, grid = 10, hillAmplitude = 30, hillScale = 160, seed = 50000, generateOcean = false, baseMaterial = Enum.Material.Grass, },
	{name = "Hokkaido_NE2", centerX = 3400, centerZ = 160, sizeXZ = 160, baseY = 0, thickness = 10, grid = 10, hillAmplitude = 30, hillScale = 160, seed = 50000, generateOcean = false, baseMaterial = Enum.Material.Grass, },

	-- å—éƒ¨
	{name = "Hokkaido_S1", centerX = 3160, centerZ = -80, sizeXZ = 160, baseY = 0, thickness = 10, grid = 10, hillAmplitude = 25, hillScale = 160, seed = 50000, generateOcean = false, baseMaterial = Enum.Material.Grass, },
	{name = "Hokkaido_S2", centerX = 3240, centerZ = -80, sizeXZ = 160, baseY = 0, thickness = 10, grid = 10, hillAmplitude = 25, hillScale = 160, seed = 50000, generateOcean = false, baseMaterial = Enum.Material.Grass, },

	-- å—è¥¿éƒ¨ï¼ˆæ¸¡å³¶ï¼‰
	{name = "Hokkaido_SW1", centerX = 3080, centerZ = -160, sizeXZ = 160, baseY = 0, thickness = 10, grid = 10, hillAmplitude = 20, hillScale = 160, seed = 50000, generateOcean = false, baseMaterial = Enum.Material.Grass, },
	{name = "Hokkaido_SW2", centerX = 3160, centerZ = -160, sizeXZ = 160, baseY = 0, thickness = 10, grid = 10, hillAmplitude = 20, hillScale = 160, seed = 50000, generateOcean = true, baseMaterial = Enum.Material.Grass, oceanRadius = 2000},
}
===== ./ReplicatedStorage/Islands/Registry.lua =====
-- ReplicatedStorage/Islands/Registry.lua (å…¨ã‚³ãƒ¼ãƒ‰)
local RS = game:GetService("ReplicatedStorage")
local IslandsFolder = RS:WaitForChild("Islands")

local allIslands = {}

-- å³¶å®šç¾©ã®ãƒªã‚¹ãƒˆ
local islandModules = {
    IslandsFolder:WaitForChild("Town"),           -- ã€ä¿®æ­£ã€‘Town.lua ã‚’å‚ç…§
    IslandsFolder:WaitForChild("HokkaidoIslands"),
}

-- å„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’èª­ã¿è¾¼ã¿
for _, module in ipairs(islandModules) do
    local result = require(module)

    -- Town (å˜ä¸€ãƒ†ãƒ¼ãƒ–ãƒ«) ã¨ Hokkaido (é…åˆ—) ã®ä¸¡æ–¹ã‚’å‡¦ç†
    if result and result.name then
        -- å˜ä¸€ã®å³¶å®šç¾© (Town)
        table.insert(allIslands, result)
    elseif type(result) == "table" and #result > 0 then
        -- è¤‡æ•°ã®å³¶å®šç¾©ï¼ˆé…åˆ—, Hokkaidoï¼‰
        for _, island in ipairs(result) do
            if island and island.name then
                table.insert(allIslands, island)
            else
                warn(("[Islands/Registry] '%s' ã‹ã‚‰å–å¾—ã—ãŸãƒªã‚¹ãƒˆã«ç„¡åŠ¹ãªè¦ç´ ãŒã‚ã‚Šã¾ã™"):format(module.Name))
            end
        end
    else
        warn(("[Islands/Registry] ä¸æ­£ãªå³¶å®šç¾©: '%s'"):format(module.Name))
    end
end

print(("[Islands/Registry] åˆè¨ˆ %d å€‹ã®å³¶ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ"):format(#allIslands))

return allIslands
===== ./ReplicatedStorage/TypingWords.lua =====
-- ReplicatedStorage/TypingWords
-- ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ç”¨ã®å˜èªãƒªã‚¹ãƒˆï¼ˆå¤šè¨€èªå¯¾å¿œï¼‰

return {
	level_1 = {
		{word = "cat", ja = "çŒ«", es = "gato", fr = "chat"},
		{word = "dog", ja = "çŠ¬", es = "perro", fr = "chien"},
		{word = "pen", ja = "ãƒšãƒ³", es = "pluma", fr = "stylo"},
		{word = "cup", ja = "ã‚«ãƒƒãƒ—", es = "taza", fr = "tasse"},
		{word = "sun", ja = "å¤ªé™½", es = "sol", fr = "soleil"},
		{word = "red", ja = "èµ¤", es = "rojo", fr = "rouge"},
		{word = "big", ja = "å¤§ãã„", es = "grande", fr = "grand"},
		{word = "run", ja = "èµ°ã‚‹", es = "correr", fr = "courir"},
		{word = "fly", ja = "é£›ã¶", es = "volar", fr = "voler"},
		{word = "eat", ja = "é£Ÿã¹ã‚‹", es = "comer", fr = "manger"},
	},
	level_2 = {
		{word = "apple", ja = "ã‚Šã‚“ã”", es = "manzana", fr = "pomme"},
		{word = "house", ja = "å®¶", es = "casa", fr = "maison"},
		{word = "water", ja = "æ°´", es = "agua", fr = "eau"},
		{word = "sleep", ja = "çœ ã‚‹", es = "dormir", fr = "dormir"},
		{word = "happy", ja = "å¹¸ã›", es = "feliz", fr = "heureux"},
		{word = "green", ja = "ç·‘", es = "verde", fr = "vert"},
		{word = "river", ja = "å·", es = "rÃ­o", fr = "riviÃ¨re"},
		{word = "night", ja = "å¤œ", es = "noche", fr = "nuit"},
		{word = "music", ja = "éŸ³æ¥½", es = "mÃºsica", fr = "musique"},
		{word = "stone", ja = "çŸ³", es = "piedra", fr = "pierre"},
	},
	level_3 = {
		{word = "banana", ja = "ãƒãƒŠãƒŠ", es = "plÃ¡tano", fr = "banane"},
		{word = "orange", ja = "ã‚ªãƒ¬ãƒ³ã‚¸", es = "naranja", fr = "orange"},
		{word = "yellow", ja = "é»„è‰²", es = "amarillo", fr = "jaune"},
		{word = "purple", ja = "ç´«", es = "morado", fr = "violet"},
		{word = "animal", ja = "å‹•ç‰©", es = "animal", fr = "animal"},
		{word = "window", ja = "çª“", es = "ventana", fr = "fenÃªtre"},
		{word = "garden", ja = "åº­", es = "jardÃ­n", fr = "jardin"},
		{word = "bridge", ja = "æ©‹", es = "puente", fr = "pont"},
		{word = "planet", ja = "æƒ‘æ˜Ÿ", es = "planeta", fr = "planÃ¨te"},
		{word = "forest", ja = "æ£®", es = "bosque", fr = "forÃªt"},
	},
	level_4 = {
		{word = "monday", ja = "æœˆæ›œæ—¥", es = "lunes", fr = "lundi"},
		{word = "sunday", ja = "æ—¥æ›œæ—¥", es = "domingo", fr = "dimanche"},
		{word = "friday", ja = "é‡‘æ›œæ—¥", es = "viernes", fr = "vendredi"},
		{word = "winter", ja = "å†¬", es = "invierno", fr = "hiver"},
		{word = "summer", ja = "å¤", es = "verano", fr = "Ã©tÃ©"},
		{word = "spring", ja = "æ˜¥", es = "primavera", fr = "printemps"},
		{word = "autumn", ja = "ç§‹", es = "otoÃ±o", fr = "automne"},
		{word = "dragon", ja = "ãƒ‰ãƒ©ã‚´ãƒ³", es = "dragÃ³n", fr = "dragon"},
		{word = "castle", ja = "åŸ", es = "castillo", fr = "chÃ¢teau"},
		{word = "warrior", ja = "æˆ¦å£«", es = "guerrero", fr = "guerrier"},
	},
	level_5 = {
		{word = "mountain", ja = "å±±", es = "montaÃ±a", fr = "montagne"},
		{word = "keyboard", ja = "ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰", es = "teclado", fr = "clavier"},
		{word = "computer", ja = "ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿", es = "computadora", fr = "ordinateur"},
		{word = "adventure", ja = "å†’é™º", es = "aventura", fr = "aventure"},
		{word = "beautiful", ja = "ç¾ã—ã„", es = "hermoso", fr = "beau"},
		{word = "champion", ja = "ãƒãƒ£ãƒ³ãƒ”ã‚ªãƒ³", es = "campeÃ³n", fr = "champion"},
		{word = "treasure", ja = "å®ç‰©", es = "tesoro", fr = "trÃ©sor"},
		{word = "butterfly", ja = "è¶", es = "mariposa", fr = "papillon"},
		{word = "elephant", ja = "è±¡", es = "elefante", fr = "Ã©lÃ©phant"},
		{word = "challenge", ja = "æŒ‘æˆ¦", es = "desafÃ­o", fr = "dÃ©fi"},
	},
}
===== ./ReplicatedStorage/FieldGen.lua =====
-- ReplicatedStorage/FieldGen (æœ€é©åŒ–ç‰ˆ)
-- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã‚’å¤§å¹…ã«æ”¹å–„ã—ãŸåœ°å½¢ç”Ÿæˆã‚¨ãƒ³ã‚¸ãƒ³

local FieldGen = {}

-- ãƒã‚¤ã‚ºé–¢æ•°ï¼ˆå¤‰æ›´ãªã—ï¼‰
local function noise2D(x, z, scale)
	local s = (x / scale + z / scale * 57)
	return (math.sin(s * 12.9898) * 43758.5453) % 1
end

local function smoothNoise(x, z, scale)
	local intX, intZ = math.floor(x / scale), math.floor(z / scale)
	local fracX, fracZ = (x / scale) - intX, (z / scale) - intZ

	local v1 = noise2D(intX, intZ, 1)
	local v2 = noise2D(intX + 1, intZ, 1)
	local v3 = noise2D(intX, intZ + 1, 1)
	local v4 = noise2D(intX + 1, intZ + 1, 1)

	local i1 = v1 * (1 - fracX) + v2 * fracX
	local i2 = v3 * (1 - fracX) + v4 * fracX

	return i1 * (1 - fracZ) + i2 * fracZ
end

-- ã€æœ€é©åŒ–1ã€‘ãƒãƒƒãƒç”Ÿæˆã‚·ã‚¹ãƒ†ãƒ 
local function fillTerrainBatch(terrain, blocks)
	local batchSize = 100  -- ä¸€åº¦ã«å‡¦ç†ã™ã‚‹æ•°
	local totalBlocks = #blocks

	for i = 1, totalBlocks, batchSize do
		local endIdx = math.min(i + batchSize - 1, totalBlocks)

		for j = i, endIdx do
			local block = blocks[j]
			terrain:FillBlock(block.cframe, block.size, block.material)
		end

		-- ã‚µãƒ¼ãƒãƒ¼ã®è² è·åˆ†æ•£
		if i % 500 == 0 then
			task.wait()
			print(("[FieldGen] é€²è¡ŒçŠ¶æ³: %d/%d (%.1f%%)"):format(i, totalBlocks, i/totalBlocks*100))
		end
	end
end

-- ReplicatedStorage/FieldGen.lua
-- ã€ä¿®æ­£ã€‘generateIsland é–¢æ•°å…¨ä½“
function FieldGen.generateIsland(config)
	local terrain = workspace.Terrain

	local cfg = {
		name = config.name or "Island",
		centerX = config.centerX or 0,
		centerZ = config.centerZ or 0,
		sizeXZ = config.sizeXZ or 500,
		baseY = config.baseY or 0,
		thickness = config.thickness or 10,
		hillAmplitude = config.hillAmplitude or 20,
		hillScale = config.hillScale or 150,
		seed = config.seed or 12345,
		generateOcean = config.generateOcean ~= false,
		oceanRadius = config.oceanRadius or 1500,
		grid = config.grid or 12,

        -- ã€ä¿®æ­£ç‚¹ Aã€‘æ–°ã—ã„ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’å–å¾—ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ Grass ã«è¨­å®š
        baseMaterial = config.baseMaterial or Enum.Material.Grass,
	}

	print(("[FieldGen] ç”Ÿæˆé–‹å§‹: %s at (%.0f, %.0f, Material: %s)"):format(cfg.name, cfg.centerX, cfg.centerZ, tostring(cfg.baseMaterial)))

	math.randomseed(cfg.seed)

	local halfSize = cfg.sizeXZ / 2
	local oceanY = cfg.baseY - 10
	local cliffHeight = oceanY + 8

	-- ã€é‡è¦ã€‘ãƒ–ãƒ­ãƒƒã‚¯ã‚’é…åˆ—ã«æºœã‚ã¦ã‹ã‚‰ãƒãƒƒãƒå‡¦ç†
	local terrainBlocks = {}
	local waterBlocks = {}

	-- åœ°å½¢ãƒ–ãƒ­ãƒƒã‚¯ã‚’æº–å‚™
	for x = -halfSize, halfSize, cfg.grid do
		for z = -halfSize, halfSize, cfg.grid do
			local worldX = cfg.centerX + x
			local worldZ = cfg.centerZ + z

			local distFromCenter = math.sqrt(x*x + z*z)
			local normalizedDist = distFromCenter / halfSize
			local edgeFade = math.max(0, 1 - normalizedDist * 1.2)

			if edgeFade > 0 then
				local height = smoothNoise(worldX + cfg.seed, worldZ + cfg.seed, cfg.hillScale)
				local hillY = cfg.baseY + (height * cfg.hillAmplitude * edgeFade)
				local targetY = math.max(hillY, cliffHeight)

				table.insert(terrainBlocks, {
					cframe = CFrame.new(worldX, targetY - cfg.thickness/2, worldZ),
					size = Vector3.new(cfg.grid, cfg.thickness, cfg.grid),

                    -- ã€ä¿®æ­£ç‚¹ Bã€‘ãƒãƒ¼ãƒ‰ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸ Material ã‚’è¨­å®šå€¤ã«ç½®ãæ›ãˆ
					material = cfg.baseMaterial
				})
			end
		end
	end

	print(("[FieldGen] åœ°å½¢ãƒ–ãƒ­ãƒƒã‚¯æ•°: %d"):format(#terrainBlocks))
	fillTerrainBatch(terrain, terrainBlocks)

	-- æµ·ã®ç”Ÿæˆ
	if cfg.generateOcean then
		local oceanGrid = 20
		local oceanHalfSize = cfg.oceanRadius / 2
		local maxDistWithTerrain = halfSize * 0.8

		for x = -oceanHalfSize, oceanHalfSize, oceanGrid do
			for z = -oceanHalfSize, oceanHalfSize, oceanGrid do
				local dist = math.sqrt(x*x + z*z)
				if dist > maxDistWithTerrain then
					table.insert(waterBlocks, {
						cframe = CFrame.new(cfg.centerX + x, oceanY, cfg.centerZ + z),
						size = Vector3.new(oceanGrid, 20, oceanGrid),
						material = Enum.Material.Water
					})
				end
			end
		end

		print(("[FieldGen] æµ·ãƒ–ãƒ­ãƒƒã‚¯æ•°: %d"):format(#waterBlocks))
		fillTerrainBatch(terrain, waterBlocks)
	end

	-- ãƒãƒ¼ã‚«ãƒ¼ä½œæˆ
	local worldFolder = workspace:FindFirstChild("World")
	if not worldFolder then
		worldFolder = Instance.new("Folder")
		worldFolder.Name = "World"
		worldFolder.Parent = workspace
	end

	local marker = Instance.new("Part")
	marker.Name = cfg.name .. "_Center"
	marker.Size = Vector3.new(10, 1, 10)
	marker.Position = Vector3.new(cfg.centerX, cfg.baseY + 5, cfg.centerZ)
	marker.Anchored = true
	marker.CanCollide = false
	marker.Transparency = 0.5
	marker.BrickColor = BrickColor.new("Bright blue")
	marker.Parent = worldFolder

	print(("[FieldGen] å®Œäº†: %s"):format(cfg.name))
end

-- ãƒ¬ã‚¤ã‚­ãƒ£ã‚¹ãƒˆï¼ˆå¤‰æ›´ãªã—ï¼‰
function FieldGen.raycastGroundY(x, z, startY)
	startY = startY or 500

	local params = RaycastParams.new()
	params.FilterType = Enum.RaycastFilterType.Include
	params.FilterDescendantsInstances = {workspace.Terrain}
	params.IgnoreWater = false

	local origin = Vector3.new(x, startY, z)
	local direction = Vector3.new(0, -startY - 500, 0)

	local result = workspace:Raycast(origin, direction, params)
	return result and result.Position.Y or nil
end

-- æ©‹ã®ç”Ÿæˆï¼ˆãƒãƒƒãƒå‡¦ç†ç‰ˆï¼‰
function FieldGen.generateBridge(fromIsland, toIsland, config)
	local terrain = workspace.Terrain

	local cfg = {
		name = config.name or "Bridge",
		width = config.width or 20,
		height = config.height or 5,
		thickness = config.thickness or 5,
	}

	print(("[FieldGen] æ©‹ã‚’ç”Ÿæˆä¸­: %s"):format(cfg.name))

	local x1, z1 = fromIsland.centerX, fromIsland.centerZ
	local x2, z2 = toIsland.centerX, toIsland.centerZ

	local dx = x2 - x1
	local dz = z2 - z1
	local distance = math.sqrt(dx*dx + dz*dz)

	local bridgeY = ((fromIsland.baseY or 0) + (toIsland.baseY or 0)) / 2 + cfg.height
	local segments = math.ceil(distance / 10)

	local bridgeBlocks = {}

	for i = 0, segments do
		local t = i / segments
		local x = x1 + dx * t
		local z = z1 + dz * t

		local perpX = -dz / distance
		local perpZ = dx / distance

		for w = -cfg.width/2, cfg.width/2, 8 do
			local worldX = x + perpX * w
			local worldZ = z + perpZ * w

			table.insert(bridgeBlocks, {
				cframe = CFrame.new(worldX, bridgeY, worldZ),
				size = Vector3.new(8, cfg.thickness, 8),
				material = Enum.Material.Slate
			})
		end
	end

	fillTerrainBatch(terrain, bridgeBlocks)
	print(("[FieldGen] æ©‹ç”Ÿæˆå®Œäº†: %s (è·é›¢: %.1f)"):format(cfg.name, distance))
end

return FieldGen
===== ./ReplicatedStorage/Monsters/Registry.lua =====
local RS = game:GetService("ReplicatedStorage")
local Monsters = RS:WaitForChild("Monsters")

return {
	require(Monsters.Slime),
	-- å°†æ¥è¿½åŠ ã™ã‚‹ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼:
	-- require(Monsters.Dragon),
	-- require(Monsters.Goblin),
}
===== ./ReplicatedStorage/Monsters/Slime.lua =====
-- ReplicatedStorage/Monsters/Slime.lua
-- ReplicatedStorage/Monsters/Slime
-- ã‚¹ãƒ©ã‚¤ãƒ ã®å®šç¾©ï¼ˆã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ‹¡å¼µç‰ˆï¼‰

return {
	Name = "Slime",
	TemplatePath = {"ServerStorage", "EnemyTemplates", "Slime"},
	WalkSpeed = 10,
	RespawnTime = 10,

	-- ã€æ–°ã€‘ãƒãƒˆãƒ«ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
	HP = 50,           -- ãƒ©ã‚¤ãƒ•
	Speed = 5,         -- ç´ æ—©ã•
	Attack = 20,        -- æ”»æ’ƒåŠ›
	Defense = 5,       -- å®ˆå‚™åŠ›

	-- ã€æ–°ã€‘å ±é…¬
	Experience = 20,   -- å€’ã—ãŸæ™‚ã«å¾—ã‚‰ã‚Œã‚‹çµŒé¨“å€¤
	Gold = 10,         -- å€’ã—ãŸæ™‚ã«å¾—ã‚‰ã‚Œã‚‹ã‚´ãƒ¼ãƒ«ãƒ‰

	-- ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ãƒ¬ãƒ™ãƒ«ï¼ˆé‡ã¿ä»˜ãï¼‰
	TypingLevels = {
		{level = "level_1", weight = 70},  -- 70%ã®ç¢ºç‡ã§ãƒ¬ãƒ™ãƒ«1
		{level = "level_2", weight = 30},  -- 30%ã®ç¢ºç‡ã§ãƒ¬ãƒ™ãƒ«2
	},

	-- æ—§è¨­å®šï¼ˆäº’æ›æ€§ã®ãŸã‚æ®‹ã™ï¼‰
	Damage = 1,  -- å¾Œã§å‰Šé™¤äºˆå®š

	-- ã‚¹ãƒãƒ¼ãƒ³è¨­å®š
	SpawnLocations = {
		{
			islandName = "Hokkaido_N1",
			count = 7,
			radiusPercent = 95,  -- å³¶ã®ã‚µã‚¤ã‚ºã®75%ç¯„å›²å†…
		},
		{
			islandName = "Hokkaido_N4",
			count = 15,
			radiusPercent = 55,  -- å³¶ã®ã‚µã‚¤ã‚ºã®75%ç¯„å›²å†…
		},

	},

	-- AIè¨­å®š
	ChaseDistance = 60,
	EscapeDistance = 80,
	WanderRadius = 30,
	UpdateNearby = 0.2,
	UpdateFar = 1.0,
}
===== ./ReplicatedStorage/Monsters/Slime_pink.lua =====
-- ReplicatedStorage/Monsters/[ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼å]

return {
	Name = "Slime_pink",
	TemplatePath = {"ServerStorage", "EnemyTemplates", "Slime_pink"},
	WalkSpeed = 8,
	RespawnTime = 20,

	-- ã€æ–°ã€‘ãƒãƒˆãƒ«ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
	HP = 80,           -- ãƒ©ã‚¤ãƒ•
	Speed = 10,         -- ç´ æ—©ã•
	Attack = 30,        -- æ”»æ’ƒåŠ›
	Defense = 10,       -- å®ˆå‚™åŠ›

	-- ã€æ–°ã€‘å ±é…¬
	Experience = 50,   -- å€’ã—ãŸæ™‚ã«å¾—ã‚‰ã‚Œã‚‹çµŒé¨“å€¤
	Gold = 25,         -- å€’ã—ãŸæ™‚ã«å¾—ã‚‰ã‚Œã‚‹ã‚´ãƒ¼ãƒ«ãƒ‰

	-- ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ãƒ¬ãƒ™ãƒ«ï¼ˆé‡ã¿ä»˜ãï¼‰
	TypingLevels = {
		{level = "level_2", weight = 70},  -- 70%ã®ç¢ºç‡ã§ãƒ¬ãƒ™ãƒ«1
		{level = "level_3", weight = 30},  -- 30%ã®ç¢ºç‡ã§ãƒ¬ãƒ™ãƒ«2
	},

	-- æ—§è¨­å®šï¼ˆäº’æ›æ€§ã®ãŸã‚æ®‹ã™ï¼‰
	Damage = 1,  -- å¾Œã§å‰Šé™¤äºˆå®š

	-- ã‚¹ãƒãƒ¼ãƒ³è¨­å®š
	SpawnLocations = {
		{
			islandName = "Hokkaido_N1",
			count = 3,
			radiusPercent = 80,
		},
		{
			islandName = "Hokkaido_N4",
			count = 5,
			radiusPercent = 80,
		},

	},

	-- AIè¨­å®š
	ChaseDistance = 60,
	EscapeDistance = 30,
	WanderRadius = 30,
	UpdateNearby = 0.2,
	UpdateFar = 1.0,
}
