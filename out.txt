===== ./StartPlayerScripts/Minimap.client.lua =====
-- StarterPlayer/StarterPlayerScripts/Minimap.client.lua
-- ミニマップシステム（ズーム機能・ポータル表示対応版）

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

print("[Minimap] 初期化開始")

-- ズームレベル設定
local ZOOM_LEVELS = {
	{
		name = "詳細",
		scale = 2,           -- 2スタッド/ピクセル
		terrainGrid = 45,    -- 60→45に削減（負荷軽減）
		terrainUpdateInterval = 0.25,  -- 0.15秒 → 0.25秒（更新頻度を下げる）
		iconUpdateInterval = 0.05,
		monsterIconSize = 7,
		portalIconSize = 9,
	},
	{
		name = "中間",
		scale = 4,           -- 4スタッド/ピクセル
		terrainGrid = 50,    -- 50x50グリッド
		terrainUpdateInterval = 0.25,
		iconUpdateInterval = 0.05,
		monsterIconSize = 5,
		portalIconSize = 7,
	},
	{
		name = "広域",
		scale = 8,           -- 8スタッド/ピクセル
		terrainGrid = 40,    -- 40x40グリッド（広域は負荷軽減）
		terrainUpdateInterval = 0.4,
		iconUpdateInterval = 0.08,
		monsterIconSize = 3,
		portalIconSize = 5,
	},
}

local currentZoomLevel = 1

-- 現在の設定を取得
local function getCurrentSettings()
	return ZOOM_LEVELS[currentZoomLevel]
end

-- 基本設定
local MINIMAP_SIZE = 200
local WATER_LEVEL = -15

-- 色設定
local LAND_COLOR = Color3.fromRGB(50, 70, 50)
local SEA_COLOR = Color3.fromRGB(30, 30, 30)
local PLAYER_COLOR = Color3.fromRGB(100, 200, 255)
local MONSTER_COLOR = Color3.fromRGB(255, 50, 50)
local PORTAL_TOWN_COLOR = Color3.fromRGB(255, 200, 100)
local PORTAL_OTHER_COLOR = Color3.fromRGB(200, 100, 255)

-- ScreenGui作成
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "MinimapUI"
screenGui.ResetOnSpawn = false
screenGui.IgnoreGuiInset = true
screenGui.Parent = playerGui

-- ミニマップの背景フレーム
local minimapFrame = Instance.new("Frame")
minimapFrame.Name = "MinimapFrame"
minimapFrame.Size = UDim2.new(0, MINIMAP_SIZE, 0, MINIMAP_SIZE)
minimapFrame.Position = UDim2.new(0, 20, 1, -MINIMAP_SIZE - 20)
minimapFrame.BackgroundColor3 = SEA_COLOR
minimapFrame.BackgroundTransparency = 0.3
minimapFrame.BorderSizePixel = 2
minimapFrame.BorderColor3 = Color3.fromRGB(255, 255, 255)
minimapFrame.Parent = screenGui

local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(0, 8)
corner.Parent = minimapFrame

-- 地形レイヤー
local terrainLayer = Instance.new("Frame")
terrainLayer.Name = "TerrainLayer"
terrainLayer.Size = UDim2.new(1, 0, 1, 0)
terrainLayer.BackgroundTransparency = 1
terrainLayer.ClipsDescendants = true
terrainLayer.ZIndex = 1
terrainLayer.Parent = minimapFrame

-- タイトル（ズームレベル表示）
local titleLabel = Instance.new("TextLabel")
titleLabel.Name = "Title"
titleLabel.Size = UDim2.new(1, 0, 0, 20)
titleLabel.Position = UDim2.new(0, 0, 0, -25)
titleLabel.BackgroundTransparency = 1
titleLabel.Text = "MAP [Z: 詳細]"
titleLabel.TextColor3 = Color3.new(1, 1, 1)
titleLabel.TextSize = 14
titleLabel.Font = Enum.Font.SourceSansBold
titleLabel.TextStrokeTransparency = 0.5
titleLabel.Parent = minimapFrame

-- プレイヤーアイコン（縦長の矢印型）
local playerIconContainer = Instance.new("Frame")
playerIconContainer.Name = "PlayerIconContainer"
playerIconContainer.Size = UDim2.new(0, 12, 0, 18)
playerIconContainer.AnchorPoint = Vector2.new(0.5, 0.5)
playerIconContainer.Position = UDim2.new(0.5, 0, 0.5, 0)
playerIconContainer.BackgroundTransparency = 1
playerIconContainer.ZIndex = 10
playerIconContainer.Parent = minimapFrame

-- 矢印の先端（小さい四角）
local arrowTip = Instance.new("Frame")
arrowTip.Name = "ArrowTip"
arrowTip.Size = UDim2.new(0, 2, 0, 4)
arrowTip.Position = UDim2.new(0.5, 0, 0, 0)
arrowTip.AnchorPoint = Vector2.new(0.5, 0)
arrowTip.BackgroundColor3 = PLAYER_COLOR
arrowTip.BorderSizePixel = 0
arrowTip.ZIndex = 10
arrowTip.Parent = playerIconContainer

-- 矢印の中央部分
local arrowMiddle = Instance.new("Frame")
arrowMiddle.Name = "ArrowMiddle"
arrowMiddle.Size = UDim2.new(0, 4, 0, 6)
arrowMiddle.Position = UDim2.new(0.5, 0, 0, 3)
arrowMiddle.AnchorPoint = Vector2.new(0.5, 0)
arrowMiddle.BackgroundColor3 = PLAYER_COLOR
arrowMiddle.BorderSizePixel = 0
arrowMiddle.ZIndex = 10
arrowMiddle.Parent = playerIconContainer

-- 矢印の下部（広い部分）
local arrowBottom = Instance.new("Frame")
arrowBottom.Name = "ArrowBottom"
arrowBottom.Size = UDim2.new(0, 6, 0, 4)
arrowBottom.Position = UDim2.new(0.5, 0, 0, 9)
arrowBottom.AnchorPoint = Vector2.new(0.5, 0)
arrowBottom.BackgroundColor3 = PLAYER_COLOR
arrowBottom.BorderSizePixel = 0
arrowBottom.ZIndex = 10
arrowBottom.Parent = playerIconContainer

local playerIcon = playerIconContainer

-- アイコンを格納するフォルダ
local monstersFolder = Instance.new("Folder")
monstersFolder.Name = "MonsterIcons"
monstersFolder.Parent = minimapFrame

local portalsFolder = Instance.new("Folder")
portalsFolder.Name = "PortalIcons"
portalsFolder.Parent = minimapFrame

-- 地形タイルのプール
local terrainTilePool = {}
local activeTiles = {}

local function getTerrainTile()
	for _, tile in ipairs(terrainTilePool) do
		if not tile.Visible then
			tile.Visible = true
			return tile
		end
	end

	local tile = Instance.new("Frame")
	tile.Name = "TerrainTile"
	tile.BackgroundColor3 = LAND_COLOR
	tile.BackgroundTransparency = 0.2
	tile.BorderSizePixel = 0
	tile.ZIndex = 2
	tile.Parent = terrainLayer

	table.insert(terrainTilePool, tile)
	return tile
end

local function hideAllTerrainTiles()
	for _, tile in ipairs(terrainTilePool) do
		tile.Visible = false
	end
	activeTiles = {}
end

-- モンスターアイコンのプール
local monsterIconPool = {}

local function getMonsterIcon(size)
	for _, icon in ipairs(monsterIconPool) do
		if not icon.Visible then
			icon.Visible = true
			icon.Size = UDim2.new(0, size, 0, size)
			return icon
		end
	end

	local icon = Instance.new("Frame")
	icon.Name = "MonsterIcon"
	icon.Size = UDim2.new(0, size, 0, size)
	icon.AnchorPoint = Vector2.new(0.5, 0.5)
	icon.BackgroundColor3 = MONSTER_COLOR
	icon.BorderSizePixel = 0
	icon.ZIndex = 5
	icon.Parent = monstersFolder

	local iconCorner = Instance.new("UICorner")
	iconCorner.CornerRadius = UDim.new(1, 0)
	iconCorner.Parent = icon

	table.insert(monsterIconPool, icon)
	return icon
end

local function hideAllMonsterIcons()
	for _, icon in ipairs(monsterIconPool) do
		icon.Visible = false
	end
end

-- ポータルアイコンのプール
local portalIconPool = {}

local function getPortalIcon(size)
	for _, icon in ipairs(portalIconPool) do
		if not icon.Visible then
			icon.Visible = true
			icon.Size = UDim2.new(0, size, 0, size)
			return icon
		end
	end

	local icon = Instance.new("Frame")
	icon.Name = "PortalIcon"
	icon.Size = UDim2.new(0, size, 0, size)
	icon.AnchorPoint = Vector2.new(0.5, 0.5)
	icon.BackgroundColor3 = PORTAL_OTHER_COLOR
	icon.BorderSizePixel = 0
	icon.ZIndex = 6
	icon.Parent = portalsFolder

	local iconCorner = Instance.new("UICorner")
	iconCorner.CornerRadius = UDim.new(1, 0)
	iconCorner.Parent = icon

	table.insert(portalIconPool, icon)
	return icon
end

local function hideAllPortalIcons()
	for _, icon in ipairs(portalIconPool) do
		icon.Visible = false
	end
end

-- レイキャストで地形チェック
local function isLand(worldX, worldZ)
	local params = RaycastParams.new()
	params.FilterType = Enum.RaycastFilterType.Include
	params.FilterDescendantsInstances = {workspace.Terrain}
	params.IgnoreWater = false

	local origin = Vector3.new(worldX, 200, worldZ)
	local direction = Vector3.new(0, -250, 0)

	local result = workspace:Raycast(origin, direction, params)

	if result then
		if result.Material == Enum.Material.Water then
			return false
		end
		if result.Position.Y > WATER_LEVEL then
			return true
		end
	end

	return false
end

-- 地形マップを更新
local lastTerrainUpdate = 0
local lastPlayerPos = nil

local function updateTerrainMap()
	local settings = getCurrentSettings()
	local now = os.clock()

	if now - lastTerrainUpdate < settings.terrainUpdateInterval then
		return
	end

	local character = player.Character
	if not character then return end

	local hrp = character:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	local playerPos = hrp.Position

	-- プレイヤーがあまり動いていなければスキップ
	if lastPlayerPos then
		local distance = (playerPos - lastPlayerPos).Magnitude
		-- 詳細モードは移動距離の閾値を上げる（頻繁に更新しない）
		local threshold = (settings.name == "詳細") and 8 or 5
		if distance < threshold then
			return
		end
	end

	lastTerrainUpdate = now
	lastPlayerPos = playerPos

	-- チラつき防止：古いタイルは残したまま、新しいタイルを配置
	local tileSize = MINIMAP_SIZE / settings.terrainGrid
	local newActiveTiles = {}
	local usedTileIndex = 1

	-- 一気に処理（task.wait()なし）
	for gridX = 0, settings.terrainGrid - 1 do
		for gridZ = 0, settings.terrainGrid - 1 do
			local mapX = (gridX + 0.5) / settings.terrainGrid
			local mapZ = (gridZ + 0.5) / settings.terrainGrid

			local relativeX = (mapX - 0.5) * MINIMAP_SIZE * settings.scale
			local relativeZ = -(mapZ - 0.5) * MINIMAP_SIZE * settings.scale

			local worldX = playerPos.X + relativeX
			local worldZ = playerPos.Z + relativeZ

			-- 地形チェック
			if isLand(worldX, worldZ) then
				local tile = getTerrainTile()
				tile.Size = UDim2.new(0, tileSize + 1, 0, tileSize + 1)
				tile.Position = UDim2.new(0, gridX * tileSize, 0, gridZ * tileSize)
				table.insert(newActiveTiles, tile)
			end
		end
	end

	-- 古いタイルを非表示（新しいタイルを表示した後）
	for _, tile in ipairs(activeTiles) do
		local isStillActive = false
		for _, newTile in ipairs(newActiveTiles) do
			if tile == newTile then
				isStillActive = true
				break
			end
		end
		if not isStillActive then
			tile.Visible = false
		end
	end

	activeTiles = newActiveTiles

	-- print(("[Minimap] 地形マップ更新完了: 陸=%d"):format(#activeTiles))
end

-- ワールド座標をミニマップ座標に変換
local function worldToMinimap(worldPos, playerPos)
	local settings = getCurrentSettings()

	local relativeX = worldPos.X - playerPos.X
	local relativeZ = worldPos.Z - playerPos.Z

	local minimapX = (relativeX / settings.scale)
	local minimapZ = -(relativeZ / settings.scale)

	local normalizedX = 0.5 + (minimapX / MINIMAP_SIZE)
	local normalizedZ = 0.5 + (minimapZ / MINIMAP_SIZE)

	return normalizedX, normalizedZ
end

local function isInRange(worldPos, playerPos)
	local settings = getCurrentSettings()
	local range = (MINIMAP_SIZE * settings.scale) / 2

	local dx = worldPos.X - playerPos.X
	local dz = worldPos.Z - playerPos.Z
	local distance = math.sqrt(dx * dx + dz * dz)
	return distance <= range
end

-- プレイヤーアイコンの向きを更新
local function updatePlayerRotation()
	local character = player.Character
	if not character then return end

	local hrp = character:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	-- プレイヤーの向きを取得（CFrameのLookVector）
	local lookVector = hrp.CFrame.LookVector

	-- ミニマップ上の角度に変換（上が0度、時計回り）
	-- LookVectorのXとZから角度を計算
	local angle = math.atan2(lookVector.X, lookVector.Z)
	local degrees = math.deg(angle)

	-- コンテナのRotationを更新
	playerIcon.Rotation = degrees
end

-- モンスターアイコンを更新
local lastIconUpdate = 0
local function updateMonsterIcons()
	local settings = getCurrentSettings()
	local now = os.clock()

	if now - lastIconUpdate < settings.iconUpdateInterval then
		return
	end
	lastIconUpdate = now

	local character = player.Character
	if not character then return end

	local hrp = character:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	local playerPos = hrp.Position

	hideAllMonsterIcons()

	-- Monstersフォルダから取得
	local monstersWorkspace = workspace:FindFirstChild("Monsters")
	if monstersWorkspace then
		for _, model in ipairs(monstersWorkspace:GetChildren()) do
			if model:IsA("Model") then
				local monsterHrp = model:FindFirstChild("HumanoidRootPart")
				if monsterHrp then
					local monsterPos = monsterHrp.Position
					if isInRange(monsterPos, playerPos) then
						local mapX, mapZ = worldToMinimap(monsterPos, playerPos)
						if mapX >= 0 and mapX <= 1 and mapZ >= 0 and mapZ <= 1 then
							local icon = getMonsterIcon(settings.monsterIconSize)
							icon.Position = UDim2.new(mapX, 0, mapZ, 0)
						end
					end
				end
			end
		end
	end

	-- 旧形式（IsEnemy属性）にも対応
	for _, model in ipairs(workspace:GetChildren()) do
		if model:IsA("Model") and model:GetAttribute("IsEnemy") then
			local monsterHrp = model:FindFirstChild("HumanoidRootPart")
			if monsterHrp then
				local monsterPos = monsterHrp.Position
				if isInRange(monsterPos, playerPos) then
					local mapX, mapZ = worldToMinimap(monsterPos, playerPos)
					if mapX >= 0 and mapX <= 1 and mapZ >= 0 and mapZ <= 1 then
						local icon = getMonsterIcon(settings.monsterIconSize)
						icon.Position = UDim2.new(mapX, 0, mapZ, 0)
					end
				end
			end
		end
	end

	-- プレイヤーの向きを更新
	updatePlayerRotation()
end

-- ポータルアイコンを更新
local portalDebugDone = false
local function updatePortalIcons()
	local settings = getCurrentSettings()
	local character = player.Character
	if not character then return end

	local hrp = character:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	local playerPos = hrp.Position

	hideAllPortalIcons()

	-- デバッグ: ポータルの配置場所を確認
	if not portalDebugDone then
		print("[Minimap DEBUG] ポータル検索開始")

		-- workspace.Worldの中身を確認
		local worldFolder = workspace:FindFirstChild("World")
		if worldFolder then
			print("[Minimap DEBUG] workspace.World発見: " .. #worldFolder:GetChildren() .. "個のオブジェクト")
			local portalCount = 0
			for _, obj in ipairs(worldFolder:GetChildren()) do
				local toZone = obj:GetAttribute("ToZone")
				if toZone then
					portalCount = portalCount + 1
					print("[Minimap DEBUG]   - " .. obj.Name .. " → " .. toZone .. " (Pos: " .. tostring(obj.Position) .. ")")
				end
			end
			print("[Minimap DEBUG] ポータル総数: " .. portalCount)
		else
			print("[Minimap DEBUG] workspace.Worldが見つかりません")
		end

		portalDebugDone = true
	end

	-- workspace.Worldからポータルを取得
	local worldFolder = workspace:FindFirstChild("World")
	if worldFolder then
		for _, portal in ipairs(worldFolder:GetChildren()) do
			-- ToZone属性があるものをポータルとして認識
			if portal:IsA("BasePart") and portal:GetAttribute("ToZone") then
				local portalPos = portal.Position
				if isInRange(portalPos, playerPos) then
					local mapX, mapZ = worldToMinimap(portalPos, playerPos)
					if mapX >= 0 and mapX <= 1 and mapZ >= 0 and mapZ <= 1 then
						local icon = getPortalIcon(settings.portalIconSize)
						icon.Position = UDim2.new(mapX, 0, mapZ, 0)

						-- Townへのポータルかそれ以外かで色分け
						local toZone = portal:GetAttribute("ToZone")
						if toZone == "StartTown" then
							-- Townへのポータル → オレンジ
							icon.BackgroundColor3 = PORTAL_TOWN_COLOR
						else
							-- それ以外（他の大陸へ） → ポータルの色またはデフォルト紫
							icon.BackgroundColor3 = portal.Color or PORTAL_OTHER_COLOR
						end
					end
				end
			end
		end
	end
end

-- ズーム切り替え
local function changeZoomLevel(delta)
	currentZoomLevel = math.clamp(currentZoomLevel + delta, 1, #ZOOM_LEVELS)
	local settings = getCurrentSettings()

	titleLabel.Text = "MAP [Z: " .. settings.name .. "]"

	-- 地形マップを即座に更新
	lastTerrainUpdate = 0
	lastPlayerPos = nil

	print("[Minimap] ズーム変更: " .. settings.name)
end

-- マウスホイール入力
UserInputService.InputChanged:Connect(function(input, gameProcessed)
	if gameProcessed then return end

	if input.UserInputType == Enum.UserInputType.MouseWheel then
		local mousePos = UserInputService:GetMouseLocation()
		local framePos = minimapFrame.AbsolutePosition
		local frameSize = minimapFrame.AbsoluteSize

		if mousePos.X >= framePos.X and mousePos.X <= framePos.X + frameSize.X and
			mousePos.Y >= framePos.Y and mousePos.Y <= framePos.Y + frameSize.Y then
			if input.Position.Z > 0 then
				changeZoomLevel(-1)
			else
				changeZoomLevel(1)
			end
		end
	end
end)

-- Zキー入力
UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then return end

	if input.KeyCode == Enum.KeyCode.Z then
		local nextLevel = currentZoomLevel + 1
		if nextLevel > #ZOOM_LEVELS then
			nextLevel = 1
		end
		changeZoomLevel(nextLevel - currentZoomLevel)
	end
end)

-- メイン更新ループ
RunService.Heartbeat:Connect(function()
	updateTerrainMap()
	updateMonsterIcons()
end)

-- ポータル専用の高速更新ループ（独立）
task.spawn(function()
	while true do
		task.wait(0.1)  -- 0.1秒ごとに更新（高速）
		updatePortalIcons()
	end
end)

-- 初期化時に即座にポータルを検索
task.spawn(function()
	task.wait(0.5)  -- 少し待ってからポータル検索
	updatePortalIcons()
end)

-- workspace.Worldの変化を監視（ポータル追加時に即反映）
task.spawn(function()
	local worldFolder = workspace:WaitForChild("World", 10)
	if worldFolder then
		worldFolder.ChildAdded:Connect(function(child)
			if child:IsA("BasePart") and child:GetAttribute("ToZone") then
				print("[Minimap] 新しいポータル検出: " .. child.Name)
				task.wait(0.1)
				updatePortalIcons()
			end
		end)
	end
end)

print("[Minimap] 初期化完了（ズーム機能付き）")
===== ./StartPlayerScripts/MenuUI.client.lua =====
-- StarterPlayer/StarterPlayerScripts/MenuUI.client.lua
-- メニューシステム（ステータス、アイテム、スキル等）

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

print("[MenuUI] 初期化中...")

-- 状態管理
local currentModal = nil
local isInBattle = false

-- RemoteEvent取得
local RequestStatusEvent = ReplicatedStorage:WaitForChild("RequestStatus", 10)

-- UIコンテナ
local menuGui = nil
local menuFrame = nil

-- プレイヤーステータスキャッシュ
local cachedStats = {
	Level = 1,
	MaxHP = 100,
	CurrentHP = 100,
	Speed = 10,
	Attack = 10,
	Defense = 10,
	Gold = 0,
	MonstersDefeated = 0
}

-- ステータス更新を受信
local StatusUpdateEvent = ReplicatedStorage:FindFirstChild("StatusUpdate")
if StatusUpdateEvent then
	StatusUpdateEvent.OnClientEvent:Connect(function(hp, maxHP, level, exp, expToNext, gold)
		cachedStats.CurrentHP = hp or cachedStats.CurrentHP
		cachedStats.MaxHP = maxHP or cachedStats.MaxHP
		cachedStats.Level = level or cachedStats.Level
		cachedStats.Gold = gold or cachedStats.Gold
	end)
end

-- 戦歴更新を受信（確実に接続）
task.spawn(function()
	print("[MenuUI] StatsDetailイベント接続を開始...")

	local StatsDetailEvent = ReplicatedStorage:WaitForChild("StatsDetail", 30)
	if not StatsDetailEvent then
		warn("[MenuUI] StatsDetailイベントが見つかりません！")
		return
	end

	print("[MenuUI] StatsDetailイベントを発見しました")

	StatsDetailEvent.OnClientEvent:Connect(function(stats)
		print("[MenuUI] ========================================")
		print("[MenuUI] 🎯 StatsDetail受信イベント発火！")
		print("[MenuUI] 受信したデータ:")
		if stats then
			print("[MenuUI] stats.MonstersDefeated =", stats.MonstersDefeated)
			print("[MenuUI] stats.Level =", stats.Level)
			print("[MenuUI] stats.Gold =", stats.Gold)

			for key, value in pairs(stats) do
				cachedStats[key] = value
			end

			print("[MenuUI] ✅ キャッシュ更新完了")
			print("[MenuUI] cachedStats.MonstersDefeated =", cachedStats.MonstersDefeated)
		else
			warn("[MenuUI] ❌ statsがnilです！")
		end
		print("[MenuUI] ========================================")
	end)

	print("[MenuUI] StatsDetailイベント接続完了")
end)

-- バトル状態を監視
local BattleStartEvent = ReplicatedStorage:FindFirstChild("BattleStart")
local BattleEndEvent = ReplicatedStorage:FindFirstChild("BattleEnd")

if BattleStartEvent then
	BattleStartEvent.OnClientEvent:Connect(function()
		isInBattle = true
		if menuFrame then
			for _, button in ipairs(menuFrame:GetChildren()) do
				if button:IsA("TextButton") then
					button.Active = false
					button.BackgroundTransparency = 0.7
					button.TextTransparency = 0.5
				end
			end
		end
		if currentModal then
			closeModal()
		end
	end)
end

if BattleEndEvent then
	BattleEndEvent.OnClientEvent:Connect(function()
		isInBattle = false
		if menuFrame then
			for _, button in ipairs(menuFrame:GetChildren()) do
				if button:IsA("TextButton") then
					button.Active = true
					button.BackgroundTransparency = 0.2
					button.TextTransparency = 0
				end
			end
		end
	end)
end

-- モーダルウィンドウを閉じる
function closeModal()
	if currentModal then
		local background = currentModal:FindFirstChild("Background")
		if background then
			local tween = TweenService:Create(background, TweenInfo.new(0.2), {
				BackgroundTransparency = 1
			})
			tween:Play()
		end

		local panel = currentModal:FindFirstChild("Panel")
		if panel then
			local tween = TweenService:Create(panel, TweenInfo.new(0.2), {
				BackgroundTransparency = 1
			})
			tween:Play()

			for _, child in ipairs(panel:GetDescendants()) do
				if child:IsA("TextLabel") or child:IsA("TextButton") then
					TweenService:Create(child, TweenInfo.new(0.2), {
						TextTransparency = 1
					}):Play()
				end
			end
		end

		task.wait(0.2)
		currentModal:Destroy()
		currentModal = nil
	end
end

-- モーダルウィンドウを作成
local function createModal(title, contentBuilder)
	if currentModal then
		closeModal()
	end

	local modal = Instance.new("ScreenGui")
	modal.Name = "ModalUI"
	modal.ResetOnSpawn = false
	modal.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	modal.Parent = playerGui

	-- 背景（暗転）
	local background = Instance.new("Frame")
	background.Name = "Background"
	background.Size = UDim2.fromScale(1, 1)
	background.BackgroundColor3 = Color3.new(0, 0, 0)
	background.BackgroundTransparency = 1
	background.BorderSizePixel = 0
	background.ZIndex = 50
	background.Parent = modal

	TweenService:Create(background, TweenInfo.new(0.2), {
		BackgroundTransparency = 0.5
	}):Play()

	-- パネル
	local panel = Instance.new("Frame")
	panel.Name = "Panel"
	panel.Size = UDim2.new(0, 500, 0, 400)
	panel.Position = UDim2.fromScale(0.5, 0.5)
	panel.AnchorPoint = Vector2.new(0.5, 0.5)
	panel.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
	panel.BackgroundTransparency = 1
	panel.BorderSizePixel = 0
	panel.ZIndex = 51
	panel.Parent = modal

	TweenService:Create(panel, TweenInfo.new(0.2), {
		BackgroundTransparency = 0.1
	}):Play()

	local panelCorner = Instance.new("UICorner")
	panelCorner.CornerRadius = UDim.new(0, 12)
	panelCorner.Parent = panel

	-- タイトル
	local titleLabel = Instance.new("TextLabel")
	titleLabel.Name = "Title"
	titleLabel.Size = UDim2.new(1, -20, 0, 40)
	titleLabel.Position = UDim2.new(0, 10, 0, 10)
	titleLabel.BackgroundTransparency = 1
	titleLabel.TextColor3 = Color3.fromRGB(255, 215, 0)
	titleLabel.TextStrokeTransparency = 0.5
	titleLabel.Font = Enum.Font.GothamBold
	titleLabel.TextSize = 24
	titleLabel.Text = title
	titleLabel.TextXAlignment = Enum.TextXAlignment.Left
	titleLabel.TextTransparency = 1
	titleLabel.ZIndex = 52
	titleLabel.Parent = panel

	TweenService:Create(titleLabel, TweenInfo.new(0.2), {
		TextTransparency = 0,
		TextStrokeTransparency = 0.5
	}):Play()

	-- 閉じるボタン
	local closeButton = Instance.new("TextButton")
	closeButton.Name = "CloseButton"
	closeButton.Size = UDim2.new(0, 40, 0, 40)
	closeButton.Position = UDim2.new(1, -50, 0, 10)
	closeButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
	closeButton.BackgroundTransparency = 1
	closeButton.BorderSizePixel = 0
	closeButton.Font = Enum.Font.GothamBold
	closeButton.TextSize = 24
	closeButton.Text = "✕"
	closeButton.TextColor3 = Color3.new(1, 1, 1)
	closeButton.TextTransparency = 1
	closeButton.ZIndex = 52
	closeButton.Parent = panel

	TweenService:Create(closeButton, TweenInfo.new(0.2), {
		BackgroundTransparency = 0.2,
		TextTransparency = 0
	}):Play()

	local closeCorner = Instance.new("UICorner")
	closeCorner.CornerRadius = UDim.new(0, 8)
	closeCorner.Parent = closeButton

	closeButton.MouseButton1Click:Connect(function()
		closeModal()
	end)

	closeButton.MouseEnter:Connect(function()
		closeButton.BackgroundColor3 = Color3.fromRGB(255, 70, 70)
	end)
	closeButton.MouseLeave:Connect(function()
		closeButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
	end)

	-- コンテンツエリア
	local contentFrame = Instance.new("Frame")
	contentFrame.Name = "Content"
	contentFrame.Size = UDim2.new(1, -20, 1, -70)
	contentFrame.Position = UDim2.new(0, 10, 0, 60)
	contentFrame.BackgroundTransparency = 1
	contentFrame.ZIndex = 52
	contentFrame.Parent = panel

	if contentBuilder then
		contentBuilder(contentFrame)
	end

	background.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			closeModal()
		end
	end)

	currentModal = modal
	return modal
end

-- ステータス画面
local function showStatus()
	createModal("ステータス", function(content)
		local stats = {
			{"レベル", cachedStats.Level},
			{"最大HP", cachedStats.MaxHP},
			{"攻撃力", cachedStats.Attack},
			{"防御力", cachedStats.Defense},
			{"素早さ", cachedStats.Speed},
		}

		for i, stat in ipairs(stats) do
			local label = Instance.new("TextLabel")
			label.Size = UDim2.new(1, 0, 0, 40)
			label.Position = UDim2.new(0, 0, 0, (i - 1) * 50)
			label.BackgroundTransparency = 1
			label.TextColor3 = Color3.fromRGB(255, 255, 255)
			label.TextStrokeTransparency = 0.7
			label.Font = Enum.Font.Gotham
			label.TextSize = 20
			label.Text = string.format("%s: %d", stat[1], stat[2])
			label.TextXAlignment = Enum.TextXAlignment.Left
			label.TextTransparency = 1
			label.ZIndex = 53
			label.Parent = content

			TweenService:Create(label, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, i * 0.05), {
				TextTransparency = 0,
				TextStrokeTransparency = 0.7
			}):Play()
		end
	end)
end

-- アイテム画面
local function showItems()
	createModal("アイテム", function(content)
		local emptyLabel = Instance.new("TextLabel")
		emptyLabel.Size = UDim2.fromScale(1, 1)
		emptyLabel.BackgroundTransparency = 1
		emptyLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
		emptyLabel.TextStrokeTransparency = 0.7
		emptyLabel.Font = Enum.Font.Gotham
		emptyLabel.TextSize = 18
		emptyLabel.Text = "アイテムがありません"
		emptyLabel.TextTransparency = 1
		emptyLabel.ZIndex = 53
		emptyLabel.Parent = content

		TweenService:Create(emptyLabel, TweenInfo.new(0.2), {
			TextTransparency = 0,
			TextStrokeTransparency = 0.7
		}):Play()
	end)
end

-- スキル画面
local function showSkills()
	createModal("スキル", function(content)
		local emptyLabel = Instance.new("TextLabel")
		emptyLabel.Size = UDim2.fromScale(1, 1)
		emptyLabel.BackgroundTransparency = 1
		emptyLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
		emptyLabel.TextStrokeTransparency = 0.7
		emptyLabel.Font = Enum.Font.Gotham
		emptyLabel.TextSize = 18
		emptyLabel.Text = "習得済みスキルなし"
		emptyLabel.TextTransparency = 1
		emptyLabel.ZIndex = 53
		emptyLabel.Parent = content

		TweenService:Create(emptyLabel, TweenInfo.new(0.2), {
			TextTransparency = 0,
			TextStrokeTransparency = 0.7
		}):Play()
	end)
end

-- 戦歴画面
local function showRecords()
	createModal("戦歴", function(content)
		print("[MenuUI] ========================================")
		print("[MenuUI] 戦歴画面を開きました")
		print("[MenuUI] キャッシュされた値:", cachedStats.MonstersDefeated or 0)

		-- ラベルを先に作成
		local label = Instance.new("TextLabel")
		label.Size = UDim2.new(1, 0, 0, 40)
		label.Position = UDim2.new(0, 0, 0, 0)
		label.BackgroundTransparency = 1
		label.TextColor3 = Color3.fromRGB(255, 255, 255)
		label.TextStrokeTransparency = 0.7
		label.Font = Enum.Font.Gotham
		label.TextSize = 20
		label.Text = string.format("倒したモンスター数: %d (取得中...)", cachedStats.MonstersDefeated or 0)
		label.TextXAlignment = Enum.TextXAlignment.Left
		label.TextTransparency = 1
		label.ZIndex = 53
		label.Parent = content

		TweenService:Create(label, TweenInfo.new(0.2), {
			TextTransparency = 0,
			TextStrokeTransparency = 0.7
		}):Play()

		-- サーバーに最新の戦歴をリクエスト
		local RequestStatsDetailEvent = ReplicatedStorage:FindFirstChild("RequestStatsDetail")
		if RequestStatsDetailEvent then
			print("[MenuUI] サーバーに詳細ステータスをリクエスト中...")
			RequestStatsDetailEvent:FireServer()

			-- 0.5秒後にラベルを更新（サーバーからのレスポンスを待つ）
			task.delay(0.5, function()
				if label and label.Parent then
					label.Text = string.format("倒したモンスター数: %d", cachedStats.MonstersDefeated or 0)
					print("[MenuUI] ラベル更新: MonstersDefeated =", cachedStats.MonstersDefeated)
				end
			end)
		else
			warn("[MenuUI] RequestStatsDetailEventが見つかりません")
		end

		print("[MenuUI] ========================================")
	end)
end

-- 設定画面
local function showSettings()
	createModal("設定", function(content)
		local bgmLabel = Instance.new("TextLabel")
		bgmLabel.Size = UDim2.new(1, 0, 0, 30)
		bgmLabel.Position = UDim2.new(0, 0, 0, 20)
		bgmLabel.BackgroundTransparency = 1
		bgmLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
		bgmLabel.TextStrokeTransparency = 0.7
		bgmLabel.Font = Enum.Font.Gotham
		bgmLabel.TextSize = 18
		bgmLabel.Text = "BGM音量（未実装）"
		bgmLabel.TextXAlignment = Enum.TextXAlignment.Left
		bgmLabel.TextTransparency = 1
		bgmLabel.ZIndex = 53
		bgmLabel.Parent = content

		TweenService:Create(bgmLabel, TweenInfo.new(0.2), {
			TextTransparency = 0,
			TextStrokeTransparency = 0.7
		}):Play()

		local seLabel = Instance.new("TextLabel")
		seLabel.Size = UDim2.new(1, 0, 0, 30)
		seLabel.Position = UDim2.new(0, 0, 0, 80)
		seLabel.BackgroundTransparency = 1
		seLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
		seLabel.TextStrokeTransparency = 0.7
		seLabel.Font = Enum.Font.Gotham
		seLabel.TextSize = 18
		seLabel.Text = "SE音量（未実装）"
		seLabel.TextXAlignment = Enum.TextXAlignment.Left
		seLabel.TextTransparency = 1
		seLabel.ZIndex = 53
		seLabel.Parent = content

		TweenService:Create(seLabel, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0.05), {
			TextTransparency = 0,
			TextStrokeTransparency = 0.7
		}):Play()
	end)
end

-- ログアウト確認
local function showLogout()
	createModal("ログアウト", function(content)
		local warningLabel = Instance.new("TextLabel")
		warningLabel.Size = UDim2.new(1, 0, 0, 60)
		warningLabel.Position = UDim2.new(0, 0, 0, 20)
		warningLabel.BackgroundTransparency = 1
		warningLabel.TextColor3 = Color3.fromRGB(255, 200, 100)
		warningLabel.TextStrokeTransparency = 0.7
		warningLabel.Font = Enum.Font.Gotham
		warningLabel.TextSize = 18
		warningLabel.Text = "本当にログアウトしますか？\n\n※ 現在、進行状況は保存されません"
		warningLabel.TextWrapped = true
		warningLabel.TextTransparency = 1
		warningLabel.ZIndex = 53
		warningLabel.Parent = content

		TweenService:Create(warningLabel, TweenInfo.new(0.2), {
			TextTransparency = 0,
			TextStrokeTransparency = 0.7
		}):Play()

		local logoutButton = Instance.new("TextButton")
		logoutButton.Size = UDim2.new(0, 150, 0, 50)
		logoutButton.Position = UDim2.new(0.5, -160, 1, -70)
		logoutButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
		logoutButton.BackgroundTransparency = 1
		logoutButton.BorderSizePixel = 0
		logoutButton.Font = Enum.Font.GothamBold
		logoutButton.TextSize = 18
		logoutButton.Text = "ログアウト"
		logoutButton.TextColor3 = Color3.new(1, 1, 1)
		logoutButton.TextTransparency = 1
		logoutButton.ZIndex = 53
		logoutButton.Parent = content

		TweenService:Create(logoutButton, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0.1), {
			BackgroundTransparency = 0.2,
			TextTransparency = 0
		}):Play()

		local logoutCorner = Instance.new("UICorner")
		logoutCorner.CornerRadius = UDim.new(0, 8)
		logoutCorner.Parent = logoutButton

		logoutButton.MouseButton1Click:Connect(function()
			player:Kick("ログアウトしました")
		end)

		local cancelButton = Instance.new("TextButton")
		cancelButton.Size = UDim2.new(0, 150, 0, 50)
		cancelButton.Position = UDim2.new(0.5, 10, 1, -70)
		cancelButton.BackgroundColor3 = Color3.fromRGB(52, 152, 219)
		cancelButton.BackgroundTransparency = 1
		cancelButton.BorderSizePixel = 0
		cancelButton.Font = Enum.Font.GothamBold
		cancelButton.TextSize = 18
		cancelButton.Text = "キャンセル"
		cancelButton.TextColor3 = Color3.new(1, 1, 1)
		cancelButton.TextTransparency = 1
		cancelButton.ZIndex = 53
		cancelButton.Parent = content

		TweenService:Create(cancelButton, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0.15), {
			BackgroundTransparency = 0.2,
			TextTransparency = 0
		}):Play()

		local cancelCorner = Instance.new("UICorner")
		cancelCorner.CornerRadius = UDim.new(0, 8)
		cancelCorner.Parent = cancelButton

		cancelButton.MouseButton1Click:Connect(function()
			closeModal()
		end)
	end)
end

-- メニューUI作成
local function createMenuUI()
	menuGui = Instance.new("ScreenGui")
	menuGui.Name = "MenuUI"
	menuGui.ResetOnSpawn = false
	menuGui.Parent = playerGui

	menuFrame = Instance.new("Frame")
	menuFrame.Name = "MenuFrame"
	menuFrame.Size = UDim2.new(0, 250, 0, 120)
	menuFrame.Position = UDim2.new(1, -270, 1, -270)
	menuFrame.BackgroundTransparency = 1
	menuFrame.Parent = menuGui

	local menuButtons = {
		{name = "ステータス", func = showStatus, row = 0, col = 0},
		{name = "アイテム", func = showItems, row = 0, col = 1},
		{name = "スキル", func = showSkills, row = 0, col = 2},
		{name = "戦歴", func = showRecords, row = 1, col = 0},
		{name = "設定", func = showSettings, row = 1, col = 1},
		{name = "ログアウト", func = showLogout, row = 1, col = 2},
	}

	local buttonWidth = 80
	local buttonHeight = 50
	local spacing = 5

	for _, btnData in ipairs(menuButtons) do
		local button = Instance.new("TextButton")
		button.Name = btnData.name .. "Button"
		button.Size = UDim2.new(0, buttonWidth, 0, buttonHeight)
		button.Position = UDim2.new(0, btnData.col * (buttonWidth + spacing), 0, btnData.row * (buttonHeight + spacing))
		button.BackgroundColor3 = Color3.fromRGB(50, 50, 60)
		button.BackgroundTransparency = 0.2
		button.BorderSizePixel = 0
		button.Font = Enum.Font.GothamBold
		button.TextSize = 14
		button.Text = btnData.name
		button.TextColor3 = Color3.new(1, 1, 1)
		button.TextStrokeTransparency = 0.7
		button.Parent = menuFrame

		local corner = Instance.new("UICorner")
		corner.CornerRadius = UDim.new(0, 8)
		corner.Parent = button

		button.MouseButton1Click:Connect(function()
			if not isInBattle then
				btnData.func()
			end
		end)

		button.MouseEnter:Connect(function()
			if not isInBattle then
				button.BackgroundColor3 = Color3.fromRGB(70, 70, 80)
			end
		end)
		button.MouseLeave:Connect(function()
			button.BackgroundColor3 = Color3.fromRGB(50, 50, 60)
		end)
	end

	print("[MenuUI] メニューUI作成完了")
end

createMenuUI()

if RequestStatusEvent then
	task.wait(1)
	RequestStatusEvent:FireServer()
end

print("[MenuUI] 初期化完了")
===== ./StartPlayerScripts/LevelUpUI.client.lua =====
-- StarterPlayer/StarterPlayerScripts/LevelUpUI.client.lua
-- レベルアップ演出

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

print("[LevelUpUI] 初期化中...")

-- UI要素
local levelUpGui = nil

-- レベルアップ演出を表示
local function showLevelUp(level, maxHP, speed, attack, defense)
	print(("[LevelUpUI] ========================================"):format())
	print(("[LevelUpUI] レベルアップ演出開始！"):format())
	print(("[LevelUpUI] Lv.%d, HP:%d, 素早さ:%d, 攻撃:%d, 守備:%d"):format(
		level, maxHP, speed, attack, defense
		))
	print(("[LevelUpUI] ========================================"):format())

	-- 既存のGUIを削除
	if levelUpGui then
		levelUpGui:Destroy()
	end

	-- 新しいGUIを作成
	levelUpGui = Instance.new("ScreenGui")
	levelUpGui.Name = "LevelUpUI"
	levelUpGui.ResetOnSpawn = false
	levelUpGui.Parent = playerGui

	-- 背景（暗い）
	local background = Instance.new("Frame")
	background.Size = UDim2.fromScale(1, 1)
	background.Position = UDim2.fromScale(0, 0)
	background.BackgroundColor3 = Color3.new(0, 0, 0)
	background.BackgroundTransparency = 1
	background.BorderSizePixel = 0
	background.ZIndex = 100
	background.Parent = levelUpGui

	-- 背景を暗くする
	local bgTween = TweenService:Create(background, TweenInfo.new(0.3), {
		BackgroundTransparency = 0.5
	})
	bgTween:Play()

	-- レベルアップテキスト
	local levelUpText = Instance.new("TextLabel")
	levelUpText.Size = UDim2.new(0, 600, 0, 100)
	levelUpText.Position = UDim2.new(0.5, -300, 0.35, -50)
	levelUpText.BackgroundTransparency = 1
	levelUpText.TextColor3 = Color3.fromRGB(255, 215, 0)
	levelUpText.TextStrokeTransparency = 0
	levelUpText.TextStrokeColor3 = Color3.new(0, 0, 0)
	levelUpText.Font = Enum.Font.GothamBold
	levelUpText.TextSize = 60
	levelUpText.Text = "LEVEL UP!"
	levelUpText.TextTransparency = 1
	levelUpText.ZIndex = 101
	levelUpText.Parent = levelUpGui

	-- テキストをフェードイン
	local textTween = TweenService:Create(levelUpText, TweenInfo.new(0.5), {
		TextTransparency = 0,
		TextStrokeTransparency = 0
	})
	textTween:Play()

	-- レベル表示
	local levelText = Instance.new("TextLabel")
	levelText.Size = UDim2.new(0, 600, 0, 60)
	levelText.Position = UDim2.new(0.5, -300, 0.45, 0)
	levelText.BackgroundTransparency = 1
	levelText.TextColor3 = Color3.fromRGB(255, 255, 255)
	levelText.TextStrokeTransparency = 0
	levelText.Font = Enum.Font.GothamBold
	levelText.TextSize = 40
	levelText.Text = string.format("Level %d", level)
	levelText.TextTransparency = 1
	levelText.ZIndex = 101
	levelText.Parent = levelUpGui

	-- レベルテキストをフェードイン
	local levelTextTween = TweenService:Create(levelText, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0.2), {
		TextTransparency = 0,
		TextStrokeTransparency = 0.5
	})
	levelTextTween:Play()

	-- ステータス表示フレーム
	local statsFrame = Instance.new("Frame")
	statsFrame.Size = UDim2.new(0, 400, 0, 150)
	statsFrame.Position = UDim2.new(0.5, -200, 0.55, 0)
	statsFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
	statsFrame.BackgroundTransparency = 1
	statsFrame.BorderSizePixel = 0
	statsFrame.ZIndex = 101
	statsFrame.Parent = levelUpGui

	-- 角を丸くする
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 10)
	corner.Parent = statsFrame

	-- フレームをフェードイン
	local frameTween = TweenService:Create(statsFrame, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0.3), {
		BackgroundTransparency = 0.2
	})
	frameTween:Play()

	-- ステータステキスト
	local statsText = Instance.new("TextLabel")
	statsText.Size = UDim2.new(1, -40, 1, -40)
	statsText.Position = UDim2.new(0, 20, 0, 20)
	statsText.BackgroundTransparency = 1
	statsText.TextColor3 = Color3.fromRGB(200, 255, 200)
	statsText.TextStrokeTransparency = 0.5
	statsText.Font = Enum.Font.Gotham
	statsText.TextSize = 20
	statsText.Text = string.format(
		"HP: %d (+10)\n素早さ: %d (+2)\n攻撃力: %d (+2)\n守備力: %d (+2)",
		maxHP, speed, attack, defense
	)
	statsText.TextTransparency = 1
	statsText.TextYAlignment = Enum.TextYAlignment.Top
	statsText.ZIndex = 102
	statsText.Parent = statsFrame

	-- ステータステキストをフェードイン
	local statsTween = TweenService:Create(statsText, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0.4), {
		TextTransparency = 0,
		TextStrokeTransparency = 0.5
	})
	statsTween:Play()

	-- 2.5秒後にフェードアウト
	task.delay(2.5, function()
		local fadeOutTween = TweenService:Create(background, TweenInfo.new(0.5), {
			BackgroundTransparency = 1
		})
		fadeOutTween:Play()

		TweenService:Create(levelUpText, TweenInfo.new(0.5), {
			TextTransparency = 1,
			TextStrokeTransparency = 1
		}):Play()

		TweenService:Create(levelText, TweenInfo.new(0.5), {
			TextTransparency = 1,
			TextStrokeTransparency = 1
		}):Play()

		TweenService:Create(statsFrame, TweenInfo.new(0.5), {
			BackgroundTransparency = 1
		}):Play()

		TweenService:Create(statsText, TweenInfo.new(0.5), {
			TextTransparency = 1,
			TextStrokeTransparency = 1
		}):Play()

		-- 3秒後に削除
		task.wait(0.5)
		if levelUpGui then
			levelUpGui:Destroy()
			levelUpGui = nil
		end
	end)
end

-- RemoteEventを待機
local LevelUpEvent = ReplicatedStorage:WaitForChild("LevelUp", 10)
if LevelUpEvent then
	LevelUpEvent.OnClientEvent:Connect(showLevelUp)
	print("[LevelUpUI] LevelUpイベント接続完了")
else
	warn("[LevelUpUI] LevelUpイベントが見つかりません")
end

print("[LevelUpUI] 初期化完了")
===== ./StartPlayerScripts/BattleUI.client.lua =====
-- StarterPlayer/StarterPlayerScripts/BattleUI.client.lua
-- タイピングバトルUI制御（クライアント側）

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local StarterGui = game:GetService("StarterGui")
local ContextActionService = game:GetService("ContextActionService")
local LocalizationService = game:GetService("LocalizationService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

print("[BattleUI] クライアント起動中...")

-- ユーザーのロケールを取得
local userLocale = string.lower(LocalizationService.RobloxLocaleId)
local localeCode = string.match(userLocale, "^(%a+)") or "en"  -- "ja-jp" → "ja"

-- 【開発用】強制的に日本語表示（本番では削除可能）
local FORCE_LOCALE = "ja"  -- ここを変更すると表示言語が変わる（nil で自動検出）
if FORCE_LOCALE then
	localeCode = FORCE_LOCALE
	print(("[BattleUI] 言語を強制設定: %s"):format(localeCode))
end

print(("[BattleUI] ユーザーロケール: %s → 表示言語: %s"):format(userLocale, localeCode))

-- RemoteEventsを待機
local BattleStartEvent = ReplicatedStorage:WaitForChild("BattleStart", 30)
local BattleEndEvent = ReplicatedStorage:WaitForChild("BattleEnd", 30)
local BattleDamageEvent = ReplicatedStorage:WaitForChild("BattleDamage", 30)

if not BattleStartEvent or not BattleEndEvent or not BattleDamageEvent then
	warn("[BattleUI] RemoteEventの取得に失敗しました")
	return
end

-- 単語リストを読み込み
local TypingWords = require(ReplicatedStorage:WaitForChild("TypingWords"))

-- デバッグ：単語リストの内容を確認
print("[BattleUI DEBUG] TypingWords.level_1[1]:")
if TypingWords.level_1 and TypingWords.level_1[1] then
	local firstWord = TypingWords.level_1[1]
	print("  Type:", type(firstWord))
	if type(firstWord) == "table" then
		print("  word:", firstWord.word)
		print("  ja:", firstWord.ja)
	else
		print("  Value:", firstWord)
	end
end

print("[BattleUI] RemoteEvents取得完了")

-- 状態
local inBattle = false
local currentWord = ""
local currentWordData = nil  -- 翻訳データを含む単語情報
local lastWord = nil  -- 前回の単語（連続回避用）
local currentIndex = 1
local typingLevels = {}
local currentBattleTimeout = nil
local monsterHP = 0
local monsterMaxHP = 0
local playerHP = 0  -- プレイヤーの現在HP
local playerMaxHP = 0  -- プレイヤーの最大HP
local damagePerKey = 1

-- カメラ設定保存用
local originalCameraMaxZoom = nil
local originalCameraMinZoom = nil

-- UI要素
local battleGui = nil
local darkenFrame = nil
local wordFrame = nil
local wordLabel = nil
local translationLabel = nil  -- 翻訳表示用
local hpBarBackground = nil
local hpBarFill = nil
local hpLabel = nil

-- システムキーをブロックする関数
local function blockSystemKeys()
	-- カメラズームを完全に固定
	originalCameraMaxZoom = player.CameraMaxZoomDistance
	originalCameraMinZoom = player.CameraMinZoomDistance

	-- 現在のズーム距離を取得して固定
	local camera = workspace.CurrentCamera
	local currentZoom = (camera.CFrame.Position - player.Character.HumanoidRootPart.Position).Magnitude
	player.CameraMaxZoomDistance = currentZoom
	player.CameraMinZoomDistance = currentZoom

	print(("[BattleUI] カメラを固定しました (距離: %.1f)"):format(currentZoom))
end

-- ブロック解除
local function unblockSystemKeys()
	-- カメラズームを復元
	if originalCameraMaxZoom and originalCameraMinZoom then
		player.CameraMaxZoomDistance = originalCameraMaxZoom
		player.CameraMinZoomDistance = originalCameraMinZoom
		print("[BattleUI] カメラ設定を復元しました")
	end
end

-- 【forward declaration】
local onBattleEnd
local updateDisplay
local setNextWord

-- HPバーの色を取得（HP割合に応じて変化）
local function getHPColor(hpPercent)
	if hpPercent > 0.6 then
		-- 緑
		return Color3.fromRGB(46, 204, 113)
	elseif hpPercent > 0.3 then
		-- 黄色
		return Color3.fromRGB(241, 196, 15)
	else
		-- 赤
		return Color3.fromRGB(231, 76, 60)
	end
end

-- 表示を更新
updateDisplay = function()
	if not wordLabel then return end

	-- 入力済み文字を緑、未入力を白で表示
	local typedPart = string.sub(currentWord, 1, currentIndex - 1)
	local remainingPart = string.sub(currentWord, currentIndex)

	wordLabel.Text = string.format('<font color="#00FF00">%s</font>%s', typedPart, remainingPart)

	-- 敵HPバー更新
	if hpBarFill and hpLabel then
		local hpPercent = monsterHP / monsterMaxHP

		-- バーの長さをアニメーション
		local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
		local tween = TweenService:Create(hpBarFill, tweenInfo, {
			Size = UDim2.new(hpPercent, 0, 1, 0)
		})
		tween:Play()

		-- 色を変更
		hpBarFill.BackgroundColor3 = getHPColor(hpPercent)

		-- テキスト更新
		hpLabel.Text = string.format("Enemy HP: %d / %d", monsterHP, monsterMaxHP)
	end
end

-- 単語を選択する関数
local function selectWord()
	if #typingLevels == 0 then
		-- デフォルト：level_1のみ
		typingLevels = {{level = "level_1", weight = 100}}
	end

	-- 重み付きランダム選択
	local totalWeight = 0
	for _, config in ipairs(typingLevels) do
		totalWeight = totalWeight + config.weight
	end

	local randomValue = math.random(1, totalWeight)
	local cumulativeWeight = 0
	local selectedLevel = "level_1"

	for _, config in ipairs(typingLevels) do
		cumulativeWeight = cumulativeWeight + config.weight
		if randomValue <= cumulativeWeight then
			selectedLevel = config.level
			break
		end
	end

	-- 選択されたレベルから単語を取得
	local wordList = TypingWords[selectedLevel]
	if wordList and #wordList > 0 then
		-- 前回と同じ単語を避ける（最大5回まで再抽選）
		local wordData = nil
		local attempts = 0

		repeat
			wordData = wordList[math.random(1, #wordList)]
			attempts = attempts + 1

			-- 新形式（テーブル）か旧形式（文字列）か判定
			local currentWordStr = type(wordData) == "table" and wordData.word or wordData

			-- 前回と違う単語が出たら、または5回試したらループ終了
			if currentWordStr ~= lastWord or attempts >= 5 or #wordList == 1 then
				break
			end
		until false

		-- 新形式（テーブル）か旧形式（文字列）か判定
		if type(wordData) == "table" then
			return wordData
		else
			-- 旧形式の場合は互換性のためテーブルに変換
			return {word = wordData}
		end
	else
		return {word = "apple", ja = "りんご"}  -- フォールバック
	end
end

-- 次の単語を設定
setNextWord = function()
	currentWordData = selectWord()
	currentWord = currentWordData.word
	currentIndex = 1

	-- 今回の単語を記憶（次回の連続回避用）
	lastWord = currentWord

	print(("[BattleUI DEBUG] currentWordData:"):format())
	print(currentWordData)
	print(("[BattleUI DEBUG] localeCode: %s"):format(localeCode))

	-- 翻訳を表示（フォールバック付き）
	if translationLabel then
		-- 優先順位：指定言語 → 日本語 → スペイン語 → フランス語 → 空
		local translation = currentWordData[localeCode]
			or currentWordData.ja
			or currentWordData.es
			or currentWordData.fr
			or ""

		translationLabel.Text = translation
		translationLabel.Visible = translation ~= ""
		print(("[BattleUI DEBUG] translation: %s"):format(translation))
	else
		warn("[BattleUI DEBUG] translationLabel が nil です！")
	end

	updateDisplay()
	print(("[BattleUI] 次の単語: %s (%s)"):format(currentWord, currentWordData[localeCode] or currentWordData.ja or ""))
end

-- UI作成
local function createBattleUI()
	battleGui = Instance.new("ScreenGui")
	battleGui.Name = "BattleUI"
	battleGui.ResetOnSpawn = false
	battleGui.Enabled = false
	battleGui.Parent = playerGui

	-- 暗転用フレーム
	darkenFrame = Instance.new("Frame")
	darkenFrame.Name = "DarkenFrame"
	darkenFrame.Size = UDim2.fromScale(1, 1)
	darkenFrame.Position = UDim2.fromScale(0, 0)
	darkenFrame.BackgroundColor3 = Color3.new(0, 0, 0)
	darkenFrame.BackgroundTransparency = 1
	darkenFrame.BorderSizePixel = 0
	darkenFrame.ZIndex = 1
	darkenFrame.Parent = battleGui

	-- 敵HPバー背景
	hpBarBackground = Instance.new("Frame")
	hpBarBackground.Name = "HPBarBackground"
	hpBarBackground.Size = UDim2.new(0, 500, 0, 40)
	hpBarBackground.Position = UDim2.new(0.5, -250, 0.25, 0)
	hpBarBackground.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
	hpBarBackground.BorderSizePixel = 0
	hpBarBackground.ZIndex = 2
	hpBarBackground.Parent = battleGui

	-- HPバー背景の角を丸くする
	local hpBarCorner = Instance.new("UICorner")
	hpBarCorner.CornerRadius = UDim.new(0, 8)
	hpBarCorner.Parent = hpBarBackground

	-- HPバー（塗りつぶし部分）
	hpBarFill = Instance.new("Frame")
	hpBarFill.Name = "HPBarFill"
	hpBarFill.Size = UDim2.new(1, 0, 1, 0)
	hpBarFill.Position = UDim2.new(0, 0, 0, 0)
	hpBarFill.BackgroundColor3 = Color3.fromRGB(46, 204, 113)
	hpBarFill.BorderSizePixel = 0
	hpBarFill.ZIndex = 3
	hpBarFill.Parent = hpBarBackground

	-- HPバーの角を丸くする
	local hpFillCorner = Instance.new("UICorner")
	hpFillCorner.CornerRadius = UDim.new(0, 8)
	hpFillCorner.Parent = hpBarFill

	-- HPテキスト（バーの上に表示）
	hpLabel = Instance.new("TextLabel")
	hpLabel.Name = "HPLabel"
	hpLabel.Size = UDim2.new(1, 0, 1, 0)
	hpLabel.Position = UDim2.new(0, 0, 0, 0)
	hpLabel.BackgroundTransparency = 1
	hpLabel.TextColor3 = Color3.new(1, 1, 1)
	hpLabel.TextStrokeTransparency = 0.5
	hpLabel.Font = Enum.Font.GothamBold
	hpLabel.TextSize = 20
	hpLabel.Text = "HP: 10 / 10"
	hpLabel.ZIndex = 4
	hpLabel.Parent = hpBarBackground

	-- 単語表示用フレーム（枠）
	wordFrame = Instance.new("Frame")
	wordFrame.Name = "WordFrame"
	wordFrame.Size = UDim2.new(0, 700, 0, 150)
	wordFrame.Position = UDim2.new(0.5, -350, 0.5, -75)
	wordFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
	wordFrame.BorderSizePixel = 3
	wordFrame.BorderColor3 = Color3.fromRGB(100, 200, 255)
	wordFrame.ZIndex = 2
	wordFrame.Parent = battleGui

	-- 枠の角を丸くする
	local wordFrameCorner = Instance.new("UICorner")
	wordFrameCorner.CornerRadius = UDim.new(0, 12)
	wordFrameCorner.Parent = wordFrame

	-- 枠に光るエフェクト（UIStroke）
	local wordFrameStroke = Instance.new("UIStroke")
	wordFrameStroke.Color = Color3.fromRGB(100, 200, 255)
	wordFrameStroke.Thickness = 3
	wordFrameStroke.Transparency = 0
	wordFrameStroke.Parent = wordFrame

	-- 単語表示（RichText対応）
	wordLabel = Instance.new("TextLabel")
	wordLabel.Name = "WordLabel"
	wordLabel.Size = UDim2.new(1, -40, 0.6, 0)
	wordLabel.Position = UDim2.new(0, 20, 0, 10)
	wordLabel.BackgroundTransparency = 1
	wordLabel.TextColor3 = Color3.new(1, 1, 1)
	wordLabel.TextStrokeTransparency = 0
	wordLabel.Font = Enum.Font.GothamBold
	wordLabel.TextSize = 60
	wordLabel.Text = "apple"
	wordLabel.RichText = true
	wordLabel.ZIndex = 3
	wordLabel.Parent = wordFrame

	-- 翻訳表示（単語の下）
	translationLabel = Instance.new("TextLabel")
	translationLabel.Name = "TranslationLabel"
	translationLabel.Size = UDim2.new(1, -40, 0.35, 0)
	translationLabel.Position = UDim2.new(0, 20, 0.65, 0)
	translationLabel.BackgroundTransparency = 1
	translationLabel.TextColor3 = Color3.fromRGB(150, 200, 255)
	translationLabel.TextStrokeTransparency = 0.3
	translationLabel.Font = Enum.Font.Gotham
	translationLabel.TextSize = 28
	translationLabel.Text = "テスト"  -- デバッグ用の初期値
	translationLabel.TextYAlignment = Enum.TextYAlignment.Top
	translationLabel.Visible = true
	translationLabel.ZIndex = 3
	translationLabel.Parent = wordFrame

	print("[BattleUI DEBUG] translationLabel 作成完了")

	print("[BattleUI] UI作成完了")
end

local Sounds = ReplicatedStorage:WaitForChild("Sounds", 10)
local TypingCorrectSound = Sounds and Sounds:FindFirstChild("TypingCorrect")
local TypingErrorSound = Sounds and Sounds:FindFirstChild("TypingError")

if not TypingCorrectSound then
	warn("[BattleUI] TypingCorrect効果音が見つかりません")
end
if not TypingErrorSound then
	warn("[BattleUI] TypingError効果音が見つかりません")
end

-- バトル開始処理
local function onBattleStart(monsterName, hp, maxHP, damage, levels, pHP, pMaxHP)
	print("[BattleUI] === onBattleStart呼び出し ===")

	-- nil チェックとデフォルト値
	monsterName = monsterName or "Unknown"
	hp = hp or 10
	maxHP = maxHP or 10
	damage = damage or 1
	levels = levels or {{level = "level_1", weight = 100}}
	pHP = pHP or 100
	pMaxHP = pMaxHP or 100

	print(("[BattleUI] バトル開始: vs %s (敵HP: %d, プレイヤーHP: %d/%d, Damage: %d)"):format(
		monsterName, hp, pHP, pMaxHP, damage
		))

	if inBattle then
		print("[BattleUI DEBUG] すでに戦闘中")
		return
	end

	inBattle = true
	monsterHP = hp
	monsterMaxHP = maxHP
	playerHP = pHP
	playerMaxHP = pMaxHP
	damagePerKey = damage
	typingLevels = levels

	-- システムキーをブロック
	blockSystemKeys()

	print("[BattleUI] プレイヤー停止処理開始")

	-- プレイヤーの入力を完全にブロック
	local character = player.Character
	if character then
		local humanoid = character:FindFirstChildOfClass("Humanoid")
		if humanoid then
			humanoid.WalkSpeed = 0
			humanoid.JumpPower = 0
			humanoid.JumpHeight = 0
		end
	end

	print("[BattleUI] RobloxのUIを無効化")

	-- RobloxのUIを無効化
	pcall(function()
		StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Chat, false)
		StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, false)
		StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, false)
		StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.EmotesMenu, false)
	end)

	print("[BattleUI] UIを表示")

	battleGui.Enabled = true

	-- 【重要】RichTextを確実に有効化、全ラベルをリセット
	print("[BattleUI] UI要素をリセット")
	if wordLabel then
		wordLabel.RichText = true
		wordLabel.TextColor3 = Color3.new(1, 1, 1)
		wordLabel.Text = ""
		wordLabel.TextTransparency = 0  -- 追加
		wordLabel.TextStrokeTransparency = 0  -- 追加
	end
	if translationLabel then
		translationLabel.TextColor3 = Color3.fromRGB(150, 200, 255)
		translationLabel.Text = ""
		translationLabel.Visible = true
		translationLabel.TextTransparency = 0  -- 追加
		translationLabel.TextStrokeTransparency = 0.3  -- 追加
	end
	if hpLabel then
		hpLabel.TextColor3 = Color3.new(1, 1, 1)
		hpLabel.Text = ""
		hpLabel.TextTransparency = 0  -- 追加
		hpLabel.TextStrokeTransparency = 0.5  -- 追加
	end
	if hpBarFill then
		hpBarFill.Size = UDim2.new(1, 0, 1, 0)
		hpBarFill.BackgroundColor3 = Color3.fromRGB(46, 204, 113)
		hpBarFill.BackgroundTransparency = 0  -- 追加
	end
	if hpBarBackground then
		hpBarBackground.BackgroundTransparency = 0  -- 追加
	end
	if playerHPBarFill then
		playerHPBarFill.Size = UDim2.new(1, 0, 1, 0)
		playerHPBarFill.BackgroundColor3 = Color3.fromRGB(46, 204, 113)
	end

	-- 枠の色をリセット（青に戻す）
	if wordFrame then
		wordFrame.BorderColor3 = Color3.fromRGB(100, 200, 255)
		wordFrame.BackgroundTransparency = 0.2  -- 追加
		local frameStroke = wordFrame:FindFirstChildOfClass("UIStroke")
		if frameStroke then
			frameStroke.Color = Color3.fromRGB(100, 200, 255)
			frameStroke.Transparency = 0  -- 追加
		end
	end

	-- 背景の透明度をリセット
	if darkenFrame then
		darkenFrame.BackgroundTransparency = 0.4  -- 追加
	end
	print("[BattleUI] 暗転処理")

	-- 画面を薄暗くする
	darkenFrame.BackgroundTransparency = 0.4

	print("[BattleUI] 単語設定")

	-- 最初の単語を設定
	setNextWord()

	print("[BattleUI] タイムアウト設定")

	-- タイムアウト機能：30秒経過したら強制終了
	currentBattleTimeout = task.delay(30, function()
		if inBattle then
			warn("[BattleUI] バトルタイムアウト！強制終了します")
			onBattleEnd(false)
		end
	end)

	print("[BattleUI] === バトル開始処理完了 ===")
end

-- バトル終了処理
onBattleEnd = function(victory)
	print("[BattleUI] === バトル終了開始: " .. tostring(victory) .. " ===")

	-- 既にバトルが終了している場合はスキップ
	if not inBattle and not battleGui.Enabled then
		print("[BattleUI] 既にバトル終了済み")
		return
	end

	-- 【最優先】バトル状態を即座にクリア（キー入力を停止）
	inBattle = false
	currentWord = ""
	currentWordData = nil
	currentIndex = 1
	playerHP = 0
	playerMaxHP = 0

	-- タイムアウトをキャンセル
	if currentBattleTimeout then
		task.cancel(currentBattleTimeout)
		currentBattleTimeout = nil
	end

	-- 勝利時の処理
	-- 勝利時の処理
	if victory then
		-- システムキーのブロックを解除
		unblockSystemKeys()

		print("[BattleUI] Roblox UI再有効化")

		-- Roblox UIを再有効化
		pcall(function()
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Chat, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.EmotesMenu, true)
		end)

		-- 勝利メッセージを表示
		if wordLabel then
			wordLabel.RichText = false
			wordLabel.Text = "VICTORY!"
			wordLabel.TextColor3 = Color3.fromRGB(255, 215, 0)
			wordLabel.TextTransparency = 0
			wordLabel.TextStrokeTransparency = 0

			-- 0.5秒かけてフェードアウト
			TweenService:Create(wordLabel, TweenInfo.new(0.5), {
				TextTransparency = 1,
				TextStrokeTransparency = 1
			}):Play()
		end

		-- 翻訳ラベルを非表示
		if translationLabel then
			translationLabel.Visible = false
		end

		-- 枠を金色にしてフェードアウト
		if wordFrame then
			wordFrame.BorderColor3 = Color3.fromRGB(255, 215, 0)
			local frameStroke = wordFrame:FindFirstChildOfClass("UIStroke")
			if frameStroke then
				frameStroke.Color = Color3.fromRGB(255, 215, 0)
				TweenService:Create(frameStroke, TweenInfo.new(0.5), {
					Transparency = 1
				}):Play()
			end

			TweenService:Create(wordFrame, TweenInfo.new(0.5), {
				BackgroundTransparency = 1
			}):Play()
		end

		-- HPバーをフェードアウト
		if hpBarBackground then
			TweenService:Create(hpBarBackground, TweenInfo.new(0.5), {
				BackgroundTransparency = 1
			}):Play()
		end

		if hpBarFill then
			TweenService:Create(hpBarFill, TweenInfo.new(0.5), {
				BackgroundTransparency = 1
			}):Play()
		end

		if hpLabel then
			TweenService:Create(hpLabel, TweenInfo.new(0.5), {
				TextTransparency = 1,
				TextStrokeTransparency = 1
			}):Play()
		end

		-- プレイヤーの入力ブロックを解除
		local character = player.Character
		if character then
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			if humanoid then
				humanoid.WalkSpeed = 16
				humanoid.JumpPower = 50
				humanoid.JumpHeight = 7.2
			end
		end

		-- 画面を明るく戻す
		TweenService:Create(darkenFrame, TweenInfo.new(0.5), {
			BackgroundTransparency = 1
		}):Play()

		-- UIを非表示にするための遅延実行（別スレッドで）
		task.spawn(function()
			task.wait(0.6)  -- アニメーション完了を待つ
			if not inBattle then  -- まだ次のバトルが始まっていないことを確認
				battleGui.Enabled = false
			end
		end)
	else
		-- 敗北時：UIを維持したまま死亡選択UIを待つ
		print("[BattleUI] 敗北 - UIを維持します")

		-- 敗北メッセージ
		if wordLabel then
			wordLabel.RichText = false
			wordLabel.Text = "DEFEAT..."
			wordLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
		end

		-- 翻訳ラベルを非表示
		if translationLabel then
			translationLabel.Visible = false
		end

		-- 枠の色も変更
		if wordFrame then
			local frameStroke = wordFrame:FindFirstChildOfClass("UIStroke")
			if frameStroke then
				frameStroke.Color = Color3.fromRGB(255, 100, 100)
			end
		end

		-- システムキーのブロックとRoblox UIは維持
		-- プレイヤーの移動制限も維持
		-- 死亡選択UIで選んだ後に解除する
	end

	print("[BattleUI] === バトル終了完了 ===")
end

-- HP更新処理（敵）
local function onHPUpdate(newHP)
	monsterHP = newHP

	print(("[BattleUI] ========================================"):format())
	print(("[BattleUI] 敵HP更新"):format())
	print(("  新HP: %d"):format(newHP))
	print(("  最大HP: %d"):format(monsterMaxHP))
	print(("  HP割合: %.1f%%"):format((newHP / monsterMaxHP) * 100))
	print(("[BattleUI] ========================================"):format())

	updateDisplay()

	-- HPが0になったら勝利（サーバーからの通知も来るが念のため）
	if monsterHP <= 0 then
		print("[BattleUI] ⚠️ 敵HPが0になりました（クライアント側で検出）")
	end
end

-- HP更新処理（プレイヤー）
local function onPlayerHPUpdate(newHP, newMaxHP)
	playerHP = newHP
	playerMaxHP = newMaxHP or playerMaxHP
	updateDisplay()

	print(("[BattleUI] プレイヤーHP更新: %d / %d"):format(playerHP, playerMaxHP))

	-- HPが0になったら敗北（サーバーからの通知も来るが念のため）
	if playerHP <= 0 then
		print("[BattleUI] プレイヤーHPが0になりました")
	end
end

-- システムキーをブロックする入力処理（最優先）
UserInputService.InputBegan:Connect(function(input, gameProcessed)
	-- バトル中にシステムキーが押された場合、先に処理して消費する
	if inBattle and input.UserInputType == Enum.UserInputType.Keyboard then
		local blockedKeys = {
			[Enum.KeyCode.I] = true,
			[Enum.KeyCode.O] = true,
			[Enum.KeyCode.Slash] = true,
			[Enum.KeyCode.Backquote] = true,
			[Enum.KeyCode.Tab] = true,
			[Enum.KeyCode.BackSlash] = true,
			[Enum.KeyCode.Equals] = true,
			[Enum.KeyCode.Minus] = true,
		}

		if blockedKeys[input.KeyCode] then
			-- このキーはタイピング処理に回す（ズームなどは発動させない）
			return
		end
	end
end)

-- キー入力処理
local function onKeyPress(input, gameProcessed)
	if not inBattle then return end

	if input.UserInputType == Enum.UserInputType.Keyboard then
		local keyCode = input.KeyCode
		local keyString = UserInputService:GetStringForKeyCode(keyCode):lower()

		-- 英字のみ受け付け
		if #keyString == 1 and keyString:match("%a") then
			local expectedChar = string.sub(currentWord, currentIndex, currentIndex):lower()

			if keyString == expectedChar then
				-- 正解
				currentIndex = currentIndex + 1

				-- 正解音を再生
				if TypingCorrectSound then
					TypingCorrectSound:Play()
				end

				-- サーバーにダメージ通知
				BattleDamageEvent:FireServer(damagePerKey)

				-- 単語完成チェック
				if currentIndex > #currentWord then
					task.wait(0.3)
					if inBattle then
						setNextWord()
					end
				else
					updateDisplay()
				end
			else
				-- タイプミス
				if TypingErrorSound then
					TypingErrorSound:Play()
				end

				-- 枠を赤く光らせる（点滅エフェクト）
				if wordFrame then
					-- 背景を赤く
					wordFrame.BackgroundColor3 = Color3.fromRGB(255, 50, 50)
					wordFrame.BackgroundTransparency = 0.3  -- 少し濃く

					-- 枠線も赤く
					local frameStroke = wordFrame:FindFirstChildOfClass("UIStroke")
					if frameStroke then
						frameStroke.Color = Color3.fromRGB(255, 50, 50)
					end

					-- 0.3秒かけて元に戻す
					TweenService:Create(wordFrame, TweenInfo.new(0.3), {
						BackgroundColor3 = Color3.fromRGB(30, 30, 40),
						BackgroundTransparency = 0.2
					}):Play()

					if frameStroke then
						TweenService:Create(frameStroke, TweenInfo.new(0.3), {
							Color = Color3.fromRGB(100, 200, 255)
						}):Play()
					end
				end

				-- タイプミス時のダメージをサーバーに通知
				local TypingMistakeEvent = ReplicatedStorage:FindFirstChild("TypingMistake")
				if TypingMistakeEvent then
					TypingMistakeEvent:FireServer()
				end
			end
		end
	end
end

-- 初期化
createBattleUI()

print("[BattleUI] イベント接続中...")
BattleStartEvent.OnClientEvent:Connect(onBattleStart)
BattleEndEvent.OnClientEvent:Connect(onBattleEnd)

-- HP更新イベント（敵）
local HPUpdateEvent = ReplicatedStorage:FindFirstChild("BattleHPUpdate")
if HPUpdateEvent then
	HPUpdateEvent.OnClientEvent:Connect(onHPUpdate)
end

-- HP更新イベント（プレイヤー）
local PlayerHPUpdateEvent = ReplicatedStorage:FindFirstChild("PlayerHPUpdate")

if PlayerHPUpdateEvent then
	PlayerHPUpdateEvent.OnClientEvent:Connect(onPlayerHPUpdate)
else
	warn("[BattleUI] PlayerHPUpdate イベントが見つかりません")
end

UserInputService.InputBegan:Connect(onKeyPress)

-- 緊急脱出用：Escキーで強制終了
UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if input.KeyCode == Enum.KeyCode.Escape and battleGui.Enabled then
		warn("[BattleUI] Escキーで強制終了")

		-- システムキーのブロックを解除
		unblockSystemKeys()

		-- Roblox UIを再有効化
		pcall(function()
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Chat, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.EmotesMenu, true)
		end)

		darkenFrame.BackgroundTransparency = 1
		battleGui.Enabled = false
		inBattle = false
		currentWord = ""
		currentWordData = nil
		currentIndex = 1
		playerHP = 0
		playerMaxHP = 0

		local character = player.Character
		if character then
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			if humanoid then
				humanoid.WalkSpeed = 16
				humanoid.JumpPower = 50
				humanoid.JumpHeight = 7.2
			end
		end
	end
end)

print("[BattleUI] クライアント初期化完了（タイピングモード）")
===== ./StartPlayerScripts/StatusUI.client.lua =====
-- StarterPlayer/StarterPlayerScripts/StatusUI.client.lua
-- 画面左下に常時表示するプレイヤーステータス

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

print("[StatusUI] 初期化中...")

-- 現在のステータス
local currentHP = 100
local currentMaxHP = 100
local currentLevel = 1
local currentExp = 0
local currentExpToNext = 100
local currentGold = 0

-- UI要素
local statusGui = nil
local hpBarBackground = nil
local hpBarFill = nil
local hpLabel = nil
local levelLabel = nil
local expLabel = nil
local goldLabel = nil

-- HPの色を取得
local function getHPColor(hpPercent)
	if hpPercent > 0.6 then
		return Color3.fromRGB(46, 204, 113)  -- 緑
	elseif hpPercent > 0.3 then
		return Color3.fromRGB(241, 196, 15)  -- 黄色
	else
		return Color3.fromRGB(231, 76, 60)  -- 赤
	end
end

-- 表示を更新
local function updateDisplay()
	if hpBarFill and hpLabel then
		local hpPercent = currentHP / currentMaxHP

		-- バーの長さをアニメーション
		local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
		local tween = TweenService:Create(hpBarFill, tweenInfo, {
			Size = UDim2.new(hpPercent, 0, 1, 0)
		})
		tween:Play()

		-- 色を変更
		hpBarFill.BackgroundColor3 = getHPColor(hpPercent)

		-- テキスト更新
		hpLabel.Text = string.format("%d / %d", currentHP, currentMaxHP)
	end

	if levelLabel then
		levelLabel.Text = string.format("Lv.%d", currentLevel)
	end

	if expLabel then
		expLabel.Text = string.format("EXP: %d / %d", currentExp, currentExpToNext)
	end

	if goldLabel then
		goldLabel.Text = string.format("💰 %d G", currentGold)
	end
end

-- UI作成
local function createStatusUI()
	statusGui = Instance.new("ScreenGui")
	statusGui.Name = "StatusUI"
	statusGui.ResetOnSpawn = false
	statusGui.Parent = playerGui

	-- 背景フレーム
	local backgroundFrame = Instance.new("Frame")
	backgroundFrame.Name = "StatusBackground"
	backgroundFrame.Size = UDim2.new(0, 250, 0, 120)
	backgroundFrame.Position = UDim2.new(1, -270, 1, -140)
	backgroundFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
	backgroundFrame.BackgroundTransparency = 0.3
	backgroundFrame.BorderSizePixel = 0
	backgroundFrame.Parent = statusGui

	-- 角を丸くする
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 10)
	corner.Parent = backgroundFrame

	-- レベル表示
	levelLabel = Instance.new("TextLabel")
	levelLabel.Name = "LevelLabel"
	levelLabel.Size = UDim2.new(0, 80, 0, 25)
	levelLabel.Position = UDim2.new(0, 10, 0, 10)
	levelLabel.BackgroundTransparency = 1
	levelLabel.TextColor3 = Color3.fromRGB(255, 215, 0)
	levelLabel.TextStrokeTransparency = 0.5
	levelLabel.Font = Enum.Font.GothamBold
	levelLabel.TextSize = 20
	levelLabel.Text = "Lv.1"
	levelLabel.TextXAlignment = Enum.TextXAlignment.Left
	levelLabel.Parent = backgroundFrame

	-- HPバー背景
	hpBarBackground = Instance.new("Frame")
	hpBarBackground.Name = "HPBarBackground"
	hpBarBackground.Size = UDim2.new(1, -20, 0, 20)
	hpBarBackground.Position = UDim2.new(0, 10, 0, 40)
	hpBarBackground.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
	hpBarBackground.BorderSizePixel = 0
	hpBarBackground.Parent = backgroundFrame

	-- HPバー背景の角を丸くする
	local hpBarCorner = Instance.new("UICorner")
	hpBarCorner.CornerRadius = UDim.new(0, 5)
	hpBarCorner.Parent = hpBarBackground

	-- HPバー（塗りつぶし）
	hpBarFill = Instance.new("Frame")
	hpBarFill.Name = "HPBarFill"
	hpBarFill.Size = UDim2.new(1, 0, 1, 0)
	hpBarFill.Position = UDim2.new(0, 0, 0, 0)
	hpBarFill.BackgroundColor3 = Color3.fromRGB(46, 204, 113)
	hpBarFill.BorderSizePixel = 0
	hpBarFill.Parent = hpBarBackground

	-- HPバーの角を丸くする
	local hpFillCorner = Instance.new("UICorner")
	hpFillCorner.CornerRadius = UDim.new(0, 5)
	hpFillCorner.Parent = hpBarFill

	-- HPテキスト
	hpLabel = Instance.new("TextLabel")
	hpLabel.Name = "HPLabel"
	hpLabel.Size = UDim2.new(1, 0, 1, 0)
	hpLabel.Position = UDim2.new(0, 0, 0, 0)
	hpLabel.BackgroundTransparency = 1
	hpLabel.TextColor3 = Color3.new(1, 1, 1)
	hpLabel.TextStrokeTransparency = 0.5
	hpLabel.Font = Enum.Font.GothamBold
	hpLabel.TextSize = 14
	hpLabel.Text = "100 / 100"
	hpLabel.Parent = hpBarBackground

	-- 経験値表示
	expLabel = Instance.new("TextLabel")
	expLabel.Name = "ExpLabel"
	expLabel.Size = UDim2.new(1, -20, 0, 18)
	expLabel.Position = UDim2.new(0, 10, 0, 65)
	expLabel.BackgroundTransparency = 1
	expLabel.TextColor3 = Color3.fromRGB(150, 200, 255)
	expLabel.TextStrokeTransparency = 0.7
	expLabel.Font = Enum.Font.Gotham
	expLabel.TextSize = 14
	expLabel.Text = "EXP: 0 / 100"
	expLabel.TextXAlignment = Enum.TextXAlignment.Left
	expLabel.Parent = backgroundFrame

	-- ゴールド表示
	goldLabel = Instance.new("TextLabel")
	goldLabel.Name = "GoldLabel"
	goldLabel.Size = UDim2.new(1, -20, 0, 18)
	goldLabel.Position = UDim2.new(0, 10, 0, 88)
	goldLabel.BackgroundTransparency = 1
	goldLabel.TextColor3 = Color3.fromRGB(255, 215, 0)
	goldLabel.TextStrokeTransparency = 0.7
	goldLabel.Font = Enum.Font.GothamBold
	goldLabel.TextSize = 14
	goldLabel.Text = "💰 0 G"
	goldLabel.TextXAlignment = Enum.TextXAlignment.Left
	goldLabel.Parent = backgroundFrame

	print("[StatusUI] UI作成完了")
end

-- ステータス更新イベント
local function onStatusUpdate(hp, maxHP, level, exp, expToNext, gold)
	print(("[StatusUI] ステータス更新受信: HP=%d/%d, Lv=%d, EXP=%d/%d, Gold=%d"):format(
		hp or 0, maxHP or 0, level or 0, exp or 0, expToNext or 0, gold or 0
		))

	currentHP = hp or currentHP
	currentMaxHP = maxHP or currentMaxHP
	currentLevel = level or currentLevel
	currentExp = exp or currentExp
	currentExpToNext = expToNext or currentExpToNext
	currentGold = gold or currentGold

	updateDisplay()
end

-- 初期化
createStatusUI()

print("[StatusUI] RemoteEventを待機中...")

-- RemoteEventを待機（最大30秒）
task.spawn(function()
	local StatusUpdateEvent = ReplicatedStorage:WaitForChild("StatusUpdate", 30)
	if StatusUpdateEvent then
		StatusUpdateEvent.OnClientEvent:Connect(onStatusUpdate)
		print("[StatusUI] StatusUpdateイベント接続完了")

		-- 初回のステータス要求
		task.wait(1)  -- 1秒待ってから要求
		local RequestStatusEvent = ReplicatedStorage:FindFirstChild("RequestStatus")
		if RequestStatusEvent then
			print("[StatusUI] 初回ステータスを要求")
			RequestStatusEvent:FireServer()
		else
			warn("[StatusUI] RequestStatusイベントが見つかりません")
		end
	else
		warn("[StatusUI] StatusUpdateイベントの待機がタイムアウトしました")
	end
end)

print("[StatusUI] 初期化完了")
===== ./StartPlayerScripts/WarpUI.client.lua =====
-- StarterPlayer/StarterPlayerScripts/WarpUI.client.lua
-- ワープ時のロード画面

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- RemoteEventを取得
local warpEvent = ReplicatedStorage:WaitForChild("WarpEvent")

print("[WarpUI] 初期化完了")

-- ロード画面のUI
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "WarpLoadingUI"
screenGui.ResetOnSpawn = false
screenGui.IgnoreGuiInset = true
screenGui.Parent = playerGui

local frame = Instance.new("Frame")
frame.Name = "LoadingFrame"
frame.Size = UDim2.new(1, 0, 1, 0)
frame.BackgroundColor3 = Color3.new(0, 0, 0)
frame.BackgroundTransparency = 1
frame.Visible = false
frame.Parent = screenGui

local label = Instance.new("TextLabel")
label.Size = UDim2.new(0.6, 0, 0.2, 0)
label.Position = UDim2.new(0.2, 0, 0.4, 0)
label.BackgroundTransparency = 1
label.Text = "Loading..."
label.TextColor3 = Color3.new(1, 1, 1)
label.TextScaled = true
label.Font = Enum.Font.SourceSansBold
label.Parent = frame

-- RemoteEventを受信
warpEvent.OnClientEvent:Connect(function(action, zoneName)
	if action == "StartLoading" then
		print("[WarpUI] ロード画面表示:", zoneName)
		label.Text = "Warping to " .. (zoneName or "???") .. "..."
		frame.BackgroundTransparency = 0.3
		frame.Visible = true

		-- フェードイン
		for i = 0.3, 0.7, 0.1 do
			frame.BackgroundTransparency = 1 - i
			task.wait(0.05)
		end

	elseif action == "EndLoading" then
		print("[WarpUI] ロード画面非表示")

		-- フェードアウト
		for i = 0.7, 0, -0.1 do
			frame.BackgroundTransparency = 1 - i
			task.wait(0.05)
		end

		frame.Visible = false
	end
end)
===== ./StartPlayerScripts/DeathUI.client.lua =====
-- StarterPlayer/StarterPlayerScripts/DeathUI.client.lua
-- 死亡時の選択UI（街に戻る / ゴールドロストで復活）

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

print("[DeathUI] 初期化中...")

-- UI要素
local deathGui = nil

-- 死亡UIを表示
local function showDeathUI(currentGold, reviveCost)
	print(("[DeathUI] ========================================"):format())
	print(("[DeathUI] 死亡UI表示"):format())
	print(("[DeathUI] 所持金: %d G, 復活コスト: %d G"):format(currentGold, reviveCost))
	print(("[DeathUI] ========================================"):format())

	-- 既存のGUIを削除
	if deathGui then
		deathGui:Destroy()
	end

	-- 新しいGUIを作成
	deathGui = Instance.new("ScreenGui")
	deathGui.Name = "DeathUI"
	deathGui.ResetOnSpawn = false
	deathGui.Parent = playerGui

	-- 背景（暗い）
	local background = Instance.new("Frame")
	background.Size = UDim2.fromScale(1, 1)
	background.Position = UDim2.fromScale(0, 0)
	background.BackgroundColor3 = Color3.new(0, 0, 0)
	background.BackgroundTransparency = 0.3
	background.BorderSizePixel = 0
	background.ZIndex = 200
	background.Parent = deathGui

	-- タイトル
	local titleText = Instance.new("TextLabel")
	titleText.Size = UDim2.new(0, 600, 0, 80)
	titleText.Position = UDim2.new(0.5, -300, 0.3, 0)
	titleText.BackgroundTransparency = 1
	titleText.TextColor3 = Color3.fromRGB(255, 100, 100)
	titleText.TextStrokeTransparency = 0
	titleText.Font = Enum.Font.GothamBold
	titleText.TextSize = 50
	titleText.Text = "YOU DIED"
	titleText.ZIndex = 201
	titleText.Parent = deathGui

	-- 選択フレーム
	local choiceFrame = Instance.new("Frame")
	choiceFrame.Size = UDim2.new(0, 600, 0, 200)
	choiceFrame.Position = UDim2.new(0.5, -300, 0.45, 0)
	choiceFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
	choiceFrame.BackgroundTransparency = 0.2
	choiceFrame.BorderSizePixel = 0
	choiceFrame.ZIndex = 201
	choiceFrame.Parent = deathGui

	-- 角を丸くする
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 10)
	corner.Parent = choiceFrame

	-- 説明テキスト
	local descText = Instance.new("TextLabel")
	descText.Size = UDim2.new(1, -40, 0, 60)
	descText.Position = UDim2.new(0, 20, 0, 20)
	descText.BackgroundTransparency = 1
	descText.TextColor3 = Color3.fromRGB(255, 255, 255)
	descText.TextStrokeTransparency = 0.5
	descText.Font = Enum.Font.Gotham
	descText.TextSize = 18
	descText.Text = "敗北しました。どうしますか？"
	descText.TextWrapped = true
	descText.ZIndex = 202
	descText.Parent = choiceFrame

	-- 「街に戻る」ボタン
	local returnButton = Instance.new("TextButton")
	returnButton.Size = UDim2.new(0, 250, 0, 50)
	returnButton.Position = UDim2.new(0.5, -260, 0, 100)
	returnButton.BackgroundColor3 = Color3.fromRGB(52, 152, 219)
	returnButton.BorderSizePixel = 0
	returnButton.Font = Enum.Font.GothamBold
	returnButton.TextSize = 20
	returnButton.Text = "🏠 街に戻る"
	returnButton.TextColor3 = Color3.new(1, 1, 1)
	returnButton.ZIndex = 202
	returnButton.Parent = choiceFrame

	-- ボタンの角を丸くする
	local returnCorner = Instance.new("UICorner")
	returnCorner.CornerRadius = UDim.new(0, 8)
	returnCorner.Parent = returnButton

	-- 「ゴールドで復活」ボタン
	local reviveButton = Instance.new("TextButton")
	reviveButton.Size = UDim2.new(0, 250, 0, 50)
	reviveButton.Position = UDim2.new(0.5, 10, 0, 100)
	reviveButton.BorderSizePixel = 0
	reviveButton.Font = Enum.Font.GothamBold
	reviveButton.TextSize = 20
	reviveButton.TextColor3 = Color3.new(1, 1, 1)
	reviveButton.ZIndex = 202
	reviveButton.Parent = choiceFrame

	-- ボタンの角を丸くする
	local reviveCorner = Instance.new("UICorner")
	reviveCorner.CornerRadius = UDim.new(0, 8)
	reviveCorner.Parent = reviveButton

	-- ゴールドが足りるかチェック
	if currentGold >= reviveCost then
		reviveButton.BackgroundColor3 = Color3.fromRGB(46, 204, 113)
		reviveButton.Text = string.format("💰 復活 (%d G)", reviveCost)
	else
		reviveButton.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
		reviveButton.Text = string.format("💰 復活 (%d G) - 不足", reviveCost)
		reviveButton.Active = false
	end

	-- ボタンのホバーエフェクト
	returnButton.MouseEnter:Connect(function()
		returnButton.BackgroundColor3 = Color3.fromRGB(62, 172, 239)
	end)
	returnButton.MouseLeave:Connect(function()
		returnButton.BackgroundColor3 = Color3.fromRGB(52, 152, 219)
	end)

	if currentGold >= reviveCost then
		reviveButton.MouseEnter:Connect(function()
			reviveButton.BackgroundColor3 = Color3.fromRGB(56, 224, 133)
		end)
		reviveButton.MouseLeave:Connect(function()
			reviveButton.BackgroundColor3 = Color3.fromRGB(46, 204, 113)
		end)
	end

	-- 「街に戻る」ボタンクリック
	returnButton.MouseButton1Click:Connect(function()
		print("[DeathUI] 街に戻るを選択")

		-- サーバーに通知
		local DeathChoiceEvent = ReplicatedStorage:FindFirstChild("DeathChoice")
		if DeathChoiceEvent then
			DeathChoiceEvent:FireServer("return")
		end

		-- バトルUIを閉じる
		local battleUI = playerGui:FindFirstChild("BattleUI")
		if battleUI then
			battleUI.Enabled = false
		end

		-- システムキーのブロックを解除
		local ContextActionService = game:GetService("ContextActionService")
		ContextActionService:UnbindAction("BlockSystemKeys")

		-- Roblox UIを再有効化
		local StarterGui = game:GetService("StarterGui")
		pcall(function()
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Chat, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.EmotesMenu, true)
		end)

		-- UIを閉じる
		if deathGui then
			deathGui:Destroy()
			deathGui = nil
		end
	end)

	-- 「ゴールドで復活」ボタンクリック
	reviveButton.MouseButton1Click:Connect(function()
		if currentGold < reviveCost then
			print("[DeathUI] ゴールド不足")
			return
		end

		print("[DeathUI] ゴールドで復活を選択")

		-- サーバーに通知
		local DeathChoiceEvent = ReplicatedStorage:FindFirstChild("DeathChoice")
		if DeathChoiceEvent then
			DeathChoiceEvent:FireServer("revive")
		end

		-- バトルUIを閉じる
		local battleUI = playerGui:FindFirstChild("BattleUI")
		if battleUI then
			battleUI.Enabled = false
		end

		-- システムキーのブロックを解除
		local ContextActionService = game:GetService("ContextActionService")
		ContextActionService:UnbindAction("BlockSystemKeys")

		-- Roblox UIを再有効化
		local StarterGui = game:GetService("StarterGui")
		pcall(function()
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Chat, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.EmotesMenu, true)
		end)

		-- UIを閉じる
		if deathGui then
			deathGui:Destroy()
			deathGui = nil
		end
	end)
end

-- RemoteEventを待機
local ShowDeathUIEvent = ReplicatedStorage:WaitForChild("ShowDeathUI", 10)
if ShowDeathUIEvent then
	ShowDeathUIEvent.OnClientEvent:Connect(showDeathUI)
	print("[DeathUI] ShowDeathUIイベント接続完了")
else
	warn("[DeathUI] ShowDeathUIイベントが見つかりません")
end

print("[DeathUI] 初期化完了")
===== ./ServerScriptService/ZoneManager.lua =====
-- ServerScriptService/ZoneManager.lua (大陸対応版)
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local FieldGen = require(ReplicatedStorage:WaitForChild("FieldGen"))

local ZoneManager = {}

ZoneManager.ActiveZones = {}
ZoneManager.PlayerZones = {}

-- 島と大陸の設定を読み込み
local IslandsRegistry = require(ReplicatedStorage.Islands.Registry)
local ContinentsRegistry = require(ReplicatedStorage.Continents.Registry)

-- 島の設定をマップ化
local Islands = {}
for _, island in ipairs(IslandsRegistry) do
	Islands[island.name] = island
end

-- 大陸の設定をマップ化
local Continents = {}
for _, continent in ipairs(ContinentsRegistry) do
	Continents[continent.name] = continent
end

print("[ZoneManager] 初期化完了。島:", #IslandsRegistry, "大陸:", #ContinentsRegistry)

-- ゾーンが大陸かチェック
local function isContinent(zoneName)
	return Continents[zoneName] ~= nil
end

-- 大陸をロード（複数の島と橋を生成）
local function loadContinent(continentName)
	local continent = Continents[continentName]
	if not continent then
		warn(("[ZoneManager] 大陸 '%s' が見つかりません"):format(continentName))
		return false
	end

	print(("[ZoneManager] 大陸生成開始: %s"):format(continentName))

	-- 含まれる全ての島を生成
	for _, islandName in ipairs(continent.islands) do
		local islandConfig = Islands[islandName]
		if islandConfig then
			print(("[ZoneManager]   - 島を生成: %s"):format(islandName))
			FieldGen.generateIsland(islandConfig)
		else
			warn(("[ZoneManager]   - 島が見つかりません: %s"):format(islandName))
		end
	end

	-- 橋を生成
	if continent.bridges then
		for _, bridgeConfig in ipairs(continent.bridges) do
			local fromIsland = Islands[bridgeConfig.fromIsland]
			local toIsland = Islands[bridgeConfig.toIsland]

			if fromIsland and toIsland then
				print(("[ZoneManager]   - 橋を生成: %s"):format(bridgeConfig.name))
				FieldGen.generateBridge(fromIsland, toIsland, bridgeConfig)
			else
				warn(("[ZoneManager]   - 橋の生成失敗: %s"):format(bridgeConfig.name))
			end
		end
	end

	ZoneManager.ActiveZones[continentName] = {
		config = continent,
		loadedAt = os.time(),
	}

	print(("[ZoneManager] 大陸生成完了: %s"):format(continentName))
	return true
end

-- 単一の島をロード（Town用）
local function loadIsland(islandName)
	local config = Islands[islandName]
	if not config then
		warn(("[ZoneManager] 島 '%s' が見つかりません"):format(islandName))
		return false
	end

	print(("[ZoneManager] 島生成開始: %s"):format(islandName))
	FieldGen.generateIsland(config)

	ZoneManager.ActiveZones[islandName] = {
		config = config,
		loadedAt = os.time(),
	}

	print(("[ZoneManager] 島生成完了: %s"):format(islandName))
	return true
end

-- ゾーンをロード（大陸 or 島を自動判定）
function ZoneManager.LoadZone(zoneName)
	if ZoneManager.ActiveZones[zoneName] then
		print(("[ZoneManager] %s は既に生成済みです"):format(zoneName))
		return true
	end

	if isContinent(zoneName) then
		return loadContinent(zoneName)
	else
		return loadIsland(zoneName)
	end
end

-- ゾーンをアンロード
function ZoneManager.UnloadZone(zoneName)
	if not ZoneManager.ActiveZones[zoneName] then
		return
	end

	print(("[ZoneManager] ゾーン削除開始: %s"):format(zoneName))

	local terrain = workspace.Terrain
	local islandsToUnload = {}

	-- 大陸の場合は含まれる全ての島を削除
	if isContinent(zoneName) then
		local continent = Continents[zoneName]
		for _, islandName in ipairs(continent.islands) do
			table.insert(islandsToUnload, islandName)
		end
	else
		-- 単一の島
		table.insert(islandsToUnload, zoneName)
	end

	-- 各島の地形を削除
	for _, islandName in ipairs(islandsToUnload) do
		local config = Islands[islandName]
		if config then
			local halfSize = config.sizeXZ / 2 + 50
			local region = Region3.new(
				Vector3.new(config.centerX - halfSize, config.baseY - 50, config.centerZ - halfSize),
				Vector3.new(config.centerX + halfSize, config.baseY + 100, config.centerZ + halfSize)
			)
			region = region:ExpandToGrid(4)
			terrain:FillRegion(region, 4, Enum.Material.Air)

			-- マーカー削除
			local worldFolder = workspace:FindFirstChild("World")
			if worldFolder then
				local marker = worldFolder:FindFirstChild(config.name .. "_Center")
				if marker then marker:Destroy() end
			end
		end
	end

	-- モンスター削除
	for _, model in ipairs(workspace:GetChildren()) do
		if model:IsA("Model") and model:GetAttribute("IsEnemy") then
			local spawnZone = model:GetAttribute("SpawnZone")
			if spawnZone == zoneName then
				model:Destroy()
			end
		end
	end

	ZoneManager.ActiveZones[zoneName] = nil
	print(("[ZoneManager] ゾーン削除完了: %s"):format(zoneName))
end

-- プレイヤーをワープ
-- プレイヤーをワープ
function ZoneManager.WarpPlayerToZone(player, zoneName)
	print(("[ZoneManager] %s を %s にワープ中..."):format(player.Name, zoneName))

	ZoneManager.LoadZone(zoneName)

	local character = player.Character
	if not character then
		warn(("[ZoneManager] %s のキャラクターが見つかりません"):format(player.Name))
		return false
	end

	local hrp = character:FindFirstChild("HumanoidRootPart")
	if not hrp then return false end

	-- ワープ先の座標を決定
	local targetX, targetZ, baseY, hillAmplitude

	if isContinent(zoneName) then
		-- 大陸の場合は最初の島の中心
		local continent = Continents[zoneName]
		local firstIslandName = continent.islands[1]
		local firstIsland = Islands[firstIslandName]
		targetX = firstIsland.centerX
		targetZ = firstIsland.centerZ
		baseY = firstIsland.baseY
		hillAmplitude = firstIsland.hillAmplitude or 20
	else
		-- 単一の島
		local config = Islands[zoneName]
		targetX = config.centerX
		targetZ = config.centerZ
		baseY = config.baseY
		hillAmplitude = config.hillAmplitude or 20
	end

	-- 十分に高い位置からレイキャスト（地形の最高点より上）
	local rayStartY = baseY + hillAmplitude + 100
	local groundY = FieldGen.raycastGroundY(targetX, targetZ, rayStartY)

	-- レイキャストが失敗した場合は予想高度を使用
	local spawnY
	if groundY then
		spawnY = groundY + 5
		print(("[ZoneManager] 地面検出成功: Y=%.1f"):format(groundY))
	else
		-- 安全な高度：baseY + hillAmplitudeの中間地点
		spawnY = baseY + (hillAmplitude * 0.6) + 10
		warn(("[ZoneManager] 地面検出失敗、予想高度使用: Y=%.1f"):format(spawnY))
	end

	hrp.CFrame = CFrame.new(targetX, spawnY, targetZ)
	ZoneManager.PlayerZones[player] = zoneName

	print(("[ZoneManager] %s を %s にワープ完了 (%.1f, %.1f, %.1f)"):format(
		player.Name, zoneName, targetX, spawnY, targetZ
		))
	return true
end

function ZoneManager.GetPlayerZone(player)
	return ZoneManager.PlayerZones[player]
end

function ZoneManager.InitializeTown()
	print("[ZoneManager] 街（Town）を生成中...")
	ZoneManager.LoadZone("StartTown")
end

-- 大陸の設定を取得
function ZoneManager.GetContinentConfig(continentName)
	return Continents[continentName]
end

return ZoneManager
===== ./ServerScriptService/PlayerStats.lua =====
-- ServerScriptService/PlayerStats.lua
-- プレイヤーのステータスを管理するModuleScript

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local PlayerStats = {}

-- RemoteEventを取得する関数
local function getRemoteEvent(name)
	return ReplicatedStorage:WaitForChild(name, 10)
end

-- デフォルトステータス
local DEFAULT_STATS = {
	Level = 1,
	Experience = 0,
	Gold = 100,  -- 初期ゴールド100G

	MaxHP = 100,
	CurrentHP = 100,

	Speed = 10,      -- 素早さ
	Attack = 10,     -- 攻撃力
	Defense = 10,    -- 守備力
	MonstersDefeated = 0,
}

-- レベルアップに必要な経験値（レベル * 100）
local function getRequiredExp(level)
	return level * 100
end

-- 各プレイヤーのステータスを保存
local PlayerData = {}

-- プレイヤーのステータスを初期化
function PlayerStats.initPlayer(player: Player)
	if PlayerData[player] then
		warn(("[PlayerStats] %s は既に初期化済みです"):format(player.Name))
		return
	end

	-- デフォルト値でステータスを作成
	PlayerData[player] = {}
	for key, value in pairs(DEFAULT_STATS) do
		PlayerData[player][key] = value
	end

	print(("[PlayerStats] %s のステータスを初期化しました"):format(player.Name))

	-- TODO: DataStoreから読み込み
end

-- プレイヤーのステータスを取得
function PlayerStats.getStats(player: Player)
	return PlayerData[player]
end

-- 特定のステータスを取得
function PlayerStats.getStat(player: Player, statName: string)
	local stats = PlayerData[player]
	if not stats then
		warn(("[PlayerStats] %s のステータスが見つかりません"):format(player.Name))
		return nil
	end
	return stats[statName]
end

-- 特定のステータスを設定
function PlayerStats.setStat(player: Player, statName: string, value)
	local stats = PlayerData[player]
	if not stats then
		warn(("[PlayerStats] %s のステータスが見つかりません"):format(player.Name))
		return
	end

	stats[statName] = value
	print(("[PlayerStats] %s の %s を %s に設定"):format(player.Name, statName, tostring(value)))
end

-- HPを回復
function PlayerStats.healHP(player: Player, amount: number)
	local stats = PlayerData[player]
	if not stats then return end

	stats.CurrentHP = math.min(stats.CurrentHP + amount, stats.MaxHP)
	print(("[PlayerStats] %s のHPを %d 回復（現在: %d/%d）"):format(
		player.Name, amount, stats.CurrentHP, stats.MaxHP
		))
end

-- HPを全回復
function PlayerStats.fullHeal(player: Player)
	local stats = PlayerData[player]
	if not stats then return end

	stats.CurrentHP = stats.MaxHP
	print(("[PlayerStats] %s のHPを全回復"):format(player.Name))
end

-- ダメージを受ける
function PlayerStats.takeDamage(player: Player, damage: number): boolean
	local stats = PlayerData[player]
	if not stats then return false end

	stats.CurrentHP = math.max(0, stats.CurrentHP - damage)
	print(("[PlayerStats] %s が %d ダメージを受けた（残りHP: %d/%d）"):format(
		player.Name, damage, stats.CurrentHP, stats.MaxHP
		))

	-- ステータス更新を送信
	local StatusUpdateEvent = getRemoteEvent("StatusUpdate")
	if StatusUpdateEvent then
		local expToNext = getRequiredExp(stats.Level)
		StatusUpdateEvent:FireClient(
			player,
			stats.CurrentHP,
			stats.MaxHP,
			stats.Level,
			stats.Experience,
			expToNext,
			stats.Gold
		)
	end

	-- 死亡判定
	if stats.CurrentHP <= 0 then
		print(("[PlayerStats] %s は倒れた！"):format(player.Name))
		return true  -- 死亡
	end

	return false  -- 生存
end

-- 経験値を追加
function PlayerStats.addExperience(player: Player, exp: number)
	local stats = PlayerData[player]
	if not stats then return end

	stats.Experience = stats.Experience + exp
	print(("[PlayerStats] %s が経験値 %d を獲得（合計: %d）"):format(
		player.Name, exp, stats.Experience
		))

	-- レベルアップチェック
	local requiredExp = getRequiredExp(stats.Level)
	while stats.Experience >= requiredExp do
		PlayerStats.levelUp(player)
		requiredExp = getRequiredExp(stats.Level)
	end

	-- ステータス更新を送信
	local StatusUpdateEvent = getRemoteEvent("StatusUpdate")
	if StatusUpdateEvent then
		local expToNext = getRequiredExp(stats.Level)
		StatusUpdateEvent:FireClient(
			player,
			stats.CurrentHP,
			stats.MaxHP,
			stats.Level,
			stats.Experience,
			expToNext,
			stats.Gold
		)
	end
end

-- ゴールドを追加
function PlayerStats.addGold(player: Player, gold: number)
	local stats = PlayerData[player]
	if not stats then return end

	stats.Gold = stats.Gold + gold
	print(("[PlayerStats] %s がゴールド %d を獲得（合計: %d）"):format(
		player.Name, gold, stats.Gold
		))

	-- ステータス更新を送信
	local StatusUpdateEvent = getRemoteEvent("StatusUpdate")
	if StatusUpdateEvent then
		local expToNext = getRequiredExp(stats.Level)
		StatusUpdateEvent:FireClient(
			player,
			stats.CurrentHP,
			stats.MaxHP,
			stats.Level,
			stats.Experience,
			expToNext,
			stats.Gold
		)
	end
end

-- ゴールドを減らす
function PlayerStats.removeGold(player: Player, gold: number): boolean
	local stats = PlayerData[player]
	if not stats then return false end

	if stats.Gold < gold then
		print(("[PlayerStats] %s のゴールドが不足しています"):format(player.Name))
		return false
	end

	stats.Gold = stats.Gold - gold
	print(("[PlayerStats] %s がゴールド %d を失った（残り: %d）"):format(
		player.Name, gold, stats.Gold
		))
	return true
end

-- 倒したモンスター数を追加
function PlayerStats.addMonstersDefeated(player: Player, count: number)
	print(("[PlayerStats] ========================================"):format())
	print(("[PlayerStats] addMonstersDefeated 呼び出し"):format())
	print(("  プレイヤー: %s"):format(player.Name))
	print(("  追加数: %d"):format(count or 1))

	local stats = PlayerData[player]
	if not stats then
		warn(("[PlayerStats] ❌ %s のステータスが見つかりません（モンスターカウント失敗）"):format(player.Name))
		print(("[PlayerStats] ========================================"):format())
		return
	end

	local oldCount = stats.MonstersDefeated
	count = count or 1
	stats.MonstersDefeated = stats.MonstersDefeated + count

	print(("  変更前: %d"):format(oldCount))
	print(("  変更後: %d"):format(stats.MonstersDefeated))
	print(("[PlayerStats] ✅ モンスター撃破数更新成功"):format())
	print(("[PlayerStats] ========================================"):format())
end

-- レベルアップ
function PlayerStats.levelUp(player: Player)
	local stats = PlayerData[player]
	if not stats then return end

	local oldLevel = stats.Level
	stats.Level = stats.Level + 1

	-- ステータスアップ
	stats.MaxHP = stats.MaxHP + 10
	stats.CurrentHP = stats.MaxHP  -- 全回復
	stats.Speed = stats.Speed + 2
	stats.Attack = stats.Attack + 2
	stats.Defense = stats.Defense + 2

	print(("[PlayerStats] 🎉 %s がレベルアップ！ %d → %d"):format(
		player.Name, oldLevel, stats.Level
		))
	print(("  HP: %d, 素早さ: %d, 攻撃: %d, 守備: %d"):format(
		stats.MaxHP, stats.Speed, stats.Attack, stats.Defense
		))

	-- クライアントにレベルアップ演出を通知
	local LevelUpEvent = getRemoteEvent("LevelUp")
	if LevelUpEvent then
		LevelUpEvent:FireClient(player, stats.Level, stats.MaxHP, stats.Speed, stats.Attack, stats.Defense)
	end

	-- ステータス更新を送信
	local StatusUpdateEvent = getRemoteEvent("StatusUpdate")
	if StatusUpdateEvent then
		local expToNext = stats.Level * 100
		StatusUpdateEvent:FireClient(
			player,
			stats.CurrentHP,
			stats.MaxHP,
			stats.Level,
			stats.Experience,
			expToNext,
			stats.Gold
		)
	end
end

-- プレイヤーが退出したらデータをクリア
function PlayerStats.removePlayer(player: Player)
	-- TODO: DataStoreに保存
	PlayerData[player] = nil
	print(("[PlayerStats] %s のデータを削除しました"):format(player.Name))
end

-- 初期化
function PlayerStats.init()
	-- 既存のプレイヤーを初期化
	for _, player in ipairs(Players:GetPlayers()) do
		PlayerStats.initPlayer(player)
	end

	-- 新規参加プレイヤーを初期化
	Players.PlayerAdded:Connect(function(player)
		PlayerStats.initPlayer(player)
	end)

	-- 退出時にデータをクリア
	Players.PlayerRemoving:Connect(function(player)
		PlayerStats.removePlayer(player)
	end)

	-- 詳細ステータスリクエスト用RemoteEvent
	local RequestStatsDetailEvent = ReplicatedStorage:FindFirstChild("RequestStatsDetail")
	if not RequestStatsDetailEvent then
		RequestStatsDetailEvent = Instance.new("RemoteEvent")
		RequestStatsDetailEvent.Name = "RequestStatsDetail"
		RequestStatsDetailEvent.Parent = ReplicatedStorage
	end

	RequestStatsDetailEvent.OnServerEvent:Connect(function(player)
		local stats = PlayerStats.getStats(player)
		if stats then
			-- StatsDetailEventを取得または作成
			local StatsDetailEvent = ReplicatedStorage:FindFirstChild("StatsDetail")
			if not StatsDetailEvent then
				StatsDetailEvent = Instance.new("RemoteEvent")
				StatsDetailEvent.Name = "StatsDetail"
				StatsDetailEvent.Parent = ReplicatedStorage
				print("[PlayerStats] StatsDetailイベントを作成しました")
			end

			print(("[PlayerStats] 詳細ステータスを送信: MonstersDefeated=%d"):format(stats.MonstersDefeated or 0))
			StatsDetailEvent:FireClient(player, stats)
		end
	end)

	print("[PlayerStats] 初期化完了")
end

return PlayerStats
===== ./ServerScriptService/Bootstrap.server.lua =====
-- ServerScriptService/Bootstrap.server.lua
-- ゲーム初期化スクリプト（街のみ生成版）

local ServerScriptService = game:GetService("ServerScriptService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

print("[Bootstrap] === ゲーム初期化開始 ===")

-- ZoneManagerを読み込み
local ZoneManager = require(script.Parent.ZoneManager)
local PlayerStats = require(ServerScriptService:WaitForChild("PlayerStats"))

PlayerStats.init()

-- 街を生成
print("[Bootstrap] 街を生成中...")
ZoneManager.InitializeTown()

-- 街の設定を取得
local IslandsRegistry = require(ReplicatedStorage.Islands.Registry)
local townConfig = nil
for _, island in ipairs(IslandsRegistry) do
	if island.name == "StartTown" then
		townConfig = island
		break
	end
end

if not townConfig then
	warn("[Bootstrap] StartTown の設定が見つかりません！")
	return
end

-- プレイヤーのスポーン位置を街に設定
local function setupPlayerSpawn(player)
	player.CharacterAdded:Connect(function(character)
		-- 少し待機（キャラクターのロード完了を待つ）
		task.wait(0.5)

		local hrp = character:FindFirstChild("HumanoidRootPart")
		if not hrp then return end

		-- プレイヤーが既にゾーンにいる場合はスキップ
		local currentZone = ZoneManager.GetPlayerZone(player)
		if currentZone then
			print(("[Bootstrap] %s は既に %s にいます"):format(player.Name, currentZone))
			return
		end

		-- 街の中心にスポーン
		local spawnX = townConfig.centerX
		local spawnZ = townConfig.centerZ
		local spawnY = townConfig.baseY + 25

		print(("[Bootstrap] %s を街にスポーン: (%.0f, %.0f, %.0f)"):format(
			player.Name, spawnX, spawnY, spawnZ
			))

		hrp.CFrame = CFrame.new(spawnX, spawnY, spawnZ)

		-- プレイヤーのゾーンを記録
		ZoneManager.PlayerZones[player] = "StartTown"
	end)
end

-- 既存プレイヤーと新規プレイヤーに適用
for _, player in ipairs(Players:GetPlayers()) do
	setupPlayerSpawn(player)

	-- 既にキャラクターがいる場合は即座にスポーン
	if player.Character then
		local hrp = player.Character:FindFirstChild("HumanoidRootPart")
		if hrp then
			hrp.CFrame = CFrame.new(townConfig.centerX, townConfig.baseY + 25, townConfig.centerZ)
			ZoneManager.PlayerZones[player] = "StartTown"
		end
	end
end

Players.PlayerAdded:Connect(setupPlayerSpawn)

print("[Bootstrap] === ゲーム初期化完了 ===")
print("[Bootstrap] プレイヤーは街（StartTown）からスタートします")
===== ./ServerScriptService/LoadTest.server.lua =====
-- ServerScriptService/LoadTest (Script)
local startTime = os.clock()
local startMemory = gcinfo()

-- ゲーム開始を待つ
task.wait(5)

local endTime = os.clock()
local endMemory = gcinfo()

print("=== 負荷テスト結果 ===")
print(("地形生成時間: %.2f秒"):format(endTime - startTime))
print(("メモリ使用量: %.2f MB"):format((endMemory - startMemory) / 1024))
print(("総オブジェクト数: %d"):format(#workspace:GetDescendants()))

-- 継続モニタリング
task.spawn(function()
	while true do
		task.wait(5)
		local fps = 1 / game:GetService("RunService").Heartbeat:Wait()
		print(("FPS: %.1f | メモリ: %.1f MB"):format(fps, gcinfo() / 1024))
	end
end)
===== ./ServerScriptService/OceanSafety.server.lua =====
-- ServerScriptService/OceanSafety.server.lua
-- 海に落ちた時の処理

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- 設定
local WATER_LEVEL = -25  -- この高さより下に落ちたら処理
local CHECK_INTERVAL = 0.5  -- チェック間隔（秒）

-- 島の中心（プレイヤーのリスポーン位置）
local Islands = require(ReplicatedStorage.Islands.Registry)
local firstIsland = Islands[1]
local SPAWN_X = firstIsland.centerX
local SPAWN_Z = firstIsland.centerZ
local SPAWN_Y = firstIsland.baseY + 25  -- 島の上空

print("[OceanSafety] 初期化完了")

-- プレイヤーの監視
local function monitorPlayer(player)
	player.CharacterAdded:Connect(function(character)
		local hrp = character:WaitForChild("HumanoidRootPart")
		local humanoid = character:WaitForChild("Humanoid")

		local lastCheck = 0

		RunService.Heartbeat:Connect(function()
			if not character.Parent or not hrp.Parent then return end

			local now = os.clock()
			if now - lastCheck < CHECK_INTERVAL then return end
			lastCheck = now

			-- 水面より下に落ちたかチェック
			if hrp.Position.Y < WATER_LEVEL then
				print(("[OceanSafety] %s が海に落ちました。リスポーン中..."):format(player.Name))

				-- 速度をゼロに
				hrp.AssemblyLinearVelocity = Vector3.zero
				hrp.AssemblyAngularVelocity = Vector3.zero

				-- 島の中心に戻す
				hrp.CFrame = CFrame.new(SPAWN_X, SPAWN_Y, SPAWN_Z)

				-- 体力を少し減らす（ペナルティ）
				if humanoid.Health > 10 then
					humanoid.Health = humanoid.Health - 10
				end
			end
		end)
	end)
end

-- 既存プレイヤーと新規プレイヤーに適用
for _, player in ipairs(Players:GetPlayers()) do
	monitorPlayer(player)
end
Players.PlayerAdded:Connect(monitorPlayer)

-- モンスターの監視
RunService.Heartbeat:Connect(function()
	for _, model in ipairs(workspace:GetChildren()) do
		if model:IsA("Model") and model:GetAttribute("IsEnemy") then
			local hrp = model:FindFirstChild("HumanoidRootPart")

			if hrp and hrp.Position.Y < WATER_LEVEL then
				print(("[OceanSafety] %s が海に落ちました。消去中..."):format(model.Name))
				model:Destroy()
			end
		end
	end
end)
===== ./ServerScriptService/WarpPortal.server.lua =====
-- ServerScriptService/WarpPortal.server.lua
-- 大陸対応ワープポータルシステム（高速化版）

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local ZoneManager = require(script.Parent.ZoneManager)
local BattleSystem = require(script.Parent.BattleSystem)

print("[WarpPortal] 初期化開始")

-- RemoteEvent作成
local warpEvent = ReplicatedStorage:FindFirstChild("WarpEvent")
if not warpEvent then
	warpEvent = Instance.new("RemoteEvent")
	warpEvent.Name = "WarpEvent"
	warpEvent.Parent = ReplicatedStorage
end

local warpingPlayers = {}
local activePortals = {}

-- 島と大陸の設定を読み込み
local IslandsRegistry = require(ReplicatedStorage.Islands.Registry)
local ContinentsRegistry = require(ReplicatedStorage.Continents.Registry)

local Islands = {}
for _, island in ipairs(IslandsRegistry) do
	Islands[island.name] = island
end

local Continents = {}
for _, continent in ipairs(ContinentsRegistry) do
	Continents[continent.name] = continent
end

-- Townのポータル設定（各大陸へ）
local townPortalConfigs = {
	{
		name = "Town_to_ContinentA",
		toZone = "ContinentA",
		offsetX = 50,
		offsetZ = 0,
		size = Vector3.new(8, 12, 8),
		color = Color3.fromRGB(100, 255, 100),
		label = "→ Grassland",
	},
	{
		name = "Town_to_ContinentB",
		toZone = "ContinentB",
		offsetX = -50,
		offsetZ = 0,
		size = Vector3.new(8, 12, 8),
		color = Color3.fromRGB(150, 150, 255),
		label = "→ Wilderness",
	},
	{
		name = "Town_to_ContinentT",
		toZone = "ContinentT",
		offsetX = 0,
		offsetZ = 50,
		size = Vector3.new(8, 12, 8),
		color = Color3.fromRGB(255, 255, 100),
		label = "→ T-Continent",
	},
	{
		name = "Town_to_Hokkaido",
		toZone = "ContinentHokkaido",
		offsetX = 0,
		offsetZ = -50,
		size = Vector3.new(8, 12, 8),
		color = Color3.fromRGB(200, 200, 255),
		label = "→ Hokkaido",
	},
}

-- ポータルを作成する関数（高速化版）
local function createPortal(config, fromZone)
	-- ゾーンの中心座標を取得
	local zoneConfig = Islands[fromZone]
	if not zoneConfig then
		warn(("[WarpPortal] ゾーン '%s' の設定が見つかりません"):format(fromZone))
		return nil
	end

	-- ポータルの絶対位置を計算
	local portalX = zoneConfig.centerX + (config.offsetX or 0)
	local portalZ = zoneConfig.centerZ + (config.offsetZ or 0)

	-- 地面の高さを取得（リトライ回数削減：5→2回、待機時間短縮：0.2→0.05秒）
	local FieldGen = require(ReplicatedStorage:WaitForChild("FieldGen"))
	local groundY = nil
	local maxRetries = 2  -- 5 → 2に削減

	for attempt = 1, maxRetries do
		groundY = FieldGen.raycastGroundY(portalX, portalZ, zoneConfig.baseY + 100)

		if groundY then
			break
		else
			task.wait(0.05)  -- 0.2 → 0.05秒に短縮
		end
	end

	local portalY
	if groundY then
		portalY = groundY + 1
	else
		local estimatedHeight = zoneConfig.baseY + ((zoneConfig.hillAmplitude or 20) * 0.5)
		portalY = estimatedHeight
		-- warn(("[WarpPortal] レイキャスト失敗、予想高度を使用: Y=%.1f"):format(portalY))
	end

	local portalPosition = Vector3.new(portalX, portalY, portalZ)

	local portal = Instance.new("Part")
	portal.Name = config.name
	portal.Size = config.size or Vector3.new(8, 12, 8)
	portal.Position = portalPosition
	portal.Anchored = true
	portal.CanCollide = false
	portal.Transparency = 0.3
	portal.Color = config.color or Color3.fromRGB(255, 255, 255)
	portal.Material = Enum.Material.Neon

	portal:SetAttribute("FromZone", fromZone)
	portal:SetAttribute("ToZone", config.toZone)

	-- 回転アニメーション
	local bodyAngularVelocity = Instance.new("BodyAngularVelocity")
	bodyAngularVelocity.AngularVelocity = Vector3.new(0, 2, 0)
	bodyAngularVelocity.MaxTorque = Vector3.new(0, math.huge, 0)
	bodyAngularVelocity.P = 1000
	bodyAngularVelocity.Parent = portal

	-- ラベル
	local billboard = Instance.new("BillboardGui")
	billboard.Name = "PortalLabel"
	billboard.Size = UDim2.new(0, 200, 0, 50)
	billboard.StudsOffset = Vector3.new(0, 7, 0)
	billboard.AlwaysOnTop = true
	billboard.Parent = portal

	local label = Instance.new("TextLabel")
	label.Size = UDim2.new(1, 0, 1, 0)
	label.BackgroundTransparency = 1
	label.Text = config.label or ("→ " .. config.toZone)
	label.TextColor3 = Color3.new(1, 1, 1)
	label.TextScaled = true
	label.Font = Enum.Font.SourceSansBold
	label.TextStrokeTransparency = 0.5
	label.Parent = billboard

	-- Worldフォルダに配置
	local worldFolder = workspace:FindFirstChild("World")
	if not worldFolder then
		worldFolder = Instance.new("Folder")
		worldFolder.Name = "World"
		worldFolder.Parent = workspace
	end

	portal.Parent = worldFolder

	-- 配置後の調整レイキャスト（非同期化して高速化）
	task.spawn(function()
		task.wait(0.05)  -- 0.1 → 0.05秒に短縮

		local params = RaycastParams.new()
		params.FilterType = Enum.RaycastFilterType.Include
		params.FilterDescendantsInstances = {workspace.Terrain}

		local rayOrigin = portal.Position
		local rayDirection = Vector3.new(0, -200, 0)
		local rayResult = workspace:Raycast(rayOrigin, rayDirection, params)

		if rayResult and portal.Parent then
			local adjustedY = rayResult.Position.Y + (portal.Size.Y / 2) + 0.5
			portal.Position = Vector3.new(portal.Position.X, adjustedY, portal.Position.Z)
		end
	end)

	-- タッチイベント
	portal.Touched:Connect(function(hit)
		local character = hit.Parent
		if not character then return end

		local player = Players:GetPlayerFromCharacter(character)
		if not player then return end

		if warpingPlayers[player.UserId] then
			return
		end

		local actualFromZone = portal:GetAttribute("FromZone")

		local currentZone = ZoneManager.GetPlayerZone(player)
		if currentZone ~= actualFromZone then
			if not currentZone then
				ZoneManager.PlayerZones[player] = actualFromZone
			else
				-- print(("[WarpPortal DEBUG] ゾーン不一致: current=%s, from=%s"):format(
				-- 	tostring(currentZone), tostring(actualFromZone)
				-- ))
				return
			end
		end

		print(("[WarpPortal] %s が %s に入りました"):format(player.Name, config.name))

		warpingPlayers[player.UserId] = true

		warpEvent:FireClient(player, "StartLoading", config.toZone)

		task.wait(1)

		-- バトルシステムリセット
		if BattleSystem and BattleSystem.resetAllBattles then
			-- print("[WarpPortal] バトルシステムをリセット中...")
			BattleSystem.resetAllBattles()
		end

		destroyPortalsForZone(actualFromZone)

		-- 前のゾーンのモンスターを削除
		if actualFromZone ~= "StartTown" and _G.DespawnMonstersForZone then
			-- print(("[WarpPortal] %s のモンスターを削除中..."):format(actualFromZone))
			_G.DespawnMonstersForZone(actualFromZone)
		end

		-- ゾーン切り替え
		local success = ZoneManager.WarpPlayerToZone(player, config.toZone)

		if success then
			-- 新しいゾーンのポータルを作成
			createPortalsForZone(config.toZone)

			-- 新しいゾーンのモンスターをスポーン
			if config.toZone ~= "StartTown" and _G.SpawnMonstersForZone then
				-- print(("[WarpPortal] %s にモンスターをスポーン中..."):format(config.toZone))
				_G.SpawnMonstersForZone(config.toZone)
			end

			task.wait(0.5)
			warpEvent:FireClient(player, "EndLoading")
		else
			warn(("[WarpPortal] %s のワープに失敗"):format(player.Name))
			warpEvent:FireClient(player, "EndLoading")
		end

		task.wait(2)
		warpingPlayers[player.UserId] = nil
	end)

	return portal
end

-- ゾーンのポータルを作成（並列処理で高速化）
function createPortalsForZone(zoneName)
	if activePortals[zoneName] then
		print(("[WarpPortal] %s のポータルは既に存在します"):format(zoneName))
		return
	end

	activePortals[zoneName] = {}

	-- Townの場合
	if zoneName == "StartTown" then
		print(("[WarpPortal] %s のポータルを並列生成中..."):format(zoneName))

		-- 並列でポータルを生成（待機時間を短縮）
		for _, config in ipairs(townPortalConfigs) do
			task.spawn(function()
				local portal = createPortal(config, zoneName)
				if portal then
					table.insert(activePortals[zoneName], portal)
					print(("[WarpPortal] ポータル作成: %s"):format(config.name))
				end
			end)
		end
		return
	end

	-- 大陸の場合
	local continent = Continents[zoneName]
	if continent and continent.portals then
		print(("[WarpPortal] %s のポータルを並列生成中..."):format(zoneName))

		for _, portalConfig in ipairs(continent.portals) do
			task.spawn(function()
				local islandName = portalConfig.islandName
				if not Islands[islandName] then
					warn(("[WarpPortal] 島 '%s' が見つかりません"):format(islandName))
				else
					local portal = createPortal(portalConfig, islandName)
					if portal then
						portal:SetAttribute("FromZone", zoneName)
						table.insert(activePortals[zoneName], portal)
						print(("[WarpPortal] ポータル作成: %s (配置: %s)"):format(portalConfig.name, islandName))
					end
				end
			end)
		end
	else
		print(("[WarpPortal] %s のポータル設定が見つかりません"):format(zoneName))
	end
end

-- ゾーンのポータルを削除
function destroyPortalsForZone(zoneName)
	if not activePortals[zoneName] then
		return
	end

	for _, portal in ipairs(activePortals[zoneName]) do
		if portal and portal.Parent then
			portal:Destroy()
		end
	end

	activePortals[zoneName] = nil
	print(("[WarpPortal] %s のポータルを削除しました"):format(zoneName))
end

-- MonsterSpawner関数の待機
task.spawn(function()
	local maxWait = 10
	local waited = 0

	while not _G.SpawnMonstersForZone and waited < maxWait do
		task.wait(0.5)
		waited = waited + 0.5
	end

	if _G.SpawnMonstersForZone then
		print("[WarpPortal] MonsterSpawner関数検出成功")
	else
		warn("[WarpPortal] MonsterSpawner関数が見つかりません")
	end
end)

-- 街のポータルを最初に作成（待機時間短縮：1秒→0.3秒）
task.wait(0.3)  -- 1秒 → 0.3秒に短縮
createPortalsForZone("StartTown")

-- プレイヤー退出時にクリーンアップ
Players.PlayerRemoving:Connect(function(player)
	warpingPlayers[player.UserId] = nil
	ZoneManager.PlayerZones[player] = nil
end)

_G.CreatePortalsForZone = createPortalsForZone
_G.DestroyPortalsForZone = destroyPortalsForZone

print("[WarpPortal] 初期化完了")
===== ./ServerScriptService/BattleSystem.lua =====
-- ServerScriptService/BattleSystem.lua
-- バトルシステムの管理（敵の定期攻撃対応版）

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")

local BattleSystem = {}

-- PlayerStatsモジュールをロード
local PlayerStats = require(ServerScriptService:WaitForChild("PlayerStats"))

-- 戦闘中のプレイヤーを追跡
local ActiveBattles = {}

-- グローバルバトルフラグ
local GlobalBattleActive = false

-- バトル終了直後のクールダウン
local LastBattleEndTime = 0
local BATTLE_COOLDOWN = 0.5

-- バトル終了処理中のプレイヤー（二重終了防止）
local EndingBattles = {}

-- 敗北時のモンスター記録（消去用）
local DefeatedByMonster = {}

-- RemoteEvent の作成/取得
local function getOrCreateRemoteEvent(name)
	local event = ReplicatedStorage:FindFirstChild(name)
	if not event then
		event = Instance.new("RemoteEvent")
		event.Name = name
		event.Parent = ReplicatedStorage
		print(("[BattleSystem] RemoteEvent作成: %s"):format(name))
	end
	return event
end

-- RemoteEventsを作成
local BattleStartEvent = getOrCreateRemoteEvent("BattleStart")
local BattleEndEvent = getOrCreateRemoteEvent("BattleEnd")
local BattleVictoryEvent = getOrCreateRemoteEvent("BattleVictory")
local BattleDamageEvent = getOrCreateRemoteEvent("BattleDamage")
local BattleHPUpdateEvent = getOrCreateRemoteEvent("BattleHPUpdate")
local PlayerHPUpdateEvent = getOrCreateRemoteEvent("PlayerHPUpdate")
local StatusUpdateEvent = getOrCreateRemoteEvent("StatusUpdate")
local RequestStatusEvent = getOrCreateRemoteEvent("RequestStatus")
local LevelUpEvent = getOrCreateRemoteEvent("LevelUp")
local ShowDeathUIEvent = getOrCreateRemoteEvent("ShowDeathUI")
local DeathChoiceEvent = getOrCreateRemoteEvent("DeathChoice")
local TypingMistakeEvent = getOrCreateRemoteEvent("TypingMistake")

print("[BattleSystem] RemoteEvents準備完了")

-- モンスター定義を取得
local MonstersRegistry = require(ReplicatedStorage:WaitForChild("Monsters"):WaitForChild("Registry"))

-- プレイヤーのステータスをクライアントに送信
local function sendStatusUpdate(player: Player)
	local stats = PlayerStats.getStats(player)
	if not stats then return end

	local expToNext = stats.Level * 100  -- レベルアップに必要な経験値

	StatusUpdateEvent:FireClient(
		player,
		stats.CurrentHP,
		stats.MaxHP,
		stats.Level,
		stats.Experience,
		expToNext,
		stats.Gold
	)
end

-- プレイヤーが戦闘中かチェック
function BattleSystem.isInBattle(player: Player): boolean
	return ActiveBattles[player] ~= nil
end

-- グローバルなバトル状態を取得
function BattleSystem.isAnyBattleActive(): boolean
	return GlobalBattleActive
end

-- モンスター定義を名前から取得
local function getMonsterDef(monsterName)
	for _, def in ipairs(MonstersRegistry) do
		if def.Name == monsterName then
			return def
		end
	end
	return nil
end

-- ダメージを計算（敵→プレイヤー）
local function calculateDamage(attackerAttack: number, defenderDefense: number): number
	-- 基本ダメージ = 攻撃力 * 0.5 - 守備力 * 0.25
	local baseDamage = attackerAttack * 0.5 - defenderDefense * 0.25
	baseDamage = math.max(1, baseDamage)  -- 最低1ダメージ

	-- ±10%のランダム幅
	local randomMultiplier = 0.9 + math.random() * 0.2  -- 0.9 ~ 1.1
	local finalDamage = baseDamage * randomMultiplier

	return math.floor(finalDamage)  -- 整数に丸める
end

-- 攻撃間隔を計算
local function calculateAttackInterval(playerSpeed: number, enemySpeed: number): number
	-- 攻撃間隔 = 1 + (プレイヤー素早さ / 敵素早さ - 1) * 0.5
	local interval = 1 + (playerSpeed / enemySpeed - 1) * 0.5
	return math.max(0.5, interval)  -- 最低0.5秒
end

-- 敵の攻撃処理
local function enemyAttack(player: Player, battleData)
	if not ActiveBattles[player] or EndingBattles[player] then
		return  -- バトル終了済み
	end

	local monsterDef = battleData.monsterDef
	local playerStats = PlayerStats.getStats(player)

	if not playerStats then
		warn(("[BattleSystem] %s のステータスが見つかりません"):format(player.Name))
		return
	end

	-- ダメージ計算
	local damage = calculateDamage(monsterDef.Attack, playerStats.Defense)

	print(("[BattleSystem] %s が %s から %d ダメージを受けた"):format(
		player.Name, battleData.monster.Name, damage
		))

	-- プレイヤーにダメージ
	local isDead = PlayerStats.takeDamage(player, damage)

	-- HPをクライアントに通知
	PlayerHPUpdateEvent:FireClient(player, playerStats.CurrentHP, playerStats.MaxHP)

	-- 死亡判定
	if isDead then
		print(("[BattleSystem] %s は倒れた！"):format(player.Name))
		BattleSystem.endBattle(player, false)  -- 敗北
		return
	end

	-- 次の攻撃をスケジュール
	local attackInterval = calculateAttackInterval(playerStats.Speed, monsterDef.Speed)
	battleData.nextAttackTime = tick() + attackInterval

	print(("[BattleSystem] 次の攻撃まで %.1f 秒"):format(attackInterval))
end

-- バトル開始
function BattleSystem.startBattle(player: Player, monster: Model)
	print(("[BattleSystem] startBattle呼び出し: %s vs %s"):format(player.Name, monster.Name))

	-- クールダウンチェック
	local timeSinceLastBattle = tick() - LastBattleEndTime
	if timeSinceLastBattle < BATTLE_COOLDOWN then
		return false
	end

	-- 二重チェック
	if GlobalBattleActive then
		return false
	end

	if BattleSystem.isInBattle(player) then
		return false
	end

	-- 終了処理中チェック
	if EndingBattles[player] then
		print(("[BattleSystem] %s は終了処理中です"):format(player.Name))
		return false
	end

	local character = player.Character
	if not character then
		return false
	end

	local humanoid = character:FindFirstChildOfClass("Humanoid")
	local hrp = character:FindFirstChild("HumanoidRootPart")
	local monsterHumanoid = monster:FindFirstChildOfClass("Humanoid")
	local monsterHrp = monster.PrimaryPart

	if not humanoid or not hrp or not monsterHumanoid or not monsterHrp then
		return false
	end

	-- モンスターの種類を取得
	local monsterKind = monster:GetAttribute("MonsterKind") or "Unknown"
	local monsterDef = getMonsterDef(monsterKind)

	if not monsterDef then
		warn(("[BattleSystem] モンスター定義が見つかりません: %s"):format(monsterKind))
		return false
	end

	-- プレイヤーステータスを取得
	local playerStats = PlayerStats.getStats(player)
	if not playerStats then
		warn(("[BattleSystem] %s のステータスが見つかりません"):format(player.Name))
		return false
	end

	print(("[BattleSystem] バトル開始: %s vs %s"):format(player.Name, monster.Name))
	print(("  プレイヤー: HP %d/%d, 素早さ %d, 攻撃 %d, 守備 %d"):format(
		playerStats.CurrentHP, playerStats.MaxHP,
		playerStats.Speed, playerStats.Attack, playerStats.Defense
		))
	print(("  モンスター: HP %d, 素早さ %d, 攻撃 %d, 守備 %d"):format(
		monsterDef.HP, monsterDef.Speed, monsterDef.Attack, monsterDef.Defense
		))

	-- グローバルバトルフラグをON
	GlobalBattleActive = true

	-- 元の速度を保存
	local originalPlayerSpeed = humanoid.WalkSpeed
	local originalJumpPower = humanoid.JumpPower
	local originalMonsterSpeed = monsterHumanoid.WalkSpeed

	-- プレイヤーを完全停止
	humanoid.WalkSpeed = 0
	humanoid.JumpPower = 0
	humanoid.JumpHeight = 0

	-- アニメーションを完全停止
	for _, track in pairs(humanoid:GetPlayingAnimationTracks()) do
		track:Stop(0)
	end

	humanoid:ChangeState(Enum.HumanoidStateType.Physics)
	task.wait(0.05)
	humanoid:ChangeState(Enum.HumanoidStateType.Running)
	hrp.Anchored = true
	hrp.AssemblyLinearVelocity = Vector3.zero
	hrp.AssemblyAngularVelocity = Vector3.zero

	-- モンスターを完全停止
	monsterHumanoid.WalkSpeed = 0
	monsterHumanoid.JumpPower = 0
	monsterHumanoid:MoveTo(monsterHrp.Position)

	-- モンスターの全パーツをAnchor
	for _, part in ipairs(monster:GetDescendants()) do
		if part:IsA("BasePart") then
			part.Anchored = true
		end
	end

	-- プレイヤーの1文字あたりのダメージを計算
	local damagePerKey = math.floor(playerStats.Attack * 0.8)
	damagePerKey = math.max(1, damagePerKey)  -- 最低1ダメージ

	-- 敵の最初の攻撃タイミングを計算
	local attackInterval = calculateAttackInterval(playerStats.Speed, monsterDef.Speed)
	local nextAttackTime = tick() + attackInterval

	-- 戦闘データを記録
	ActiveBattles[player] = {
		monster = monster,
		monsterDef = monsterDef,
		monsterHP = monsterDef.HP,
		monsterMaxHP = monsterDef.HP,
		damagePerKey = damagePerKey,
		nextAttackTime = nextAttackTime,
		startTime = tick(),
		originalPlayerSpeed = originalPlayerSpeed,
		originalJumpPower = originalJumpPower,
		originalMonsterSpeed = originalMonsterSpeed
	}

	-- クライアントにバトル開始を通知
	BattleStartEvent:FireClient(
		player,
		monster.Name,
		monsterDef.HP,
		monsterDef.HP,
		damagePerKey,
		monsterDef.TypingLevels or {{level = "level_1", weight = 100}},
		playerStats.CurrentHP,
		playerStats.MaxHP
	)

	-- 敵の攻撃ループを開始
	task.spawn(function()
		while ActiveBattles[player] and not EndingBattles[player] do
			local battleData = ActiveBattles[player]
			if not battleData then break end

			-- 攻撃タイミングをチェック
			if tick() >= battleData.nextAttackTime then
				enemyAttack(player, battleData)
			end

			task.wait(0.1)  -- 0.1秒ごとにチェック
		end
	end)

	return true
end

-- プレイヤーからのダメージ処理
local function onDamageReceived(player, damageAmount)
	-- バトル終了処理中はダメージを無視
	if EndingBattles[player] then
		print(("[BattleSystem] %s は終了処理中のため、ダメージを無視"):format(player.Name))
		return
	end

	local battleData = ActiveBattles[player]
	if not battleData then
		warn(("[BattleSystem] %s はバトル中ではありません（ダメージ無視）"):format(player.Name))
		return
	end

	-- HPを減らす
	local oldHP = battleData.monsterHP
	battleData.monsterHP = math.max(0, battleData.monsterHP - damageAmount)

	print(("[BattleSystem] ========================================"):format())
	print(("[BattleSystem] ダメージ処理"):format())
	print(("  プレイヤー: %s"):format(player.Name))
	print(("  ダメージ量: %d"):format(damageAmount))
	print(("  HP変化: %d → %d"):format(oldHP, battleData.monsterHP))
	print(("  最大HP: %d"):format(battleData.monsterMaxHP))
	print(("[BattleSystem] ========================================"):format())

	-- クライアントにHP更新を通知
	BattleHPUpdateEvent:FireClient(player, battleData.monsterHP)

	-- HPが0になったら勝利
	if battleData.monsterHP <= 0 then
		print(("[BattleSystem] ========================================"):format())
		print(("[BattleSystem] 🎉 勝利条件達成！"):format())
		print(("  %s が %s を倒しました！"):format(player.Name, battleData.monster.Name))
		print(("  モンスターHP: %d"):format(battleData.monsterHP))
		print(("[BattleSystem] endBattle(true) を呼び出します"):format())
		print(("[BattleSystem] ========================================"):format())

		BattleSystem.endBattle(player, true)

		print(("[BattleSystem] endBattle(true) 呼び出し完了"):format())
	end
end

-- バトル終了
function BattleSystem.endBattle(player: Player, victory: boolean)
	print(("[BattleSystem] バトル終了: %s - %s"):format(
		player.Name, victory and "勝利" or "敗北"
		))

	-- 二重終了チェック
	if EndingBattles[player] then
		warn(("[BattleSystem] %s は既に終了処理中です"):format(player.Name))
		return
	end

	-- 終了処理中フラグを立てる
	EndingBattles[player] = true

	-- 【重要】勝利時のみグローバルバトルフラグをOFF
	-- 敗北時は死亡選択が完了するまで維持
	if victory then
		GlobalBattleActive = false
	end

	-- クールダウン開始
	LastBattleEndTime = tick()

	local battleData = ActiveBattles[player]
	if not battleData then
		warn("[BattleSystem] battleDataが存在しません！")

		-- 最低限の復元
		local character = player.Character
		if character then
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			local hrp = character:FindFirstChild("HumanoidRootPart")
			if humanoid then
				humanoid.WalkSpeed = 16
				humanoid.JumpPower = 50
				humanoid.JumpHeight = 7.2
			end
			if hrp then
				hrp.Anchored = false
			end
		end

		BattleEndEvent:FireClient(player, victory)
		ActiveBattles[player] = nil

		-- 終了処理完了後にフラグを解除
		task.delay(1, function()
			EndingBattles[player] = nil
		end)

		return
	end

	local character = player.Character
	local monster = battleData.monster
	local monsterDef = battleData.monsterDef

	-- 勝利時の処理
	if victory then
		-- プレイヤーの移動を復元
		if character then
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			local hrp = character:FindFirstChild("HumanoidRootPart")
			if humanoid then
				humanoid.WalkSpeed = battleData.originalPlayerSpeed or 16
				humanoid.JumpPower = battleData.originalJumpPower or 50
				humanoid.JumpHeight = 7.2
			end
			if hrp then
				hrp.Anchored = false
			end
		end

		-- 経験値とゴールドを付与
		if monsterDef.Experience then
			print(("[BattleSystem] 経験値 %d を付与"):format(monsterDef.Experience))
			PlayerStats.addExperience(player, monsterDef.Experience)
		end
		if monsterDef.Gold then
			print(("[BattleSystem] ゴールド %d を付与"):format(monsterDef.Gold))
			PlayerStats.addGold(player, monsterDef.Gold)
		end

		print(("[BattleSystem] ========================================"):format())
		print(("[BattleSystem] モンスター撃破カウント処理開始"):format())
		print(("[BattleSystem] プレイヤー: %s"):format(player.Name))
		print(("[BattleSystem] モンスター: %s"):format(battleData.monster.Name))


		PlayerStats.addMonstersDefeated(player, 1)

		print(("[BattleSystem] モンスター撃破カウント処理完了"):format())
		print(("[BattleSystem] ========================================"):format())


		-- 少し待ってからステータス更新を送信（念のため）
		task.wait(0.1)
		sendStatusUpdate(player)

		-- モンスターを非表示
		monster:SetAttribute("Defeated", true)

		for _, part in ipairs(monster:GetDescendants()) do
			if part:IsA("BasePart") then
				part.Transparency = 1
			end
		end

		local hrp = monster:FindFirstChild("HumanoidRootPart")
		if hrp then
			local gui = hrp:FindFirstChild("DebugInfo")
			if gui then
				gui.Enabled = false
			end
		end

		-- 1秒後に削除
		task.delay(1, function()
			if monster and monster.Parent then
				monster:Destroy()
			end
		end)
	else
		-- 敗北時：プレイヤーは移動制限を維持（死亡選択UIで選んだ後に復元）
		-- モンスターを復元
		monster:SetAttribute("InBattle", false)

		local monsterHumanoid = monster:FindFirstChildOfClass("Humanoid")
		if monsterHumanoid then
			monsterHumanoid.WalkSpeed = battleData.originalMonsterSpeed or 14
		end

		-- Anchor解除
		local partsToUnanchor = {}
		for _, part in ipairs(monster:GetDescendants()) do
			if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
				table.insert(partsToUnanchor, part)
			end
		end

		for _, part in ipairs(partsToUnanchor) do
			part.Anchored = false
		end

		if monster.PrimaryPart then
			task.wait(0.1)
			monster.PrimaryPart.Anchored = false
		end

		-- 死亡時の選択UIを表示
		local playerStats = PlayerStats.getStats(player)
		if playerStats then
			local reviveCost = math.floor(playerStats.Level * 50)  -- レベル * 50ゴールド
			print(("[BattleSystem] ========================================"):format())
			print(("[BattleSystem] 死亡UI表示を送信"):format())
			print(("[BattleSystem] 所持金: %d G, 復活コスト: %d G"):format(playerStats.Gold, reviveCost))
			print(("[BattleSystem] ========================================"):format())

			-- プレイヤーに死亡フラグを立てる（モンスターが接触しないように）
			if character then
				character:SetAttribute("IsDead", true)
				print(("[BattleSystem] %s に死亡フラグを設定"):format(player.Name))
			end

			-- 【重要】倒したモンスターを記録（選択後に消去するため）
			DefeatedByMonster[player] = monster
			print(("[BattleSystem] 倒したモンスター %s を記録"):format(monster.Name))

			ShowDeathUIEvent:FireClient(player, playerStats.Gold, reviveCost)
		else
			warn("[BattleSystem] プレイヤーステータスが見つかりません！")
		end
	end

	-- クライアントに通知
	BattleEndEvent:FireClient(player, victory)

	-- 勝利時は戦闘データをクリアして終了処理フラグも解除
	if victory then
		ActiveBattles[player] = nil

		-- 終了処理完了後にフラグを解除（1秒後）
		task.delay(1, function()
			EndingBattles[player] = nil
			print(("[BattleSystem] %s の終了処理フラグを解除"):format(player.Name))
		end)
	else
		-- 敗北時は戦闘データをクリアするが、終了処理フラグは維持
		-- （死亡選択UIで選んだ後に解除する）
		ActiveBattles[player] = nil
		print(("[BattleSystem] 敗北 - 終了処理フラグを維持します（選択まで）"))
	end
end

-- 初期化
function BattleSystem.init()
	-- ステータス要求イベント
	RequestStatusEvent.OnServerEvent:Connect(function(player)
		print(("[BattleSystem] %s がステータスを要求しました"):format(player.Name))
		sendStatusUpdate(player)
	end)

	-- ダメージイベント
	BattleDamageEvent.OnServerEvent:Connect(function(player, damageAmount)
		print(("[BattleSystem] ダメージ通知受信: %s -> %d"):format(player.Name, damageAmount))
		onDamageReceived(player, damageAmount)
	end)

	-- 勝利イベント（念のため残しておく）
	BattleVictoryEvent.OnServerEvent:Connect(function(player)
		print(("[BattleSystem] 勝利通知受信: %s"):format(player.Name))

		if BattleSystem.isInBattle(player) then
			BattleSystem.endBattle(player, true)
		end
	end)

	-- 死亡時の選択イベント
	DeathChoiceEvent.OnServerEvent:Connect(function(player, choice)
		print(("[BattleSystem] %s が選択: %s"):format(player.Name, choice))

		-- 【重要】グローバルバトルフラグを解除（敗北時に維持していた）
		GlobalBattleActive = false
		print("[BattleSystem] グローバルバトルフラグを解除")

		-- 【重要】終了処理フラグを解除（モンスターが接触できるようにする）
		EndingBattles[player] = nil
		print(("[BattleSystem] %s の終了処理フラグを解除"):format(player.Name))

		local playerStats = PlayerStats.getStats(player)
		if not playerStats then return end

		-- 死亡フラグを解除
		local character = player.Character
		if character then
			character:SetAttribute("IsDead", false)
			print(("[BattleSystem] %s の死亡フラグを解除"):format(player.Name))
		end

		-- プレイヤーの移動制限を解除
		if character then
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			local hrp = character:FindFirstChild("HumanoidRootPart")
			if humanoid then
				humanoid.WalkSpeed = 16
				humanoid.JumpPower = 50
				humanoid.JumpHeight = 7.2
			end
			if hrp then
				hrp.Anchored = false
			end
		end

		-- 【重要】倒したモンスターを消去（両方の選択肢で消去）
		local defeatedMonster = DefeatedByMonster[player]
		if defeatedMonster and defeatedMonster.Parent then
			print(("[BattleSystem] 倒したモンスター %s を消去"):format(defeatedMonster.Name))

			-- 非表示化
			defeatedMonster:SetAttribute("Defeated", true)
			for _, part in ipairs(defeatedMonster:GetDescendants()) do
				if part:IsA("BasePart") then
					part.Transparency = 1
				end
			end

			-- ラベル非表示
			local hrp = defeatedMonster:FindFirstChild("HumanoidRootPart")
			if hrp then
				local gui = hrp:FindFirstChild("DebugInfo")
				if gui then
					gui.Enabled = false
				end
			end

			-- 削除
			task.delay(0.5, function()
				if defeatedMonster and defeatedMonster.Parent then
					defeatedMonster:Destroy()
				end
			end)
		end

		-- 記録をクリア
		DefeatedByMonster[player] = nil

		if choice == "return" then
			-- 街に戻る
			print(("[BattleSystem] %s を街に戻します"):format(player.Name))

			-- HPを全回復
			PlayerStats.fullHeal(player)

			-- StartTownの座標を取得
			print("[BattleSystem] StartTownの座標を取得中...")
			local IslandsRegistry = require(ReplicatedStorage:WaitForChild("Islands"):WaitForChild("Registry"))
			print(("[BattleSystem] IslandsRegistry取得完了。島の数: %d"):format(#IslandsRegistry))

			local townConfig = nil
			for i, island in ipairs(IslandsRegistry) do
				print(("[BattleSystem] 島 %d: name=%s"):format(i, tostring(island.name)))
				if island.name == "StartTown" then
					townConfig = island
					print("[BattleSystem] StartTownを発見！")
					break
				end
			end

			-- 街にテレポート
			if character and townConfig then
				local hrp = character:FindFirstChild("HumanoidRootPart")
				if hrp then
					local spawnX = townConfig.centerX
					local spawnZ = townConfig.centerZ
					local spawnY = townConfig.baseY + 50  -- 高めに設定
					print(("[BattleSystem] テレポート座標: X=%.0f, Y=%.0f, Z=%.0f"):format(
						spawnX, spawnY, spawnZ
						))

					-- テレポート実行
					hrp.CFrame = CFrame.new(spawnX, spawnY, spawnZ)

					-- 少し待ってから再度設定（他のシステムの干渉を防ぐ）
					task.wait(0.1)
					hrp.CFrame = CFrame.new(spawnX, spawnY, spawnZ)

					print(("[BattleSystem] %s を街にテレポート完了"):format(player.Name))

					-- ZoneManagerにも通知
					local ZoneManager = require(ServerScriptService:WaitForChild("ZoneManager"))
					ZoneManager.PlayerZones[player] = "StartTown"
					print("[BattleSystem] ZoneManagerにStartTownを記録")

					-- 【重要】StartTownのポータルを再生成
					if _G.CreatePortalsForZone then
						print("[BattleSystem] StartTownのポータルを再生成")
						_G.CreatePortalsForZone("StartTown")
					else
						warn("[BattleSystem] CreatePortalsForZone関数が見つかりません")
					end
				end
			elseif character then
				-- フォールバック：townConfigが見つからない場合
				warn("[BattleSystem] StartTownが見つかりません！")
				print("[BattleSystem] フォールバック：原点にテレポート")
				local hrp = character:FindFirstChild("HumanoidRootPart")
				if hrp then
					hrp.CFrame = CFrame.new(0, 50, 0)
				end
			end

			-- ステータス更新
			sendStatusUpdate(player)

		elseif choice == "revive" then
			-- ゴールドで復活
			local reviveCost = math.floor(playerStats.Level * 50)

			if PlayerStats.removeGold(player, reviveCost) then
				print(("[BattleSystem] %s がゴールド %d で復活"):format(player.Name, reviveCost))

				-- HPを全回復
				PlayerStats.fullHeal(player)

				-- 【重要】復活後のクールダウンを設定（3秒間バトル不可）
				LastBattleEndTime = tick()
				print("[BattleSystem] 復活後のクールダウン開始")

				-- ステータス更新
				sendStatusUpdate(player)
			else
				warn(("[BattleSystem] %s のゴールドが不足しています"):format(player.Name))
			end
		end
	end)

	-- ダメージイベント
	BattleDamageEvent.OnServerEvent:Connect(function(player, damageAmount)
		print(("[BattleSystem] ダメージ通知受信: %s -> %d"):format(player.Name, damageAmount))
		onDamageReceived(player, damageAmount)
	end)

	-- タイプミスイベント（新規追加）
	TypingMistakeEvent.OnServerEvent:Connect(function(player)
		print(("[BattleSystem] タイプミス受信: %s"):format(player.Name))

		local battleData = ActiveBattles[player]
		if not battleData then
			warn(("[BattleSystem] %s はバトル中ではありません（タイプミス無視）"):format(player.Name))
			return
		end

		local monsterDef = battleData.monsterDef
		local playerStats = PlayerStats.getStats(player)

		if not playerStats then
			warn(("[BattleSystem] %s のステータスが見つかりません"):format(player.Name))
			return
		end

		-- タイプミスダメージ = 敵の通常攻撃の半分
		local normalDamage = calculateDamage(monsterDef.Attack, playerStats.Defense)
		local mistakeDamage = math.floor(normalDamage * 0.5)
		mistakeDamage = math.max(1, mistakeDamage)  -- 最低1ダメージ

		print(("[BattleSystem] %s がタイプミスで %d ダメージ"):format(player.Name, mistakeDamage))

		-- ダメージ処理
		local isDead = PlayerStats.takeDamage(player, mistakeDamage)

		-- HPをクライアントに通知
		PlayerHPUpdateEvent:FireClient(player, playerStats.CurrentHP, playerStats.MaxHP)

		-- 死亡判定
		if isDead then
			print(("[BattleSystem] %s はタイプミスで倒れた！"):format(player.Name))
			BattleSystem.endBattle(player, false)  -- 敗北
		end
	end)

	-- 勝利イベント（念のため残しておく）

	-- デッドロック検出
	task.spawn(function()
		while true do
			task.wait(5)

			for player, battleData in pairs(ActiveBattles) do
				local duration = tick() - battleData.startTime

				if duration > 60 then
					warn(("[BattleSystem] デッドロック検出！ %s のバトルを強制終了"):format(player.Name))
					BattleSystem.endBattle(player, false)
				end
			end
		end
	end)

	print("[BattleSystem] 初期化完了（敵攻撃システム対応）")
end

-- バトル状態を強制リセット
function BattleSystem.resetAllBattles()
	print("[BattleSystem] 全バトル状態をリセット")

	GlobalBattleActive = false

	for player, _ in pairs(ActiveBattles) do
		ActiveBattles[player] = nil
		EndingBattles[player] = nil

		if player.Character then
			player.Character:SetAttribute("InBattle", false)

			local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
			local hrp = player.Character:FindFirstChild("HumanoidRootPart")
			if humanoid then
				humanoid.WalkSpeed = 16
				humanoid.JumpPower = 50
				humanoid.JumpHeight = 7.2
			end
			if hrp then
				hrp.Anchored = false
			end
		end
	end

	local monstersFolder = workspace:FindFirstChild("Monsters")
	if monstersFolder then
		for _, model in ipairs(monstersFolder:GetChildren()) do
			if model:IsA("Model") then
				model:SetAttribute("InBattle", false)
				model:SetAttribute("Defeated", false)
			end
		end
	end

	for _, model in ipairs(workspace:GetChildren()) do
		if model:IsA("Model") and model:GetAttribute("IsEnemy") then
			model:SetAttribute("InBattle", false)
			model:SetAttribute("Defeated", false)
		end
	end

	print("[BattleSystem] リセット完了")
end

return BattleSystem
===== ./ServerScriptService/MonsterSpawner.server.lua =====
-- ServerScriptService/MonsterSpawner.server.lua
-- ゾーン対応版モンスター配置システム（バトル高速化版）

local ServerStorage = game:GetService("ServerStorage")
local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local FieldGen = require(ReplicatedStorage:WaitForChild("FieldGen"))
local ZoneManager = require(script.Parent.ZoneManager)

-- BattleSystem読込（オプショナル）
local BattleSystem = nil
local battleSystemScript = script.Parent:FindFirstChild("BattleSystem")
if battleSystemScript then
	local success, result = pcall(function()
		return require(battleSystemScript)
	end)
	if success then
		BattleSystem = result
		print("[MonsterSpawner] BattleSystem読み込み成功")
	else
		warn("[MonsterSpawner] BattleSystem読み込み失敗:", result)
	end
else
	warn("[MonsterSpawner] BattleSystemが見つかりません - バトル機能は無効です")
end

-- Registry読込
local MonstersFolder = ReplicatedStorage:WaitForChild("Monsters")
local Registry = require(MonstersFolder:WaitForChild("Registry"))

-- 島の設定を読み込み
local IslandsRegistry = require(ReplicatedStorage.Islands.Registry)
local Islands = {}
for _, island in ipairs(IslandsRegistry) do
	Islands[island.name] = island
end

-- グローバル変数
local ActiveMonsters = {}
local UpdateInterval = 0.05  -- 0.1 → 0.05秒に高速化
local MonsterCounts = {}
local TemplateCache = {}
local RespawnQueue = {}

-- 安全地帯チェック
local function isSafeZone(zoneName)
	local island = Islands[zoneName]
	if island and island.safeZone then
		return true
	end
	return false
end

-- ユーティリティ関数
local function resolveTemplate(pathArray: {string}): Model?
	local node: Instance = game
	for _, seg in ipairs(pathArray) do
		node = node:FindFirstChild(seg)
		if not node then return nil end
	end
	return (node and node:IsA("Model")) and node or nil
end

local function ensureHRP(model: Model): BasePart?
	local hrp = model:FindFirstChild("HumanoidRootPart")
	if hrp and hrp:IsA("BasePart") then
		if not model.PrimaryPart then model.PrimaryPart = hrp end
		return hrp
	end
	return nil
end

local function attachLabel(model: Model, maxDist: number)
	local hrp = model.PrimaryPart or model:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	local _, bboxSize = model:GetBoundingBox()
	local labelOffset = math.min(bboxSize.Y * 0.5 + 2, 15)

	local gui = Instance.new("BillboardGui")
	gui.Name = "DebugInfo"
	gui.Adornee = hrp
	gui.AlwaysOnTop = true
	gui.Size = UDim2.new(0, 150, 0, 50)
	gui.StudsOffset = Vector3.new(0, labelOffset, 0)
	gui.MaxDistance = maxDist
	gui.Parent = hrp

	local lb = Instance.new("TextLabel")
	lb.Name = "InfoText"
	lb.BackgroundTransparency = 1
	lb.TextScaled = true
	lb.Font = Enum.Font.GothamBold
	lb.TextColor3 = Color3.new(1, 1, 1)
	lb.TextStrokeTransparency = 0.5
	lb.Size = UDim2.fromScale(1, 1)
	lb.Text = "Ready"
	lb.Parent = gui
end

local function placeOnGround(model: Model, x: number, z: number)
	local hrp = model.PrimaryPart or model:FindFirstChild("HumanoidRootPart")
	if not hrp then
		warn("[MonsterSpawner] HumanoidRootPart が見つかりません: " .. model.Name)
		return
	end

	local groundY = FieldGen.raycastGroundY(x, z, 100)
		or FieldGen.raycastGroundY(x, z, 200)
		or FieldGen.raycastGroundY(x, z, 50)
		or 10

	local _, yaw = hrp.CFrame:ToOrientation()
	model:PivotTo(CFrame.new(x, groundY + 20, z) * CFrame.Angles(0, yaw, 0))

	local bboxCFrame, bboxSize = model:GetBoundingBox()
	local bottomY = bboxCFrame.Position.Y - (bboxSize.Y * 0.5)
	local offset = hrp.Position.Y - bottomY

	model:PivotTo(CFrame.new(x, groundY + offset, z) * CFrame.Angles(0, yaw, 0))
end

local function nearestPlayer(position: Vector3)
	local best, bestDist = nil, math.huge
	for _, pl in ipairs(Players:GetPlayers()) do
		local ch = pl.Character
		local hrp = ch and ch:FindFirstChild("HumanoidRootPart")
		if hrp then
			local d = (position - hrp.Position).Magnitude
			if d < bestDist then
				best, bestDist = pl, d
			end
		end
	end
	return best, bestDist
end

-- AI状態管理（高速化版）
local AIState = {}
AIState.__index = AIState

function AIState.new(monster, def)
	local self = setmetatable({}, AIState)
	self.monster = monster
	self.def = def
	self.humanoid = monster:FindFirstChildOfClass("Humanoid")
	self.root = monster.PrimaryPart
	self.courage = math.random()
	self.brave = (self.courage > 0.5)
	self.wanderGoal = nil
	self.nextWanderAt = 0
	self.lastUpdateTime = 0
	self.lastDistanceLog = 0
	self.updateRate = def.AiTickRate or 0.3
	self.nearUpdateRate = 0.05  -- 0.2 → 0.05秒に高速化（バトル判定が速くなる）
	self.farUpdateRate = 0.5    -- 1.0 → 0.5秒に高速化

	self.originalSpeed = self.humanoid.WalkSpeed
	self.wasInBattle = false

	return self
end

function AIState:shouldUpdate(currentTime)
	local _, dist = nearestPlayer(self.root.Position)
	-- 近距離判定を150スタッドに拡大（バトル判定をより頻繁に）
	local rate = dist < 150 and self.nearUpdateRate or self.farUpdateRate
	return (currentTime - self.lastUpdateTime) >= rate
end

function AIState:update()
	if not self.monster.Parent or not self.humanoid or not self.root then
		return false
	end

	if self.monster:GetAttribute("Defeated") then
		if not self.loggedDefeated then
			-- print(("[AI DEBUG] %s - Defeated状態のためスキップ"):format(self.monster.Name))
			self.loggedDefeated = true
		end
		return false
	end

	-- バトル状態を確認
	local isGlobalBattle = BattleSystem and BattleSystem.isAnyBattleActive and BattleSystem.isAnyBattleActive()
	local isThisMonsterInBattle = self.monster:GetAttribute("InBattle")
	local isAnyBattle = isGlobalBattle or isThisMonsterInBattle

	-- いずれかのバトルが進行中なら停止
	if isAnyBattle then
		self.humanoid.WalkSpeed = 0
		self.humanoid:MoveTo(self.root.Position)
		self.wasInBattle = true
		return true
	end

	-- バトルが終了したら速度を復元
	if self.wasInBattle and not isAnyBattle then
		-- print(("[AI DEBUG] %s - バトル終了、速度復元: %.1f"):format(self.monster.Name, self.originalSpeed))
		self.humanoid.WalkSpeed = self.originalSpeed
		self.wasInBattle = false
		self.loggedDefeated = false
	end

	local p, dist = nearestPlayer(self.root.Position)
	local chaseRange = self.def.ChaseDistance or 60
	local now = os.clock()

	-- バトル判定（高速化・距離拡大）
	if BattleSystem and p and dist <= 7 then  -- 5 → 7スタッドに拡大
		-- print(("[AI DEBUG] %s - 接触検出！距離=%.1f"):format(self.monster.Name, dist))

		if BattleSystem.isInBattle(p) then
			self.humanoid:MoveTo(self.root.Position)
			return true
		end

		if BattleSystem.isAnyBattleActive and BattleSystem.isAnyBattleActive() then
			self.humanoid:MoveTo(self.root.Position)
			return true
		end

		if self.monster:GetAttribute("InBattle") then
			return true
		end

		local character = p.Character
		if character then
			-- 【重要】即座にプレイヤーを停止（バトル開始前）
			local playerHumanoid = character:FindFirstChildOfClass("Humanoid")
			local playerHrp = character:FindFirstChild("HumanoidRootPart")

			if playerHumanoid and playerHrp then
				-- プレイヤーを即座に停止
				playerHumanoid.WalkSpeed = 0
				playerHumanoid.JumpPower = 0
				playerHrp.Anchored = true
			end

			self.monster:SetAttribute("InBattle", true)
			self.humanoid.WalkSpeed = 0
			self.humanoid:MoveTo(self.root.Position)

			-- task.wait(0.1) を削除して即座にバトル開始

			local battleStarted = BattleSystem.startBattle(p, self.monster)
			-- print(("[AI DEBUG] バトル開始結果: %s"):format(tostring(battleStarted)))

			if not battleStarted then
				-- バトル開始失敗時はプレイヤーも解放
				self.monster:SetAttribute("InBattle", false)
				self.humanoid.WalkSpeed = self.originalSpeed

				if playerHumanoid and playerHrp then
					playerHumanoid.WalkSpeed = 16
					playerHumanoid.JumpPower = 50
					playerHrp.Anchored = false
				end
			end

			return true
		else
			self.monster:SetAttribute("InBattle", false)
		end
	end

	-- 海チェック
	local isInWater = self.root.Position.Y < 0 or self.humanoid:GetState() == Enum.HumanoidStateType.Swimming

	-- ラベル更新
	local label = self.root:FindFirstChild("DebugInfo")
		and self.root.DebugInfo:FindFirstChild("InfoText")
	if label then
		local behavior = self.brave and "CHASE" or "FLEE"
		label.Text = string.format("%s\n%s | %.1fm", self.monster.Name, behavior, dist or 999)
	end

	local gui = self.root:FindFirstChild("DebugInfo")
	if gui then
		gui.Enabled = not isInWater
	end

	-- 行動決定
	if not p then
		-- プレイヤーがいない：徘徊のみ
		local w = self.def.Wander or {}
		if not self.wanderGoal or (self.root.Position - self.wanderGoal).Magnitude < 5 or now >= self.nextWanderAt then
			local ang = math.random() * math.pi * 2
			local rad = math.random(w.MinRadius or 20, w.MaxRadius or 60)
			local gx = self.root.Position.X + math.cos(ang) * rad
			local gz = self.root.Position.Z + math.sin(ang) * rad
			local gy = FieldGen.raycastGroundY(gx, gz, 100) or self.root.Position.Y
			self.wanderGoal = Vector3.new(gx, gy, gz)
			self.nextWanderAt = now + math.random(w.MinWait or 2, w.MaxWait or 5)
		end
		if self.wanderGoal then
			self.humanoid:MoveTo(self.wanderGoal)
		end
	elseif dist < chaseRange then
		-- 追跡 or 逃走
		self.wanderGoal = nil
		if self.brave then
			self.humanoid:MoveTo(p.Character.HumanoidRootPart.Position)
		else
			local away = (self.root.Position - p.Character.HumanoidRootPart.Position).Unit
			self.humanoid:MoveTo(self.root.Position + away * 80)
		end
	else
		-- 徘徊
		local w = self.def.Wander or {}
		if not self.wanderGoal or (self.root.Position - self.wanderGoal).Magnitude < 5 or now >= self.nextWanderAt then
			local ang = math.random() * math.pi * 2
			local rad = math.random(w.MinRadius or 20, w.MaxRadius or 60)
			local gx = self.root.Position.X + math.cos(ang) * rad
			local gz = self.root.Position.Z + math.sin(ang) * rad
			local gy = FieldGen.raycastGroundY(gx, gz, 100) or self.root.Position.Y
			self.wanderGoal = Vector3.new(gx, gy, gz)
			self.nextWanderAt = now + math.random(w.MinWait or 2, w.MaxWait or 5)
		end
		if self.wanderGoal then
			self.humanoid:MoveTo(self.wanderGoal)
		end
	end

	self.lastUpdateTime = now
	return true
end

-- スポーン処理（島指定版）
local function spawnMonster(template: Model, index: number, def, islandName)
	local m = template:Clone()
	m.Name = (def.Name or template.Name) .. "_" .. index

	local hum = m:FindFirstChildOfClass("Humanoid")
	local hrp = ensureHRP(m)

	if not hum or not hrp then
		warn("[MonsterSpawner] Humanoid または HRP がありません: " .. m.Name)
		m:Destroy()
		return
	end

	m:SetAttribute("IsEnemy", true)
	m:SetAttribute("MonsterKind", def.Name or "Monster")
	m:SetAttribute("ChaseDistance", def.ChaseDistance or 60)
	m:SetAttribute("SpawnZone", islandName)
	m:SetAttribute("SpawnIsland", islandName)

	local speedMin = def.SpeedMin or 0.7
	local speedMax = def.SpeedMax or 1.3
	local speedMult = speedMin + math.random() * (speedMax - speedMin)
	hum.WalkSpeed = (def.WalkSpeed or 14) * speedMult
	hum.HipHeight = 0

	hrp.Anchored = true
	hrp.CanCollide = false
	hrp.Transparency = 1

	for _, descendant in ipairs(m:GetDescendants()) do
		if descendant:IsA("BasePart") and descendant ~= hrp then
			descendant.CanCollide = true
			descendant.Anchored = false

			for _, child in ipairs(descendant:GetChildren()) do
				if child:IsA("WeldConstraint") or child:IsA("Weld") then
					child:Destroy()
				end
			end

			local weld = Instance.new("WeldConstraint")
			weld.Part0 = hrp
			weld.Part1 = descendant
			weld.Parent = descendant
		end
	end

	m.Parent = Workspace

	local island = Islands[islandName]
	if not island then
		warn(("[MonsterSpawner] 島 '%s' が見つかりません"):format(islandName))
		m:Destroy()
		return
	end

	local spawnRadius
	if def.radiusPercent then
		spawnRadius = (island.sizeXZ / 2) * (def.radiusPercent / 100)
	else
		spawnRadius = def.spawnRadius or 50
	end

	local rx = island.centerX + math.random(-spawnRadius, spawnRadius)
	local rz = island.centerZ + math.random(-spawnRadius, spawnRadius)

	placeOnGround(m, rx, rz)
	-- attachLabel(m, def.LabelMaxDistance or 250)

	task.wait(0.05)
	hrp.Anchored = false

	local aiState = AIState.new(m, def)
	table.insert(ActiveMonsters, aiState)

	local monsterName = def.Name or "Monster"
	if not MonsterCounts[islandName] then
		MonsterCounts[islandName] = {}
	end
	MonsterCounts[islandName][monsterName] = (MonsterCounts[islandName][monsterName] or 0) + 1

	print(("[MonsterSpawner] %s を %s にスポーン"):format(m.Name, islandName))
end

-- ゾーンにモンスターをスポーンする（大陸対応版）
function spawnMonstersForZone(zoneName)
	if isSafeZone(zoneName) then
		print(("[MonsterSpawner] %s は安全地帯です。モンスターをスポーンしません"):format(zoneName))
		return
	end

	print(("[MonsterSpawner] %s にモンスターを配置中..."):format(zoneName))

	local islandsInZone = {}

	local ContinentsRegistry = require(ReplicatedStorage.Continents.Registry)
	local Continents = {}
	for _, continent in ipairs(ContinentsRegistry) do
		Continents[continent.name] = continent
	end

	if Continents[zoneName] then
		local continent = Continents[zoneName]
		for _, islandName in ipairs(continent.islands) do
			islandsInZone[islandName] = true
		end
		print(("[MonsterSpawner] 大陸 %s の島: %s"):format(zoneName, table.concat(continent.islands, ", ")))
	else
		islandsInZone[zoneName] = true
	end

	for _, def in ipairs(Registry) do
		local monsterName = def.Name or "Monster"
		local template = TemplateCache[monsterName]

		if template then
			if def.SpawnLocations then
				for _, location in ipairs(def.SpawnLocations) do
					local islandName = location.islandName

					if islandsInZone[islandName] then
						local radiusText = location.radiusPercent or 100
						print(("[MonsterSpawner] %s を %s に配置中 (数: %d, 範囲: %d%%)"):format(
							monsterName, islandName, location.count, radiusText
							))

						if not MonsterCounts[islandName] then
							MonsterCounts[islandName] = {}
						end
						MonsterCounts[islandName][monsterName] = 0

						for i = 1, (location.count or 0) do
							local spawnDef = {}
							for k, v in pairs(def) do
								spawnDef[k] = v
							end
							spawnDef.radiusPercent = location.radiusPercent
							spawnDef.spawnRadius = location.spawnRadius

							spawnMonster(template, i, spawnDef, islandName)
							if i % 5 == 0 then task.wait() end
						end
					end
				end
			else
				warn(("[MonsterSpawner] %s は旧形式です。SpawnLocations形式に移行してください"):format(monsterName))
			end
		end
	end
end

-- リスポーン処理（島対応版）
local function scheduleRespawn(monsterName, def, islandName)
	local respawnTime = def.RespawnTime or 10
	if respawnTime <= 0 then return end

	local respawnData = {
		monsterName = monsterName,
		def = def,
		islandName = islandName,
		respawnAt = os.clock() + respawnTime
	}
	table.insert(RespawnQueue, respawnData)
end

local function processRespawnQueue()
	task.spawn(function()
		while true do
			local now = os.clock()

			for i = #RespawnQueue, 1, -1 do
				local data = RespawnQueue[i]
				if now >= data.respawnAt then
					local isActive = false
					for zoneName, _ in pairs(ZoneManager.ActiveZones) do
						isActive = true
						break
					end

					if isActive then
						local template = TemplateCache[data.monsterName]
						if template and MonsterCounts[data.islandName] then
							local nextIndex = (MonsterCounts[data.islandName][data.monsterName] or 0) + 1
							spawnMonster(template, nextIndex, data.def, data.islandName)
							print(("[MonsterSpawner] %s が %s にリスポーン"):format(data.monsterName, data.islandName))
						end
					end
					table.remove(RespawnQueue, i)
				end
			end

			task.wait(1)
		end
	end)
end

-- AI更新ループ（高速化）
local function startGlobalAILoop()
	print("[MonsterSpawner] AI更新ループ開始（高速化版）")

	task.spawn(function()
		while true do
			if #ActiveMonsters > 0 then
				local currentTime = os.clock()

				for i = #ActiveMonsters, 1, -1 do
					local state = ActiveMonsters[i]

					if state:shouldUpdate(currentTime) then
						local success, result = pcall(function()
							return state:update()
						end)

						if not success then
							warn(("[MonsterSpawner ERROR] AI更新エラー: %s - %s"):format(
								state.monster.Name, tostring(result)
								))
						elseif not result then
							local monsterDef = state.def
							local monsterName = monsterDef.Name or "Unknown"
							local zoneName = state.monster:GetAttribute("SpawnZone") or "Unknown"

							if MonsterCounts[zoneName] and MonsterCounts[zoneName][monsterName] then
								MonsterCounts[zoneName][monsterName] = MonsterCounts[zoneName][monsterName] - 1
							end

							table.remove(ActiveMonsters, i)
							scheduleRespawn(monsterName, monsterDef, zoneName)
						end
					end
				end
			end

			task.wait(UpdateInterval)
		end
	end)
end

-- ゾーンのモンスターを削除する
function despawnMonstersForZone(zoneName)
	print(("[MonsterSpawner] %s のモンスターを削除中..."):format(zoneName))

	local removedCount = 0

	for i = #ActiveMonsters, 1, -1 do
		local state = ActiveMonsters[i]
		local monsterZone = state.monster:GetAttribute("SpawnZone")

		if monsterZone == zoneName then
			state.monster:Destroy()
			table.remove(ActiveMonsters, i)
			removedCount = removedCount + 1
		end
	end

	for i = #RespawnQueue, 1, -1 do
		if RespawnQueue[i].zoneName == zoneName then
			table.remove(RespawnQueue, i)
		end
	end

	MonsterCounts[zoneName] = nil

	print(("[MonsterSpawner] %s のモンスターを %d体 削除しました"):format(zoneName, removedCount))
end

-- 初期化
print("[MonsterSpawner] === スクリプト開始（バトル高速化版）===")

if BattleSystem then
	BattleSystem.init()
	print("[MonsterSpawner] BattleSystem初期化完了")
else
	print("[MonsterSpawner] BattleSystemなしで起動")
end

Workspace:WaitForChild("World", 10)
print("[MonsterSpawner] World フォルダ検出")

task.wait(1)

print("[MonsterSpawner] モンスターテンプレートをキャッシュ中...")
for _, def in ipairs(Registry) do
	local template = resolveTemplate(def.TemplatePath)
	if template then
		local monsterName = def.Name or "Monster"
		TemplateCache[monsterName] = template
		print(("[MonsterSpawner] テンプレートキャッシュ: %s"):format(monsterName))
	else
		warn(("[MonsterSpawner] テンプレート未発見: %s"):format(def.Name or "?"))
	end
end

startGlobalAILoop()
processRespawnQueue()

print("[MonsterSpawner] === 初期化完了（バトル即座開始対応）===")

_G.SpawnMonstersForZone = spawnMonstersForZone
_G.DespawnMonstersForZone = despawnMonstersForZone
===== ./ReplicatedStorage/Continents/Registry.lua =====
local RS = game:GetService("ReplicatedStorage")
local ContinentsFolder = RS:WaitForChild("Continents")

return {
	require(ContinentsFolder.ContinentA),
	require(ContinentsFolder.ContinentB),
	require(ContinentsFolder.ContinentT),
	require(ContinentsFolder.ContinentHokkaido),  -- 追加
}
===== ./ReplicatedStorage/Continents/ContinentHokkaido.lua =====
return {
	name = "ContinentHokkaido",
	displayName = "Hokkaido Continent",

	islands = {
		"Hokkaido_W1", "Hokkaido_C1", "Hokkaido_C2", "Hokkaido_C3", 
		"Hokkaido_C4", "Hokkaido_C5", "Hokkaido_E1",
		"Hokkaido_N1", "Hokkaido_N2", "Hokkaido_N3", "Hokkaido_N4",
		"Hokkaido_NE1", "Hokkaido_NE2",
		"Hokkaido_S1", "Hokkaido_S2",
		"Hokkaido_SW1", "Hokkaido_SW2",
	},

	bridges = {},

	portals = {
		{
			name = "Hokkaido_to_Town",
			toZone = "StartTown",
			islandName = "Hokkaido_C3",
			offsetX = 0,
			offsetZ = 0,
			label = "→ Town",
			color = Color3.fromRGB(255, 200, 100),
		},
	},
}
===== ./ReplicatedStorage/Continents/ContinentA.lua =====
-- ReplicatedStorage/Continents/ContinentA
return {
	name = "ContinentA",
	displayName = "Grassland Continent",

	-- この大陸に含まれる島
	islands = {
		"StartIsland",
		"ForestIsland",
	},

	-- 島を繋ぐ橋
	bridges = {
		{
			name = "Bridge_Start_to_Forest",
			fromIsland = "StartIsland",
			toIsland = "ForestIsland",
			width = 15,
			height = 5,
			thickness = 5,
		},
	},

	-- ポータルの配置（この大陸から他の場所へ）
	portals = {
		{
			name = "ContinentA_to_Town",
			toZone = "StartTown",
			islandName = "StartIsland",  -- この島に配置
			offsetX = -50,
			offsetZ = 0,
			label = "→ Town",
			color = Color3.fromRGB(255, 200, 100),
		},
		{
			name = "ContinentA_to_ContinentB",
			toZone = "ContinentB",
			islandName = "ForestIsland",  -- この島に配置
			offsetX = 50,
			offsetZ = 0,
			label = "→ Mountain Area",
			color = Color3.fromRGB(150, 150, 255),
		},
	},
}
===== ./ReplicatedStorage/Continents/ContinentB.lua =====
-- ReplicatedStorage/Continents/ContinentB
return {
	name = "ContinentB",
	displayName = "Wilderness Continent",

	islands = {
		"MountainIsland",
		"DesertIsland",
		"VolcanoIsland",
	},

	bridges = {
		{
			name = "Bridge_Mountain_to_Desert",
			fromIsland = "MountainIsland",
			toIsland = "DesertIsland",
			width = 15,
			height = 5,
			thickness = 5,
		},
		{
			name = "Bridge_Desert_to_Volcano",
			fromIsland = "DesertIsland",
			toIsland = "VolcanoIsland",
			width = 15,
			height = 5,
			thickness = 5,
		},
	},

	portals = {
		{
			name = "ContinentB_to_ContinentA",
			toZone = "ContinentA",
			islandName = "MountainIsland",
			offsetX = -50,
			offsetZ = 0,
			label = "→ Grassland",
			color = Color3.fromRGB(100, 255, 100),
		},
	},
}
===== ./ReplicatedStorage/Continents/ContinentT.lua =====
-- ReplicatedStorage/Continents/ContinentT.lua
return {
	name = "ContinentT",
	displayName = "T-Shaped Continent",

	islands = {
		"TIsland_Left",
		"TIsland_LeftCenter",
		"TIsland_Center",
		"TIsland_RightCenter",
		"TIsland_Right",
		"TIsland_Down1",
		"TIsland_Down2",
	},

	-- 橋を削除
	bridges = {},

	portals = {
		{
			name = "ContinentT_to_Town",
			toZone = "StartTown",
			islandName = "TIsland_Center",
			offsetX = 0,
			offsetZ = 0,
			label = "→ Town",
			color = Color3.fromRGB(255, 200, 100),
		},
	},
}
===== ./ReplicatedStorage/Islands/Bridges.lua =====
return {
	{
		name = "Bridge_Start_to_Forest",
		fromIsland = 1,
		toIsland = 2,
		width = 15,  -- 20から15に変更（橋も少し細く）
		height = 5,
	},
}
===== ./ReplicatedStorage/Islands/TIsland_Down1.lua =====
return {
	name = "TIsland_Down1",
	centerX = 2160,
	centerZ = -80,
	sizeXZ = 160,
	baseY = 0,
	thickness = 10,
	grid = 10,
	hillAmplitude = 20,
	hillScale = 150,
	seed = 40000,
	generateOcean = false,
	oceanRadius = 1500,
}
===== ./ReplicatedStorage/Islands/Town.lua =====
-- ReplicatedStorage/Islands/Town.lua
return {
	name = "StartTown",
	centerX = 0,
	centerZ = 0,
	sizeXZ = 120,
	baseY = 0,
	thickness = 8,
	grid = 8,
	hillAmplitude = 3,
	hillScale = 80,
	seed = 77777,
	generateOcean = false,
	safeZone = true,  -- ← この行を追加（モンスターが出現しない）
}
===== ./ReplicatedStorage/Islands/TIsland_Down2.lua =====
return {
	name = "TIsland_Down2",
	centerX = 2160,
	centerZ = -160,
	sizeXZ = 160,
	baseY = 0,
	thickness = 10,
	grid = 10,
	hillAmplitude = 20,
	hillScale = 150,
	seed = 40000,
	generateOcean = false,
	oceanRadius = 1500,
}
===== ./ReplicatedStorage/Islands/HokkaidoIslands.lua =====
-- ReplicatedStorage/Islands/HokkaidoIslands
return {
	-- 中央部
	{name = "Hokkaido_W1", centerX = 3000, centerZ = 0, sizeXZ = 160, baseY = 0, thickness = 10, grid = 10, hillAmplitude = 25, hillScale = 160, seed = 50000, generateOcean = false},
	{name = "Hokkaido_C1", centerX = 3080, centerZ = 0, sizeXZ = 160, baseY = 0, thickness = 10, grid = 10, hillAmplitude = 25, hillScale = 160, seed = 50000, generateOcean = false},
	{name = "Hokkaido_C2", centerX = 3160, centerZ = 0, sizeXZ = 160, baseY = 0, thickness = 10, grid = 10, hillAmplitude = 25, hillScale = 160, seed = 50000, generateOcean = false},
	{name = "Hokkaido_C3", centerX = 3240, centerZ = 0, sizeXZ = 160, baseY = 0, thickness = 10, grid = 10, hillAmplitude = 25, hillScale = 160, seed = 50000, generateOcean = false},
	{name = "Hokkaido_C4", centerX = 3320, centerZ = 0, sizeXZ = 160, baseY = 0, thickness = 10, grid = 10, hillAmplitude = 25, hillScale = 160, seed = 50000, generateOcean = false},
	{name = "Hokkaido_C5", centerX = 3400, centerZ = 0, sizeXZ = 160, baseY = 0, thickness = 10, grid = 10, hillAmplitude = 25, hillScale = 160, seed = 50000, generateOcean = false},
	{name = "Hokkaido_E1", centerX = 3480, centerZ = 0, sizeXZ = 160, baseY = 0, thickness = 10, grid = 10, hillAmplitude = 25, hillScale = 160, seed = 50000, generateOcean = false},

	-- 北部
	{name = "Hokkaido_N1", centerX = 3080, centerZ = 80, sizeXZ = 160, baseY = 0, thickness = 10, grid = 10, hillAmplitude = 25, hillScale = 160, seed = 50000, generateOcean = false},
	{name = "Hokkaido_N2", centerX = 3160, centerZ = 80, sizeXZ = 160, baseY = 0, thickness = 10, grid = 10, hillAmplitude = 25, hillScale = 160, seed = 50000, generateOcean = false},
	{name = "Hokkaido_N3", centerX = 3240, centerZ = 80, sizeXZ = 160, baseY = 0, thickness = 10, grid = 10, hillAmplitude = 25, hillScale = 160, seed = 50000, generateOcean = false},
	{name = "Hokkaido_N4", centerX = 3320, centerZ = 80, sizeXZ = 160, baseY = 0, thickness = 10, grid = 10, hillAmplitude = 25, hillScale = 160, seed = 50000, generateOcean = false},

	-- 北東部（知床）
	{name = "Hokkaido_NE1", centerX = 3320, centerZ = 160, sizeXZ = 160, baseY = 0, thickness = 10, grid = 10, hillAmplitude = 30, hillScale = 160, seed = 50000, generateOcean = false},
	{name = "Hokkaido_NE2", centerX = 3400, centerZ = 160, sizeXZ = 160, baseY = 0, thickness = 10, grid = 10, hillAmplitude = 30, hillScale = 160, seed = 50000, generateOcean = false},

	-- 南部
	{name = "Hokkaido_S1", centerX = 3160, centerZ = -80, sizeXZ = 160, baseY = 0, thickness = 10, grid = 10, hillAmplitude = 25, hillScale = 160, seed = 50000, generateOcean = false},
	{name = "Hokkaido_S2", centerX = 3240, centerZ = -80, sizeXZ = 160, baseY = 0, thickness = 10, grid = 10, hillAmplitude = 25, hillScale = 160, seed = 50000, generateOcean = false},

	-- 南西部（渡島）
	{name = "Hokkaido_SW1", centerX = 3080, centerZ = -160, sizeXZ = 160, baseY = 0, thickness = 10, grid = 10, hillAmplitude = 20, hillScale = 160, seed = 50000, generateOcean = false},
	{name = "Hokkaido_SW2", centerX = 3160, centerZ = -160, sizeXZ = 160, baseY = 0, thickness = 10, grid = 10, hillAmplitude = 20, hillScale = 160, seed = 50000, generateOcean = true, oceanRadius = 2000},
}
===== ./ReplicatedStorage/Islands/TIsland_LeftCenter.lua =====
return {
	name = "TIsland_LeftCenter",
	centerX = 2080,  -- 80スタッド間隔（大幅に重なる）
	centerZ = 0,
	sizeXZ = 160,
	baseY = 0,
	thickness = 10,
	grid = 10,
	hillAmplitude = 20,
	hillScale = 150,
	seed = 40000,
	generateOcean = false,
	oceanRadius = 1500,
}
===== ./ReplicatedStorage/Islands/Registry.lua =====
-- ReplicatedStorage/Islands/Registry
local RS = game:GetService("ReplicatedStorage")
local IslandsFolder = RS:WaitForChild("Islands")

local allIslands = {}

-- 島定義のリスト
local islandModules = {
	IslandsFolder.Town,
	IslandsFolder.Island1,
	IslandsFolder.Island2,
	IslandsFolder.Island3,
	IslandsFolder.Island4,
	IslandsFolder.Island5,
	IslandsFolder.TIsland_Left,
	IslandsFolder.TIsland_LeftCenter,
	IslandsFolder.TIsland_Center,
	IslandsFolder.TIsland_RightCenter,
	IslandsFolder.TIsland_Right,
	IslandsFolder.TIsland_Down1,
	IslandsFolder.TIsland_Down2,
	IslandsFolder.HokkaidoIslands,  -- 複数島をまとめたファイル
}

-- 各モジュールを読み込み
for _, module in ipairs(islandModules) do
	local result = require(module)

	-- 配列かどうかをチェック（nameフィールドがあるか）
	if result.name then
		-- 単一の島定義
		table.insert(allIslands, result)
	elseif type(result) == "table" and #result > 0 then
		-- 複数の島定義（配列）
		for _, island in ipairs(result) do
			table.insert(allIslands, island)
		end
	else
		warn("[Islands/Registry] 不正な島定義:", module.Name)
	end
end

print(("[Islands/Registry] 合計 %d 個の島を読み込みました"):format(#allIslands))

return allIslands
===== ./ReplicatedStorage/Islands/TIsland_Center.lua =====
return {
	name = "TIsland_Center",
	centerX = 2160,
	centerZ = 0,
	sizeXZ = 160,
	baseY = 0,
	thickness = 10,
	grid = 10,
	hillAmplitude = 20,
	hillScale = 150,
	seed = 40000,
	generateOcean = false,
	oceanRadius = 1500,
}
===== ./ReplicatedStorage/Islands/Island3.lua =====
-- ReplicatedStorage/Islands/Island3
return {
	name = "MountainIsland",
	centerX = 1000,
	centerZ = 0,
	sizeXZ = 280,
	baseY = 0,
	thickness = 12,
	grid = 10,
	hillAmplitude = 35,  -- 山岳なので高低差大きめ
	hillScale = 200,
	seed = 11111,
	generateOcean = true,
	oceanRadius = 1500,
}
===== ./ReplicatedStorage/Islands/Island2.lua =====
return {
	name = "ForestIsland",
	centerX = 250,  -- 1200から500に変更（近く）
	centerZ = 0,
	sizeXZ = 250,  -- 500から250に変更（小さく）
	baseY = 0,
	thickness = 10,
	grid = 10,
	hillAmplitude = 25,
	hillScale = 180,
	seed = 99999,

	generateOcean = false,
}
===== ./ReplicatedStorage/Islands/TIsland_Left.lua =====
return {
	name = "TIsland_Left",
	centerX = 2000,
	centerZ = 0,
	sizeXZ = 160,  -- さらに拡大
	baseY = 0,
	thickness = 10,
	grid = 10,
	hillAmplitude = 20,
	hillScale = 150,
	seed = 40000,
	generateOcean = false,  -- 海生成をオフ
	oceanRadius = 1500,
}
===== ./ReplicatedStorage/Islands/Island1.lua =====
return {
	name = "StartIsland",
	centerX = 150,
	centerZ = 0,
	sizeXZ = 300,  -- 700から300に変更（小さく）
	baseY = 0,
	thickness = 10,
	grid = 10,
	hillAmplitude = 22,
	hillScale = 200,
	seed = 24680,

	generateOcean = true,
	oceanRadius = 1500,
}
===== ./ReplicatedStorage/Islands/Island5.lua =====
-- ReplicatedStorage/Islands/Island5

return {
	name = "VolcanoIsland",
	centerX = 1600,
	centerZ = 0,
	sizeXZ = 240,
	baseY = 0,
	thickness = 10,
	grid = 10,
	hillAmplitude = 40,  -- 火山なので高低差最大
	hillScale = 180,
	seed = 33333,
	generateOcean = true,
	oceanRadius = 1500,
}
===== ./ReplicatedStorage/Islands/Island4.lua =====
-- ReplicatedStorage/Islands/Island4
return {
	name = "DesertIsland",
	centerX = 1300,
	centerZ = 0,
	sizeXZ = 260,
	baseY = 0,
	thickness = 10,
	grid = 12,
	hillAmplitude = 15,  -- 砂漠なので平坦
	hillScale = 150,
	seed = 22222,
	generateOcean = true,
	oceanRadius = 1500,
}
===== ./ReplicatedStorage/Islands/TIsland_Right.lua =====
return {
	name = "TIsland_Right",
	centerX = 2320,
	centerZ = 0,
	sizeXZ = 160,
	baseY = 0,
	thickness = 10,
	grid = 10,
	hillAmplitude = 20,
	hillScale = 150,
	seed = 40000,
	generateOcean = true,  -- 最後の島だけ海を生成
	oceanRadius = 1500,
}
===== ./ReplicatedStorage/Islands/TIsland_RightCenter.lua =====
return {
	name = "TIsland_RightCenter",
	centerX = 2240,
	centerZ = 0,
	sizeXZ = 160,
	baseY = 0,
	thickness = 10,
	grid = 10,
	hillAmplitude = 20,
	hillScale = 150,
	seed = 40000,
	generateOcean = false,
	oceanRadius = 1500,
}
===== ./ReplicatedStorage/TypingWords.lua =====
-- ReplicatedStorage/TypingWords
-- タイピング用の単語リスト（多言語対応）

return {
	level_1 = {
		{word = "cat", ja = "猫", es = "gato", fr = "chat"},
		{word = "dog", ja = "犬", es = "perro", fr = "chien"},
		{word = "pen", ja = "ペン", es = "pluma", fr = "stylo"},
		{word = "cup", ja = "カップ", es = "taza", fr = "tasse"},
		{word = "sun", ja = "太陽", es = "sol", fr = "soleil"},
		{word = "red", ja = "赤", es = "rojo", fr = "rouge"},
		{word = "big", ja = "大きい", es = "grande", fr = "grand"},
		{word = "run", ja = "走る", es = "correr", fr = "courir"},
		{word = "fly", ja = "飛ぶ", es = "volar", fr = "voler"},
		{word = "eat", ja = "食べる", es = "comer", fr = "manger"},
	},
	level_2 = {
		{word = "apple", ja = "りんご", es = "manzana", fr = "pomme"},
		{word = "house", ja = "家", es = "casa", fr = "maison"},
		{word = "water", ja = "水", es = "agua", fr = "eau"},
		{word = "sleep", ja = "眠る", es = "dormir", fr = "dormir"},
		{word = "happy", ja = "幸せ", es = "feliz", fr = "heureux"},
		{word = "green", ja = "緑", es = "verde", fr = "vert"},
		{word = "river", ja = "川", es = "río", fr = "rivière"},
		{word = "night", ja = "夜", es = "noche", fr = "nuit"},
		{word = "music", ja = "音楽", es = "música", fr = "musique"},
		{word = "stone", ja = "石", es = "piedra", fr = "pierre"},
	},
	level_3 = {
		{word = "banana", ja = "バナナ", es = "plátano", fr = "banane"},
		{word = "orange", ja = "オレンジ", es = "naranja", fr = "orange"},
		{word = "yellow", ja = "黄色", es = "amarillo", fr = "jaune"},
		{word = "purple", ja = "紫", es = "morado", fr = "violet"},
		{word = "animal", ja = "動物", es = "animal", fr = "animal"},
		{word = "window", ja = "窓", es = "ventana", fr = "fenêtre"},
		{word = "garden", ja = "庭", es = "jardín", fr = "jardin"},
		{word = "bridge", ja = "橋", es = "puente", fr = "pont"},
		{word = "planet", ja = "惑星", es = "planeta", fr = "planète"},
		{word = "forest", ja = "森", es = "bosque", fr = "forêt"},
	},
	level_4 = {
		{word = "monday", ja = "月曜日", es = "lunes", fr = "lundi"},
		{word = "sunday", ja = "日曜日", es = "domingo", fr = "dimanche"},
		{word = "friday", ja = "金曜日", es = "viernes", fr = "vendredi"},
		{word = "winter", ja = "冬", es = "invierno", fr = "hiver"},
		{word = "summer", ja = "夏", es = "verano", fr = "été"},
		{word = "spring", ja = "春", es = "primavera", fr = "printemps"},
		{word = "autumn", ja = "秋", es = "otoño", fr = "automne"},
		{word = "dragon", ja = "ドラゴン", es = "dragón", fr = "dragon"},
		{word = "castle", ja = "城", es = "castillo", fr = "château"},
		{word = "warrior", ja = "戦士", es = "guerrero", fr = "guerrier"},
	},
	level_5 = {
		{word = "mountain", ja = "山", es = "montaña", fr = "montagne"},
		{word = "keyboard", ja = "キーボード", es = "teclado", fr = "clavier"},
		{word = "computer", ja = "コンピュータ", es = "computadora", fr = "ordinateur"},
		{word = "adventure", ja = "冒険", es = "aventura", fr = "aventure"},
		{word = "beautiful", ja = "美しい", es = "hermoso", fr = "beau"},
		{word = "champion", ja = "チャンピオン", es = "campeón", fr = "champion"},
		{word = "treasure", ja = "宝物", es = "tesoro", fr = "trésor"},
		{word = "butterfly", ja = "蝶", es = "mariposa", fr = "papillon"},
		{word = "elephant", ja = "象", es = "elefante", fr = "éléphant"},
		{word = "challenge", ja = "挑戦", es = "desafío", fr = "défi"},
	},
}
===== ./ReplicatedStorage/FieldGen.lua =====
-- ReplicatedStorage/FieldGen (最適化版)
-- パフォーマンスを大幅に改善した地形生成エンジン

local FieldGen = {}

-- ノイズ関数（変更なし）
local function noise2D(x, z, scale)
	local s = (x / scale + z / scale * 57)
	return (math.sin(s * 12.9898) * 43758.5453) % 1
end

local function smoothNoise(x, z, scale)
	local intX, intZ = math.floor(x / scale), math.floor(z / scale)
	local fracX, fracZ = (x / scale) - intX, (z / scale) - intZ

	local v1 = noise2D(intX, intZ, 1)
	local v2 = noise2D(intX + 1, intZ, 1)
	local v3 = noise2D(intX, intZ + 1, 1)
	local v4 = noise2D(intX + 1, intZ + 1, 1)

	local i1 = v1 * (1 - fracX) + v2 * fracX
	local i2 = v3 * (1 - fracX) + v4 * fracX

	return i1 * (1 - fracZ) + i2 * fracZ
end

-- 【最適化1】バッチ生成システム
local function fillTerrainBatch(terrain, blocks)
	local batchSize = 100  -- 一度に処理する数
	local totalBlocks = #blocks

	for i = 1, totalBlocks, batchSize do
		local endIdx = math.min(i + batchSize - 1, totalBlocks)

		for j = i, endIdx do
			local block = blocks[j]
			terrain:FillBlock(block.cframe, block.size, block.material)
		end

		-- サーバーの負荷分散
		if i % 500 == 0 then
			task.wait()
			print(("[FieldGen] 進行状況: %d/%d (%.1f%%)"):format(i, totalBlocks, i/totalBlocks*100))
		end
	end
end

-- 【最適化2】島の生成（バッチ処理版）
function FieldGen.generateIsland(config)
	local terrain = workspace.Terrain

	local cfg = {
		name = config.name or "Island",
		centerX = config.centerX or 0,
		centerZ = config.centerZ or 0,
		sizeXZ = config.sizeXZ or 500,
		baseY = config.baseY or 0,
		thickness = config.thickness or 10,
		hillAmplitude = config.hillAmplitude or 20,
		hillScale = config.hillScale or 150,
		seed = config.seed or 12345,
		generateOcean = config.generateOcean ~= false,
		oceanRadius = config.oceanRadius or 1500,
		grid = config.grid or 12,  -- 8→12に増やして呼び出し回数削減
	}

	print(("[FieldGen] 生成開始: %s at (%.0f, %.0f)"):format(cfg.name, cfg.centerX, cfg.centerZ))

	math.randomseed(cfg.seed)

	local halfSize = cfg.sizeXZ / 2
	local oceanY = cfg.baseY - 10
	local cliffHeight = oceanY + 8

	-- 【重要】ブロックを配列に溜めてからバッチ処理
	local terrainBlocks = {}
	local waterBlocks = {}

	-- 地形ブロックを準備
	for x = -halfSize, halfSize, cfg.grid do
		for z = -halfSize, halfSize, cfg.grid do
			local worldX = cfg.centerX + x
			local worldZ = cfg.centerZ + z

			local distFromCenter = math.sqrt(x*x + z*z)
			local normalizedDist = distFromCenter / halfSize
			local edgeFade = math.max(0, 1 - normalizedDist * 1.2)

			if edgeFade > 0 then
				local height = smoothNoise(worldX + cfg.seed, worldZ + cfg.seed, cfg.hillScale)
				local hillY = cfg.baseY + (height * cfg.hillAmplitude * edgeFade)
				local targetY = math.max(hillY, cliffHeight)

				table.insert(terrainBlocks, {
					cframe = CFrame.new(worldX, targetY - cfg.thickness/2, worldZ),
					size = Vector3.new(cfg.grid, cfg.thickness, cfg.grid),
					material = Enum.Material.Grass
				})
			end
		end
	end

	print(("[FieldGen] 地形ブロック数: %d"):format(#terrainBlocks))
	fillTerrainBatch(terrain, terrainBlocks)

	-- 海の生成
	if cfg.generateOcean then
		local oceanGrid = 20  -- 16→20に増やして更に削減
		local oceanHalfSize = cfg.oceanRadius / 2
		local maxDistWithTerrain = halfSize * 0.8  -- 推定値

		for x = -oceanHalfSize, oceanHalfSize, oceanGrid do
			for z = -oceanHalfSize, oceanHalfSize, oceanGrid do
				local dist = math.sqrt(x*x + z*z)
				if dist > maxDistWithTerrain then
					table.insert(waterBlocks, {
						cframe = CFrame.new(cfg.centerX + x, oceanY, cfg.centerZ + z),
						size = Vector3.new(oceanGrid, 20, oceanGrid),
						material = Enum.Material.Water
					})
				end
			end
		end

		print(("[FieldGen] 海ブロック数: %d"):format(#waterBlocks))
		fillTerrainBatch(terrain, waterBlocks)
	end

	-- マーカー作成
	local worldFolder = workspace:FindFirstChild("World")
	if not worldFolder then
		worldFolder = Instance.new("Folder")
		worldFolder.Name = "World"
		worldFolder.Parent = workspace
	end

	local marker = Instance.new("Part")
	marker.Name = cfg.name .. "_Center"
	marker.Size = Vector3.new(10, 1, 10)
	marker.Position = Vector3.new(cfg.centerX, cfg.baseY + 5, cfg.centerZ)
	marker.Anchored = true
	marker.CanCollide = false
	marker.Transparency = 0.5
	marker.BrickColor = BrickColor.new("Bright blue")
	marker.Parent = worldFolder

	print(("[FieldGen] 完了: %s"):format(cfg.name))
end

-- レイキャスト（変更なし）
function FieldGen.raycastGroundY(x, z, startY)
	startY = startY or 500

	local params = RaycastParams.new()
	params.FilterType = Enum.RaycastFilterType.Include
	params.FilterDescendantsInstances = {workspace.Terrain}
	params.IgnoreWater = false

	local origin = Vector3.new(x, startY, z)
	local direction = Vector3.new(0, -startY - 500, 0)

	local result = workspace:Raycast(origin, direction, params)
	return result and result.Position.Y or nil
end

-- 橋の生成（バッチ処理版）
function FieldGen.generateBridge(fromIsland, toIsland, config)
	local terrain = workspace.Terrain

	local cfg = {
		name = config.name or "Bridge",
		width = config.width or 20,
		height = config.height or 5,
		thickness = config.thickness or 5,
	}

	print(("[FieldGen] 橋を生成中: %s"):format(cfg.name))

	local x1, z1 = fromIsland.centerX, fromIsland.centerZ
	local x2, z2 = toIsland.centerX, toIsland.centerZ

	local dx = x2 - x1
	local dz = z2 - z1
	local distance = math.sqrt(dx*dx + dz*dz)

	local bridgeY = ((fromIsland.baseY or 0) + (toIsland.baseY or 0)) / 2 + cfg.height
	local segments = math.ceil(distance / 10)

	local bridgeBlocks = {}

	for i = 0, segments do
		local t = i / segments
		local x = x1 + dx * t
		local z = z1 + dz * t

		local perpX = -dz / distance
		local perpZ = dx / distance

		for w = -cfg.width/2, cfg.width/2, 8 do
			local worldX = x + perpX * w
			local worldZ = z + perpZ * w

			table.insert(bridgeBlocks, {
				cframe = CFrame.new(worldX, bridgeY, worldZ),
				size = Vector3.new(8, cfg.thickness, 8),
				material = Enum.Material.Slate
			})
		end
	end

	fillTerrainBatch(terrain, bridgeBlocks)
	print(("[FieldGen] 橋生成完了: %s (距離: %.1f)"):format(cfg.name, distance))
end

return FieldGen
===== ./ReplicatedStorage/Monsters/Registry.lua =====
local RS = game:GetService("ReplicatedStorage")
local Monsters = RS:WaitForChild("Monsters")

return {
	require(Monsters.Slime),
	-- 将来追加するモンスター:
	-- require(Monsters.Dragon),
	-- require(Monsters.Goblin),
}
===== ./ReplicatedStorage/Monsters/Slime.lua =====
-- ReplicatedStorage/Monsters/Slime.lua
-- ReplicatedStorage/Monsters/Slime
-- スライムの定義（ステータス拡張版）

return {
	Name = "Slime",
	TemplatePath = {"ServerStorage", "EnemyTemplates", "Slime"},
	WalkSpeed = 4,
	RespawnTime = 10,

	-- 【新】バトルステータス
	HP = 50,           -- ライフ
	Speed = 5,         -- 素早さ
	Attack = 20,        -- 攻撃力
	Defense = 5,       -- 守備力

	-- 【新】報酬
	Experience = 20,   -- 倒した時に得られる経験値
	Gold = 10,         -- 倒した時に得られるゴールド

	-- タイピングレベル（重み付き）
	TypingLevels = {
		{level = "level_1", weight = 70},  -- 70%の確率でレベル1
		{level = "level_2", weight = 30},  -- 30%の確率でレベル2
	},

	-- 旧設定（互換性のため残す）
	Damage = 1,  -- 後で削除予定

	-- スポーン設定
	SpawnLocations = {
		{
			islandName = "StartIsland",
			count = 10,
			radiusPercent = 50,  -- 島のサイズの50%範囲内
		},
		{
			islandName = "MountainIsland",
			count = 5,
			radiusPercent = 75,  -- 島のサイズの75%範囲内
		},
		{
			islandName = "DesertIsland",
			count = 5,
			radiusPercent = 75,  -- 島のサイズの75%範囲内
		},
		{
			islandName = "TIsland_Center",
			count = 15,
			radiusPercent = 95,  -- 島のサイズの75%範囲内
		},
		{
			islandName = "Hokkaido_N1",
			count = 7,
			radiusPercent = 95,  -- 島のサイズの75%範囲内
		},
		{
			islandName = "Hokkaido_N4",
			count = 8,
			radiusPercent = 95,  -- 島のサイズの75%範囲内
		},

	},

	-- AI設定
	ChaseDistance = 60,
	EscapeDistance = 80,
	WanderRadius = 30,
	UpdateNearby = 0.2,
	UpdateFar = 1.0,
}
