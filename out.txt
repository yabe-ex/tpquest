total 8
drwxr-xr-x  12 yabea  staff  384 10 12 08:58 ReplicatedStorage
drwxr-xr-x  16 yabea  staff  512 10 12 21:46 ServerScriptService
drwxr-xr-x  15 yabea  staff  480 10 12 21:46 StartPlayerScripts
-rwxr-xr-x   1 yabea  staff  976 10  4 11:52 go.sh
-rw-r--r--   1 yabea  staff    0 10 13 04:05 out.txt

./ReplicatedStorage:
total 72
drwxr-xr-x   9 yabea  staff    288 10 11 11:12 Continents
-rw-r--r--   1 yabea  staff  22644 10 12 22:06 FieldGen.lua
drwxr-xr-x   2 yabea  staff     64 10 12 08:58 FieldObjects
-rw-r--r--   1 yabea  staff   2722 10  6 18:17 GameEvents.lua
drwxr-xr-x  10 yabea  staff    320 10 11 11:12 Islands
drwxr-xr-x   5 yabea  staff    160 10  6 14:42 Monsters
-rw-r--r--   1 yabea  staff   1153 10  6 18:17 SharedState.lua
drwxr-xr-x   2 yabea  staff     64 10  4 10:07 Sounds
-rw-r--r--   1 yabea  staff   3512 10  3 18:05 TypingWords.lua

./ReplicatedStorage/Continents:
total 72
-rw-r--r--  1 yabea  staff  5276 10 12 18:55 ContientTown.lua
-rw-r--r--  1 yabea  staff  7568 10 13 00:04 ContinentHokkaido.lua
-rw-r--r--  1 yabea  staff  2819 10 13 00:08 ContinentKyushu.lua
-rw-r--r--  1 yabea  staff   616 10 10 16:43 ContinentShikoku.lua
-rw-r--r--  1 yabea  staff  1079 10 11 11:28 Greenland.lua
-rw-r--r--  1 yabea  staff   428 10 11 11:13 Registry.lua
-rw-r--r--  1 yabea  staff   726 10 11 10:50 Snowland.lua

./ReplicatedStorage/FieldObjects:
total 0

./ReplicatedStorage/Islands:
total 72
-rw-r--r--  1 yabea  staff   162 10  3 18:05 Bridges.lua
-rw-r--r--  1 yabea  staff   910 10 11 11:12 Greenland.lua
-rw-r--r--  1 yabea  staff  3933 10 12 23:45 HokkaidoIslands.lua
-rw-r--r--  1 yabea  staff  5995 10 11 20:41 KyushuIslands.lua
-rw-r--r--  1 yabea  staff  1547 10 11 11:13 Registry.lua
-rw-r--r--  1 yabea  staff  1356 10  6 10:43 ShikokuIslands.lua
-rw-r--r--  1 yabea  staff  3679 10 11 11:06 Snowland.lua
-rw-r--r--  1 yabea  staff  1900 10  5 20:30 Town.lua

./ReplicatedStorage/Monsters:
total 24
-rw-r--r--  1 yabea  staff   260 10 11 16:06 Registry.lua
-rw-r--r--  1 yabea  staff  1359 10  7 09:51 Slime.lua
-rw-r--r--  1 yabea  staff  1709 10 11 20:33 Slime_pink.lua

./ReplicatedStorage/Sounds:
total 0

./ServerScriptService:
total 304
-rw-r--r--  1 yabea  staff  27966 10 10 13:04 BattleSystem.lua
-rw-r--r--  1 yabea  staff  13702 10 10 13:40 Bootstrap.server.lua
-rw-r--r--  1 yabea  staff   3932 10 12 11:46 DataCollectors.lua
-rw-r--r--  1 yabea  staff   3617 10 12 06:34 DataStoreManager.lua
-rw-r--r--  1 yabea  staff   3249 10 13 04:01 DebugCommands.server.lua
-rw-r--r--  1 yabea  staff   3764 10 11 10:30 FastTravelSystem.server.lua
-rw-r--r--  1 yabea  staff   7911 10 12 21:53 InteractionSystem.server.lua
-rw-r--r--  1 yabea  staff    708 10  9 15:11 LoadTest.server.lua
-rw-r--r--  1 yabea  staff  26859 10  9 14:56 MonsterSpawner.server.lua
-rw-r--r--  1 yabea  staff   2313 10  5 17:26 OceanSafety.server.lua
-rw-r--r--  1 yabea  staff  12225 10 12 11:49 PlayerStats.lua
-rw-r--r--  1 yabea  staff   5612 10  5 20:34 TowerPlacement.server.lua
-rw-r--r--  1 yabea  staff  12653 10 10 13:04 WarpPortal.server.lua
-rw-r--r--  1 yabea  staff  10369 10 12 22:07 ZoneManager.lua

./StartPlayerScripts:
total 304
-rw-r--r--  1 yabea  staff   4870 10  5 08:26 BGMManager.client.lua
-rw-r--r--  1 yabea  staff  26090 10  5 20:30 BattleUI.client.lua
-rw-r--r--  1 yabea  staff   7575 10  3 18:05 DeathUI.client.lua
-rw-r--r--  1 yabea  staff   3155 10 12 22:32 DebugButtons.client.lua
-rw-r--r--  1 yabea  staff   7786 10 11 10:36 FastTravelUI.client.lua
-rw-r--r--  1 yabea  staff   5920 10 12 21:52 InteractionUI.client.lua
-rw-r--r--  1 yabea  staff   5844 10  3 18:05 LevelUpUI.client.lua
-rw-r--r--  1 yabea  staff   2872 10  9 20:42 LoadingScreen.client.lua
-rw-r--r--  1 yabea  staff  31638 10  9 15:01 MenuUI.client.lua
-rw-r--r--  1 yabea  staff  20744 10 10 13:40 Minimap.client.lua
-rw-r--r--  1 yabea  staff   5948 10 12 18:45 RewardPopup.client.lua
-rw-r--r--  1 yabea  staff   6847 10  9 13:33 StatusUI.client.lua
-rw-r--r--  1 yabea  staff   2045 10  6 10:49 WarpUI.client.lua
===== ./StartPlayerScripts/DebugButtons.client.lua =====
-- StarterPlayer/StarterPlayerScripts/DebugButtons.client.lua
-- ãƒ‡ãƒãƒƒã‚°ç”¨ãƒœã‚¿ãƒ³ï¼ˆé–‹ç™ºæ™‚ã®ã¿ä½¿ç”¨ï¼‰

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

print("[DebugButtons] åˆæœŸåŒ–é–‹å§‹")

-- ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰ï¼ˆæœ¬ç•ªç’°å¢ƒã§ã¯falseã«ï¼‰
local DEBUG_MODE = true

if not DEBUG_MODE then
	print("[DebugButtons] ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰OFF")
	return
end

-- RemoteEventå–å¾—ï¼ˆã‚µãƒ¼ãƒãƒ¼ãŒä½œæˆã™ã‚‹ã¾ã§å¾…æ©Ÿï¼‰
local DebugCommandEvent = ReplicatedStorage:WaitForChild("DebugCommand", 10)
if not DebugCommandEvent then
	warn("[DebugButtons] DebugCommandEventãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
	return
end

print("[DebugButtons] RemoteEventã‚’å–å¾—ã—ã¾ã—ãŸ")

-- ScreenGuiä½œæˆ
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "DebugButtonsUI"
screenGui.ResetOnSpawn = false
screenGui.IgnoreGuiInset = true
screenGui.DisplayOrder = 300
screenGui.Parent = playerGui

-- ãƒœã‚¿ãƒ³ã‚³ãƒ³ãƒ†ãƒŠï¼ˆå³ä¸Šã‹ã‚‰å·¦ã«ä¸¦ã¶ï¼‰
local container = Instance.new("Frame")
container.Name = "ButtonContainer"
container.Size = UDim2.new(0, 600, 0, 50)
container.Position = UDim2.new(1, -620, 0, 20) -- å³ä¸Š
container.BackgroundTransparency = 1
container.Parent = screenGui

local listLayout = Instance.new("UIListLayout")
listLayout.FillDirection = Enum.FillDirection.Horizontal
listLayout.HorizontalAlignment = Enum.HorizontalAlignment.Right
listLayout.VerticalAlignment = Enum.VerticalAlignment.Top
listLayout.Padding = UDim.new(0, 10)
listLayout.Parent = container

-- ãƒ‡ãƒãƒƒã‚°ãƒœã‚¿ãƒ³ä½œæˆé–¢æ•°
local function createDebugButton(text, callback)
	local button = Instance.new("TextButton")
	button.Size = UDim2.new(0, 180, 0, 40)
	button.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
	button.BackgroundTransparency = 0.2
	button.BorderSizePixel = 2
	button.BorderColor3 = Color3.new(1, 1, 1)
	button.Text = text
	button.TextColor3 = Color3.new(1, 1, 1)
	button.TextSize = 16
	button.Font = Enum.Font.SourceSansBold
	button.AutoButtonColor = true
	button.Parent = container

	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 8)
	corner.Parent = button

	-- ãƒ›ãƒãƒ¼ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
	button.MouseEnter:Connect(function()
		button.BackgroundTransparency = 0
	end)

	button.MouseLeave:Connect(function()
		button.BackgroundTransparency = 0.2
	end)

	-- ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆ
	button.MouseButton1Click:Connect(callback)

	return button
end

-- ã€ãƒœã‚¿ãƒ³1ã€‘å®ç®±ãƒªã‚»ãƒƒãƒˆ
createDebugButton("ğŸ”„ å®ç®±ãƒªã‚»ãƒƒãƒˆ", function()
	print("[DebugButtons] å®ç®±ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯")
	DebugCommandEvent:FireServer("reset_chests")
	print("[DebugButtons] ã‚µãƒ¼ãƒãƒ¼ã«ãƒªã‚»ãƒƒãƒˆè¦æ±‚ã‚’é€ä¿¡ã—ã¾ã—ãŸ")
end)

-- ã€å°†æ¥è¿½åŠ äºˆå®šã®ãƒœã‚¿ãƒ³ä¾‹ã€‘
-- createDebugButton("ğŸ’° ã‚´ãƒ¼ãƒ«ãƒ‰+1000", function()
-- 	DebugCommandEvent:FireServer("add_gold", 1000)
-- end)

-- createDebugButton("â¬†ï¸ ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—", function()
-- 	DebugCommandEvent:FireServer("level_up")
-- end)

print("[DebugButtons] åˆæœŸåŒ–å®Œäº†")
===== ./StartPlayerScripts/Minimap.client.lua =====
-- StarterPlayer/StarterPlayerScripts/Minimap.client.lua
-- ãƒŸãƒ‹ãƒãƒƒãƒ—ã‚·ã‚¹ãƒ†ãƒ ï¼ˆã‚ºãƒ¼ãƒ æ©Ÿèƒ½ãƒ»ãƒãƒ¼ã‚¿ãƒ«è¡¨ç¤ºå¯¾å¿œç‰ˆï¼‰

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

print("[Minimap] åˆæœŸåŒ–é–‹å§‹")

-- ã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«è¨­å®š
local ZOOM_LEVELS = {
	{
		name = "è©³ç´°",
		scale = 2,           -- 2ã‚¹ã‚¿ãƒƒãƒ‰/ãƒ”ã‚¯ã‚»ãƒ«
		terrainGrid = 45,    -- 60â†’45ã«å‰Šæ¸›ï¼ˆè² è·è»½æ¸›ï¼‰
		terrainUpdateInterval = 0.25,  -- 0.15ç§’ â†’ 0.25ç§’ï¼ˆæ›´æ–°é »åº¦ã‚’ä¸‹ã’ã‚‹ï¼‰
		iconUpdateInterval = 0.05,
		monsterIconSize = 7,
		portalIconSize = 9,
	},
	{
		name = "ä¸­é–“",
		scale = 4,           -- 4ã‚¹ã‚¿ãƒƒãƒ‰/ãƒ”ã‚¯ã‚»ãƒ«
		terrainGrid = 50,    -- 50x50ã‚°ãƒªãƒƒãƒ‰
		terrainUpdateInterval = 0.25,
		iconUpdateInterval = 0.05,
		monsterIconSize = 5,
		portalIconSize = 7,
	},
	{
		name = "åºƒåŸŸ",
		scale = 8,           -- 8ã‚¹ã‚¿ãƒƒãƒ‰/ãƒ”ã‚¯ã‚»ãƒ«
		terrainGrid = 40,    -- 40x40ã‚°ãƒªãƒƒãƒ‰ï¼ˆåºƒåŸŸã¯è² è·è»½æ¸›ï¼‰
		terrainUpdateInterval = 0.4,
		iconUpdateInterval = 0.08,
		monsterIconSize = 3,
		portalIconSize = 5,
	},
}

local currentZoomLevel = 1

-- ç¾åœ¨ã®è¨­å®šã‚’å–å¾—
local function getCurrentSettings()
	return ZOOM_LEVELS[currentZoomLevel]
end

-- åŸºæœ¬è¨­å®š
local MINIMAP_SIZE = 200
local WATER_LEVEL = -15

-- è‰²è¨­å®š
local LAND_COLOR = Color3.fromRGB(50, 70, 50)
local SEA_COLOR = Color3.fromRGB(30, 30, 30)
local PLAYER_COLOR = Color3.fromRGB(100, 200, 255)
local MONSTER_COLOR = Color3.fromRGB(255, 50, 50)
local PORTAL_TOWN_COLOR = Color3.fromRGB(255, 200, 100)
local PORTAL_OTHER_COLOR = Color3.fromRGB(200, 100, 255)

-- ScreenGuiä½œæˆ
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "MinimapUI"
screenGui.ResetOnSpawn = false
screenGui.IgnoreGuiInset = true
screenGui.Parent = playerGui

-- ãƒŸãƒ‹ãƒãƒƒãƒ—ã®èƒŒæ™¯ãƒ•ãƒ¬ãƒ¼ãƒ 
local minimapFrame = Instance.new("Frame")
minimapFrame.Name = "MinimapFrame"
minimapFrame.Size = UDim2.new(0, MINIMAP_SIZE, 0, MINIMAP_SIZE)
minimapFrame.Position = UDim2.new(0, 20, 1, -MINIMAP_SIZE - 20)
minimapFrame.BackgroundColor3 = SEA_COLOR
minimapFrame.BackgroundTransparency = 0.3
minimapFrame.BorderSizePixel = 2
minimapFrame.BorderColor3 = Color3.fromRGB(255, 255, 255)
minimapFrame.Parent = screenGui

local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(0, 8)
corner.Parent = minimapFrame

-- åœ°å½¢ãƒ¬ã‚¤ãƒ¤ãƒ¼
local terrainLayer = Instance.new("Frame")
terrainLayer.Name = "TerrainLayer"
terrainLayer.Size = UDim2.new(1, 0, 1, 0)
terrainLayer.BackgroundTransparency = 1
terrainLayer.ClipsDescendants = true
terrainLayer.ZIndex = 1
terrainLayer.Parent = minimapFrame

-- ã‚¿ã‚¤ãƒˆãƒ«ï¼ˆã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«è¡¨ç¤ºï¼‰
local titleLabel = Instance.new("TextLabel")
titleLabel.Name = "Title"
titleLabel.Size = UDim2.new(1, 0, 0, 20)
titleLabel.Position = UDim2.new(0, 0, 0, -25)
titleLabel.BackgroundTransparency = 1
titleLabel.Text = "MAP [Z: è©³ç´°]"
titleLabel.TextColor3 = Color3.new(1, 1, 1)
titleLabel.TextSize = 14
titleLabel.Font = Enum.Font.SourceSansBold
titleLabel.TextStrokeTransparency = 0.5
titleLabel.Parent = minimapFrame

-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¢ã‚¤ã‚³ãƒ³ï¼ˆç¸¦é•·ã®çŸ¢å°å‹ï¼‰
-- local playerIconContainer = Instance.new("Frame")
-- playerIconContainer.Name = "PlayerIconContainer"
-- playerIconContainer.Size = UDim2.new(0, 12, 0, 18)
-- playerIconContainer.AnchorPoint = Vector2.new(0.5, 0.5)
-- playerIconContainer.Position = UDim2.new(0.5, 0, 0.5, 0)
-- playerIconContainer.BackgroundTransparency = 1
-- playerIconContainer.ZIndex = 10
-- playerIconContainer.Parent = minimapFrame
local playerIcon = Instance.new("ImageLabel")
playerIcon.Name = "PlayerIcon"
playerIcon.Size = UDim2.new(0, 24, 0, 24) -- ã‚µã‚¤ã‚ºã¯èª¿æ•´å¯èƒ½
playerIcon.AnchorPoint = Vector2.new(0.5, 0.5)
playerIcon.Position = UDim2.new(0.5, 0, 0.5, 0)
playerIcon.BackgroundTransparency = 1
playerIcon.Image = "rbxassetid://137204683713117" -- ä¸Šå‘
-- playerIcon.Image = "rbxassetid://88281133700630"
playerIcon.ImageColor3 = PLAYER_COLOR
playerIcon.ZIndex = 10
playerIcon.Parent = minimapFrame


-- ã‚¢ã‚¤ã‚³ãƒ³ã‚’æ ¼ç´ã™ã‚‹ãƒ•ã‚©ãƒ«ãƒ€
local monstersFolder = Instance.new("Folder")
monstersFolder.Name = "MonsterIcons"
monstersFolder.Parent = minimapFrame

local portalsFolder = Instance.new("Folder")
portalsFolder.Name = "PortalIcons"
portalsFolder.Parent = minimapFrame

-- åœ°å½¢ã‚¿ã‚¤ãƒ«ã®ãƒ—ãƒ¼ãƒ«
local terrainTilePool = {}
local activeTiles = {}

local function getTerrainTile()
	for _, tile in ipairs(terrainTilePool) do
		if not tile.Visible then
			tile.Visible = true
			return tile
		end
	end

	local tile = Instance.new("Frame")
	tile.Name = "TerrainTile"
	tile.BackgroundColor3 = LAND_COLOR
	tile.BackgroundTransparency = 0.2
	tile.BorderSizePixel = 0
	tile.ZIndex = 2
	tile.Parent = terrainLayer

	table.insert(terrainTilePool, tile)
	return tile
end

local function hideAllTerrainTiles()
	for _, tile in ipairs(terrainTilePool) do
		tile.Visible = false
	end
	activeTiles = {}
end

-- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚¢ã‚¤ã‚³ãƒ³ã®ãƒ—ãƒ¼ãƒ«
local monsterIconPool = {}

local function getMonsterIcon(size)
	for _, icon in ipairs(monsterIconPool) do
		if not icon.Visible then
			icon.Visible = true
			icon.Size = UDim2.new(0, size, 0, size)
			return icon
		end
	end

	local icon = Instance.new("Frame")
	icon.Name = "MonsterIcon"
	icon.Size = UDim2.new(0, size, 0, size)
	icon.AnchorPoint = Vector2.new(0.5, 0.5)
	icon.BackgroundColor3 = MONSTER_COLOR
	icon.BorderSizePixel = 0
	icon.ZIndex = 5
	icon.Parent = monstersFolder

	local iconCorner = Instance.new("UICorner")
	iconCorner.CornerRadius = UDim.new(1, 0)
	iconCorner.Parent = icon

	table.insert(monsterIconPool, icon)
	return icon
end

local function hideAllMonsterIcons()
	for _, icon in ipairs(monsterIconPool) do
		icon.Visible = false
	end
end

-- ãƒãƒ¼ã‚¿ãƒ«ã‚¢ã‚¤ã‚³ãƒ³ã®ãƒ—ãƒ¼ãƒ«
local portalIconPool = {}

local function getPortalIcon(size)
	for _, icon in ipairs(portalIconPool) do
		if not icon.Visible then
			icon.Visible = true
			icon.Size = UDim2.new(0, size, 0, size)
			return icon
		end
	end

	local icon = Instance.new("Frame")
	icon.Name = "PortalIcon"
	icon.Size = UDim2.new(0, size, 0, size)
	icon.AnchorPoint = Vector2.new(0.5, 0.5)
	icon.BackgroundColor3 = PORTAL_OTHER_COLOR
	icon.BorderSizePixel = 0
	icon.ZIndex = 6
	icon.Parent = portalsFolder

	local iconCorner = Instance.new("UICorner")
	iconCorner.CornerRadius = UDim.new(1, 0)
	iconCorner.Parent = icon

	table.insert(portalIconPool, icon)
	return icon
end

local function hideAllPortalIcons()
	for _, icon in ipairs(portalIconPool) do
		icon.Visible = false
	end
end

-- ãƒ¬ã‚¤ã‚­ãƒ£ã‚¹ãƒˆã§åœ°å½¢ãƒã‚§ãƒƒã‚¯
local function isLand(worldX, worldZ)
	local params = RaycastParams.new()
	params.FilterType = Enum.RaycastFilterType.Include
	params.FilterDescendantsInstances = {workspace.Terrain}
	params.IgnoreWater = false

	local origin = Vector3.new(worldX, 200, worldZ)
	local direction = Vector3.new(0, -250, 0)

	local result = workspace:Raycast(origin, direction, params)

	if result then
		if result.Material == Enum.Material.Water then
			return false
		end
		if result.Position.Y > WATER_LEVEL then
			return true
		end
	end

	return false
end

-- åœ°å½¢ãƒãƒƒãƒ—ã‚’æ›´æ–°
local lastTerrainUpdate = 0
local lastPlayerPos = nil

local function updateTerrainMap()
	local settings = getCurrentSettings()
	local now = os.clock()

	if now - lastTerrainUpdate < settings.terrainUpdateInterval then
		return
	end

	local character = player.Character
	if not character then return end

	local hrp = character:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	local playerPos = hrp.Position

	-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒã‚ã¾ã‚Šå‹•ã„ã¦ã„ãªã‘ã‚Œã°ã‚¹ã‚­ãƒƒãƒ—
	if lastPlayerPos then
		local distance = (playerPos - lastPlayerPos).Magnitude
		-- è©³ç´°ãƒ¢ãƒ¼ãƒ‰ã¯ç§»å‹•è·é›¢ã®é–¾å€¤ã‚’ä¸Šã’ã‚‹ï¼ˆé »ç¹ã«æ›´æ–°ã—ãªã„ï¼‰
		local threshold = (settings.name == "è©³ç´°") and 8 or 5
		if distance < threshold then
			return
		end
	end

	lastTerrainUpdate = now
	lastPlayerPos = playerPos

	-- ãƒãƒ©ã¤ãé˜²æ­¢ï¼šå¤ã„ã‚¿ã‚¤ãƒ«ã¯æ®‹ã—ãŸã¾ã¾ã€æ–°ã—ã„ã‚¿ã‚¤ãƒ«ã‚’é…ç½®
	local tileSize = MINIMAP_SIZE / settings.terrainGrid
	local newActiveTiles = {}
	local usedTileIndex = 1

	-- ä¸€æ°—ã«å‡¦ç†ï¼ˆtask.wait()ãªã—ï¼‰
	for gridX = 0, settings.terrainGrid - 1 do
		for gridZ = 0, settings.terrainGrid - 1 do
			local mapX = (gridX + 0.5) / settings.terrainGrid
			local mapZ = (gridZ + 0.5) / settings.terrainGrid

			local relativeX = (mapX - 0.5) * MINIMAP_SIZE * settings.scale
			local relativeZ = (mapZ - 0.5) * MINIMAP_SIZE * settings.scale

			local worldX = playerPos.X + relativeX
			local worldZ = playerPos.Z + relativeZ

			-- åœ°å½¢ãƒã‚§ãƒƒã‚¯
			if isLand(worldX, worldZ) then
				local tile = getTerrainTile()
				tile.Size = UDim2.new(0, tileSize + 1, 0, tileSize + 1)
				tile.Position = UDim2.new(0, gridX * tileSize, 0, gridZ * tileSize)
				table.insert(newActiveTiles, tile)
			end
		end
	end

	-- å¤ã„ã‚¿ã‚¤ãƒ«ã‚’éè¡¨ç¤ºï¼ˆæ–°ã—ã„ã‚¿ã‚¤ãƒ«ã‚’è¡¨ç¤ºã—ãŸå¾Œï¼‰
	for _, tile in ipairs(activeTiles) do
		local isStillActive = false
		for _, newTile in ipairs(newActiveTiles) do
			if tile == newTile then
				isStillActive = true
				break
			end
		end
		if not isStillActive then
			tile.Visible = false
		end
	end

	activeTiles = newActiveTiles

	-- print(("[Minimap] åœ°å½¢ãƒãƒƒãƒ—æ›´æ–°å®Œäº†: é™¸=%d"):format(#activeTiles))
end

-- ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ã‚’ãƒŸãƒ‹ãƒãƒƒãƒ—åº§æ¨™ã«å¤‰æ›
local function worldToMinimap(worldPos, playerPos)
	local settings = getCurrentSettings()

	local relativeX = worldPos.X - playerPos.X
	local relativeZ = worldPos.Z - playerPos.Z

	local minimapX = (relativeX / settings.scale)
	-- local minimapZ = -(relativeZ / settings.scale)
	local minimapZ = (relativeZ / settings.scale)

	local normalizedX = 0.5 + (minimapX / MINIMAP_SIZE)
	local normalizedZ = 0.5 + (minimapZ / MINIMAP_SIZE)

	return normalizedX, normalizedZ
end

local function isInRange(worldPos, playerPos)
	local settings = getCurrentSettings()
	local range = (MINIMAP_SIZE * settings.scale) / 2

	local dx = worldPos.X - playerPos.X
	local dz = worldPos.Z - playerPos.Z
	local distance = math.sqrt(dx * dx + dz * dz)
	return distance <= range
end

-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¢ã‚¤ã‚³ãƒ³ã®å‘ãã‚’æ›´æ–°
local function updatePlayerRotation_debug()
	local character = player.Character
	if not character then return end

	local hrp = character:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	if not playerIcon then return end

	-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å‘ãã‚’å–å¾—
	local lookVector = hrp.CFrame.LookVector

	-- 8ãƒ‘ã‚¿ãƒ¼ãƒ³å…¨ã¦è©¦ã™
	local patterns = {
		{name = "ãƒ‘ã‚¿ãƒ¼ãƒ³1", calc = function() return math.atan2(lookVector.X, lookVector.Z) end},
		{name = "ãƒ‘ã‚¿ãƒ¼ãƒ³2", calc = function() return math.atan2(lookVector.Z, lookVector.X) end},
		{name = "ãƒ‘ã‚¿ãƒ¼ãƒ³3", calc = function() return math.atan2(-lookVector.X, lookVector.Z) end},
		{name = "ãƒ‘ã‚¿ãƒ¼ãƒ³4", calc = function() return math.atan2(lookVector.X, -lookVector.Z) end},
		{name = "ãƒ‘ã‚¿ãƒ¼ãƒ³5", calc = function() return math.atan2(-lookVector.Z, lookVector.X) end},
		{name = "ãƒ‘ã‚¿ãƒ¼ãƒ³6", calc = function() return math.atan2(lookVector.Z, -lookVector.X) end},
		{name = "ãƒ‘ã‚¿ãƒ¼ãƒ³7", calc = function() return math.atan2(-lookVector.X, -lookVector.Z) end},
		{name = "ãƒ‘ã‚¿ãƒ¼ãƒ³8", calc = function() return math.atan2(-lookVector.Z, -lookVector.X) end},
	}

	-- ãƒ‘ã‚¿ãƒ¼ãƒ³1ã‚’ä½¿ç”¨ï¼ˆå¾Œã§å¤‰æ›´ã§ãã‚‹ï¼‰
	local angle = patterns[1].calc()
	local degrees = math.deg(angle)

	-- å›è»¢ã‚’é©ç”¨
	playerIcon.Rotation = degrees

	-- 5ç§’ã«1å›ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã‚’è¡¨ç¤º
	if os.clock() % 5 < 0.1 then
		print(string.format("[Minimap DEBUG] LookVector: (%.2f, %.2f, %.2f)", lookVector.X, lookVector.Y, lookVector.Z))
		print(string.format("[Minimap DEBUG] è§’åº¦: %.1fåº¦", degrees))
	end
end


-- ãƒ‡ãƒãƒƒã‚°ç‰ˆï¼ˆæ–¹è§’åã‚‚è¡¨ç¤ºï¼‰
local function updatePlayerRotation_news()
	local character = player.Character
	if not character then return end

	local hrp = character:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	if not playerIcon then return end

	local lookVector = hrp.CFrame.LookVector

	-- æ–¹è§’ã‚’åˆ¤å®š
	local direction = ""
	if math.abs(lookVector.Z) > math.abs(lookVector.X) then
		direction = lookVector.Z < 0 and "åŒ—" or "å—"
	else
		direction = lookVector.X > 0 and "æ±" or "è¥¿"
	end

	local angle = math.atan2(lookVector.Z, lookVector.X)
	local degrees = math.deg(angle)

	playerIcon.Rotation = degrees

	if os.clock() % 5 < 0.1 then
		print(string.format("[Minimap DEBUG] æ–¹è§’: %s", direction))
		print(string.format("[Minimap DEBUG] LookVector: (%.2f, %.2f, %.2f)", lookVector.X, lookVector.Y, lookVector.Z))
		print(string.format("[Minimap DEBUG] è§’åº¦: %.1fåº¦", degrees))
	end
end

local function updatePlayerRotation()
	local character = player.Character
	if not character then return end

	local hrp = character:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	if not playerIcon then return end

	-- ã€å¤‰æ›´ã€‘CFrameã‹ã‚‰ç›´æ¥Yè»¸å›è»¢ã‚’å–å¾—
	local _, yRotation, _ = hrp.CFrame:ToOrientation()
	local degrees = math.deg(yRotation)

	-- åº§æ¨™ç³»ã‚’åˆã‚ã›ã‚‹ï¼ˆåœ°å½¢ãƒãƒƒãƒ—ã¨åŒã˜åè»¢ï¼‰
	playerIcon.Rotation = -degrees

	-- if os.clock() % 1 < 0.1 then
	-- 	print(string.format("[DEBUG] Yè»¸å›è»¢: %.1fåº¦ â†’ è¡¨ç¤º: %.1fåº¦", degrees, -degrees))
	-- end
end


-- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚¢ã‚¤ã‚³ãƒ³ã‚’æ›´æ–°
local lastIconUpdate = 0
local function updateMonsterIcons()
	local settings = getCurrentSettings()
	local now = os.clock()

	if now - lastIconUpdate < settings.iconUpdateInterval then
		return
	end
	lastIconUpdate = now

	local character = player.Character
	if not character then return end

	local hrp = character:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	local playerPos = hrp.Position

	hideAllMonsterIcons()

	-- Monstersãƒ•ã‚©ãƒ«ãƒ€ã‹ã‚‰å–å¾—
	local monstersWorkspace = workspace:FindFirstChild("Monsters")
	if monstersWorkspace then
		for _, model in ipairs(monstersWorkspace:GetChildren()) do
			if model:IsA("Model") then
				local monsterHrp = model:FindFirstChild("HumanoidRootPart")
				if monsterHrp then
					local monsterPos = monsterHrp.Position
					if isInRange(monsterPos, playerPos) then
						local mapX, mapZ = worldToMinimap(monsterPos, playerPos)
						if mapX >= 0 and mapX <= 1 and mapZ >= 0 and mapZ <= 1 then
							local icon = getMonsterIcon(settings.monsterIconSize)
							icon.Position = UDim2.new(mapX, 0, mapZ, 0)
						end
					end
				end
			end
		end
	end

	-- æ—§å½¢å¼ï¼ˆIsEnemyå±æ€§ï¼‰ã«ã‚‚å¯¾å¿œ
	for _, model in ipairs(workspace:GetChildren()) do
		if model:IsA("Model") and model:GetAttribute("IsEnemy") then
			local monsterHrp = model:FindFirstChild("HumanoidRootPart")
			if monsterHrp then
				local monsterPos = monsterHrp.Position
				if isInRange(monsterPos, playerPos) then
					local mapX, mapZ = worldToMinimap(monsterPos, playerPos)
					if mapX >= 0 and mapX <= 1 and mapZ >= 0 and mapZ <= 1 then
						local icon = getMonsterIcon(settings.monsterIconSize)
						icon.Position = UDim2.new(mapX, 0, mapZ, 0)
					end
				end
			end
		end
	end

	-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å‘ãã‚’æ›´æ–°
	updatePlayerRotation()
end

-- ãƒãƒ¼ã‚¿ãƒ«ã‚¢ã‚¤ã‚³ãƒ³ã‚’æ›´æ–°
local portalDebugDone = false
local function updatePortalIcons()
	local settings = getCurrentSettings()
	local character = player.Character
	if not character then return end

	local hrp = character:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	local playerPos = hrp.Position

	hideAllPortalIcons()

	-- ãƒ‡ãƒãƒƒã‚°: ãƒãƒ¼ã‚¿ãƒ«ã®é…ç½®å ´æ‰€ã‚’ç¢ºèª
	if not portalDebugDone then
		print("[Minimap DEBUG] ãƒãƒ¼ã‚¿ãƒ«æ¤œç´¢é–‹å§‹")

		-- workspace.Worldã®ä¸­èº«ã‚’ç¢ºèª
		local worldFolder = workspace:FindFirstChild("World")
		if worldFolder then
			print("[Minimap DEBUG] workspace.Worldç™ºè¦‹: " .. #worldFolder:GetChildren() .. "å€‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ")
			local portalCount = 0
			for _, obj in ipairs(worldFolder:GetChildren()) do
				local toZone = obj:GetAttribute("ToZone")
				if toZone then
					portalCount = portalCount + 1
					print("[Minimap DEBUG]   - " .. obj.Name .. " â†’ " .. toZone .. " (Pos: " .. tostring(obj.Position) .. ")")
				end
			end
			print("[Minimap DEBUG] ãƒãƒ¼ã‚¿ãƒ«ç·æ•°: " .. portalCount)
		else
			print("[Minimap DEBUG] workspace.WorldãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
		end

		portalDebugDone = true
	end

	-- workspace.Worldã‹ã‚‰ãƒãƒ¼ã‚¿ãƒ«ã‚’å–å¾—
	local worldFolder = workspace:FindFirstChild("World")
	if worldFolder then
		for _, portal in ipairs(worldFolder:GetChildren()) do
			-- ToZoneå±æ€§ãŒã‚ã‚‹ã‚‚ã®ã‚’ãƒãƒ¼ã‚¿ãƒ«ã¨ã—ã¦èªè­˜
			if portal:IsA("BasePart") and portal:GetAttribute("ToZone") then
				local portalPos = portal.Position
				if isInRange(portalPos, playerPos) then
					local mapX, mapZ = worldToMinimap(portalPos, playerPos)
					if mapX >= 0 and mapX <= 1 and mapZ >= 0 and mapZ <= 1 then
						local icon = getPortalIcon(settings.portalIconSize)
						icon.Position = UDim2.new(mapX, 0, mapZ, 0)

						-- Townã¸ã®ãƒãƒ¼ã‚¿ãƒ«ã‹ãã‚Œä»¥å¤–ã‹ã§è‰²åˆ†ã‘
						local toZone = portal:GetAttribute("ToZone")
						if toZone == "StartTown" then
							-- Townã¸ã®ãƒãƒ¼ã‚¿ãƒ« â†’ ã‚ªãƒ¬ãƒ³ã‚¸
							icon.BackgroundColor3 = PORTAL_TOWN_COLOR
						else
							-- ãã‚Œä»¥å¤–ï¼ˆä»–ã®å¤§é™¸ã¸ï¼‰ â†’ ãƒãƒ¼ã‚¿ãƒ«ã®è‰²ã¾ãŸã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆç´«
							icon.BackgroundColor3 = portal.Color or PORTAL_OTHER_COLOR
						end
					end
				end
			end
		end
	end
end

-- ã‚ºãƒ¼ãƒ åˆ‡ã‚Šæ›¿ãˆ
local function changeZoomLevel(delta)
	currentZoomLevel = math.clamp(currentZoomLevel + delta, 1, #ZOOM_LEVELS)
	local settings = getCurrentSettings()

	titleLabel.Text = "MAP [Z: " .. settings.name .. "]"

	-- åœ°å½¢ãƒãƒƒãƒ—ã‚’å³åº§ã«æ›´æ–°
	lastTerrainUpdate = 0
	lastPlayerPos = nil

	print("[Minimap] ã‚ºãƒ¼ãƒ å¤‰æ›´: " .. settings.name)
end

-- ãƒã‚¦ã‚¹ãƒ›ã‚¤ãƒ¼ãƒ«å…¥åŠ›
UserInputService.InputChanged:Connect(function(input, gameProcessed)
	if gameProcessed then return end

	if input.UserInputType == Enum.UserInputType.MouseWheel then
		local mousePos = UserInputService:GetMouseLocation()
		local framePos = minimapFrame.AbsolutePosition
		local frameSize = minimapFrame.AbsoluteSize

		if mousePos.X >= framePos.X and mousePos.X <= framePos.X + frameSize.X and
			mousePos.Y >= framePos.Y and mousePos.Y <= framePos.Y + frameSize.Y then
			if input.Position.Z > 0 then
				changeZoomLevel(-1)
			else
				changeZoomLevel(1)
			end
		end
	end
end)

-- Zã‚­ãƒ¼å…¥åŠ›
UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then return end

	if input.KeyCode == Enum.KeyCode.Z then
		local nextLevel = currentZoomLevel + 1
		if nextLevel > #ZOOM_LEVELS then
			nextLevel = 1
		end
		changeZoomLevel(nextLevel - currentZoomLevel)
	end
end)

-- ãƒ¡ã‚¤ãƒ³æ›´æ–°ãƒ«ãƒ¼ãƒ—
RunService.Heartbeat:Connect(function()
	updateTerrainMap()
	updateMonsterIcons()
	updatePlayerRotation()
end)

-- ãƒãƒ¼ã‚¿ãƒ«å°‚ç”¨ã®é«˜é€Ÿæ›´æ–°ãƒ«ãƒ¼ãƒ—ï¼ˆç‹¬ç«‹ï¼‰
task.spawn(function()
	while true do
		task.wait(0.1)  -- 0.1ç§’ã”ã¨ã«æ›´æ–°ï¼ˆé«˜é€Ÿï¼‰
		updatePortalIcons()
	end
end)

-- åˆæœŸåŒ–æ™‚ã«å³åº§ã«ãƒãƒ¼ã‚¿ãƒ«ã‚’æ¤œç´¢
task.spawn(function()
	task.wait(0.5)  -- å°‘ã—å¾…ã£ã¦ã‹ã‚‰ãƒãƒ¼ã‚¿ãƒ«æ¤œç´¢
	updatePortalIcons()
end)

-- workspace.Worldã®å¤‰åŒ–ã‚’ç›£è¦–ï¼ˆãƒãƒ¼ã‚¿ãƒ«è¿½åŠ æ™‚ã«å³åæ˜ ï¼‰
task.spawn(function()
	local worldFolder = workspace:WaitForChild("World", 10)
	if worldFolder then
		worldFolder.ChildAdded:Connect(function(child)
			if child:IsA("BasePart") and child:GetAttribute("ToZone") then
				print("[Minimap] æ–°ã—ã„ãƒãƒ¼ã‚¿ãƒ«æ¤œå‡º: " .. child.Name)
				task.wait(0.1)
				updatePortalIcons()
			end
		end)
	end
end)

UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then return end

	if input.KeyCode == Enum.KeyCode.P then
		local character = player.Character
		if not character then return end

		local hrp = character:FindFirstChild("HumanoidRootPart")
		if not hrp then return end

		local position = hrp.Position

		local continent = player:GetAttribute("ContinentName") or "?"
		local island = player:GetAttribute("IslandName") or "?"

		print("ğŸ“ ç¾åœ¨åœ°æƒ…å ± -------------------------")
		print("ğŸ—ºï¸ å¤§é™¸å: " .. continent)
		-- print("ğŸï¸ å³¶å: " .. island)
		print(string.format("ğŸ“Œ åº§æ¨™: (%.1f, %.1f, %.1f)", position.X, position.Y, position.Z))
		print("--------------------------------------")
	end
end)



print("[Minimap] åˆæœŸåŒ–å®Œäº†ï¼ˆã‚ºãƒ¼ãƒ æ©Ÿèƒ½ä»˜ãï¼‰")
===== ./StartPlayerScripts/MenuUI.client.lua =====
-- StarterPlayer/StarterPlayerScripts/MenuUI.client.lua
-- ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚·ã‚¹ãƒ†ãƒ ï¼ˆã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã€ã‚¢ã‚¤ãƒ†ãƒ ã€ã‚¹ã‚­ãƒ«ç­‰ï¼‰

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

print("[MenuUI] åˆæœŸåŒ–ä¸­...")

-- çŠ¶æ…‹ç®¡ç†
local currentModal = nil
local isInBattle = false

-- RemoteEventå–å¾—
local RequestStatusEvent = ReplicatedStorage:WaitForChild("RequestStatus", 1)
local SaveGameEvent = ReplicatedStorage:WaitForChild("SaveGame", 1)
local SaveSuccessEvent = ReplicatedStorage:WaitForChild("SaveSuccess", 1)
local RequestLoadRespawnEvent = ReplicatedStorage:WaitForChild("RequestLoadRespawn", 1)


-- UIã‚³ãƒ³ãƒ†ãƒŠ
local menuGui = nil
local menuFrame = nil

-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚­ãƒ£ãƒƒã‚·ãƒ¥
local cachedStats = {
	Level = 1,
	MaxHP = 100,
	CurrentHP = 100,
	Speed = 10,
	Attack = 10,
	Defense = 10,
	Gold = 0,
	MonstersDefeated = 0
}

-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°ã‚’å—ä¿¡ (æ—¢å­˜ãƒ­ã‚¸ãƒƒã‚¯)
local StatusUpdateEvent = ReplicatedStorage:FindFirstChild("StatusUpdate")
if StatusUpdateEvent then
	StatusUpdateEvent.OnClientEvent:Connect(function(hp, maxHP, level, exp, expToNext, gold)
		cachedStats.CurrentHP = hp or cachedStats.CurrentHP
		cachedStats.MaxHP = maxHP or cachedStats.MaxHP
		cachedStats.Level = level or cachedStats.Level
		cachedStats.Gold = gold or cachedStats.Gold
	end)
end

-- æˆ¦æ­´æ›´æ–°ã‚’å—ä¿¡ (æ—¢å­˜ãƒ­ã‚¸ãƒƒã‚¯)
task.spawn(function()
	print("[MenuUI] StatsDetailã‚¤ãƒ™ãƒ³ãƒˆæ¥ç¶šã‚’é–‹å§‹...")

	local StatsDetailEvent = ReplicatedStorage:WaitForChild("StatsDetail", 5)
	if not StatsDetailEvent then
		warn("[MenuUI] StatsDetailã‚¤ãƒ™ãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ï¼")
		return
	end

	print("[MenuUI] StatsDetailã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºè¦‹ã—ã¾ã—ãŸ")

	StatsDetailEvent.OnClientEvent:Connect(function(stats)
		print("[MenuUI] ========================================")
		print("[MenuUI] ğŸ¯ StatsDetailå—ä¿¡ã‚¤ãƒ™ãƒ³ãƒˆç™ºç«ï¼")
		if stats then
			for key, value in pairs(stats) do
				cachedStats[key] = value
			end
			print("[MenuUI] âœ… ã‚­ãƒ£ãƒƒã‚·ãƒ¥æ›´æ–°å®Œäº†")
		else
			warn("[MenuUI] âŒ statsãŒnilã§ã™ï¼")
		end
		print("[MenuUI] ========================================")
	end)

	print("[MenuUI] StatsDetailã‚¤ãƒ™ãƒ³ãƒˆæ¥ç¶šå®Œäº†")
end)

-- ãƒãƒˆãƒ«çŠ¶æ…‹ã‚’ç›£è¦– (æ—¢å­˜ãƒ­ã‚¸ãƒƒã‚¯)
local BattleStartEvent = ReplicatedStorage:FindFirstChild("BattleStart")
local BattleEndEvent = ReplicatedStorage:FindFirstChild("BattleEnd")

if BattleStartEvent then
	BattleStartEvent.OnClientEvent:Connect(function()
		isInBattle = true
		if menuFrame then
			for _, button in ipairs(menuFrame:GetChildren()) do
				if button:IsA("TextButton") then
					button.Active = false
					button.BackgroundTransparency = 0.7
					button.TextTransparency = 0.5
				end
			end
		end
		if currentModal then
			closeModal()
		end
	end)
end

if BattleEndEvent then
	BattleEndEvent.OnClientEvent:Connect(function()
		isInBattle = false
		if menuFrame then
			for _, button in ipairs(menuFrame:GetChildren()) do
				if button:IsA("TextButton") then
					button.Active = true
					button.BackgroundTransparency = 0.2
					button.TextTransparency = 0
				end
			end
		end
	end)
end

-- ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’é–‰ã˜ã‚‹ (æ—¢å­˜ãƒ­ã‚¸ãƒƒã‚¯)
function closeModal()
    if not currentModal then return end -- é˜²å¾¡çš„ãªæ—©æœŸçµ‚äº†

    local modalToDestroy = currentModal
    currentModal = nil -- â˜…å³åº§ã«nilã«è¨­å®šã—ã€ä»–ã®å‡¦ç†ã«ã‚ˆã‚‹ç«¶åˆã‚’é˜²æ­¢

	if modalToDestroy then
		local background = modalToDestroy:FindFirstChild("Background")
		if background then
			local tween = TweenService:Create(background, TweenInfo.new(0.2), {
				BackgroundTransparency = 1
			})
			tween:Play()
		end

		local panel = modalToDestroy:FindFirstChild("Panel")
		if panel then
			local tween = TweenService:Create(panel, TweenInfo.new(0.2), {
				BackgroundTransparency = 1
			})
			tween:Play()

			for _, child in ipairs(panel:GetDescendants()) do
				if child:IsA("TextLabel") or child:IsA("TextButton") then
					TweenService:Create(child, TweenInfo.new(0.2), {
						TextTransparency = 1
					}):Play()
				end
			end
		end

		task.wait(0.2)
		modalToDestroy:Destroy() -- â˜…ãƒ­ãƒ¼ã‚«ãƒ«å‚ç…§ã‚’ä½¿ç”¨
	end
end

-- ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’ä½œæˆ (æ—¢å­˜ãƒ­ã‚¸ãƒƒã‚¯)
local function createModal(title, contentBuilder)
	if currentModal then
		closeModal()
	end

	local modal = Instance.new("ScreenGui")
	modal.Name = "ModalUI"
	modal.ResetOnSpawn = false
	modal.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	modal.Parent = playerGui

	-- èƒŒæ™¯ï¼ˆæš—è»¢ï¼‰
	local background = Instance.new("Frame")
	background.Name = "Background"
	background.Size = UDim2.fromScale(1, 1)
	background.BackgroundColor3 = Color3.new(0, 0, 0)
	background.BackgroundTransparency = 1
	background.BorderSizePixel = 0
	background.ZIndex = 50
	background.Parent = modal

	TweenService:Create(background, TweenInfo.new(0.2), {
		BackgroundTransparency = 0.5
	}):Play()

	-- ãƒ‘ãƒãƒ«
	local panel = Instance.new("Frame")
	panel.Name = "Panel"
	panel.Size = UDim2.new(0, 500, 0, 400)
	panel.Position = UDim2.fromScale(0.5, 0.5)
	panel.AnchorPoint = Vector2.new(0.5, 0.5)
	panel.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
	panel.BackgroundTransparency = 1
	panel.BorderSizePixel = 0
	panel.ZIndex = 51
	panel.Parent = modal

	TweenService:Create(panel, TweenInfo.new(0.2), {
		BackgroundTransparency = 0.1
	}):Play()

	local panelCorner = Instance.new("UICorner")
	panelCorner.CornerRadius = UDim.new(0, 12)
	panelCorner.Parent = panel

	-- ã‚¿ã‚¤ãƒˆãƒ«
	local titleLabel = Instance.new("TextLabel")
	titleLabel.Name = "Title"
	titleLabel.Size = UDim2.new(1, -20, 0, 40)
	titleLabel.Position = UDim2.new(0, 10, 0, 10)
	titleLabel.BackgroundTransparency = 1
	titleLabel.TextColor3 = Color3.fromRGB(255, 215, 0)
	titleLabel.TextStrokeTransparency = 0.5
	titleLabel.Font = Enum.Font.GothamBold
	titleLabel.TextSize = 24
	titleLabel.Text = title
	titleLabel.TextXAlignment = Enum.TextXAlignment.Left
	titleLabel.TextTransparency = 1
	titleLabel.ZIndex = 52
	titleLabel.Parent = panel

	TweenService:Create(titleLabel, TweenInfo.new(0.2), {
		TextTransparency = 0,
		TextStrokeTransparency = 0.5
	}):Play()

	-- é–‰ã˜ã‚‹ãƒœã‚¿ãƒ³
	local closeButton = Instance.new("TextButton")
	closeButton.Name = "CloseButton"
	closeButton.Size = UDim2.new(0, 40, 0, 40)
	closeButton.Position = UDim2.new(1, -50, 0, 10)
	closeButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
	closeButton.BackgroundTransparency = 1
	closeButton.BorderSizePixel = 0
	closeButton.Font = Enum.Font.GothamBold
	closeButton.TextSize = 24
	closeButton.Text = "âœ•"
	closeButton.TextColor3 = Color3.new(1, 1, 1)
	closeButton.TextTransparency = 1
	closeButton.ZIndex = 52
	closeButton.Parent = panel

	TweenService:Create(closeButton, TweenInfo.new(0.2), {
		BackgroundTransparency = 0.2,
		TextTransparency = 0
	}):Play()

	local closeCorner = Instance.new("UICorner")
	closeCorner.CornerRadius = UDim.new(0, 8)
	closeCorner.Parent = closeButton

	closeButton.MouseButton1Click:Connect(function()
		closeModal()
	end)

	closeButton.MouseEnter:Connect(function()
		closeButton.BackgroundColor3 = Color3.fromRGB(255, 70, 70)
	end)
	closeButton.MouseLeave:Connect(function()
		closeButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
	end)

	-- ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¨ãƒªã‚¢
	local contentFrame = Instance.new("Frame")
	contentFrame.Name = "Content"
	contentFrame.Size = UDim2.new(1, -20, 1, -70)
	contentFrame.Position = UDim2.new(0, 10, 0, 60)
	contentFrame.BackgroundTransparency = 1
	contentFrame.ZIndex = 52
	contentFrame.Parent = panel

	if contentBuilder then
		contentBuilder(contentFrame)
	end

	background.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			closeModal()
		end
	end)

	currentModal = modal
	return modal
end

local function showSaveModal()
    if not SaveGameEvent or not SaveSuccessEvent then
        createModal("ã‚»ãƒ¼ãƒ–ã‚¨ãƒ©ãƒ¼", function(content)
            local label = Instance.new("TextLabel")
            label.Size = UDim2.fromScale(1, 1)
            label.BackgroundTransparency = 1
            label.TextColor3 = Color3.fromRGB(255, 100, 100)
            label.TextStrokeTransparency = 0.7
            label.Font = Enum.Font.Gotham
            label.TextSize = 18
            label.Text = "ã‚»ãƒ¼ãƒ–æ©Ÿèƒ½ãŒã‚µãƒ¼ãƒãƒ¼ã§åˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚"
            label.Parent = content
        end)
        return
    end

    -- ã‚»ãƒ¼ãƒ–ã‚¤ãƒ™ãƒ³ãƒˆã‚’ã‚µãƒ¼ãƒãƒ¼ã«é€ä¿¡
    SaveGameEvent:FireServer()

    local connection = nil -- â˜…FIX 1: connectionã‚’ãƒ­ãƒ¼ã‚«ãƒ«å®£è¨€

    createModal("ã‚»ãƒ¼ãƒ–ä¸­", function(content)
        local label = Instance.new("TextLabel")
        label.Size = UDim2.fromScale(1, 1)
        label.BackgroundTransparency = 1
        label.TextColor3 = Color3.fromRGB(255, 255, 255)
        label.TextStrokeTransparency = 0.7
        label.Font = Enum.Font.Gotham
        label.TextSize = 18
        label.Text = "ğŸ’¾ ã‚»ãƒ¼ãƒ–ä¸­..."
        label.Parent = content
        -- ... (label setup)

        -- ã‚»ãƒ¼ãƒ–å®Œäº†ã®ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã‚’å¾…æ©Ÿ
        connection = SaveSuccessEvent.OnClientEvent:Connect(function(success)
            if connection and connection.Connected then connection:Disconnect() end -- â˜…FIX 2: Disconnectå‰ã«nil/Connectedãƒã‚§ãƒƒã‚¯

            if success then
                label.Text = "âœ… ã‚»ãƒ¼ãƒ–å®Œäº†ï¼"
                label.TextColor3 = Color3.fromRGB(46, 204, 113)
            else
                label.Text = "âŒ ã‚»ãƒ¼ãƒ–å¤±æ•—..."
                label.TextColor3 = Color3.fromRGB(231, 76, 60)
            end
            task.wait(1.5)
            closeModal()
        end)

        -- ãƒ¢ãƒ¼ãƒ€ãƒ«ãŒå¼·åˆ¶çµ‚äº†ã•ã‚ŒãŸå ´åˆã€æ¥ç¶šã‚’è§£é™¤
        -- é–‰ã˜ã‚‹ãƒœã‚¿ãƒ³ï¼ˆâœ•ï¼‰ã®ã‚¤ãƒ™ãƒ³ãƒˆæ¥ç¶šã‚’å†åˆ©ç”¨
        local closeButton = content.Parent:FindFirstChild("CloseButton")
        if closeButton then
            closeButton.MouseButton1Click:Connect(function()
                if connection and connection.Connected then connection:Disconnect() end -- â˜…FIX 3: çµ‚äº†ãƒœã‚¿ãƒ³ã‚‚nil/Connectedãƒã‚§ãƒƒã‚¯
                closeModal()
            end)
        end

        -- èƒŒæ™¯ã‚¯ãƒªãƒƒã‚¯ï¼ˆå¼·åˆ¶çµ‚äº†ï¼‰ã®ã‚¤ãƒ™ãƒ³ãƒˆæ¥ç¶šã‚’å†åˆ©ç”¨
        local background = content.Parent.Parent:FindFirstChild("Background")
        if background then
             background.InputBegan:Connect(function(input)
                if input.UserInputType == Enum.UserInputType.MouseButton1 then
                    if connection and connection.Connected then connection:Disconnect() end
                    closeModal()
                end
            end)
        end
    end)
end

local function showLoadModal()

    createModal("ãƒ­ãƒ¼ãƒ‰", function(content)
        local warningLabel = Instance.new("TextLabel")
        warningLabel.Size = UDim2.new(1, 0, 0, 60)
		warningLabel.Position = UDim2.new(0, 0, 0, 20)
		warningLabel.BackgroundTransparency = 1
		warningLabel.TextColor3 = Color3.fromRGB(255, 255, 100)
		warningLabel.TextStrokeTransparency = 0.7
		warningLabel.Font = Enum.Font.Gotham
		warningLabel.TextSize = 18
		warningLabel.Text = "ç¾åœ¨ã€ãƒ­ãƒ¼ãƒ‰ã¯å†æ¥ç¶šã«ã‚ˆã£ã¦è¡Œã‚ã‚Œã¾ã™ã€‚\nã‚²ãƒ¼ãƒ ã‚’å†èµ·å‹•ã—ã¾ã™ã‹ï¼Ÿ"
		warningLabel.TextWrapped = true
		warningLabel.TextTransparency = 1
		warningLabel.ZIndex = 53
		warningLabel.Parent = content

        TweenService:Create(warningLabel, TweenInfo.new(0.2), {TextTransparency = 0, TextStrokeTransparency = 0.7}):Play()

        -- ãƒ­ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ (ã‚µãƒ¼ãƒãƒ¼ã«ãƒ­ãƒ¼ãƒ‰è¦æ±‚ã‚’é€ã‚Šã€ã‚­ãƒƒã‚¯ã™ã‚‹)
        local loadButton = Instance.new("TextButton")
		loadButton.Size = UDim2.new(0, 150, 0, 50)
		loadButton.Position = UDim2.new(0.5, -160, 1, -70)
		loadButton.BackgroundColor3 = Color3.fromRGB(52, 152, 219)
		loadButton.BackgroundTransparency = 0.2
        loadButton.BorderSizePixel = 0
        loadButton.Font = Enum.Font.GothamBold
        loadButton.TextSize = 18
		loadButton.Text = "ã‚²ãƒ¼ãƒ ã‚’å†èµ·å‹•"
        loadButton.TextColor3 = Color3.new(1, 1, 1)
        loadButton.TextTransparency = 1
        loadButton.ZIndex = 53
        loadButton.Parent = content

        TweenService:Create(loadButton, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0.1), {
			BackgroundTransparency = 0.2,
			TextTransparency = 0
		}):Play()

        local loadCorner = Instance.new("UICorner")
		loadCorner.CornerRadius = UDim.new(0, 8)
		loadCorner.Parent = loadButton

        -- ãƒ­ãƒ¼ãƒ‰å‡¦ç†ã¯ã‚­ãƒƒã‚¯ã‚’å®Ÿè¡Œ
        loadButton.MouseButton1Click:Connect(function()
            closeModal()

            -- â˜…ä¿®æ­£ãƒ–ãƒ­ãƒƒã‚¯é–‹å§‹: Studioã¨å®Ÿç’°å¢ƒã§å‡¦ç†ã‚’åˆ†ã‘ã‚‹
            if game:GetService("RunService"):IsStudio() then
                if RequestLoadRespawnEvent then
                    -- Studioã®å ´åˆã€ã‚µãƒ¼ãƒãƒ¼ã«ãƒªã‚¹ãƒãƒ¼ãƒ³ã‚’è¦æ±‚
                    RequestLoadRespawnEvent:FireServer()
                    print("[MenuUI] Studioãƒ¢ãƒ¼ãƒ‰: ã‚µãƒ¼ãƒãƒ¼ã«ãƒ­ãƒ¼ãƒ‰ãƒªã‚¹ãƒãƒ¼ãƒ³ã‚’è¦æ±‚ã—ã¾ã—ãŸ")
                else
                    warn("[MenuUI] RequestLoadRespawnEventãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ï¼")
                end
            else
                -- å®Ÿéš›ã®ã‚²ãƒ¼ãƒ ã®å ´åˆã€ã‚­ãƒƒã‚¯ã—ã¦å†æ¥ç¶šã‚’ä¿ƒã™
                player:Kick("ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ãŸã‚å†èµ·å‹•ã—ã¾ã™")
            end
            -- â˜…ä¿®æ­£ãƒ–ãƒ­ãƒƒã‚¯çµ‚äº†
        end)

        -- ã‚­ãƒ£ãƒ³ã‚»ãƒ«ãƒœã‚¿ãƒ³ (showLogoutã‹ã‚‰æµç”¨)
		local cancelButton = Instance.new("TextButton")
		cancelButton.Size = UDim2.new(0, 150, 0, 50)
		cancelButton.Position = UDim2.new(0.5, 10, 1, -70)
		cancelButton.BackgroundColor3 = Color3.fromRGB(149, 165, 166)
		cancelButton.BackgroundTransparency = 0.2
		cancelButton.BorderSizePixel = 0
		cancelButton.Font = Enum.Font.GothamBold
		cancelButton.TextSize = 18
		cancelButton.Text = "ã‚­ãƒ£ãƒ³ã‚»ãƒ«"
		cancelButton.TextColor3 = Color3.new(1, 1, 1)
		cancelButton.TextTransparency = 1
		cancelButton.ZIndex = 53
		cancelButton.Parent = content

        TweenService:Create(cancelButton, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0,
        false, 0.15), {
			BackgroundTransparency = 0.2,
			TextTransparency = 0
		}):Play()

        local cancelCorner = Instance.new("UICorner")
		cancelCorner.CornerRadius = UDim.new(0, 8)
		cancelCorner.Parent = cancelButton

		cancelButton.MouseButton1Click:Connect(function()
			closeModal()
		end)

    end)
end

-- â˜…æ–°è¦æ©Ÿèƒ½: åˆæœŸåŒ–å‡¦ç†
local function showResetModal()
    createModal("ãƒ‡ãƒ¼ã‚¿åˆæœŸåŒ–", function(content)
        local warningLabel = Instance.new("TextLabel")
		warningLabel.Size = UDim2.new(1, 0, 0, 60)
		warningLabel.Position = UDim2.new(0, 0, 0, 20)
		warningLabel.BackgroundTransparency = 1
		warningLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
		warningLabel.TextStrokeTransparency = 0.7
		warningLabel.Font = Enum.Font.Gotham
		warningLabel.TextSize = 18
		warningLabel.Text = "!! è­¦å‘Š !!\nã™ã¹ã¦ã®é€²è¡ŒçŠ¶æ³ã‚’å¤±ã„ã¾ã™ã€‚æœ¬å½“ã«åˆæœŸåŒ–ã—ã¾ã™ã‹ï¼Ÿ"
		warningLabel.TextWrapped = true
		warningLabel.TextTransparency = 1
		warningLabel.ZIndex = 53
		warningLabel.Parent = content

		TweenService:Create(warningLabel, TweenInfo.new(0.2), {
			TextTransparency = 0,
			TextStrokeTransparency = 0.7
		}):Play()

		local resetButton = Instance.new("TextButton")
		resetButton.Size = UDim2.new(0, 150, 0, 50)
		resetButton.Position = UDim2.new(0.5, -160, 1, -70)
		resetButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
		resetButton.BackgroundTransparency = 0.2
        resetButton.BorderSizePixel = 0
        resetButton.Font = Enum.Font.GothamBold
        resetButton.TextSize = 18
		resetButton.Text = "åˆæœŸåŒ–ã™ã‚‹"
		resetButton.TextColor3 = Color3.new(1, 1, 1)
		resetButton.TextTransparency = 1
		resetButton.ZIndex = 53
		resetButton.Parent = content

        local resetCorner = Instance.new("UICorner")
		resetCorner.CornerRadius = UDim.new(0, 8)
		resetCorner.Parent = resetButton

		TweenService:Create(resetButton, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0.1), {
			BackgroundTransparency = 0.2,
			TextTransparency = 0
		}):Play()

		resetButton.MouseButton1Click:Connect(function()
			-- TODO: FireServer Reset Event
			player:Kick("ãƒ‡ãƒ¼ã‚¿ã‚’åˆæœŸåŒ–ã—ã¾ã—ãŸ")
		end)

		local cancelButton = Instance.new("TextButton")
		cancelButton.Size = UDim2.new(0, 150, 0, 50)
		cancelButton.Position = UDim2.new(0.5, 10, 1, -70)
		cancelButton.BackgroundColor3 = Color3.fromRGB(149, 165, 166)
		cancelButton.BackgroundTransparency = 0.2
		cancelButton.BorderSizePixel = 0
		cancelButton.Font = Enum.Font.GothamBold
		cancelButton.TextSize = 18
		cancelButton.Text = "ã‚­ãƒ£ãƒ³ã‚»ãƒ«"
		cancelButton.TextColor3 = Color3.new(1, 1, 1)
		cancelButton.TextTransparency = 1
		cancelButton.ZIndex = 53
		cancelButton.Parent = content

		TweenService:Create(cancelButton, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0.15), {
			BackgroundTransparency = 0.2,
			TextTransparency = 0
		}):Play()

		local cancelCorner = Instance.new("UICorner")
		cancelCorner.CornerRadius = UDim.new(0, 8)
		cancelCorner.Parent = cancelButton

		cancelButton.MouseButton1Click:Connect(function()
			closeModal()
		end)
    end)
end


-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ç”»é¢ (æ—¢å­˜ãƒ­ã‚¸ãƒƒã‚¯)
local function showStatus()
	createModal("ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹", function(content)
		local stats = {
			{"ãƒ¬ãƒ™ãƒ«", cachedStats.Level},
			{"æœ€å¤§HP", cachedStats.MaxHP},
			{"æ”»æ’ƒåŠ›", cachedStats.Attack},
			{"é˜²å¾¡åŠ›", cachedStats.Defense},
			{"ç´ æ—©ã•", cachedStats.Speed},
		}

		for i, stat in ipairs(stats) do
			local label = Instance.new("TextLabel")
			label.Size = UDim2.new(1, 0, 0, 40)
			label.Position = UDim2.new(0, 0, 0, (i - 1) * 50)
			label.BackgroundTransparency = 1
			label.TextColor3 = Color3.fromRGB(255, 255, 255)
			label.TextStrokeTransparency = 0.7
			label.Font = Enum.Font.Gotham
			label.TextSize = 20
			label.Text = string.format("%s: %d", stat[1], stat[2])
			label.TextXAlignment = Enum.TextXAlignment.Left
			label.TextTransparency = 1
			label.ZIndex = 53
			label.Parent = content

			TweenService:Create(label, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, i * 0.05), {
				TextTransparency = 0,
				TextStrokeTransparency = 0.7
			}):Play()
		end
	end)
end

-- ã‚¢ã‚¤ãƒ†ãƒ ç”»é¢ (æ—¢å­˜ãƒ­ã‚¸ãƒƒã‚¯)
local function showItems()
	createModal("ã‚¢ã‚¤ãƒ†ãƒ ", function(content)
		local emptyLabel = Instance.new("TextLabel")
		emptyLabel.Size = UDim2.fromScale(1, 1)
		emptyLabel.BackgroundTransparency = 1
		emptyLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
		emptyLabel.TextStrokeTransparency = 0.7
		emptyLabel.Font = Enum.Font.Gotham
		emptyLabel.TextSize = 18
		emptyLabel.Text = "ã‚¢ã‚¤ãƒ†ãƒ ãŒã‚ã‚Šã¾ã›ã‚“"
		emptyLabel.TextTransparency = 1
		emptyLabel.ZIndex = 53
		emptyLabel.Parent = content

		TweenService:Create(emptyLabel, TweenInfo.new(0.2), {
			TextTransparency = 0,
			TextStrokeTransparency = 0.7
		}):Play()
	end)
end

-- ã‚¹ã‚­ãƒ«ç”»é¢ (æ—¢å­˜ãƒ­ã‚¸ãƒƒã‚¯)
local function showSkills()
	createModal("ã‚¹ã‚­ãƒ«", function(content)
		local emptyLabel = Instance.new("TextLabel")
		emptyLabel.Size = UDim2.fromScale(1, 1)
		emptyLabel.BackgroundTransparency = 1
		emptyLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
		emptyLabel.TextStrokeTransparency = 0.7
		emptyLabel.Font = Enum.Font.Gotham
		emptyLabel.TextSize = 18
		emptyLabel.Text = "ç¿’å¾—æ¸ˆã¿ã‚¹ã‚­ãƒ«ãªã—"
		emptyLabel.TextTransparency = 1
		emptyLabel.ZIndex = 53
		emptyLabel.Parent = content

		TweenService:Create(emptyLabel, TweenInfo.new(0.2), {
			TextTransparency = 0,
			TextStrokeTransparency = 0.7
		}):Play()
	end)
end

-- æˆ¦æ­´ç”»é¢ (æ—¢å­˜ãƒ­ã‚¸ãƒƒã‚¯)
local function showRecords()
	createModal("æˆ¦æ­´", function(content)
		print("[MenuUI] ========================================")
		print("[MenuUI] æˆ¦æ­´ç”»é¢ã‚’é–‹ãã¾ã—ãŸ")
		print("[MenuUI] ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã•ã‚ŒãŸå€¤:", cachedStats.MonstersDefeated or 0)

		-- ãƒ©ãƒ™ãƒ«ã‚’å…ˆã«ä½œæˆ
		local label = Instance.new("TextLabel")
		label.Size = UDim2.new(1, 0, 0, 40)
		label.Position = UDim2.new(0, 0, 0, 0)
		label.BackgroundTransparency = 1
		label.TextColor3 = Color3.fromRGB(255, 255, 255)
		label.TextStrokeTransparency = 0.7
		label.Font = Enum.Font.Gotham
		label.TextSize = 20
		label.Text = string.format("å€’ã—ãŸãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æ•°: %d (å–å¾—ä¸­...)", cachedStats.MonstersDefeated or 0)
		label.TextXAlignment = Enum.TextXAlignment.Left
		label.TextTransparency = 1
		label.ZIndex = 53
		label.Parent = content

		TweenService:Create(label, TweenInfo.new(0.2), {
			TextTransparency = 0,
			TextStrokeTransparency = 0.7
		}):Play()

		-- ã‚µãƒ¼ãƒãƒ¼ã«æœ€æ–°ã®æˆ¦æ­´ã‚’ãƒªã‚¯ã‚¨ã‚¹ãƒˆ
		local RequestStatsDetailEvent = ReplicatedStorage:FindFirstChild("RequestStatsDetail")
		if RequestStatsDetailEvent then
			print("[MenuUI] ã‚µãƒ¼ãƒãƒ¼ã«è©³ç´°ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’ãƒªã‚¯ã‚¨ã‚¹ãƒˆä¸­...")
			RequestStatsDetailEvent:FireServer()

			-- 0.5ç§’å¾Œã«ãƒ©ãƒ™ãƒ«ã‚’æ›´æ–°ï¼ˆã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰ã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’å¾…ã¤ï¼‰
			task.delay(0.5, function()
				if label and label.Parent then
					label.Text = string.format("å€’ã—ãŸãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æ•°: %d", cachedStats.MonstersDefeated or 0)
					print("[MenuUI] ãƒ©ãƒ™ãƒ«æ›´æ–°: MonstersDefeated =", cachedStats.MonstersDefeated)
				end
			end)
		else
			warn("[MenuUI] RequestStatsDetailEventãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
		end

		print("[MenuUI] ========================================")
	end)
end

-- è¨­å®šç”»é¢ (æ—¢å­˜ãƒ­ã‚¸ãƒƒã‚¯)
local function showSettings()
	createModal("è¨­å®š", function(content)
		local bgmLabel = Instance.new("TextLabel")
		bgmLabel.Size = UDim2.new(1, 0, 0, 30)
		bgmLabel.Position = UDim2.new(0, 0, 0, 20)
		bgmLabel.BackgroundTransparency = 1
		bgmLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
		bgmLabel.TextStrokeTransparency = 0.7
		bgmLabel.Font = Enum.Font.Gotham
		bgmLabel.TextSize = 18
		bgmLabel.Text = "BGMéŸ³é‡ï¼ˆæœªå®Ÿè£…ï¼‰"
		bgmLabel.TextXAlignment = Enum.TextXAlignment.Left
		bgmLabel.TextTransparency = 1
		bgmLabel.ZIndex = 53
		bgmLabel.Parent = content

		TweenService:Create(bgmLabel, TweenInfo.new(0.2), {
			TextTransparency = 0,
			TextStrokeTransparency = 0.7
		}):Play()

		local seLabel = Instance.new("TextLabel")
		seLabel.Size = UDim2.new(1, 0, 0, 30)
		seLabel.Position = UDim2.new(0, 0, 0, 80)
		seLabel.BackgroundTransparency = 1
		seLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
		seLabel.TextStrokeTransparency = 0.7
		seLabel.Font = Enum.Font.Gotham
		seLabel.TextSize = 18
		seLabel.Text = "SEéŸ³é‡ï¼ˆæœªå®Ÿè£…ï¼‰"
		seLabel.TextXAlignment = Enum.TextXAlignment.Left
		seLabel.TextTransparency = 1
		seLabel.ZIndex = 53
		seLabel.Parent = content

		TweenService:Create(seLabel, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0.05), {
			TextTransparency = 0,
			TextStrokeTransparency = 0.7
		}):Play()
	end)
end

-- ãƒ­ã‚°ã‚¢ã‚¦ãƒˆç¢ºèª (showSystemã«çµ±åˆã•ã‚Œã‚‹ãŸã‚ã€ã“ã“ã§ã¯éå…¬é–‹ã®é–¢æ•°ã¨ã—ã¦æ®‹ã™)
local function showLogoutInner()
    createModal("ãƒ­ã‚°ã‚¢ã‚¦ãƒˆ", function(content)
		local warningLabel = Instance.new("TextLabel")
		warningLabel.Size = UDim2.new(1, 0, 0, 60)
		warningLabel.Position = UDim2.new(0, 0, 0, 20)
		warningLabel.BackgroundTransparency = 1
		warningLabel.TextColor3 = Color3.fromRGB(255, 200, 100)
		warningLabel.TextStrokeTransparency = 0.7
		warningLabel.Font = Enum.Font.Gotham
		warningLabel.TextSize = 18
		warningLabel.Text = "æœ¬å½“ã«ãƒ­ã‚°ã‚¢ã‚¦ãƒˆã—ã¾ã™ã‹ï¼Ÿ\n\nâ€» ç¾åœ¨ã€é€²è¡ŒçŠ¶æ³ã¯ä¿å­˜ã•ã‚Œã¾ã›ã‚“"
		warningLabel.TextWrapped = true
		warningLabel.TextTransparency = 1
		warningLabel.ZIndex = 53
		warningLabel.Parent = content

		TweenService:Create(warningLabel, TweenInfo.new(0.2), {
			TextTransparency = 0,
			TextStrokeTransparency = 0.7
		}):Play()

		local logoutButton = Instance.new("TextButton")
		logoutButton.Size = UDim2.new(0, 150, 0, 50)
		logoutButton.Position = UDim2.new(0.5, -160, 1, -70)
		logoutButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
		logoutButton.BackgroundTransparency = 0.2
		logoutButton.BorderSizePixel = 0
		logoutButton.Font = Enum.Font.GothamBold
		logoutButton.TextSize = 18
		logoutButton.Text = "ãƒ­ã‚°ã‚¢ã‚¦ãƒˆ"
		logoutButton.TextColor3 = Color3.new(1, 1, 1)
		logoutButton.TextTransparency = 1
		logoutButton.ZIndex = 53
		logoutButton.Parent = content

		TweenService:Create(logoutButton, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0.1), {
			BackgroundTransparency = 0.2,
			TextTransparency = 0
		}):Play()

		local logoutCorner = Instance.new("UICorner")
		logoutCorner.CornerRadius = UDim.new(0, 8)
		logoutCorner.Parent = logoutButton

		logoutButton.MouseButton1Click:Connect(function()
			player:Kick("ãƒ­ã‚°ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸ")
		end)

		local cancelButton = Instance.new("TextButton")
		cancelButton.Size = UDim2.new(0, 150, 0, 50)
		cancelButton.Position = UDim2.new(0.5, 10, 1, -70)
		cancelButton.BackgroundColor3 = Color3.fromRGB(149, 165, 166)
		cancelButton.BackgroundTransparency = 0.2
		cancelButton.BorderSizePixel = 0
		cancelButton.Font = Enum.Font.GothamBold
		cancelButton.TextSize = 18
		cancelButton.Text = "ã‚­ãƒ£ãƒ³ã‚»ãƒ«"
		cancelButton.TextColor3 = Color3.new(1, 1, 1)
		cancelButton.TextTransparency = 1
		cancelButton.ZIndex = 53
		cancelButton.Parent = content

		TweenService:Create(cancelButton, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0.15), {
			BackgroundTransparency = 0.2,
			TextTransparency = 0
		}):Play()

		local cancelCorner = Instance.new("UICorner")
		cancelCorner.CornerRadius = UDim.new(0, 8)
		cancelCorner.Parent = cancelButton

		cancelButton.MouseButton1Click:Connect(function()
			closeModal()
		end)
	end)
end


-- â˜…æ–°è¦æ©Ÿèƒ½: ã‚·ã‚¹ãƒ†ãƒ ãƒ¡ãƒ‹ãƒ¥ãƒ¼ (2x2ã‚°ãƒªãƒƒãƒ‰)
local function showSystem()
	createModal("ã‚·ã‚¹ãƒ†ãƒ ", function(content)
        -- ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’åŸºæº–ã«ã€2x2ã‚°ãƒªãƒƒãƒ‰ã‚’ä¸­å¤®ã«é…ç½®
        local systemFrame = Instance.new("Frame")
        systemFrame.Size = UDim2.new(1, 0, 1, 0)
        systemFrame.BackgroundTransparency = 1
        systemFrame.Parent = content

        local systemButtons = {
            {name = "ã‚»ãƒ¼ãƒ–", func = showSaveModal, row = 0, col = 0, color = Color3.fromRGB(46, 204, 113)}, -- ç·‘
            {name = "ãƒ­ãƒ¼ãƒ‰", func = showLoadModal, row = 0, col = 1, color = Color3.fromRGB(52, 152, 219)}, -- é’
            {name = "åˆæœŸåŒ–", func = showResetModal, row = 1, col = 0, color = Color3.fromRGB(231, 76, 60)}, -- èµ¤
            {name = "ãƒ­ã‚°ã‚¢ã‚¦ãƒˆ", func = showLogoutInner, row = 1, col = 1, color = Color3.fromRGB(149, 165, 166)}, -- ç°è‰²
        }

        local buttonWidth = 160
        local buttonHeight = 65
        local spacing = 15

        local totalWidth = buttonWidth * 2 + spacing
        local totalHeight = buttonHeight * 2 + spacing

        for _, btnData in ipairs(systemButtons) do
            local button = Instance.new("TextButton")
            button.Name = btnData.name .. "Button"
            button.Size = UDim2.new(0, buttonWidth, 0, buttonHeight)

            -- ã‚°ãƒªãƒƒãƒ‰ã®ä¸­å¿ƒã«é…ç½®ã™ã‚‹ãŸã‚ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆè¨ˆç®—ï¼ˆæ‰‹å‹•èª¿æ•´ãŒå®¹æ˜“ãªã‚ˆã†ã«AnchorPointã‚’ä½¿ç”¨ã—ãªã„ï¼‰
            local gridX = btnData.col * (buttonWidth + spacing)
            local gridY = btnData.row * (buttonHeight + spacing)

            -- AbsoluteSizeã¯å®Ÿè¡Œæ™‚ã«ã—ã‹ç¢ºå®šã—ãªã„ãŸã‚ã€AnchorPoint 0.5ã§ç›¸å¯¾ä½ç½®ã‚’è¨ˆç®—
            button.Position = UDim2.new(0.5, gridX - totalWidth / 2, 0.5, gridY - totalHeight / 2)

            button.BackgroundColor3 = btnData.color
            button.BackgroundTransparency = 0.2
            button.BorderSizePixel = 0
            button.Font = Enum.Font.GothamBold
            button.TextSize = 18
            button.Text = btnData.name
            button.TextColor3 = Color3.new(1, 1, 1)
            button.TextStrokeTransparency = 0.7
            button.ZIndex = 53
            button.Parent = systemFrame

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 8)
            corner.Parent = button

            button.MouseButton1Click:Connect(function()
                if not isInBattle then
                    -- Systemãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã¦ã‹ã‚‰ã€æ¬¡ã®ãƒ¢ãƒ¼ãƒ€ãƒ«ã¾ãŸã¯ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œ
                    -- showLogoutInnerã¯å†…éƒ¨ã§closeModalã‚’å‘¼ã°ãªã„ãŸã‚ã€ã“ã“ã§closeModalã™ã‚‹
                    if btnData.name ~= "ãƒ­ã‚°ã‚¢ã‚¦ãƒˆ" and btnData.name ~= "åˆæœŸåŒ–" then
                        closeModal()
                    end
                    btnData.func()
                end
            end)

            button.MouseEnter:Connect(function()
                if not isInBattle then
                    button.BackgroundColor3 = btnData.color:Lerp(Color3.new(1,1,1), 0.3)
                end
            end)
            button.MouseLeave:Connect(function()
                button.BackgroundColor3 = btnData.color
            end)
        end
	end)
end


-- ãƒ¡ãƒ‹ãƒ¥ãƒ¼UIä½œæˆ
local function createMenuUI()
	menuGui = Instance.new("ScreenGui")
	menuGui.Name = "MenuUI"
	menuGui.ResetOnSpawn = false
	menuGui.Parent = playerGui

	menuFrame = Instance.new("Frame")
	menuFrame.Name = "MenuFrame"
	menuFrame.Size = UDim2.new(0, 250, 0, 120)
	menuFrame.Position = UDim2.new(1, -270, 1, -270)
	menuFrame.BackgroundTransparency = 1
	menuFrame.Parent = menuGui

	local menuButtons = {
		{name = "ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹", func = showStatus, row = 0, col = 0},
		{name = "ã‚¢ã‚¤ãƒ†ãƒ ", func = showItems, row = 0, col = 1},
		{name = "ã‚¹ã‚­ãƒ«", func = showSkills, row = 0, col = 2},
		{name = "æˆ¦æ­´", func = showRecords, row = 1, col = 0},
		{name = "è¨­å®š", func = showSettings, row = 1, col = 1},
		{name = "ã‚·ã‚¹ãƒ†ãƒ ", func = showSystem, row = 1, col = 2}, -- â˜…ä¿®æ­£: ãƒ­ã‚°ã‚¢ã‚¦ãƒˆã‚’ã‚·ã‚¹ãƒ†ãƒ ã«ç½®ãæ›ãˆ
	}

	local buttonWidth = 80
	local buttonHeight = 50
	local spacing = 5

	for _, btnData in ipairs(menuButtons) do
		local button = Instance.new("TextButton")
		button.Name = btnData.name .. "Button"
		button.Size = UDim2.new(0, buttonWidth, 0, buttonHeight)
		button.Position = UDim2.new(0, btnData.col * (buttonWidth + spacing), 0, btnData.row * (buttonHeight + spacing))
		button.BackgroundColor3 = Color3.fromRGB(50, 50, 60)
		button.BackgroundTransparency = 0.2
		button.BorderSizePixel = 0
		button.Font = Enum.Font.GothamBold
		button.TextSize = 14
		button.Text = btnData.name
		button.TextColor3 = Color3.new(1, 1, 1)
		button.TextStrokeTransparency = 0.7
		button.Parent = menuFrame

		local corner = Instance.new("UICorner")
		corner.CornerRadius = UDim.new(0, 8)
		corner.Parent = button

		button.MouseButton1Click:Connect(function()
			if not isInBattle then
				btnData.func()
			end
		end)

		button.MouseEnter:Connect(function()
			if not isInBattle then
				button.BackgroundColor3 = Color3.fromRGB(70, 70, 80)
			end
		end)
		button.MouseLeave:Connect(function()
			button.BackgroundColor3 = Color3.fromRGB(50, 50, 60)
		end)
	end

	print("[MenuUI] ãƒ¡ãƒ‹ãƒ¥ãƒ¼UIä½œæˆå®Œäº†")
end

createMenuUI()

if RequestStatusEvent then
	task.wait(1)
	RequestStatusEvent:FireServer()
end

print("[MenuUI] åˆæœŸåŒ–å®Œäº†")
===== ./StartPlayerScripts/LevelUpUI.client.lua =====
-- StarterPlayer/StarterPlayerScripts/LevelUpUI.client.lua
-- ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—æ¼”å‡º

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

print("[LevelUpUI] åˆæœŸåŒ–ä¸­...")

-- UIè¦ç´ 
local levelUpGui = nil

-- ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—æ¼”å‡ºã‚’è¡¨ç¤º
local function showLevelUp(level, maxHP, speed, attack, defense)
	print(("[LevelUpUI] ========================================"):format())
	print(("[LevelUpUI] ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—æ¼”å‡ºé–‹å§‹ï¼"):format())
	print(("[LevelUpUI] Lv.%d, HP:%d, ç´ æ—©ã•:%d, æ”»æ’ƒ:%d, å®ˆå‚™:%d"):format(
		level, maxHP, speed, attack, defense
		))
	print(("[LevelUpUI] ========================================"):format())

	-- æ—¢å­˜ã®GUIã‚’å‰Šé™¤
	if levelUpGui then
		levelUpGui:Destroy()
	end

	-- æ–°ã—ã„GUIã‚’ä½œæˆ
	levelUpGui = Instance.new("ScreenGui")
	levelUpGui.Name = "LevelUpUI"
	levelUpGui.ResetOnSpawn = false
	levelUpGui.Parent = playerGui

	-- èƒŒæ™¯ï¼ˆæš—ã„ï¼‰
	local background = Instance.new("Frame")
	background.Size = UDim2.fromScale(1, 1)
	background.Position = UDim2.fromScale(0, 0)
	background.BackgroundColor3 = Color3.new(0, 0, 0)
	background.BackgroundTransparency = 1
	background.BorderSizePixel = 0
	background.ZIndex = 100
	background.Parent = levelUpGui

	-- èƒŒæ™¯ã‚’æš—ãã™ã‚‹
	local bgTween = TweenService:Create(background, TweenInfo.new(0.3), {
		BackgroundTransparency = 0.5
	})
	bgTween:Play()

	-- ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ãƒ†ã‚­ã‚¹ãƒˆ
	local levelUpText = Instance.new("TextLabel")
	levelUpText.Size = UDim2.new(0, 600, 0, 100)
	levelUpText.Position = UDim2.new(0.5, -300, 0.35, -50)
	levelUpText.BackgroundTransparency = 1
	levelUpText.TextColor3 = Color3.fromRGB(255, 215, 0)
	levelUpText.TextStrokeTransparency = 0
	levelUpText.TextStrokeColor3 = Color3.new(0, 0, 0)
	levelUpText.Font = Enum.Font.GothamBold
	levelUpText.TextSize = 60
	levelUpText.Text = "LEVEL UP!"
	levelUpText.TextTransparency = 1
	levelUpText.ZIndex = 101
	levelUpText.Parent = levelUpGui

	-- ãƒ†ã‚­ã‚¹ãƒˆã‚’ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
	local textTween = TweenService:Create(levelUpText, TweenInfo.new(0.5), {
		TextTransparency = 0,
		TextStrokeTransparency = 0
	})
	textTween:Play()

	-- ãƒ¬ãƒ™ãƒ«è¡¨ç¤º
	local levelText = Instance.new("TextLabel")
	levelText.Size = UDim2.new(0, 600, 0, 60)
	levelText.Position = UDim2.new(0.5, -300, 0.45, 0)
	levelText.BackgroundTransparency = 1
	levelText.TextColor3 = Color3.fromRGB(255, 255, 255)
	levelText.TextStrokeTransparency = 0
	levelText.Font = Enum.Font.GothamBold
	levelText.TextSize = 40
	levelText.Text = string.format("Level %d", level)
	levelText.TextTransparency = 1
	levelText.ZIndex = 101
	levelText.Parent = levelUpGui

	-- ãƒ¬ãƒ™ãƒ«ãƒ†ã‚­ã‚¹ãƒˆã‚’ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
	local levelTextTween = TweenService:Create(levelText, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0.2), {
		TextTransparency = 0,
		TextStrokeTransparency = 0.5
	})
	levelTextTween:Play()

	-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤ºãƒ•ãƒ¬ãƒ¼ãƒ 
	local statsFrame = Instance.new("Frame")
	statsFrame.Size = UDim2.new(0, 400, 0, 150)
	statsFrame.Position = UDim2.new(0.5, -200, 0.55, 0)
	statsFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
	statsFrame.BackgroundTransparency = 1
	statsFrame.BorderSizePixel = 0
	statsFrame.ZIndex = 101
	statsFrame.Parent = levelUpGui

	-- è§’ã‚’ä¸¸ãã™ã‚‹
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 10)
	corner.Parent = statsFrame

	-- ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
	local frameTween = TweenService:Create(statsFrame, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0.3), {
		BackgroundTransparency = 0.2
	})
	frameTween:Play()

	-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ†ã‚­ã‚¹ãƒˆ
	local statsText = Instance.new("TextLabel")
	statsText.Size = UDim2.new(1, -40, 1, -40)
	statsText.Position = UDim2.new(0, 20, 0, 20)
	statsText.BackgroundTransparency = 1
	statsText.TextColor3 = Color3.fromRGB(200, 255, 200)
	statsText.TextStrokeTransparency = 0.5
	statsText.Font = Enum.Font.Gotham
	statsText.TextSize = 20
	statsText.Text = string.format(
		"HP: %d (+10)\nç´ æ—©ã•: %d (+2)\næ”»æ’ƒåŠ›: %d (+2)\nå®ˆå‚™åŠ›: %d (+2)",
		maxHP, speed, attack, defense
	)
	statsText.TextTransparency = 1
	statsText.TextYAlignment = Enum.TextYAlignment.Top
	statsText.ZIndex = 102
	statsText.Parent = statsFrame

	-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ†ã‚­ã‚¹ãƒˆã‚’ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
	local statsTween = TweenService:Create(statsText, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0.4), {
		TextTransparency = 0,
		TextStrokeTransparency = 0.5
	})
	statsTween:Play()

	-- 2.5ç§’å¾Œã«ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
	task.delay(2.5, function()
		local fadeOutTween = TweenService:Create(background, TweenInfo.new(0.5), {
			BackgroundTransparency = 1
		})
		fadeOutTween:Play()

		TweenService:Create(levelUpText, TweenInfo.new(0.5), {
			TextTransparency = 1,
			TextStrokeTransparency = 1
		}):Play()

		TweenService:Create(levelText, TweenInfo.new(0.5), {
			TextTransparency = 1,
			TextStrokeTransparency = 1
		}):Play()

		TweenService:Create(statsFrame, TweenInfo.new(0.5), {
			BackgroundTransparency = 1
		}):Play()

		TweenService:Create(statsText, TweenInfo.new(0.5), {
			TextTransparency = 1,
			TextStrokeTransparency = 1
		}):Play()

		-- 3ç§’å¾Œã«å‰Šé™¤
		task.wait(0.5)
		if levelUpGui then
			levelUpGui:Destroy()
			levelUpGui = nil
		end
	end)
end

-- RemoteEventã‚’å¾…æ©Ÿ
local LevelUpEvent = ReplicatedStorage:WaitForChild("LevelUp", 10)
if LevelUpEvent then
	LevelUpEvent.OnClientEvent:Connect(showLevelUp)
	print("[LevelUpUI] LevelUpã‚¤ãƒ™ãƒ³ãƒˆæ¥ç¶šå®Œäº†")
else
	warn("[LevelUpUI] LevelUpã‚¤ãƒ™ãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
end

print("[LevelUpUI] åˆæœŸåŒ–å®Œäº†")
===== ./StartPlayerScripts/BattleUI.client.lua =====
-- StarterPlayer/StarterPlayerScripts/BattleUI.client.lua
-- ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ãƒãƒˆãƒ«UIåˆ¶å¾¡ï¼ˆã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ï¼‰

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local StarterGui = game:GetService("StarterGui")
local ContextActionService = game:GetService("ContextActionService")
local LocalizationService = game:GetService("LocalizationService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

print("[BattleUI] ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆèµ·å‹•ä¸­...")

-- ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒ­ã‚±ãƒ¼ãƒ«ã‚’å–å¾—
local userLocale = string.lower(LocalizationService.RobloxLocaleId)
local localeCode = string.match(userLocale, "^(%a+)") or "en"  -- "ja-jp" â†’ "ja"

-- ã€é–‹ç™ºç”¨ã€‘å¼·åˆ¶çš„ã«æ—¥æœ¬èªè¡¨ç¤ºï¼ˆæœ¬ç•ªã§ã¯å‰Šé™¤å¯èƒ½ï¼‰
local FORCE_LOCALE = "ja"  -- ã“ã“ã‚’å¤‰æ›´ã™ã‚‹ã¨è¡¨ç¤ºè¨€èªãŒå¤‰ã‚ã‚‹ï¼ˆnil ã§è‡ªå‹•æ¤œå‡ºï¼‰
if FORCE_LOCALE then
	localeCode = FORCE_LOCALE
	print(("[BattleUI] è¨€èªã‚’å¼·åˆ¶è¨­å®š: %s"):format(localeCode))
end

print(("[BattleUI] ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ã‚±ãƒ¼ãƒ«: %s â†’ è¡¨ç¤ºè¨€èª: %s"):format(userLocale, localeCode))

-- RemoteEventsã‚’å¾…æ©Ÿ
local BattleStartEvent = ReplicatedStorage:WaitForChild("BattleStart", 30)
local BattleEndEvent = ReplicatedStorage:WaitForChild("BattleEnd", 30)
local BattleDamageEvent = ReplicatedStorage:WaitForChild("BattleDamage", 30)

if not BattleStartEvent or not BattleEndEvent or not BattleDamageEvent then
	warn("[BattleUI] RemoteEventã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ")
	return
end

-- å˜èªãƒªã‚¹ãƒˆã‚’èª­ã¿è¾¼ã¿
local TypingWords = require(ReplicatedStorage:WaitForChild("TypingWords"))

-- ãƒ‡ãƒãƒƒã‚°ï¼šå˜èªãƒªã‚¹ãƒˆã®å†…å®¹ã‚’ç¢ºèª
print("[BattleUI DEBUG] TypingWords.level_1[1]:")
if TypingWords.level_1 and TypingWords.level_1[1] then
	local firstWord = TypingWords.level_1[1]
	print("  Type:", type(firstWord))
	if type(firstWord) == "table" then
		print("  word:", firstWord.word)
		print("  ja:", firstWord.ja)
	else
		print("  Value:", firstWord)
	end
end

print("[BattleUI] RemoteEventså–å¾—å®Œäº†")

-- çŠ¶æ…‹
local inBattle = false
local currentWord = ""
local currentWordData = nil  -- ç¿»è¨³ãƒ‡ãƒ¼ã‚¿ã‚’å«ã‚€å˜èªæƒ…å ±
local lastWord = nil  -- å‰å›ã®å˜èªï¼ˆé€£ç¶šå›é¿ç”¨ï¼‰
local currentIndex = 1
local typingLevels = {}
local currentBattleTimeout = nil
local monsterHP = 0
local monsterMaxHP = 0
local playerHP = 0  -- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç¾åœ¨HP
local playerMaxHP = 0  -- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æœ€å¤§HP
local damagePerKey = 1

-- ã‚«ãƒ¡ãƒ©è¨­å®šä¿å­˜ç”¨
local originalCameraMaxZoom = nil
local originalCameraMinZoom = nil

-- UIè¦ç´ 
local battleGui = nil
local darkenFrame = nil
local wordFrame = nil
local wordLabel = nil
local translationLabel = nil  -- ç¿»è¨³è¡¨ç¤ºç”¨
local hpBarBackground = nil
local hpBarFill = nil
local hpLabel = nil

-- ã‚·ã‚¹ãƒ†ãƒ ã‚­ãƒ¼ã‚’ãƒ–ãƒ­ãƒƒã‚¯ã™ã‚‹é–¢æ•°
local function blockSystemKeys()
	-- ã‚«ãƒ¡ãƒ©ã‚ºãƒ¼ãƒ ã‚’å®Œå…¨ã«å›ºå®š
	originalCameraMaxZoom = player.CameraMaxZoomDistance
	originalCameraMinZoom = player.CameraMinZoomDistance

	-- ç¾åœ¨ã®ã‚ºãƒ¼ãƒ è·é›¢ã‚’å–å¾—ã—ã¦å›ºå®š
	local camera = workspace.CurrentCamera
	local currentZoom = (camera.CFrame.Position - player.Character.HumanoidRootPart.Position).Magnitude
	player.CameraMaxZoomDistance = currentZoom
	player.CameraMinZoomDistance = currentZoom

	print(("[BattleUI] ã‚«ãƒ¡ãƒ©ã‚’å›ºå®šã—ã¾ã—ãŸ (è·é›¢: %.1f)"):format(currentZoom))
end

-- ãƒ–ãƒ­ãƒƒã‚¯è§£é™¤
local function unblockSystemKeys()
	-- ã‚«ãƒ¡ãƒ©ã‚ºãƒ¼ãƒ ã‚’å¾©å…ƒ
	if originalCameraMaxZoom and originalCameraMinZoom then
		player.CameraMaxZoomDistance = originalCameraMaxZoom
		player.CameraMinZoomDistance = originalCameraMinZoom
		print("[BattleUI] ã‚«ãƒ¡ãƒ©è¨­å®šã‚’å¾©å…ƒã—ã¾ã—ãŸ")
	end
end

-- ã€forward declarationã€‘
local onBattleEnd
local updateDisplay
local setNextWord

-- HPãƒãƒ¼ã®è‰²ã‚’å–å¾—ï¼ˆHPå‰²åˆã«å¿œã˜ã¦å¤‰åŒ–ï¼‰
local function getHPColor(hpPercent)
	if hpPercent > 0.6 then
		-- ç·‘
		return Color3.fromRGB(46, 204, 113)
	elseif hpPercent > 0.3 then
		-- é»„è‰²
		return Color3.fromRGB(241, 196, 15)
	else
		-- èµ¤
		return Color3.fromRGB(231, 76, 60)
	end
end

-- è¡¨ç¤ºã‚’æ›´æ–°
updateDisplay = function()
	if not wordLabel then return end

	-- å…¥åŠ›æ¸ˆã¿æ–‡å­—ã‚’ç·‘ã€æœªå…¥åŠ›ã‚’ç™½ã§è¡¨ç¤º
	local typedPart = string.sub(currentWord, 1, currentIndex - 1)
	local remainingPart = string.sub(currentWord, currentIndex)

	wordLabel.Text = string.format('<font color="#00FF00">%s</font>%s', typedPart, remainingPart)

	-- æ•µHPãƒãƒ¼æ›´æ–°
	if hpBarFill and hpLabel then
		local hpPercent = monsterHP / monsterMaxHP

		-- ãƒãƒ¼ã®é•·ã•ã‚’ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
		local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
		local tween = TweenService:Create(hpBarFill, tweenInfo, {
			Size = UDim2.new(hpPercent, 0, 1, 0)
		})
		tween:Play()

		-- è‰²ã‚’å¤‰æ›´
		hpBarFill.BackgroundColor3 = getHPColor(hpPercent)

		-- ãƒ†ã‚­ã‚¹ãƒˆæ›´æ–°
		hpLabel.Text = string.format("Enemy HP: %d / %d", monsterHP, monsterMaxHP)
	end
end

-- å˜èªã‚’é¸æŠã™ã‚‹é–¢æ•°
local function selectWord()
	if #typingLevels == 0 then
		-- ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼šlevel_1ã®ã¿
		typingLevels = {{level = "level_1", weight = 100}}
	end

	-- é‡ã¿ä»˜ããƒ©ãƒ³ãƒ€ãƒ é¸æŠ
	local totalWeight = 0
	for _, config in ipairs(typingLevels) do
		totalWeight = totalWeight + config.weight
	end

	local randomValue = math.random(1, totalWeight)
	local cumulativeWeight = 0
	local selectedLevel = "level_1"

	for _, config in ipairs(typingLevels) do
		cumulativeWeight = cumulativeWeight + config.weight
		if randomValue <= cumulativeWeight then
			selectedLevel = config.level
			break
		end
	end

	-- é¸æŠã•ã‚ŒãŸãƒ¬ãƒ™ãƒ«ã‹ã‚‰å˜èªã‚’å–å¾—
	local wordList = TypingWords[selectedLevel]
	if wordList and #wordList > 0 then
		-- å‰å›ã¨åŒã˜å˜èªã‚’é¿ã‘ã‚‹ï¼ˆæœ€å¤§5å›ã¾ã§å†æŠ½é¸ï¼‰
		local wordData = nil
		local attempts = 0

		repeat
			wordData = wordList[math.random(1, #wordList)]
			attempts = attempts + 1

			-- æ–°å½¢å¼ï¼ˆãƒ†ãƒ¼ãƒ–ãƒ«ï¼‰ã‹æ—§å½¢å¼ï¼ˆæ–‡å­—åˆ—ï¼‰ã‹åˆ¤å®š
			local currentWordStr = type(wordData) == "table" and wordData.word or wordData

			-- å‰å›ã¨é•ã†å˜èªãŒå‡ºãŸã‚‰ã€ã¾ãŸã¯5å›è©¦ã—ãŸã‚‰ãƒ«ãƒ¼ãƒ—çµ‚äº†
			if currentWordStr ~= lastWord or attempts >= 5 or #wordList == 1 then
				break
			end
		until false

		-- æ–°å½¢å¼ï¼ˆãƒ†ãƒ¼ãƒ–ãƒ«ï¼‰ã‹æ—§å½¢å¼ï¼ˆæ–‡å­—åˆ—ï¼‰ã‹åˆ¤å®š
		if type(wordData) == "table" then
			return wordData
		else
			-- æ—§å½¢å¼ã®å ´åˆã¯äº’æ›æ€§ã®ãŸã‚ãƒ†ãƒ¼ãƒ–ãƒ«ã«å¤‰æ›
			return {word = wordData}
		end
	else
		return {word = "apple", ja = "ã‚Šã‚“ã”"}  -- ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
	end
end

-- æ¬¡ã®å˜èªã‚’è¨­å®š
setNextWord = function()
	currentWordData = selectWord()
	currentWord = currentWordData.word
	currentIndex = 1

	-- ä»Šå›ã®å˜èªã‚’è¨˜æ†¶ï¼ˆæ¬¡å›ã®é€£ç¶šå›é¿ç”¨ï¼‰
	lastWord = currentWord

	print(("[BattleUI DEBUG] currentWordData:"):format())
	print(currentWordData)
	print(("[BattleUI DEBUG] localeCode: %s"):format(localeCode))

	-- ç¿»è¨³ã‚’è¡¨ç¤ºï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ä»˜ãï¼‰
	if translationLabel then
		-- å„ªå…ˆé †ä½ï¼šæŒ‡å®šè¨€èª â†’ æ—¥æœ¬èª â†’ ã‚¹ãƒšã‚¤ãƒ³èª â†’ ãƒ•ãƒ©ãƒ³ã‚¹èª â†’ ç©º
		local translation = currentWordData[localeCode]
			or currentWordData.ja
			or currentWordData.es
			or currentWordData.fr
			or ""

		translationLabel.Text = translation
		translationLabel.Visible = translation ~= ""
		print(("[BattleUI DEBUG] translation: %s"):format(translation))
	else
		warn("[BattleUI DEBUG] translationLabel ãŒ nil ã§ã™ï¼")
	end

	updateDisplay()
	print(("[BattleUI] æ¬¡ã®å˜èª: %s (%s)"):format(currentWord, currentWordData[localeCode] or currentWordData.ja or ""))
end

-- UIä½œæˆ
local function createBattleUI()
	battleGui = Instance.new("ScreenGui")
	battleGui.Name = "BattleUI"
	battleGui.ResetOnSpawn = false
	battleGui.Enabled = false
	battleGui.Parent = playerGui

	-- æš—è»¢ç”¨ãƒ•ãƒ¬ãƒ¼ãƒ 
	darkenFrame = Instance.new("Frame")
	darkenFrame.Name = "DarkenFrame"
	darkenFrame.Size = UDim2.fromScale(1, 1)
	darkenFrame.Position = UDim2.fromScale(0, 0)
	darkenFrame.BackgroundColor3 = Color3.new(0, 0, 0)
	darkenFrame.BackgroundTransparency = 1
	darkenFrame.BorderSizePixel = 0
	darkenFrame.ZIndex = 1
	darkenFrame.Parent = battleGui

	-- æ•µHPãƒãƒ¼èƒŒæ™¯
	hpBarBackground = Instance.new("Frame")
	hpBarBackground.Name = "HPBarBackground"
	hpBarBackground.Size = UDim2.new(0, 500, 0, 40)
	hpBarBackground.Position = UDim2.new(0.5, -250, 0.25, 0)
	hpBarBackground.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
	hpBarBackground.BorderSizePixel = 0
	hpBarBackground.ZIndex = 2
	hpBarBackground.Parent = battleGui

	-- HPãƒãƒ¼èƒŒæ™¯ã®è§’ã‚’ä¸¸ãã™ã‚‹
	local hpBarCorner = Instance.new("UICorner")
	hpBarCorner.CornerRadius = UDim.new(0, 8)
	hpBarCorner.Parent = hpBarBackground

	-- HPãƒãƒ¼ï¼ˆå¡—ã‚Šã¤ã¶ã—éƒ¨åˆ†ï¼‰
	hpBarFill = Instance.new("Frame")
	hpBarFill.Name = "HPBarFill"
	hpBarFill.Size = UDim2.new(1, 0, 1, 0)
	hpBarFill.Position = UDim2.new(0, 0, 0, 0)
	hpBarFill.BackgroundColor3 = Color3.fromRGB(46, 204, 113)
	hpBarFill.BorderSizePixel = 0
	hpBarFill.ZIndex = 3
	hpBarFill.Parent = hpBarBackground

	-- HPãƒãƒ¼ã®è§’ã‚’ä¸¸ãã™ã‚‹
	local hpFillCorner = Instance.new("UICorner")
	hpFillCorner.CornerRadius = UDim.new(0, 8)
	hpFillCorner.Parent = hpBarFill

	-- HPãƒ†ã‚­ã‚¹ãƒˆï¼ˆãƒãƒ¼ã®ä¸Šã«è¡¨ç¤ºï¼‰
	hpLabel = Instance.new("TextLabel")
	hpLabel.Name = "HPLabel"
	hpLabel.Size = UDim2.new(1, 0, 1, 0)
	hpLabel.Position = UDim2.new(0, 0, 0, 0)
	hpLabel.BackgroundTransparency = 1
	hpLabel.TextColor3 = Color3.new(1, 1, 1)
	hpLabel.TextStrokeTransparency = 0.5
	hpLabel.Font = Enum.Font.GothamBold
	hpLabel.TextSize = 20
	hpLabel.Text = "HP: 10 / 10"
	hpLabel.ZIndex = 4
	hpLabel.Parent = hpBarBackground

	-- å˜èªè¡¨ç¤ºç”¨ãƒ•ãƒ¬ãƒ¼ãƒ ï¼ˆæ ï¼‰
	wordFrame = Instance.new("Frame")
	wordFrame.Name = "WordFrame"
	wordFrame.Size = UDim2.new(0, 700, 0, 150)
	wordFrame.Position = UDim2.new(0.5, -350, 0.5, -75)
	wordFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
	wordFrame.BorderSizePixel = 3
	wordFrame.BorderColor3 = Color3.fromRGB(100, 200, 255)
	wordFrame.ZIndex = 2
	wordFrame.Parent = battleGui

	-- æ ã®è§’ã‚’ä¸¸ãã™ã‚‹
	local wordFrameCorner = Instance.new("UICorner")
	wordFrameCorner.CornerRadius = UDim.new(0, 12)
	wordFrameCorner.Parent = wordFrame

	-- æ ã«å…‰ã‚‹ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆUIStrokeï¼‰
	local wordFrameStroke = Instance.new("UIStroke")
	wordFrameStroke.Color = Color3.fromRGB(100, 200, 255)
	wordFrameStroke.Thickness = 3
	wordFrameStroke.Transparency = 0
	wordFrameStroke.Parent = wordFrame

	-- å˜èªè¡¨ç¤ºï¼ˆRichTextå¯¾å¿œï¼‰
	wordLabel = Instance.new("TextLabel")
	wordLabel.Name = "WordLabel"
	wordLabel.Size = UDim2.new(1, -40, 0.6, 0)
	wordLabel.Position = UDim2.new(0, 20, 0, 10)
	wordLabel.BackgroundTransparency = 1
	wordLabel.TextColor3 = Color3.new(1, 1, 1)
	wordLabel.TextStrokeTransparency = 0
	wordLabel.Font = Enum.Font.GothamBold
	wordLabel.TextSize = 60
	wordLabel.Text = "apple"
	wordLabel.RichText = true
	wordLabel.ZIndex = 3
	wordLabel.Parent = wordFrame

	-- ç¿»è¨³è¡¨ç¤ºï¼ˆå˜èªã®ä¸‹ï¼‰
	translationLabel = Instance.new("TextLabel")
	translationLabel.Name = "TranslationLabel"
	translationLabel.Size = UDim2.new(1, -40, 0.35, 0)
	translationLabel.Position = UDim2.new(0, 20, 0.65, 0)
	translationLabel.BackgroundTransparency = 1
	translationLabel.TextColor3 = Color3.fromRGB(150, 200, 255)
	translationLabel.TextStrokeTransparency = 0.3
	translationLabel.Font = Enum.Font.Gotham
	translationLabel.TextSize = 28
	translationLabel.Text = "ãƒ†ã‚¹ãƒˆ"  -- ãƒ‡ãƒãƒƒã‚°ç”¨ã®åˆæœŸå€¤
	translationLabel.TextYAlignment = Enum.TextYAlignment.Top
	translationLabel.Visible = true
	translationLabel.ZIndex = 3
	translationLabel.Parent = wordFrame

	print("[BattleUI DEBUG] translationLabel ä½œæˆå®Œäº†")

	print("[BattleUI] UIä½œæˆå®Œäº†")
end

local Sounds = ReplicatedStorage:WaitForChild("Sounds", 10)
local TypingCorrectSound = Sounds and Sounds:WaitForChild("TypingCorrect", 5)
local TypingErrorSound = Sounds and Sounds:WaitForChild("TypingError", 5)

if not TypingCorrectSound then
	warn("[BattleUI] TypingCorrectåŠ¹æœéŸ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ (WaitForChild ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ)")
end
if not TypingErrorSound then
	warn("[BattleUI] TypingErroråŠ¹æœéŸ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ (WaitForChild ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ)")
end

-- ãƒãƒˆãƒ«é–‹å§‹å‡¦ç†
local function onBattleStart(monsterName, hp, maxHP, damage, levels, pHP, pMaxHP)
	print("[BattleUI] === onBattleStartå‘¼ã³å‡ºã— ===")

	-- nil ãƒã‚§ãƒƒã‚¯ã¨ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
	monsterName = monsterName or "Unknown"
	hp = hp or 10
	maxHP = maxHP or 10
	damage = damage or 1
	levels = levels or {{level = "level_1", weight = 100}}
	pHP = pHP or 100
	pMaxHP = pMaxHP or 100

	print(("[BattleUI] ãƒãƒˆãƒ«é–‹å§‹: vs %s (æ•µHP: %d, ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼HP: %d/%d, Damage: %d)"):format(
		monsterName, hp, pHP, pMaxHP, damage
		))

	if inBattle then
		print("[BattleUI DEBUG] ã™ã§ã«æˆ¦é—˜ä¸­")
		return
	end

	inBattle = true
	monsterHP = hp
	monsterMaxHP = maxHP
	playerHP = pHP
	playerMaxHP = pMaxHP
	damagePerKey = damage
	typingLevels = levels

	-- ã‚·ã‚¹ãƒ†ãƒ ã‚­ãƒ¼ã‚’ãƒ–ãƒ­ãƒƒã‚¯
	blockSystemKeys()

	print("[BattleUI] ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åœæ­¢å‡¦ç†é–‹å§‹")

	-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å…¥åŠ›ã‚’å®Œå…¨ã«ãƒ–ãƒ­ãƒƒã‚¯
	local character = player.Character
	if character then
		local humanoid = character:FindFirstChildOfClass("Humanoid")
		if humanoid then
			humanoid.WalkSpeed = 0
			humanoid.JumpPower = 0
			humanoid.JumpHeight = 0
		end
	end

	print("[BattleUI] Robloxã®UIã‚’ç„¡åŠ¹åŒ–")

	-- Robloxã®UIã‚’ç„¡åŠ¹åŒ–
	pcall(function()
		StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Chat, false)
		StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, false)
		StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, false)
		StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.EmotesMenu, false)
	end)

	print("[BattleUI] UIã‚’è¡¨ç¤º")

	battleGui.Enabled = true

	-- ã€é‡è¦ã€‘RichTextã‚’ç¢ºå®Ÿã«æœ‰åŠ¹åŒ–ã€å…¨ãƒ©ãƒ™ãƒ«ã‚’ãƒªã‚»ãƒƒãƒˆ
	print("[BattleUI] UIè¦ç´ ã‚’ãƒªã‚»ãƒƒãƒˆ")
	if wordLabel then
		wordLabel.RichText = true
		wordLabel.TextColor3 = Color3.new(1, 1, 1)
		wordLabel.Text = ""
		wordLabel.TextTransparency = 0  -- è¿½åŠ 
		wordLabel.TextStrokeTransparency = 0  -- è¿½åŠ 
	end
	if translationLabel then
		translationLabel.TextColor3 = Color3.fromRGB(150, 200, 255)
		translationLabel.Text = ""
		translationLabel.Visible = true
		translationLabel.TextTransparency = 0  -- è¿½åŠ 
		translationLabel.TextStrokeTransparency = 0.3  -- è¿½åŠ 
	end
	if hpLabel then
		hpLabel.TextColor3 = Color3.new(1, 1, 1)
		hpLabel.Text = ""
		hpLabel.TextTransparency = 0  -- è¿½åŠ 
		hpLabel.TextStrokeTransparency = 0.5  -- è¿½åŠ 
	end
	if hpBarFill then
		hpBarFill.Size = UDim2.new(1, 0, 1, 0)
		hpBarFill.BackgroundColor3 = Color3.fromRGB(46, 204, 113)
		hpBarFill.BackgroundTransparency = 0  -- è¿½åŠ 
	end
	if hpBarBackground then
		hpBarBackground.BackgroundTransparency = 0  -- è¿½åŠ 
	end
	if playerHPBarFill then
		playerHPBarFill.Size = UDim2.new(1, 0, 1, 0)
		playerHPBarFill.BackgroundColor3 = Color3.fromRGB(46, 204, 113)
	end

	-- æ ã®è‰²ã‚’ãƒªã‚»ãƒƒãƒˆï¼ˆé’ã«æˆ»ã™ï¼‰
	if wordFrame then
		wordFrame.BorderColor3 = Color3.fromRGB(100, 200, 255)
		wordFrame.BackgroundTransparency = 0.2  -- è¿½åŠ 
		local frameStroke = wordFrame:FindFirstChildOfClass("UIStroke")
		if frameStroke then
			frameStroke.Color = Color3.fromRGB(100, 200, 255)
			frameStroke.Transparency = 0  -- è¿½åŠ 
		end
	end

	-- èƒŒæ™¯ã®é€æ˜åº¦ã‚’ãƒªã‚»ãƒƒãƒˆ
	if darkenFrame then
		darkenFrame.BackgroundTransparency = 0.4  -- è¿½åŠ 
	end
	print("[BattleUI] æš—è»¢å‡¦ç†")

	-- ç”»é¢ã‚’è–„æš—ãã™ã‚‹
	darkenFrame.BackgroundTransparency = 0.4

	print("[BattleUI] å˜èªè¨­å®š")

	-- æœ€åˆã®å˜èªã‚’è¨­å®š
	setNextWord()

	print("[BattleUI] ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆè¨­å®š")

	-- ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆæ©Ÿèƒ½ï¼š30ç§’çµŒéã—ãŸã‚‰å¼·åˆ¶çµ‚äº†
	currentBattleTimeout = task.delay(30, function()
		if inBattle then
			warn("[BattleUI] ãƒãƒˆãƒ«ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆï¼å¼·åˆ¶çµ‚äº†ã—ã¾ã™")
			onBattleEnd(false)
		end
	end)

	print("[BattleUI] === ãƒãƒˆãƒ«é–‹å§‹å‡¦ç†å®Œäº† ===")
end

-- ãƒãƒˆãƒ«çµ‚äº†å‡¦ç†
onBattleEnd = function(victory)
	print("[BattleUI] === ãƒãƒˆãƒ«çµ‚äº†é–‹å§‹: " .. tostring(victory) .. " ===")

	-- æ—¢ã«ãƒãƒˆãƒ«ãŒçµ‚äº†ã—ã¦ã„ã‚‹å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
	if not inBattle and not battleGui.Enabled then
		print("[BattleUI] æ—¢ã«ãƒãƒˆãƒ«çµ‚äº†æ¸ˆã¿")
		return
	end

	-- ã€æœ€å„ªå…ˆã€‘ãƒãƒˆãƒ«çŠ¶æ…‹ã‚’å³åº§ã«ã‚¯ãƒªã‚¢ï¼ˆã‚­ãƒ¼å…¥åŠ›ã‚’åœæ­¢ï¼‰
	inBattle = false
	currentWord = ""
	currentWordData = nil
	currentIndex = 1
	playerHP = 0
	playerMaxHP = 0

	-- ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«
	if currentBattleTimeout then
		task.cancel(currentBattleTimeout)
		currentBattleTimeout = nil
	end

	-- å‹åˆ©æ™‚ã®å‡¦ç†
	-- å‹åˆ©æ™‚ã®å‡¦ç†
	if victory then
		-- ã‚·ã‚¹ãƒ†ãƒ ã‚­ãƒ¼ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’è§£é™¤
		unblockSystemKeys()

		print("[BattleUI] Roblox UIå†æœ‰åŠ¹åŒ–")

		-- Roblox UIã‚’å†æœ‰åŠ¹åŒ–
		pcall(function()
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Chat, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.EmotesMenu, true)
		end)

		-- å‹åˆ©ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
		if wordLabel then
			wordLabel.RichText = false
			wordLabel.Text = "VICTORY!"
			wordLabel.TextColor3 = Color3.fromRGB(255, 215, 0)
			wordLabel.TextTransparency = 0
			wordLabel.TextStrokeTransparency = 0

			-- 0.5ç§’ã‹ã‘ã¦ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
			TweenService:Create(wordLabel, TweenInfo.new(0.5), {
				TextTransparency = 1,
				TextStrokeTransparency = 1
			}):Play()
		end

		-- ç¿»è¨³ãƒ©ãƒ™ãƒ«ã‚’éè¡¨ç¤º
		if translationLabel then
			translationLabel.Visible = false
		end

		-- æ ã‚’é‡‘è‰²ã«ã—ã¦ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
		if wordFrame then
			wordFrame.BorderColor3 = Color3.fromRGB(255, 215, 0)
			local frameStroke = wordFrame:FindFirstChildOfClass("UIStroke")
			if frameStroke then
				frameStroke.Color = Color3.fromRGB(255, 215, 0)
				TweenService:Create(frameStroke, TweenInfo.new(0.5), {
					Transparency = 1
				}):Play()
			end

			TweenService:Create(wordFrame, TweenInfo.new(0.5), {
				BackgroundTransparency = 1
			}):Play()
		end

		-- HPãƒãƒ¼ã‚’ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
		if hpBarBackground then
			TweenService:Create(hpBarBackground, TweenInfo.new(0.5), {
				BackgroundTransparency = 1
			}):Play()
		end

		if hpBarFill then
			TweenService:Create(hpBarFill, TweenInfo.new(0.5), {
				BackgroundTransparency = 1
			}):Play()
		end

		if hpLabel then
			TweenService:Create(hpLabel, TweenInfo.new(0.5), {
				TextTransparency = 1,
				TextStrokeTransparency = 1
			}):Play()
		end

		-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å…¥åŠ›ãƒ–ãƒ­ãƒƒã‚¯ã‚’è§£é™¤
		local character = player.Character
		if character then
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			if humanoid then
				humanoid.WalkSpeed = 16
				humanoid.JumpPower = 50
				humanoid.JumpHeight = 7.2
			end
		end

		-- ç”»é¢ã‚’æ˜ã‚‹ãæˆ»ã™
		TweenService:Create(darkenFrame, TweenInfo.new(0.5), {
			BackgroundTransparency = 1
		}):Play()

		-- UIã‚’éè¡¨ç¤ºã«ã™ã‚‹ãŸã‚ã®é…å»¶å®Ÿè¡Œï¼ˆåˆ¥ã‚¹ãƒ¬ãƒƒãƒ‰ã§ï¼‰
		task.spawn(function()
			task.wait(0.6)  -- ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº†ã‚’å¾…ã¤
			if not inBattle then  -- ã¾ã æ¬¡ã®ãƒãƒˆãƒ«ãŒå§‹ã¾ã£ã¦ã„ãªã„ã“ã¨ã‚’ç¢ºèª
				battleGui.Enabled = false
			end
		end)
	else
		-- æ•—åŒ—æ™‚ï¼šUIã‚’ç¶­æŒã—ãŸã¾ã¾æ­»äº¡é¸æŠUIã‚’å¾…ã¤
		print("[BattleUI] æ•—åŒ— - UIã‚’ç¶­æŒã—ã¾ã™")

		-- æ•—åŒ—ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
		if wordLabel then
			wordLabel.RichText = false
			wordLabel.Text = "DEFEAT..."
			wordLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
		end

		-- ç¿»è¨³ãƒ©ãƒ™ãƒ«ã‚’éè¡¨ç¤º
		if translationLabel then
			translationLabel.Visible = false
		end

		-- æ ã®è‰²ã‚‚å¤‰æ›´
		if wordFrame then
			local frameStroke = wordFrame:FindFirstChildOfClass("UIStroke")
			if frameStroke then
				frameStroke.Color = Color3.fromRGB(255, 100, 100)
			end
		end

		-- ã‚·ã‚¹ãƒ†ãƒ ã‚­ãƒ¼ã®ãƒ–ãƒ­ãƒƒã‚¯ã¨Roblox UIã¯ç¶­æŒ
		-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç§»å‹•åˆ¶é™ã‚‚ç¶­æŒ
		-- æ­»äº¡é¸æŠUIã§é¸ã‚“ã å¾Œã«è§£é™¤ã™ã‚‹
	end

	print("[BattleUI] === ãƒãƒˆãƒ«çµ‚äº†å®Œäº† ===")
end

-- HPæ›´æ–°å‡¦ç†ï¼ˆæ•µï¼‰
local function onHPUpdate(newHP)
	monsterHP = newHP

	print(("[BattleUI] ========================================"):format())
	print(("[BattleUI] æ•µHPæ›´æ–°"):format())
	print(("  æ–°HP: %d"):format(newHP))
	print(("  æœ€å¤§HP: %d"):format(monsterMaxHP))
	print(("  HPå‰²åˆ: %.1f%%"):format((newHP / monsterMaxHP) * 100))
	print(("[BattleUI] ========================================"):format())

	updateDisplay()

	-- HPãŒ0ã«ãªã£ãŸã‚‰å‹åˆ©ï¼ˆã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰ã®é€šçŸ¥ã‚‚æ¥ã‚‹ãŒå¿µã®ãŸã‚ï¼‰
	if monsterHP <= 0 then
		print("[BattleUI] âš ï¸ æ•µHPãŒ0ã«ãªã‚Šã¾ã—ãŸï¼ˆã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã§æ¤œå‡ºï¼‰")
	end
end

-- HPæ›´æ–°å‡¦ç†ï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼‰
local function onPlayerHPUpdate(newHP, newMaxHP)
	playerHP = newHP
	playerMaxHP = newMaxHP or playerMaxHP
	updateDisplay()

	print(("[BattleUI] ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼HPæ›´æ–°: %d / %d"):format(playerHP, playerMaxHP))

	-- HPãŒ0ã«ãªã£ãŸã‚‰æ•—åŒ—ï¼ˆã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰ã®é€šçŸ¥ã‚‚æ¥ã‚‹ãŒå¿µã®ãŸã‚ï¼‰
	if playerHP <= 0 then
		print("[BattleUI] ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼HPãŒ0ã«ãªã‚Šã¾ã—ãŸ")
	end
end

-- ã‚·ã‚¹ãƒ†ãƒ ã‚­ãƒ¼ã‚’ãƒ–ãƒ­ãƒƒã‚¯ã™ã‚‹å…¥åŠ›å‡¦ç†ï¼ˆæœ€å„ªå…ˆï¼‰
UserInputService.InputBegan:Connect(function(input, gameProcessed)
	-- ãƒãƒˆãƒ«ä¸­ã«ã‚·ã‚¹ãƒ†ãƒ ã‚­ãƒ¼ãŒæŠ¼ã•ã‚ŒãŸå ´åˆã€å…ˆã«å‡¦ç†ã—ã¦æ¶ˆè²»ã™ã‚‹
	if inBattle and input.UserInputType == Enum.UserInputType.Keyboard then
		local blockedKeys = {
			[Enum.KeyCode.I] = true,
			[Enum.KeyCode.O] = true,
			[Enum.KeyCode.Slash] = true,
			[Enum.KeyCode.Backquote] = true,
			[Enum.KeyCode.Tab] = true,
			[Enum.KeyCode.BackSlash] = true,
			[Enum.KeyCode.Equals] = true,
			[Enum.KeyCode.Minus] = true,
		}

		if blockedKeys[input.KeyCode] then
			-- ã“ã®ã‚­ãƒ¼ã¯ã‚¿ã‚¤ãƒ”ãƒ³ã‚°å‡¦ç†ã«å›ã™ï¼ˆã‚ºãƒ¼ãƒ ãªã©ã¯ç™ºå‹•ã•ã›ãªã„ï¼‰
			return
		end
	end
end)

-- ã‚­ãƒ¼å…¥åŠ›å‡¦ç†
local function onKeyPress(input, gameProcessed)
	if not inBattle then return end

	if input.UserInputType == Enum.UserInputType.Keyboard then
		local keyCode = input.KeyCode
		local keyString = UserInputService:GetStringForKeyCode(keyCode):lower()

		-- è‹±å­—ã®ã¿å—ã‘ä»˜ã‘
		if #keyString == 1 and keyString:match("%a") then
			local expectedChar = string.sub(currentWord, currentIndex, currentIndex):lower()

			if keyString == expectedChar then
				-- æ­£è§£
				currentIndex = currentIndex + 1

				-- æ­£è§£éŸ³ã‚’å†ç”Ÿ
				if TypingCorrectSound then
					TypingCorrectSound:Play()
				end

				-- ã‚µãƒ¼ãƒãƒ¼ã«ãƒ€ãƒ¡ãƒ¼ã‚¸é€šçŸ¥
				BattleDamageEvent:FireServer(damagePerKey)

				-- å˜èªå®Œæˆãƒã‚§ãƒƒã‚¯
				if currentIndex > #currentWord then
					task.wait(0.3)
					if inBattle then
						setNextWord()
					end
				else
					updateDisplay()
				end
			else
				-- ã‚¿ã‚¤ãƒ—ãƒŸã‚¹
				if TypingErrorSound then
					TypingErrorSound:Play()
				end

				-- æ ã‚’èµ¤ãå…‰ã‚‰ã›ã‚‹ï¼ˆç‚¹æ»…ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼‰
				if wordFrame then
					-- èƒŒæ™¯ã‚’èµ¤ã
					wordFrame.BackgroundColor3 = Color3.fromRGB(255, 50, 50)
					wordFrame.BackgroundTransparency = 0.3  -- å°‘ã—æ¿ƒã

					-- æ ç·šã‚‚èµ¤ã
					local frameStroke = wordFrame:FindFirstChildOfClass("UIStroke")
					if frameStroke then
						frameStroke.Color = Color3.fromRGB(255, 50, 50)
					end

					-- 0.3ç§’ã‹ã‘ã¦å…ƒã«æˆ»ã™
					TweenService:Create(wordFrame, TweenInfo.new(0.3), {
						BackgroundColor3 = Color3.fromRGB(30, 30, 40),
						BackgroundTransparency = 0.2
					}):Play()

					if frameStroke then
						TweenService:Create(frameStroke, TweenInfo.new(0.3), {
							Color = Color3.fromRGB(100, 200, 255)
						}):Play()
					end
				end

				-- ã‚¿ã‚¤ãƒ—ãƒŸã‚¹æ™‚ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ã‚µãƒ¼ãƒãƒ¼ã«é€šçŸ¥
				local TypingMistakeEvent = ReplicatedStorage:FindFirstChild("TypingMistake")
				if TypingMistakeEvent then
					TypingMistakeEvent:FireServer()
				end
			end
		end
	end
end

-- åˆæœŸåŒ–
createBattleUI()

print("[BattleUI] ã‚¤ãƒ™ãƒ³ãƒˆæ¥ç¶šä¸­...")
BattleStartEvent.OnClientEvent:Connect(onBattleStart)
BattleEndEvent.OnClientEvent:Connect(onBattleEnd)

-- HPæ›´æ–°ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆæ•µï¼‰
local HPUpdateEvent = ReplicatedStorage:FindFirstChild("BattleHPUpdate")
if HPUpdateEvent then
	HPUpdateEvent.OnClientEvent:Connect(onHPUpdate)
end

-- HPæ›´æ–°ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼‰
local PlayerHPUpdateEvent = ReplicatedStorage:FindFirstChild("PlayerHPUpdate")

if PlayerHPUpdateEvent then
	PlayerHPUpdateEvent.OnClientEvent:Connect(onPlayerHPUpdate)
else
	warn("[BattleUI] PlayerHPUpdate ã‚¤ãƒ™ãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
end

UserInputService.InputBegan:Connect(onKeyPress)

-- ç·Šæ€¥è„±å‡ºç”¨ï¼šEscã‚­ãƒ¼ã§å¼·åˆ¶çµ‚äº†
UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if input.KeyCode == Enum.KeyCode.Escape and battleGui.Enabled then
		warn("[BattleUI] Escã‚­ãƒ¼ã§å¼·åˆ¶çµ‚äº†")

		-- ã‚·ã‚¹ãƒ†ãƒ ã‚­ãƒ¼ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’è§£é™¤
		unblockSystemKeys()

		-- Roblox UIã‚’å†æœ‰åŠ¹åŒ–
		pcall(function()
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Chat, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.EmotesMenu, true)
		end)

		darkenFrame.BackgroundTransparency = 1
		battleGui.Enabled = false
		inBattle = false
		currentWord = ""
		currentWordData = nil
		currentIndex = 1
		playerHP = 0
		playerMaxHP = 0

		local character = player.Character
		if character then
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			if humanoid then
				humanoid.WalkSpeed = 16
				humanoid.JumpPower = 50
				humanoid.JumpHeight = 7.2
			end
		end
	end
end)

print("[BattleUI] ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆåˆæœŸåŒ–å®Œäº†ï¼ˆã‚¿ã‚¤ãƒ”ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ï¼‰")
===== ./StartPlayerScripts/RewardPopup.client.lua =====
-- StarterPlayer/StarterPlayerScripts/RewardPopup.client.lua
-- å ±é…¬å–å¾—æ™‚ã®ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—è¡¨ç¤º

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

print("[RewardPopup] åˆæœŸåŒ–é–‹å§‹")

-- RemoteEventå–å¾—
local InteractionResponseEvent = ReplicatedStorage:WaitForChild("InteractionResponse", 10)
if not InteractionResponseEvent then
	warn("[RewardPopup] InteractionResponseãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
	return
end

-- ScreenGuiä½œæˆ
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "RewardPopupUI"
screenGui.ResetOnSpawn = false
screenGui.IgnoreGuiInset = true
screenGui.DisplayOrder = 200
screenGui.Parent = playerGui

-- ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã‚’è¡¨ç¤º
local function showRewardPopup(rewards, duration)
	duration = duration or 3
	print(("[RewardPopup] å ±é…¬ã‚’è¡¨ç¤º: %då€‹, è¡¨ç¤ºæ™‚é–“: %dç§’"):format(#rewards, duration))

	-- ãƒ¡ã‚¤ãƒ³ãƒ•ãƒ¬ãƒ¼ãƒ 
	local frame = Instance.new("Frame")
	frame.Name = "RewardFrame"
	frame.Size = UDim2.new(0, 400, 0, 0) -- é«˜ã•ã¯å‹•çš„ã«èª¿æ•´
	frame.Position = UDim2.new(0.5, -200, 0.3, 0)
	frame.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
	frame.BackgroundTransparency = 0.2
	frame.BorderSizePixel = 0
	frame.Parent = screenGui

	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 12)
	corner.Parent = frame

	-- ã‚¿ã‚¤ãƒˆãƒ«
	local title = Instance.new("TextLabel")
	title.Size = UDim2.new(1, -20, 0, 40)
	title.Position = UDim2.new(0, 10, 0, 10)
	title.BackgroundTransparency = 1
	title.Text = "âœ¨ ã‚¢ã‚¤ãƒ†ãƒ ã‚’æ‰‹ã«å…¥ã‚ŒãŸï¼"
	title.TextColor3 = Color3.fromRGB(255, 220, 100)
	title.TextSize = 24
	title.Font = Enum.Font.GothamBold
	title.TextXAlignment = Enum.TextXAlignment.Left
	title.Parent = frame

	-- å ±é…¬ãƒªã‚¹ãƒˆã‚³ãƒ³ãƒ†ãƒŠ
	local listContainer = Instance.new("Frame")
	listContainer.Size = UDim2.new(1, -20, 1, -60)
	listContainer.Position = UDim2.new(0, 10, 0, 50)
	listContainer.BackgroundTransparency = 1
	listContainer.Parent = frame

	local listLayout = Instance.new("UIListLayout")
	listLayout.SortOrder = Enum.SortOrder.LayoutOrder
	listLayout.Padding = UDim.new(0, 8)
	listLayout.Parent = listContainer

	-- å„å ±é…¬ã‚’è¡¨ç¤º
	for i, reward in ipairs(rewards) do
		local rewardFrame = Instance.new("Frame")
		rewardFrame.Size = UDim2.new(1, 0, 0, 35)
		rewardFrame.BackgroundColor3 = Color3.fromRGB(60, 60, 70)
		rewardFrame.BackgroundTransparency = 0.5
		rewardFrame.BorderSizePixel = 0
		rewardFrame.LayoutOrder = i
		rewardFrame.Parent = listContainer

		local rewardCorner = Instance.new("UICorner")
		rewardCorner.CornerRadius = UDim.new(0, 8)
		rewardCorner.Parent = rewardFrame

		-- ã‚¢ã‚¤ãƒ†ãƒ å
		local itemLabel = Instance.new("TextLabel")
		itemLabel.Size = UDim2.new(0.7, 0, 1, 0)
		itemLabel.Position = UDim2.new(0, 15, 0, 0)
		itemLabel.BackgroundTransparency = 1
		itemLabel.Text = reward.item
		itemLabel.TextColor3 = Color3.new(1, 1, 1)
		itemLabel.TextSize = 20
		itemLabel.Font = Enum.Font.SourceSansBold
		itemLabel.TextXAlignment = Enum.TextXAlignment.Left
		itemLabel.Parent = rewardFrame

		-- å€‹æ•°
		local countLabel = Instance.new("TextLabel")
		countLabel.Size = UDim2.new(0.3, -15, 1, 0)
		countLabel.Position = UDim2.new(0.7, 0, 0, 0)
		countLabel.BackgroundTransparency = 1
		countLabel.Text = "x" .. tostring(reward.count)
		countLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
		countLabel.TextSize = 20
		countLabel.Font = Enum.Font.SourceSansBold
		countLabel.TextXAlignment = Enum.TextXAlignment.Right
		countLabel.Parent = rewardFrame
	end

	-- ãƒ•ãƒ¬ãƒ¼ãƒ ã®é«˜ã•ã‚’èª¿æ•´
	local contentHeight = 60 + (#rewards * 35) + ((#rewards - 1) * 8)
	frame.Size = UDim2.new(0, 400, 0, contentHeight)

	-- ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
	frame.BackgroundTransparency = 1
	title.TextTransparency = 1

	for _, child in ipairs(listContainer:GetChildren()) do
		if child:IsA("Frame") then
			child.BackgroundTransparency = 1
			for _, label in ipairs(child:GetChildren()) do
				if label:IsA("TextLabel") then
					label.TextTransparency = 1
				end
			end
		end
	end

	-- ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼šãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
	TweenService:Create(frame, TweenInfo.new(0.5), {
		BackgroundTransparency = 0.2
	}):Play()

	TweenService:Create(title, TweenInfo.new(0.5), {
		TextTransparency = 0
	}):Play()

	for _, child in ipairs(listContainer:GetChildren()) do
		if child:IsA("Frame") then
			TweenService:Create(child, TweenInfo.new(0.5), {
				BackgroundTransparency = 0.5
			}):Play()

			for _, label in ipairs(child:GetChildren()) do
				if label:IsA("TextLabel") then
					TweenService:Create(label, TweenInfo.new(0.5), {
						TextTransparency = 0
					}):Play()
				end
			end
		end
	end

	-- 5ç§’å¾Œã«ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
	task.wait(5)

	-- ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼šãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
	local fadeOut = TweenService:Create(frame, TweenInfo.new(1), {
		BackgroundTransparency = 1
	})

	TweenService:Create(title, TweenInfo.new(1), {
		TextTransparency = 1
	}):Play()

	for _, child in ipairs(listContainer:GetChildren()) do
		if child:IsA("Frame") then
			TweenService:Create(child, TweenInfo.new(1), {
				BackgroundTransparency = 1
			}):Play()

			for _, label in ipairs(child:GetChildren()) do
				if label:IsA("TextLabel") then
					TweenService:Create(label, TweenInfo.new(1), {
						TextTransparency = 1
					}):Play()
				end
			end
		end
	end

	fadeOut:Play()
	fadeOut.Completed:Connect(function()
		frame:Destroy()
		print("[RewardPopup] ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã‚’å‰Šé™¤ã—ã¾ã—ãŸ")
	end)
end

-- ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰ã®å ±é…¬æƒ…å ±ã‚’å—ä¿¡
InteractionResponseEvent.OnClientEvent:Connect(function(data)
	if data.success and data.type == "chest" and data.rewards then
		local duration = data.displayDuration or 3
		showRewardPopup(data.rewards, duration)
	end
end)

print("[RewardPopup] åˆæœŸåŒ–å®Œäº†")
===== ./StartPlayerScripts/FastTravelUI.client.lua =====
-- StarterPlayer/StarterPlayerScripts/FastTravelUI.client.lua
-- ãƒ•ã‚¡ã‚¹ãƒˆãƒˆãƒ©ãƒ™ãƒ«UIã‚·ã‚¹ãƒ†ãƒ 

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

print("[FastTravelUI] åˆæœŸåŒ–é–‹å§‹")

-- RemoteEventå–å¾—
local FastTravelEvent = ReplicatedStorage:WaitForChild("FastTravelEvent", 10)
local GetContinentsEvent = ReplicatedStorage:WaitForChild("GetContinentsEvent", 10)

if not FastTravelEvent or not GetContinentsEvent then
	warn("[FastTravelUI] RemoteEventãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
	return
end

-- UIã‚³ãƒ³ãƒ†ãƒŠ
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "FastTravelUI"
screenGui.ResetOnSpawn = false
screenGui.IgnoreGuiInset = true
-- screenGui.ZIndex = 100
screenGui.Parent = playerGui

-- ãƒ¯ãƒ¼ãƒ—ãƒœã‚¿ãƒ³ï¼ˆãƒŸãƒ‹ãƒãƒƒãƒ—ã®ä¸Šï¼‰
local warpButton = Instance.new("TextButton")
warpButton.Name = "WarpButton"
warpButton.Size = UDim2.new(0, 200, 0, 35) -- ãƒŸãƒ‹ãƒãƒƒãƒ—ã¨åŒã˜æ¨ªå¹…200ã€é«˜ã•35
warpButton.Position = UDim2.new(0, 20, 1, -300) -- ãƒŸãƒ‹ãƒãƒƒãƒ—ã®ä¸Šã«é…ç½®
warpButton.BackgroundColor3 = Color3.fromRGB(50, 120, 200)
warpButton.BackgroundTransparency = 0.2
warpButton.BorderSizePixel = 2
warpButton.BorderColor3 = Color3.fromRGB(255, 255, 255)
warpButton.Text = "ãƒ¯ãƒ¼ãƒ—"
warpButton.TextColor3 = Color3.new(1, 1, 1)
warpButton.TextSize = 18
warpButton.Font = Enum.Font.SourceSansBold
warpButton.Parent = screenGui

local warpButtonCorner = Instance.new("UICorner")
warpButtonCorner.CornerRadius = UDim.new(0, 6)
warpButtonCorner.Parent = warpButton

-- ãƒ¢ãƒ¼ãƒ€ãƒ«èƒŒæ™¯
local modalBackground = Instance.new("Frame")
modalBackground.Name = "ModalBackground"
modalBackground.Size = UDim2.fromScale(1, 1)
modalBackground.Position = UDim2.fromScale(0, 0)
modalBackground.BackgroundColor3 = Color3.new(0, 0, 0)
modalBackground.BackgroundTransparency = 1
modalBackground.Visible = false
modalBackground.ZIndex = 101
modalBackground.Parent = screenGui

-- ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦
local modalWindow = Instance.new("Frame")
modalWindow.Name = "ModalWindow"
modalWindow.Size = UDim2.new(0, 400, 0, 500)
modalWindow.Position = UDim2.new(0.5, -200, 0.5, -250)
modalWindow.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
modalWindow.BackgroundTransparency = 0.1
modalWindow.BorderSizePixel = 3
modalWindow.BorderColor3 = Color3.fromRGB(100, 150, 255)
modalWindow.ZIndex = 102
modalWindow.Parent = modalBackground

local modalCorner = Instance.new("UICorner")
modalCorner.CornerRadius = UDim.new(0, 12)
modalCorner.Parent = modalWindow

-- ã‚¿ã‚¤ãƒˆãƒ«
local titleLabel = Instance.new("TextLabel")
titleLabel.Name = "Title"
titleLabel.Size = UDim2.new(1, 0, 0, 50)
titleLabel.Position = UDim2.new(0, 0, 0, 0)
titleLabel.BackgroundTransparency = 1
titleLabel.Text = "ãƒ¯ãƒ¼ãƒ—å…ˆã‚’é¸æŠ"
titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
titleLabel.TextSize = 24
titleLabel.Font = Enum.Font.GothamBold
titleLabel.ZIndex = 103
titleLabel.Parent = modalWindow

-- é–‰ã˜ã‚‹ãƒœã‚¿ãƒ³
local closeButton = Instance.new("TextButton")
closeButton.Name = "CloseButton"
closeButton.Size = UDim2.new(0, 40, 0, 40)
closeButton.Position = UDim2.new(1, -50, 0, 5)
closeButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
closeButton.BackgroundTransparency = 0.3
closeButton.BorderSizePixel = 0
closeButton.Text = "âœ•"
closeButton.TextColor3 = Color3.new(1, 1, 1)
closeButton.TextSize = 24
closeButton.Font = Enum.Font.SourceSansBold
closeButton.ZIndex = 103
closeButton.Parent = modalWindow

local closeButtonCorner = Instance.new("UICorner")
closeButtonCorner.CornerRadius = UDim.new(0, 8)
closeButtonCorner.Parent = closeButton

-- ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒ•ãƒ¬ãƒ¼ãƒ ï¼ˆå¤§é™¸ä¸€è¦§ï¼‰
local scrollFrame = Instance.new("ScrollingFrame")
scrollFrame.Name = "ContinentsList"
scrollFrame.Size = UDim2.new(1, -40, 1, -100)
scrollFrame.Position = UDim2.new(0, 20, 0, 70)
scrollFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 30)
scrollFrame.BackgroundTransparency = 0.5
scrollFrame.BorderSizePixel = 0
scrollFrame.ScrollBarThickness = 8
scrollFrame.ZIndex = 102
scrollFrame.Parent = modalWindow

local scrollCorner = Instance.new("UICorner")
scrollCorner.CornerRadius = UDim.new(0, 8)
scrollCorner.Parent = scrollFrame

local listLayout = Instance.new("UIListLayout")
listLayout.SortOrder = Enum.SortOrder.LayoutOrder
listLayout.Padding = UDim.new(0, 10)
listLayout.Parent = scrollFrame

local listPadding = Instance.new("UIPadding")
listPadding.PaddingTop = UDim.new(0, 10)
listPadding.PaddingBottom = UDim.new(0, 10)
listPadding.PaddingLeft = UDim.new(0, 10)
listPadding.PaddingRight = UDim.new(0, 10)
listPadding.Parent = scrollFrame

-- ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ã
local function openModal()
	print("[FastTravelUI] ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ã")

	-- å¤§é™¸ä¸€è¦§ã‚’å–å¾—
	local success, continents = pcall(function()
		return GetContinentsEvent:InvokeServer()
	end)

	if not success or not continents then
		warn("[FastTravelUI] å¤§é™¸ä¸€è¦§ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ")
		return
	end

	-- æ—¢å­˜ã®ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªã‚¢
	for _, child in ipairs(scrollFrame:GetChildren()) do
		if child:IsA("TextButton") then
			child:Destroy()
		end
	end

	-- å¤§é™¸ãƒœã‚¿ãƒ³ã‚’ä½œæˆ
	for i, continent in ipairs(continents) do
		local button = Instance.new("TextButton")
		button.Name = continent.name
		button.Size = UDim2.new(1, -20, 0, 60)
		button.BackgroundColor3 = Color3.fromRGB(60, 100, 180)
		button.BackgroundTransparency = 0.2
		button.BorderSizePixel = 0
		button.Text = continent.displayName
		button.TextColor3 = Color3.new(1, 1, 1)
		button.TextSize = 20
		button.Font = Enum.Font.SourceSansBold
		button.LayoutOrder = i
		button.ZIndex = 103
		button.Parent = scrollFrame

		local buttonCorner = Instance.new("UICorner")
		buttonCorner.CornerRadius = UDim.new(0, 8)
		buttonCorner.Parent = button

		-- ãƒ›ãƒãƒ¼ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
		button.MouseEnter:Connect(function()
			TweenService:Create(button, TweenInfo.new(0.2), {
				BackgroundTransparency = 0
			}):Play()
		end)

		button.MouseLeave:Connect(function()
			TweenService:Create(button, TweenInfo.new(0.2), {
				BackgroundTransparency = 0.2
			}):Play()
		end)

		-- ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆ
		button.MouseButton1Click:Connect(function()
			print(("[FastTravelUI] %s ã¸ãƒ¯ãƒ¼ãƒ—è¦æ±‚"):format(continent.name))
			FastTravelEvent:FireServer(continent.name)
			closeModal()
		end)
	end

	-- ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒ•ãƒ¬ãƒ¼ãƒ ã®ã‚µã‚¤ã‚ºèª¿æ•´
	scrollFrame.CanvasSize = UDim2.new(0, 0, 0, listLayout.AbsoluteContentSize.Y + 20)

	-- ãƒ¢ãƒ¼ãƒ€ãƒ«è¡¨ç¤º
	modalBackground.Visible = true
	modalBackground.BackgroundTransparency = 0.5

	-- ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
	TweenService:Create(modalBackground, TweenInfo.new(0.3), {
		BackgroundTransparency = 0.3
	}):Play()
end

-- ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
function closeModal()
	print("[FastTravelUI] ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹")

	TweenService:Create(modalBackground, TweenInfo.new(0.3), {
		BackgroundTransparency = 1
	}):Play()

	task.wait(0.3)
	modalBackground.Visible = false
end

-- ã‚¤ãƒ™ãƒ³ãƒˆæ¥ç¶š
warpButton.MouseButton1Click:Connect(openModal)
closeButton.MouseButton1Click:Connect(closeModal)

-- èƒŒæ™¯ã‚¯ãƒªãƒƒã‚¯ã§é–‰ã˜ã‚‹
modalBackground.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		-- ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦å¤–ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸå ´åˆ
		local mousePos = input.Position
		local windowPos = modalWindow.AbsolutePosition
		local windowSize = modalWindow.AbsoluteSize

		if mousePos.X < windowPos.X or mousePos.X > windowPos.X + windowSize.X or
		   mousePos.Y < windowPos.Y or mousePos.Y > windowPos.Y + windowSize.Y then
			closeModal()
		end
	end
end)

print("[FastTravelUI] åˆæœŸåŒ–å®Œäº†")
===== ./StartPlayerScripts/LoadingScreen.client.lua =====
-- StarterPlayer/StarterPlayerScripts/LoadingScreen.client.lua
-- åˆå›ãƒ­ãƒ¼ãƒ‰æ™‚ã®ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ç”»é¢

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

print("[LoadingScreen] åˆæœŸåŒ–ä¸­...")

-- ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ç”»é¢ã®UI
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "InitialLoadingUI"
screenGui.ResetOnSpawn = false
screenGui.IgnoreGuiInset = true
screenGui.DisplayOrder = 1000 -- æœ€å‰é¢ã«è¡¨ç¤º
screenGui.Parent = playerGui

local frame = Instance.new("Frame")
frame.Name = "LoadingFrame"
frame.Size = UDim2.new(1, 0, 1, 0)
frame.BackgroundColor3 = Color3.new(0, 0, 0)
frame.BackgroundTransparency = 0
frame.Visible = true
frame.Parent = screenGui

local label = Instance.new("TextLabel")
label.Size = UDim2.new(0.6, 0, 0.2, 0)
label.Position = UDim2.new(0.2, 0, 0.4, 0)
label.BackgroundTransparency = 1
label.Text = "Loading..."
label.TextColor3 = Color3.new(1, 1, 1)
label.TextScaled = true
label.Font = Enum.Font.SourceSansBold
label.Parent = frame

-- ãƒ’ãƒ³ãƒˆãƒ†ã‚­ã‚¹ãƒˆï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
local hintLabel = Instance.new("TextLabel")
hintLabel.Size = UDim2.new(0.8, 0, 0.1, 0)
hintLabel.Position = UDim2.new(0.1, 0, 0.6, 0)
hintLabel.BackgroundTransparency = 1
hintLabel.Text = "ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ã‚’ç·´ç¿’ã—ã¦ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’å€’ãã†ï¼"
hintLabel.TextColor3 = Color3.new(0.8, 0.8, 0.8)
hintLabel.TextSize = 18
hintLabel.Font = Enum.Font.Gotham
hintLabel.Parent = frame

-- ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰ã®æº–å‚™å®Œäº†ä¿¡å·ã‚’å¾…ã¤
local spawnReadyEvent = ReplicatedStorage:WaitForChild("SpawnReady", 10)

if spawnReadyEvent then
    spawnReadyEvent.OnClientEvent:Connect(function()
        print("[LoadingScreen] ã‚¹ãƒãƒ¼ãƒ³æº–å‚™å®Œäº†ã€ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆé–‹å§‹")

        -- ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
        local fadeOut = TweenService:Create(frame, TweenInfo.new(1, Enum.EasingStyle.Quad), {
            BackgroundTransparency = 1
        })

        local labelFadeOut = TweenService:Create(label, TweenInfo.new(1, Enum.EasingStyle.Quad), {
            TextTransparency = 1
        })

        local hintFadeOut = TweenService:Create(hintLabel, TweenInfo.new(1, Enum.EasingStyle.Quad), {
            TextTransparency = 1
        })

        fadeOut:Play()
        labelFadeOut:Play()
        hintFadeOut:Play()

        fadeOut.Completed:Connect(function()
            screenGui:Destroy()
            print("[LoadingScreen] ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ç”»é¢ã‚’å‰Šé™¤")
        end)
    end)
else
    warn("[LoadingScreen] SpawnReadyã‚¤ãƒ™ãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
    -- ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼š3ç§’å¾Œã«è‡ªå‹•ã§æ¶ˆã™
    task.wait(3)
    screenGui:Destroy()
end

print("[LoadingScreen] åˆæœŸåŒ–å®Œäº†")
===== ./StartPlayerScripts/StatusUI.client.lua =====
-- StarterPlayer/StarterPlayerScripts/StatusUI.client.lua
-- ç”»é¢å·¦ä¸‹ã«å¸¸æ™‚è¡¨ç¤ºã™ã‚‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

print("[StatusUI] åˆæœŸåŒ–ä¸­...")

-- ç¾åœ¨ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
local currentHP = 100
local currentMaxHP = 100
local currentLevel = 1
local currentExp = 0
local currentExpToNext = 100
local currentGold = 0

-- UIè¦ç´ 
local statusGui = nil
local hpBarBackground = nil
local hpBarFill = nil
local hpLabel = nil
local levelLabel = nil
local expLabel = nil
local goldLabel = nil

-- HPã®è‰²ã‚’å–å¾—
local function getHPColor(hpPercent)
	if hpPercent > 0.6 then
		return Color3.fromRGB(46, 204, 113)  -- ç·‘
	elseif hpPercent > 0.3 then
		return Color3.fromRGB(241, 196, 15)  -- é»„è‰²
	else
		return Color3.fromRGB(231, 76, 60)  -- èµ¤
	end
end

-- è¡¨ç¤ºã‚’æ›´æ–°
local function updateDisplay()
	if hpBarFill and hpLabel then
		local hpPercent = currentHP / currentMaxHP

		-- ãƒãƒ¼ã®é•·ã•ã‚’ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
		local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
		local tween = TweenService:Create(hpBarFill, tweenInfo, {
			Size = UDim2.new(hpPercent, 0, 1, 0)
		})
		tween:Play()

		-- è‰²ã‚’å¤‰æ›´
		hpBarFill.BackgroundColor3 = getHPColor(hpPercent)

		-- ãƒ†ã‚­ã‚¹ãƒˆæ›´æ–°
		hpLabel.Text = string.format("%d / %d", currentHP, currentMaxHP)
	end

	if levelLabel then
		levelLabel.Text = string.format("Lv.%d", currentLevel)
	end

	if expLabel then
		expLabel.Text = string.format("EXP: %d / %d", currentExp, currentExpToNext)
	end

	if goldLabel then
		goldLabel.Text = string.format("ğŸ’° %d G", currentGold)
	end
end

-- UIä½œæˆ
local function createStatusUI()
	statusGui = Instance.new("ScreenGui")
	statusGui.Name = "StatusUI"
	statusGui.ResetOnSpawn = false
	statusGui.Parent = playerGui

	-- èƒŒæ™¯ãƒ•ãƒ¬ãƒ¼ãƒ 
	local backgroundFrame = Instance.new("Frame")
	backgroundFrame.Name = "StatusBackground"
	backgroundFrame.Size = UDim2.new(0, 250, 0, 120)
	backgroundFrame.Position = UDim2.new(1, -270, 1, -140)
	backgroundFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
	backgroundFrame.BackgroundTransparency = 0.3
	backgroundFrame.BorderSizePixel = 0
	backgroundFrame.Parent = statusGui

	-- è§’ã‚’ä¸¸ãã™ã‚‹
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 10)
	corner.Parent = backgroundFrame

	-- ãƒ¬ãƒ™ãƒ«è¡¨ç¤º
	levelLabel = Instance.new("TextLabel")
	levelLabel.Name = "LevelLabel"
	levelLabel.Size = UDim2.new(0, 80, 0, 25)
	levelLabel.Position = UDim2.new(0, 10, 0, 10)
	levelLabel.BackgroundTransparency = 1
	levelLabel.TextColor3 = Color3.fromRGB(255, 215, 0)
	levelLabel.TextStrokeTransparency = 0.5
	levelLabel.Font = Enum.Font.GothamBold
	levelLabel.TextSize = 20
	levelLabel.Text = "Lv.1"
	levelLabel.TextXAlignment = Enum.TextXAlignment.Left
	levelLabel.Parent = backgroundFrame

	-- HPãƒãƒ¼èƒŒæ™¯
	hpBarBackground = Instance.new("Frame")
	hpBarBackground.Name = "HPBarBackground"
	hpBarBackground.Size = UDim2.new(1, -20, 0, 20)
	hpBarBackground.Position = UDim2.new(0, 10, 0, 40)
	hpBarBackground.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
	hpBarBackground.BorderSizePixel = 0
	hpBarBackground.Parent = backgroundFrame

	-- HPãƒãƒ¼èƒŒæ™¯ã®è§’ã‚’ä¸¸ãã™ã‚‹
	local hpBarCorner = Instance.new("UICorner")
	hpBarCorner.CornerRadius = UDim.new(0, 5)
	hpBarCorner.Parent = hpBarBackground

	-- HPãƒãƒ¼ï¼ˆå¡—ã‚Šã¤ã¶ã—ï¼‰
	hpBarFill = Instance.new("Frame")
	hpBarFill.Name = "HPBarFill"
	hpBarFill.Size = UDim2.new(1, 0, 1, 0)
	hpBarFill.Position = UDim2.new(0, 0, 0, 0)
	hpBarFill.BackgroundColor3 = Color3.fromRGB(46, 204, 113)
	hpBarFill.BorderSizePixel = 0
	hpBarFill.Parent = hpBarBackground

	-- HPãƒãƒ¼ã®è§’ã‚’ä¸¸ãã™ã‚‹
	local hpFillCorner = Instance.new("UICorner")
	hpFillCorner.CornerRadius = UDim.new(0, 5)
	hpFillCorner.Parent = hpBarFill

	-- HPãƒ†ã‚­ã‚¹ãƒˆ
	hpLabel = Instance.new("TextLabel")
	hpLabel.Name = "HPLabel"
	hpLabel.Size = UDim2.new(1, 0, 1, 0)
	hpLabel.Position = UDim2.new(0, 0, 0, 0)
	hpLabel.BackgroundTransparency = 1
	hpLabel.TextColor3 = Color3.new(1, 1, 1)
	hpLabel.TextStrokeTransparency = 0.5
	hpLabel.Font = Enum.Font.GothamBold
	hpLabel.TextSize = 14
	hpLabel.Text = "100 / 100"
	hpLabel.Parent = hpBarBackground

	-- çµŒé¨“å€¤è¡¨ç¤º
	expLabel = Instance.new("TextLabel")
	expLabel.Name = "ExpLabel"
	expLabel.Size = UDim2.new(1, -20, 0, 18)
	expLabel.Position = UDim2.new(0, 10, 0, 65)
	expLabel.BackgroundTransparency = 1
	expLabel.TextColor3 = Color3.fromRGB(150, 200, 255)
	expLabel.TextStrokeTransparency = 0.7
	expLabel.Font = Enum.Font.Gotham
	expLabel.TextSize = 14
	expLabel.Text = "EXP: 0 / 100"
	expLabel.TextXAlignment = Enum.TextXAlignment.Left
	expLabel.Parent = backgroundFrame

	-- ã‚´ãƒ¼ãƒ«ãƒ‰è¡¨ç¤º
	goldLabel = Instance.new("TextLabel")
	goldLabel.Name = "GoldLabel"
	goldLabel.Size = UDim2.new(1, -20, 0, 18)
	goldLabel.Position = UDim2.new(0, 10, 0, 88)
	goldLabel.BackgroundTransparency = 1
	goldLabel.TextColor3 = Color3.fromRGB(255, 215, 0)
	goldLabel.TextStrokeTransparency = 0.7
	goldLabel.Font = Enum.Font.GothamBold
	goldLabel.TextSize = 14
	goldLabel.Text = "ğŸ’° 0 G"
	goldLabel.TextXAlignment = Enum.TextXAlignment.Left
	goldLabel.Parent = backgroundFrame

	print("[StatusUI] UIä½œæˆå®Œäº†")
end

-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°ã‚¤ãƒ™ãƒ³ãƒˆ
local function onStatusUpdate(hp, maxHP, level, exp, expToNext, gold)
	print(("[StatusUI] ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°å—ä¿¡: HP=%d/%d, Lv=%d, EXP=%d/%d, Gold=%d"):format(
		hp or 0, maxHP or 0, level or 0, exp or 0, expToNext or 0, gold or 0
		))

	currentHP = hp or currentHP
	currentMaxHP = maxHP or currentMaxHP
	currentLevel = level or currentLevel
	currentExp = exp or currentExp
	currentExpToNext = expToNext or currentExpToNext
	currentGold = gold or currentGold

	updateDisplay()
end

-- åˆæœŸåŒ–
createStatusUI()

print("[StatusUI] RemoteEventã‚’å¾…æ©Ÿä¸­...")

-- RemoteEventã‚’å¾…æ©Ÿï¼ˆæœ€å¤§30ç§’ï¼‰
task.spawn(function()
	local StatusUpdateEvent = ReplicatedStorage:WaitForChild("StatusUpdate", 10)
	if StatusUpdateEvent then
		StatusUpdateEvent.OnClientEvent:Connect(onStatusUpdate)
		print("[StatusUI] StatusUpdateã‚¤ãƒ™ãƒ³ãƒˆæ¥ç¶šå®Œäº†")

		-- åˆå›ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¦æ±‚
		task.wait(1)  -- 1ç§’å¾…ã£ã¦ã‹ã‚‰è¦æ±‚
		local RequestStatusEvent = ReplicatedStorage:FindFirstChild("RequestStatus")
		if RequestStatusEvent then
			print("[StatusUI] åˆå›ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’è¦æ±‚")
			RequestStatusEvent:FireServer()
		else
			warn("[StatusUI] RequestStatusã‚¤ãƒ™ãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
		end
	else
		warn("[StatusUI] StatusUpdateã‚¤ãƒ™ãƒ³ãƒˆã®å¾…æ©ŸãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸ")
	end
end)

print("[StatusUI] åˆæœŸåŒ–å®Œäº†")
===== ./StartPlayerScripts/WarpUI.client.lua =====
-- ===== ./StartPlayerScripts/WarpUI.client.lua =====
-- StarterPlayer/StarterPlayerScripts/WarpUI.client.lua
-- ãƒ¯ãƒ¼ãƒ—æ™‚ã®ãƒ­ãƒ¼ãƒ‰ç”»é¢

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- RemoteEventã‚’å–å¾— - ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’çŸ­ãè¨­å®š
local warpEvent = ReplicatedStorage:WaitForChild("WarpEvent", 5) -- â˜…ä¿®æ­£: ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’5ç§’ã«è¨­å®š

if not warpEvent then
    warn("[WarpUI] WarpEventãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚ãƒ¯ãƒ¼ãƒ—UIã¯æ©Ÿèƒ½ã—ã¾ã›ã‚“ã€‚")
    return
end

print("[WarpUI] åˆæœŸåŒ–å®Œäº†")

-- ãƒ­ãƒ¼ãƒ‰ç”»é¢ã®UI
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "WarpLoadingUI"
screenGui.ResetOnSpawn = false
screenGui.IgnoreGuiInset = true
screenGui.Parent = playerGui

local frame = Instance.new("Frame")
frame.Name = "LoadingFrame"
frame.Size = UDim2.new(1, 0, 1, 0)
frame.BackgroundColor3 = Color3.new(0, 0, 0)
frame.BackgroundTransparency = 1
frame.Visible = false
frame.Parent = screenGui

local label = Instance.new("TextLabel")
label.Size = UDim2.new(0.6, 0, 0.2, 0)
label.Position = UDim2.new(0.2, 0, 0.4, 0)
label.BackgroundTransparency = 1
label.Text = "Loading..."
label.TextColor3 = Color3.new(1, 1, 1)
label.TextScaled = true
label.Font = Enum.Font.SourceSansBold
label.Parent = frame

-- RemoteEventã‚’å—ä¿¡
warpEvent.OnClientEvent:Connect(function(action, zoneName)
	if action == "StartLoading" then
		print("[WarpUI] ãƒ­ãƒ¼ãƒ‰ç”»é¢è¡¨ç¤º:", zoneName)
		label.Text = "Warping to " .. (zoneName or "???") .. "..."
		frame.BackgroundTransparency = 0.3
		frame.Visible = true

		-- ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
		for i = 0.3, 0.7, 0.1 do
			frame.BackgroundTransparency = 1 - i
			task.wait(0.05)
		end

	elseif action == "EndLoading" then
		print("[WarpUI] ãƒ­ãƒ¼ãƒ‰ç”»é¢éè¡¨ç¤º")

		-- ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
		for i = 0.7, 0, -0.1 do
			frame.BackgroundTransparency = 1 - i
			task.wait(0.05)
		end

		frame.Visible = false
	end
end)
===== ./StartPlayerScripts/DeathUI.client.lua =====
-- StarterPlayer/StarterPlayerScripts/DeathUI.client.lua
-- æ­»äº¡æ™‚ã®é¸æŠUIï¼ˆè¡—ã«æˆ»ã‚‹ / ã‚´ãƒ¼ãƒ«ãƒ‰ãƒ­ã‚¹ãƒˆã§å¾©æ´»ï¼‰

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

print("[DeathUI] åˆæœŸåŒ–ä¸­...")

-- UIè¦ç´ 
local deathGui = nil

-- æ­»äº¡UIã‚’è¡¨ç¤º
local function showDeathUI(currentGold, reviveCost)
	print(("[DeathUI] ========================================"):format())
	print(("[DeathUI] æ­»äº¡UIè¡¨ç¤º"):format())
	print(("[DeathUI] æ‰€æŒé‡‘: %d G, å¾©æ´»ã‚³ã‚¹ãƒˆ: %d G"):format(currentGold, reviveCost))
	print(("[DeathUI] ========================================"):format())

	-- æ—¢å­˜ã®GUIã‚’å‰Šé™¤
	if deathGui then
		deathGui:Destroy()
	end

	-- æ–°ã—ã„GUIã‚’ä½œæˆ
	deathGui = Instance.new("ScreenGui")
	deathGui.Name = "DeathUI"
	deathGui.ResetOnSpawn = false
	deathGui.Parent = playerGui

	-- èƒŒæ™¯ï¼ˆæš—ã„ï¼‰
	local background = Instance.new("Frame")
	background.Size = UDim2.fromScale(1, 1)
	background.Position = UDim2.fromScale(0, 0)
	background.BackgroundColor3 = Color3.new(0, 0, 0)
	background.BackgroundTransparency = 0.3
	background.BorderSizePixel = 0
	background.ZIndex = 200
	background.Parent = deathGui

	-- ã‚¿ã‚¤ãƒˆãƒ«
	local titleText = Instance.new("TextLabel")
	titleText.Size = UDim2.new(0, 600, 0, 80)
	titleText.Position = UDim2.new(0.5, -300, 0.3, 0)
	titleText.BackgroundTransparency = 1
	titleText.TextColor3 = Color3.fromRGB(255, 100, 100)
	titleText.TextStrokeTransparency = 0
	titleText.Font = Enum.Font.GothamBold
	titleText.TextSize = 50
	titleText.Text = "YOU DIED"
	titleText.ZIndex = 201
	titleText.Parent = deathGui

	-- é¸æŠãƒ•ãƒ¬ãƒ¼ãƒ 
	local choiceFrame = Instance.new("Frame")
	choiceFrame.Size = UDim2.new(0, 600, 0, 200)
	choiceFrame.Position = UDim2.new(0.5, -300, 0.45, 0)
	choiceFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
	choiceFrame.BackgroundTransparency = 0.2
	choiceFrame.BorderSizePixel = 0
	choiceFrame.ZIndex = 201
	choiceFrame.Parent = deathGui

	-- è§’ã‚’ä¸¸ãã™ã‚‹
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 10)
	corner.Parent = choiceFrame

	-- èª¬æ˜ãƒ†ã‚­ã‚¹ãƒˆ
	local descText = Instance.new("TextLabel")
	descText.Size = UDim2.new(1, -40, 0, 60)
	descText.Position = UDim2.new(0, 20, 0, 20)
	descText.BackgroundTransparency = 1
	descText.TextColor3 = Color3.fromRGB(255, 255, 255)
	descText.TextStrokeTransparency = 0.5
	descText.Font = Enum.Font.Gotham
	descText.TextSize = 18
	descText.Text = "æ•—åŒ—ã—ã¾ã—ãŸã€‚ã©ã†ã—ã¾ã™ã‹ï¼Ÿ"
	descText.TextWrapped = true
	descText.ZIndex = 202
	descText.Parent = choiceFrame

	-- ã€Œè¡—ã«æˆ»ã‚‹ã€ãƒœã‚¿ãƒ³
	local returnButton = Instance.new("TextButton")
	returnButton.Size = UDim2.new(0, 250, 0, 50)
	returnButton.Position = UDim2.new(0.5, -260, 0, 100)
	returnButton.BackgroundColor3 = Color3.fromRGB(52, 152, 219)
	returnButton.BorderSizePixel = 0
	returnButton.Font = Enum.Font.GothamBold
	returnButton.TextSize = 20
	returnButton.Text = "ğŸ  è¡—ã«æˆ»ã‚‹"
	returnButton.TextColor3 = Color3.new(1, 1, 1)
	returnButton.ZIndex = 202
	returnButton.Parent = choiceFrame

	-- ãƒœã‚¿ãƒ³ã®è§’ã‚’ä¸¸ãã™ã‚‹
	local returnCorner = Instance.new("UICorner")
	returnCorner.CornerRadius = UDim.new(0, 8)
	returnCorner.Parent = returnButton

	-- ã€Œã‚´ãƒ¼ãƒ«ãƒ‰ã§å¾©æ´»ã€ãƒœã‚¿ãƒ³
	local reviveButton = Instance.new("TextButton")
	reviveButton.Size = UDim2.new(0, 250, 0, 50)
	reviveButton.Position = UDim2.new(0.5, 10, 0, 100)
	reviveButton.BorderSizePixel = 0
	reviveButton.Font = Enum.Font.GothamBold
	reviveButton.TextSize = 20
	reviveButton.TextColor3 = Color3.new(1, 1, 1)
	reviveButton.ZIndex = 202
	reviveButton.Parent = choiceFrame

	-- ãƒœã‚¿ãƒ³ã®è§’ã‚’ä¸¸ãã™ã‚‹
	local reviveCorner = Instance.new("UICorner")
	reviveCorner.CornerRadius = UDim.new(0, 8)
	reviveCorner.Parent = reviveButton

	-- ã‚´ãƒ¼ãƒ«ãƒ‰ãŒè¶³ã‚Šã‚‹ã‹ãƒã‚§ãƒƒã‚¯
	if currentGold >= reviveCost then
		reviveButton.BackgroundColor3 = Color3.fromRGB(46, 204, 113)
		reviveButton.Text = string.format("ğŸ’° å¾©æ´» (%d G)", reviveCost)
	else
		reviveButton.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
		reviveButton.Text = string.format("ğŸ’° å¾©æ´» (%d G) - ä¸è¶³", reviveCost)
		reviveButton.Active = false
	end

	-- ãƒœã‚¿ãƒ³ã®ãƒ›ãƒãƒ¼ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
	returnButton.MouseEnter:Connect(function()
		returnButton.BackgroundColor3 = Color3.fromRGB(62, 172, 239)
	end)
	returnButton.MouseLeave:Connect(function()
		returnButton.BackgroundColor3 = Color3.fromRGB(52, 152, 219)
	end)

	if currentGold >= reviveCost then
		reviveButton.MouseEnter:Connect(function()
			reviveButton.BackgroundColor3 = Color3.fromRGB(56, 224, 133)
		end)
		reviveButton.MouseLeave:Connect(function()
			reviveButton.BackgroundColor3 = Color3.fromRGB(46, 204, 113)
		end)
	end

	-- ã€Œè¡—ã«æˆ»ã‚‹ã€ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯
	returnButton.MouseButton1Click:Connect(function()
		print("[DeathUI] è¡—ã«æˆ»ã‚‹ã‚’é¸æŠ")

		-- ã‚µãƒ¼ãƒãƒ¼ã«é€šçŸ¥
		local DeathChoiceEvent = ReplicatedStorage:FindFirstChild("DeathChoice")
		if DeathChoiceEvent then
			DeathChoiceEvent:FireServer("return")
		end

		-- ãƒãƒˆãƒ«UIã‚’é–‰ã˜ã‚‹
		local battleUI = playerGui:FindFirstChild("BattleUI")
		if battleUI then
			battleUI.Enabled = false
		end

		-- ã‚·ã‚¹ãƒ†ãƒ ã‚­ãƒ¼ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’è§£é™¤
		local ContextActionService = game:GetService("ContextActionService")
		ContextActionService:UnbindAction("BlockSystemKeys")

		-- Roblox UIã‚’å†æœ‰åŠ¹åŒ–
		local StarterGui = game:GetService("StarterGui")
		pcall(function()
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Chat, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.EmotesMenu, true)
		end)

		-- UIã‚’é–‰ã˜ã‚‹
		if deathGui then
			deathGui:Destroy()
			deathGui = nil
		end
	end)

	-- ã€Œã‚´ãƒ¼ãƒ«ãƒ‰ã§å¾©æ´»ã€ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯
	reviveButton.MouseButton1Click:Connect(function()
		if currentGold < reviveCost then
			print("[DeathUI] ã‚´ãƒ¼ãƒ«ãƒ‰ä¸è¶³")
			return
		end

		print("[DeathUI] ã‚´ãƒ¼ãƒ«ãƒ‰ã§å¾©æ´»ã‚’é¸æŠ")

		-- ã‚µãƒ¼ãƒãƒ¼ã«é€šçŸ¥
		local DeathChoiceEvent = ReplicatedStorage:FindFirstChild("DeathChoice")
		if DeathChoiceEvent then
			DeathChoiceEvent:FireServer("revive")
		end

		-- ãƒãƒˆãƒ«UIã‚’é–‰ã˜ã‚‹
		local battleUI = playerGui:FindFirstChild("BattleUI")
		if battleUI then
			battleUI.Enabled = false
		end

		-- ã‚·ã‚¹ãƒ†ãƒ ã‚­ãƒ¼ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’è§£é™¤
		local ContextActionService = game:GetService("ContextActionService")
		ContextActionService:UnbindAction("BlockSystemKeys")

		-- Roblox UIã‚’å†æœ‰åŠ¹åŒ–
		local StarterGui = game:GetService("StarterGui")
		pcall(function()
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Chat, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.EmotesMenu, true)
		end)

		-- UIã‚’é–‰ã˜ã‚‹
		if deathGui then
			deathGui:Destroy()
			deathGui = nil
		end
	end)
end

-- RemoteEventã‚’å¾…æ©Ÿ
local ShowDeathUIEvent = ReplicatedStorage:WaitForChild("ShowDeathUI", 10)
if ShowDeathUIEvent then
	ShowDeathUIEvent.OnClientEvent:Connect(showDeathUI)
	print("[DeathUI] ShowDeathUIã‚¤ãƒ™ãƒ³ãƒˆæ¥ç¶šå®Œäº†")
else
	warn("[DeathUI] ShowDeathUIã‚¤ãƒ™ãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
end

print("[DeathUI] åˆæœŸåŒ–å®Œäº†")
===== ./StartPlayerScripts/BGMManager.client.lua =====
-- StarterPlayer/StarterPlayerScripts/BGMManager.client.lua
-- å¤§é™¸BGMç®¡ç†ã‚·ã‚¹ãƒ†ãƒ  (ãƒãƒˆãƒ«ä¸­ã®éŸ³é‡èª¿æ•´å¯¾å¿œç‰ˆ)

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local SoundService = game:GetService("SoundService")
local TweenService = game:GetService("TweenService") -- TweenServiceã‚’è¿½åŠ 

local player = Players.LocalPlayer

-- å¤§é™¸æƒ…å ±ã‚’èª­ã¿è¾¼ã¿
local ContinentsRegistry = require(ReplicatedStorage.Continents.Registry)
local Continents = {}
for _, continent in ipairs(ContinentsRegistry) do
	Continents[continent.name] = continent
end

-- BGMçŠ¶æ…‹
local currentBGM = nil
local currentZone = nil
local isBattleActive = false
local bgmSound = nil
local originalVolume = 0.3 -- ã€è¿½åŠ ãƒ»ä¿®æ­£1ã€‘å…ƒã®éŸ³é‡ã‚’ä¿æŒã™ã‚‹å¤‰æ•°ã‚’è¿½åŠ ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ 0.3ï¼‰

-- BGMã‚µã‚¦ãƒ³ãƒ‰ã‚’ä½œæˆ
local function createBGMSound(assetId, volume)
	if bgmSound then
		bgmSound:Stop()
		bgmSound:Destroy()
	end

	bgmSound = Instance.new("Sound")
	bgmSound.Name = "BGM"
	bgmSound.SoundId = assetId

	-- ã€ä¿®æ­£2ã€‘éŸ³é‡ã‚’è¨­å®šã—ã€originalVolumeã‚’æ›´æ–°
	local finalVolume = volume or 0.3
	bgmSound.Volume = finalVolume
	originalVolume = finalVolume -- å–å¾—ã—ãŸéŸ³é‡ã‚’ä¿å­˜

	bgmSound.Looped = true
	bgmSound.Parent = SoundService

	return bgmSound
end

-- BGMã‚’å†ç”Ÿ
local function playBGM(assetId, volume)
	if currentBGM == assetId and bgmSound and bgmSound.IsPlaying and not isBattleActive then
		-- æ—¢ã«åŒã˜BGMãŒå†ç”Ÿä¸­ã§ã€æˆ¦é—˜ä¸­ã§ãªã‘ã‚Œã°ä½•ã‚‚ã—ãªã„
		return
	end

	print(("[BGMManager] BGMå†ç”Ÿ: %s, Volume: %.2f"):format(assetId, volume or 0.3))

	currentBGM = assetId
	local sound = createBGMSound(assetId, volume)
	sound:Play()

	-- æ–°ã—ãå†ç”Ÿã™ã‚‹BGMãŒæˆ¦é—˜ä¸­ã«åˆ‡ã‚Šæ›¿ã‚ã£ãŸå ´åˆã€éŸ³é‡ã‚’ä¸‹ã’ã‚‹
	if isBattleActive and bgmSound then
		bgmSound.Volume = originalVolume * 0.3
	end
end

-- BGMã‚’åœæ­¢
local function stopBGM()
	if bgmSound then
		print("[BGMManager] BGMåœæ­¢")

        -- ã€ä¿®æ­£3ã€‘Tweenã‚’ä½¿ã£ã¦ã‚¹ãƒ ãƒ¼ã‚ºã«åœæ­¢
        TweenService:Create(bgmSound, TweenInfo.new(0.5), {
            Volume = 0
        }):Play()

        task.delay(0.5, function()
            -- 0.5ç§’å¾Œã€éŸ³é‡ãŒ0ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¦åœæ­¢ãƒ»å‰Šé™¤
            if bgmSound and bgmSound.Volume == 0 then
                bgmSound:Stop()
                bgmSound:Destroy()
                bgmSound = nil -- å‚ç…§ã‚’ã‚¯ãƒªã‚¢
            end
        end)
	end
	currentBGM = nil
end

-- ã‚¾ãƒ¼ãƒ³å¤‰æ›´æ™‚ã®BGMå‡¦ç†
local function onZoneChange(zoneName, isActive)
	if isActive then
		-- ã‚¾ãƒ¼ãƒ³ã«å…¥ã£ãŸ
		currentZone = zoneName

		-- å¤§é™¸ã®BGMè¨­å®šã‚’å–å¾—
		local continent = Continents[zoneName]
		if continent and continent.BGM then
			-- BGMVolumeã‚’playBGMã«æ¸¡ã—ã¦ã€originalVolumeã«ä¿å­˜ã•ã›ã‚‹
			playBGM(continent.BGM, continent.BGMVolume or 0.3)
		else
			-- BGMè¨­å®šãŒãªã„å ´åˆã¯åœæ­¢
			stopBGM()
		end
	else
		-- ã‚¾ãƒ¼ãƒ³ã‹ã‚‰å‡ºãŸå ´åˆã‚‚BGMã‚’åœæ­¢
		if currentZone == zoneName then
			stopBGM()
			currentZone = nil
		end
	end
end

-- ãƒãƒˆãƒ«é–‹å§‹ã‚¤ãƒ™ãƒ³ãƒˆ
local BattleStartEvent = ReplicatedStorage:WaitForChild("BattleStart", 10)
if BattleStartEvent then
	BattleStartEvent.OnClientEvent:Connect(function()
		print("[BGMManager] ãƒãƒˆãƒ«é–‹å§‹ã‚’æ¤œçŸ¥")
		isBattleActive = true

		-- ã€ä¿®æ­£4ã€‘BGMã‚’åœæ­¢ã›ãšã€éŸ³é‡ã‚’50%ã«ä¸‹ã’ã‚‹
		if bgmSound and bgmSound.IsPlaying then
			local targetVolume = originalVolume * 0.3 -- å…ƒã®éŸ³é‡ã®50%
			print(("[BGMManager] BGMéŸ³é‡ã‚’ %.2f ã‹ã‚‰ %.2f ã«èª¿æ•´"):format(bgmSound.Volume, targetVolume))
			TweenService:Create(bgmSound, TweenInfo.new(0.5), {
				Volume = targetVolume
			}):Play()
		end

	end)
end

-- ãƒãƒˆãƒ«çµ‚äº†ã‚¤ãƒ™ãƒ³ãƒˆ
local BattleEndEvent = ReplicatedStorage:WaitForChild("BattleEnd", 10)
if BattleEndEvent then
	BattleEndEvent.OnClientEvent:Connect(function()
		print("[BGMManager] ãƒãƒˆãƒ«çµ‚äº†ã‚’æ¤œçŸ¥")
		isBattleActive = false

		-- ã€ä¿®æ­£5ã€‘BGMã‚’å…ƒã®éŸ³é‡ã«æˆ»ã™
		if bgmSound and bgmSound.IsPlaying then
			print(("[BGMManager] BGMéŸ³é‡ã‚’ %.2f ã«æˆ»ã™"):format(originalVolume))
			TweenService:Create(bgmSound, TweenInfo.new(0.5), {
				Volume = originalVolume
			}):Play()
		end
	end)
end

-- ã‚¾ãƒ¼ãƒ³å¤‰æ›´ã‚’ç›£è¦–
task.spawn(function()
	local ZoneChangeEvent = ReplicatedStorage:FindFirstChild("ZoneChange")
	if not ZoneChangeEvent then
		warn("[BGMManager] ZoneChangeã‚¤ãƒ™ãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
		return
	end

	ZoneChangeEvent.OnClientEvent:Connect(function(zoneName, isActive)
		print(("[BGMManager] ã‚¾ãƒ¼ãƒ³å¤‰æ›´: %s - %s"):format(zoneName, isActive and "å…¥ã£ãŸ" or "å‡ºãŸ"))
		onZoneChange(zoneName, isActive)
	end)

	print("[BGMManager] ZoneChangeã‚¤ãƒ™ãƒ³ãƒˆæ¥ç¶šå®Œäº†")
end)

print("[BGMManager] åˆæœŸåŒ–å®Œäº†")
===== ./StartPlayerScripts/InteractionUI.client.lua =====
-- StarterPlayer/StarterPlayerScripts/InteractionUI.client.lua
-- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³æ¤œå‡ºã¨UIãƒœã‚¿ãƒ³è¡¨ç¤º

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

print("[InteractionUI] åˆæœŸåŒ–é–‹å§‹")

-- RemoteEventå–å¾—
local InteractEvent = ReplicatedStorage:WaitForChild("InteractEvent", 10)
if not InteractEvent then
	warn("[InteractionUI] InteractEventãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
	return
end

-- RemoteFunctionã§å–å¾—æ¸ˆã¿ãƒªã‚¹ãƒˆã‚’å–å¾—
local GetCollectedItemsFunc = ReplicatedStorage:FindFirstChild("GetCollectedItems")
if not GetCollectedItemsFunc then
	GetCollectedItemsFunc = Instance.new("RemoteFunction")
	GetCollectedItemsFunc.Name = "GetCollectedItems"
	GetCollectedItemsFunc.Parent = ReplicatedStorage
end

-- ç¾åœ¨ã®ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³å¯¾è±¡
local currentTarget = nil
local currentButton = nil

-- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³æ¸ˆã¿ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¨˜éŒ²
local interactedObjects = {}

-- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³UIä½œæˆ
local function createInteractionButton(targetObject, actionText, key)
	-- æ—¢å­˜ã®ãƒœã‚¿ãƒ³ã‚’å‰Šé™¤
	if currentButton then
		currentButton:Destroy()
		currentButton = nil
	end

	-- ScreenGuiã«é…ç½®ï¼ˆç”»é¢ä¸­å¤®ä¸‹éƒ¨ï¼‰
	local screenGui = playerGui:FindFirstChild("InteractionButtonGui")
	if not screenGui then
		screenGui = Instance.new("ScreenGui")
		screenGui.Name = "InteractionButtonGui"
		screenGui.ResetOnSpawn = false
		screenGui.DisplayOrder = 150
		screenGui.Parent = playerGui
	end

	-- èƒŒæ™¯ãƒ•ãƒ¬ãƒ¼ãƒ 
	local frame = Instance.new("Frame")
	frame.Name = "InteractionFrame"
	frame.Size = UDim2.new(0, 250, 0, 60)
	frame.Position = UDim2.new(0.5, -125, 0.85, 0) -- ç”»é¢ä¸‹éƒ¨ä¸­å¤®
	frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	frame.BackgroundTransparency = 0.3
	frame.BorderSizePixel = 0
	frame.Parent = screenGui

	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 12)
	corner.Parent = frame

	-- ãƒœã‚¿ãƒ³
	local button = Instance.new("TextButton")
	button.Size = UDim2.new(0.9, 0, 0.7, 0)
	button.Position = UDim2.new(0.05, 0, 0.15, 0)
	button.BackgroundColor3 = Color3.fromRGB(255, 200, 100)
	button.BackgroundTransparency = 0.2
	button.BorderSizePixel = 2
	button.BorderColor3 = Color3.new(1, 1, 1)
	button.Text = string.format("%s [%s]", actionText, key)
	button.TextColor3 = Color3.new(0, 0, 0)
	button.TextSize = 20
	button.Font = Enum.Font.SourceSansBold
	button.AutoButtonColor = true
	button.Parent = frame

	local buttonCorner = Instance.new("UICorner")
	buttonCorner.CornerRadius = UDim.new(0, 8)
	buttonCorner.Parent = button

	-- ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯
	button.MouseButton1Click:Connect(function()
		print("[InteractionUI DEBUG] ===== ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆç™ºç« =====")
		print(("[InteractionUI] ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯: %s"):format(targetObject.Name))

		-- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³æ¸ˆã¿ã«è¨˜éŒ²
		interactedObjects[targetObject] = true

		-- ã‚µãƒ¼ãƒãƒ¼ã«é€ä¿¡
		InteractEvent:FireServer(targetObject)

		-- å³åº§ã«ãƒœã‚¿ãƒ³ã‚’å‰Šé™¤
		if currentButton then
			currentButton:Destroy()
			currentButton = nil
		end
		currentTarget = nil
	end)

	-- ãƒ‡ãƒãƒƒã‚°ï¼šãƒ›ãƒãƒ¼æ¤œå‡º
	button.MouseEnter:Connect(function()
		print("[InteractionUI DEBUG] ãƒã‚¦ã‚¹ãŒãƒœã‚¿ãƒ³ã«å…¥ã£ãŸ")
		button.BackgroundTransparency = 0 -- ãƒã‚¤ãƒ©ã‚¤ãƒˆ
	end)

	button.MouseLeave:Connect(function()
		print("[InteractionUI DEBUG] ãƒã‚¦ã‚¹ãŒãƒœã‚¿ãƒ³ã‹ã‚‰å‡ºãŸ")
		button.BackgroundTransparency = 0.2
	end)

	currentButton = frame
	return frame
end

-- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³å¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ¤œå‡º
local function findNearestInteractable()
	local character = player.Character
	if not character then return nil end

	local hrp = character:FindFirstChild("HumanoidRootPart")
	if not hrp then return nil end

	local nearestObject = nil
	local nearestDistance = math.huge

	-- workspaceå†…ã®å…¨ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ãƒã‚§ãƒƒã‚¯
	for _, obj in ipairs(workspace:GetDescendants()) do
		if obj:IsA("BasePart") and obj:GetAttribute("HasInteraction") then
			-- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³æ¸ˆã¿ãªã‚‰ã‚¹ã‚­ãƒƒãƒ—
			if interactedObjects[obj] then
				continue
			end

			local distance = (hrp.Position - obj.Position).Magnitude
			local range = obj:GetAttribute("InteractionRange") or 8

			if distance <= range and distance < nearestDistance then
				nearestObject = obj
				nearestDistance = distance
			end
		end
	end

	return nearestObject
end

-- ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ—
RunService.Heartbeat:Connect(function()
	local nearest = findNearestInteractable()

	-- å¯¾è±¡ãŒå¤‰ã‚ã£ãŸå ´åˆ
	if nearest ~= currentTarget then
		-- å¤ã„ãƒœã‚¿ãƒ³ã‚’å‰Šé™¤
		if currentButton then
			currentButton:Destroy()
			currentButton = nil
		end

		currentTarget = nearest

		-- æ–°ã—ã„ãƒœã‚¿ãƒ³ã‚’ä½œæˆ
		if nearest then
			local action = nearest:GetAttribute("InteractionAction") or "èª¿ã¹ã‚‹"
			local key = nearest:GetAttribute("InteractionKey") or "E"
			createInteractionButton(nearest, action, key)

			print(("[InteractionUI] ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³å¯èƒ½: %s"):format(action))
		end
	end
end)

-- ã‚­ãƒ¼å…¥åŠ›
UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then return end

	if currentTarget and input.KeyCode == Enum.KeyCode.E then
		local action = currentTarget:GetAttribute("InteractionAction") or "èª¿ã¹ã‚‹"
		print(("[InteractionUI] Eã‚­ãƒ¼æŠ¼ä¸‹: %s"):format(action))

		-- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³æ¸ˆã¿ã«è¨˜éŒ²
		interactedObjects[currentTarget] = true

		-- ã‚µãƒ¼ãƒãƒ¼ã«é€ä¿¡
		InteractEvent:FireServer(currentTarget)

		-- å³åº§ã«ãƒœã‚¿ãƒ³ã‚’å‰Šé™¤
		if currentButton then
			currentButton:Destroy()
			currentButton = nil
		end
		currentTarget = nil
	end
end)


===== ./ServerScriptService/ZoneManager.lua =====
-- ServerScriptService/ZoneManager.lua (Islandã¨Continentã®ä¸¡æ–¹ã«å¯¾å¿œã—ãŸå®‰å®šç‰ˆ)
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local FieldGen = require(ReplicatedStorage:WaitForChild("FieldGen"))
local Players = game:GetService("Players")
local ZoneManager = {}

ZoneManager.ActiveZones = {}
ZoneManager.PlayerZones = {}

-- å³¶ã¨å¤§é™¸ã®è¨­å®šã‚’èª­ã¿è¾¼ã¿
local IslandsRegistry = require(ReplicatedStorage.Islands.Registry)
local ContinentsRegistry = require(ReplicatedStorage.Continents.Registry)

-- å³¶ã®è¨­å®šã‚’ãƒãƒƒãƒ—åŒ–
local Islands = {}
for _, island in ipairs(IslandsRegistry) do
    Islands[island.name] = island
end

-- å¤§é™¸ã®è¨­å®šã‚’ãƒãƒƒãƒ—åŒ–
local Continents = {}
for _, continent in ipairs(ContinentsRegistry) do
    if continent and continent.name then
        Continents[continent.name] = continent
    else
        warn("[ZoneManager] åå‰ãŒè¨­å®šã•ã‚Œã¦ã„ãªã„å¤§é™¸å®šç¾©ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã—ãŸ")
    end
end

print("[ZoneManager] åˆæœŸåŒ–å®Œäº†ã€‚å³¶æ•°:", #IslandsRegistry, "å¤§é™¸æ•°:", #ContinentsRegistry)

-- ZoneChangeã‚¤ãƒ™ãƒ³ãƒˆã‚’ä½œæˆï¼ˆã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¸ã®é€šçŸ¥ç”¨ï¼‰
local ZoneChangeEvent = ReplicatedStorage:FindFirstChild("ZoneChange")
if not ZoneChangeEvent then
    ZoneChangeEvent = Instance.new("RemoteEvent")
    ZoneChangeEvent.Name = "ZoneChange"
    ZoneChangeEvent.Parent = ReplicatedStorage
    print("[ZoneManager] ZoneChangeã‚¤ãƒ™ãƒ³ãƒˆã‚’ä½œæˆã—ã¾ã—ãŸ")
end

-- ã‚¾ãƒ¼ãƒ³ãŒå¤§é™¸ã‹ãƒã‚§ãƒƒã‚¯
local function isContinent(zoneName)
    return Continents[zoneName] ~= nil
end

-- ã‚¾ãƒ¼ãƒ³ãŒå³¶ã‹ãƒã‚§ãƒƒã‚¯ (TownãŒå¤§é™¸åŒ–ã•ã‚ŒãŸãŸã‚ã€ã“ã®é–¢æ•°ã¯å®Ÿè³ªæœªä½¿ç”¨ã«)
local function isIsland(zoneName)
    return Islands[zoneName] ~= nil and not isContinent(zoneName)
end

-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¾ãƒ¼ãƒ³ã‚’æ›´æ–° (ãƒ¯ãƒ¼ãƒ—ãƒãƒ¼ã‚¿ãƒ«ã§ä½¿ç”¨)
local function updatePlayerZone(player, newZone)
    local oldZone = ZoneManager.PlayerZones[player]

    if oldZone == newZone then
        return
    end

    -- å¤ã„ã‚¾ãƒ¼ãƒ³ã‹ã‚‰å‡ºãŸ
    if oldZone then
        print(("[ZoneManager] %s ãŒ %s ã‹ã‚‰å‡ºã¾ã—ãŸ"):format(player.Name, oldZone))
        ZoneChangeEvent:FireClient(player, oldZone, false)
    end

    -- æ–°ã—ã„ã‚¾ãƒ¼ãƒ³ã«å…¥ã£ãŸ
    if newZone then
        print(("[ZoneManager] %s ãŒ %s ã«å…¥ã‚Šã¾ã—ãŸ"):format(player.Name, newZone))
        ZoneManager.PlayerZones[player] = newZone
        ZoneChangeEvent:FireClient(player, newZone, true)
    else
        ZoneManager.PlayerZones[player] = nil
    end
end

-- å¤§é™¸ã‚’ãƒ­ãƒ¼ãƒ‰ï¼ˆè¤‡æ•°ã®å³¶ã¨æ©‹ã‚’ç”Ÿæˆï¼‰
local function loadContinent(continentName)
    local continent = Continents[continentName]
    if not continent then
        warn(("[ZoneManager] å¤§é™¸ '%s' ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"):format(continentName))
        return false
    end

    print(("[ZoneManager] å¤§é™¸ç”Ÿæˆé–‹å§‹: %s"):format(continentName))

    -- å«ã¾ã‚Œã‚‹å…¨ã¦ã®å³¶ã‚’ç”Ÿæˆ
    for _, islandName in ipairs(continent.islands) do
        local islandConfig = Islands[islandName]
        if islandConfig then
            print(("[ZoneManager]   - å³¶ã‚’ç”Ÿæˆ: %s"):format(islandName))
            FieldGen.generateIsland(islandConfig)
        else
            warn(("[ZoneManager]   - å³¶ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: %s (Island/Registryã‚’ç¢ºèªã—ã¦ãã ã•ã„)"):format(islandName))
        end
    end

    -- æ©‹ã‚’ç”Ÿæˆ
    if continent.bridges then
        for _, bridgeConfig in ipairs(continent.bridges) do
            local fromIsland = Islands[bridgeConfig.fromIsland]
            local toIsland = Islands[bridgeConfig.toIsland]

            if fromIsland and toIsland then
                print(("[ZoneManager]   - æ©‹ã‚’ç”Ÿæˆ: %s"):format(bridgeConfig.name))
                FieldGen.generateBridge(fromIsland, toIsland, bridgeConfig)
            else
                warn(("[ZoneManager]   - æ©‹ã®ç”Ÿæˆå¤±æ•—: %s"):format(bridgeConfig.name))
            end
        end
    end

    ZoneManager.ActiveZones[continentName] = {
        config = continent,
        loadedAt = os.time(),
    }

    local RS = game:GetService("ReplicatedStorage")
    local FieldGen = require(RS:WaitForChild("FieldGen"))

    if continent.fieldObjects and #continent.fieldObjects > 0 then
        print(("[ZoneManager] è¿½åŠ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’é…ç½®: %d å€‹"):format(#continent.fieldObjects))
        FieldGen.placeFieldObjects(continent.name, continent.fieldObjects)  -- playerå¼•æ•°ãªã—
    end

    local RS = game:GetService("ReplicatedStorage")
    local FieldGen = require(RS:WaitForChild("FieldGen"))

    -- â€¦å¤§é™¸ãƒ»å³¶ã‚’ç”Ÿæˆã—çµ‚ã‚ã£ãŸã‚ã¨
    if continent.paths and #continent.paths > 0 then
        FieldGen.buildPaths(continent.name, continent.paths)
    end

        print(("[ZoneManager] å¤§é™¸ç”Ÿæˆå®Œäº†: %s"):format(continentName))
        return true
    end


-- ã‚¾ãƒ¼ãƒ³ã‚’ãƒ­ãƒ¼ãƒ‰ï¼ˆå³¶ã¾ãŸã¯å¤§é™¸ã‚’ãƒ­ãƒ¼ãƒ‰ï¼‰
function ZoneManager.LoadZone(zoneName)
    if ZoneManager.ActiveZones[zoneName] then
        print(("[ZoneManager] %s ã¯æ—¢ã«ç”Ÿæˆæ¸ˆã¿ã§ã™"):format(zoneName))
        return true
    end

    if isContinent(zoneName) then
        return loadContinent(zoneName)
    else
        -- â˜…ä¿®æ­£: å˜ä¸€ã®å³¶ã‚’ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ãƒ­ã‚¸ãƒƒã‚¯ã‚’å‰Šé™¤ã€‚ã™ã¹ã¦å¤§é™¸çµŒç”±ã§ãƒ­ãƒ¼ãƒ‰ã€‚
        warn(("[ZoneManager] ã‚¾ãƒ¼ãƒ³ '%s' ã¯å¤§é™¸ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ãƒ­ãƒ¼ãƒ‰ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã—ãŸã€‚"):format(zoneName))
        return false
    end
end

-- ã‚¾ãƒ¼ãƒ³ã‚’ã‚¢ãƒ³ãƒ­ãƒ¼ãƒ‰ï¼ˆçœç•¥ï¼‰
function ZoneManager.UnloadZone(zoneName)
    if not ZoneManager.ActiveZones[zoneName] then
        return
    end

    print(("[ZoneManager] ã‚¾ãƒ¼ãƒ³å‰Šé™¤é–‹å§‹: %s"):format(zoneName))

    local terrain = workspace.Terrain
    local configsToUnload = {}

    -- â˜…ä¿®æ­£: å¤§é™¸ã¨ã—ã¦ã®ã¿å‡¦ç†
    if isContinent(zoneName) then
        -- å¤§é™¸ã®å ´åˆã¯å«ã¾ã‚Œã‚‹å…¨ã¦ã®å³¶ã‚’å‰Šé™¤
        local continent = Continents[zoneName]
        for _, islandName in ipairs(continent.islands) do
            table.insert(configsToUnload, Islands[islandName])
        end
    else
         -- â˜…ä¿®æ­£: å¤§é™¸ã§ãªã„ã‚¾ãƒ¼ãƒ³ã¯ã‚¢ãƒ³ãƒ­ãƒ¼ãƒ‰ã§ããªã„
         warn(("[ZoneManager] ã‚¾ãƒ¼ãƒ³ '%s' ã¯å¤§é™¸ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã‚¢ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã—ãŸã€‚"):format(zoneName))
         return
    end

    -- å„å³¶ã®åœ°å½¢ã‚’å‰Šé™¤
    for _, config in ipairs(configsToUnload) do
        if config then
            local halfSize = config.sizeXZ / 2 + 50
            local region = Region3.new(
                Vector3.new(config.centerX - halfSize, config.baseY - 50, config.centerZ - halfSize),
                Vector3.new(config.centerX + halfSize, config.baseY + 100, config.centerZ + halfSize)
            )
            region = region:ExpandToGrid(4)
            terrain:FillRegion(region, 4, Enum.Material.Air)

            -- ãƒãƒ¼ã‚«å‰Šé™¤ã¯ FieldGen.lua ã§è¡Œã†ãŸã‚ZoneManagerã‹ã‚‰ã¯å‰Šé™¤
        end
    end

    -- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼å‰Šé™¤
    for _, model in ipairs(workspace:GetChildren()) do
        if model:IsA("Model") and model:GetAttribute("IsEnemy") then
            local spawnZone = model:GetAttribute("SpawnZone")
            if spawnZone == zoneName then
                model:Destroy()
            end
        end
    end

    ZoneManager.ActiveZones[zoneName] = nil
    print(("[ZoneManager] ã‚¾ãƒ¼ãƒ³å‰Šé™¤å®Œäº†: %s"):format(zoneName))
end


-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ãƒ¯ãƒ¼ãƒ—
function ZoneManager.WarpPlayerToZone(player, zoneName)
    print(("[ZoneManager] %s ã‚’ %s ã«ãƒ¯ãƒ¼ãƒ—ä¸­..."):format(player.Name, zoneName))

    -- ãƒ¯ãƒ¼ãƒ—å…ˆã«åœ°å½¢ãŒãªã„å ´åˆã¯ãƒ­ãƒ¼ãƒ‰
    ZoneManager.LoadZone(zoneName)

    local character = player.Character
    if not character then
        warn(("[ZoneManager] %s ã®ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"):format(player.Name))
        return false
    end

    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end

    -- ãƒ¯ãƒ¼ãƒ—å…ˆã®åº§æ¨™ã‚’æ±ºå®š (å¸¸ã«å¤§é™¸ã®æœ€åˆã®å³¶ã‚’å‚ç…§ã™ã‚‹ã‚ˆã†ã«çµ±ä¸€)
    local targetX, targetZ, baseY, hillAmplitude

    if isContinent(zoneName) then
        -- å¤§é™¸ã®å ´åˆï¼ˆTownã‚‚å«ã‚€ï¼‰
        local continent = Continents[zoneName]
        local firstIslandName = continent.islands[1]
        local firstIsland = Islands[firstIslandName]

        if not firstIsland then
             warn(("[ZoneManager] å¤§é™¸ '%s' ã®æœ€åˆã®å³¶ '%s' ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚"):format(zoneName, firstIslandName))
             return false
        end

        targetX = firstIsland.centerX
        targetZ = firstIsland.centerZ
        baseY = firstIsland.baseY
        hillAmplitude = firstIsland.hillAmplitude or 20
    else
        -- â˜…ä¿®æ­£: å³¶å˜ç‹¬ã§ã®ãƒ¯ãƒ¼ãƒ—ã¯ã‚¨ãƒ©ãƒ¼ã¨ã™ã‚‹
        warn(("[ZoneManager] ã‚¾ãƒ¼ãƒ³ '%s' ã¯å¤§é™¸ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ãƒ¯ãƒ¼ãƒ—ã§ãã¾ã›ã‚“ã€‚"):format(zoneName))
        return false
    end

    -- ååˆ†ã«é«˜ã„ä½ç½®ã‹ã‚‰ãƒ¬ã‚¤ã‚­ãƒ£ã‚¹ãƒˆ
    local FieldGen = require(ReplicatedStorage:WaitForChild("FieldGen"))
    local rayStartY = baseY + hillAmplitude + 100
    local groundY = FieldGen.raycastGroundY(targetX, targetZ, rayStartY)

    local spawnY
    if groundY then
        spawnY = groundY + 5
        print(("[ZoneManager] åœ°é¢æ¤œå‡ºæˆåŠŸ: Y=%.1f"):format(groundY))
    else
        -- å®‰å…¨ãªé«˜åº¦ï¼šbaseY + hillAmplitude * 0.6 + 10 ã«å›ºå®š
        spawnY = baseY + (hillAmplitude * 0.6) + 10
        warn(("[ZoneManager] åœ°é¢æ¤œå‡ºå¤±æ•—ã€äºˆæƒ³é«˜åº¦ä½¿ç”¨: Y=%.1f"):format(spawnY))
    end

    hrp.CFrame = CFrame.new(targetX, spawnY, targetZ)

    updatePlayerZone(player, zoneName)

    print(("[ZoneManager] %s ã‚’ %s ã«ãƒ¯ãƒ¼ãƒ—å®Œäº† (%.1f, %.1f, %.1f)"):format(
        player.Name, zoneName, targetX, spawnY, targetZ
        ))
    return true
end

function ZoneManager.GetPlayerZone(player)
    return ZoneManager.PlayerZones[player]
end

-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒé€€å‡ºã—ãŸæ™‚ã®å‡¦ç† (çœç•¥)
Players.PlayerRemoving:Connect(function(player)
    local oldZone = ZoneManager.PlayerZones[player]
    if oldZone then
        print(("[ZoneManager] %s ãŒé€€å‡ºã—ã¾ã—ãŸã€‚ã‚¾ãƒ¼ãƒ³: %s"):format(player.Name, oldZone))
        ZoneManager.PlayerZones[player] = nil
    end
end)

return ZoneManager
===== ./ServerScriptService/FastTravelSystem.server.lua =====
-- ServerScriptService/FastTravelSystem.server.lua
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")

print("[FastTravel] åˆæœŸåŒ–é–‹å§‹")

-- ä¾å­˜ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
local ContinentsRegistry = require(ReplicatedStorage:WaitForChild("Continents"):WaitForChild("Registry"))
local IslandsRegistry = require(ReplicatedStorage:WaitForChild("Islands"):WaitForChild("Registry"))
local ZoneManager = require(ServerScriptService:WaitForChild("ZoneManager"))

-- ã€è¿½åŠ ã€‘IslandsRegistryã‚’è¾æ›¸å½¢å¼ã«å¤‰æ›
local Islands = {}
for _, island in ipairs(IslandsRegistry) do
	if island and island.name then
		Islands[island.name] = island
	end
end

-- RemoteEventä½œæˆ
local FastTravelEvent = ReplicatedStorage:FindFirstChild("FastTravelEvent")
if not FastTravelEvent then
	FastTravelEvent = Instance.new("RemoteEvent")
	FastTravelEvent.Name = "FastTravelEvent"
	FastTravelEvent.Parent = ReplicatedStorage
end

local GetContinentsEvent = ReplicatedStorage:FindFirstChild("GetContinentsEvent")
if not GetContinentsEvent then
	GetContinentsEvent = Instance.new("RemoteFunction")
	GetContinentsEvent.Name = "GetContinentsEvent"
	GetContinentsEvent.Parent = ReplicatedStorage
end

-- å¤§é™¸ä¸€è¦§ã‚’å–å¾—
local function getContinentsList()
	local continents = {}

	for _, continent in ipairs(ContinentsRegistry) do
		table.insert(continents, {
			name = continent.name,
			displayName = continent.displayName or continent.name
		})
	end

	return continents
end

-- ãƒ¯ãƒ¼ãƒ—å‡¦ç†
local function handleFastTravel(player, continentName)
	print(("[FastTravel] %s ãŒ %s ã¸ã®ãƒ¯ãƒ¼ãƒ—ã‚’è¦æ±‚"):format(player.Name, continentName))

	-- å¤§é™¸æƒ…å ±ã‚’å–å¾—
	local continent = nil
	for _, cont in ipairs(ContinentsRegistry) do
		if cont.name == continentName then
			continent = cont
			break
		end
	end

	if not continent then
		warn(("[FastTravel] å¤§é™¸ '%s' ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"):format(continentName))
		return false
	end

	-- æœ€åˆã®å³¶ã‚’å–å¾—
	local firstIslandName = continent.islands[1]
	if not firstIslandName then
		warn(("[FastTravel] å¤§é™¸ '%s' ã«å³¶ãŒã‚ã‚Šã¾ã›ã‚“"):format(continentName))
		return false
	end

	-- è¾æ›¸ã‹ã‚‰å³¶ã‚’å–å¾—
	local island = Islands[firstIslandName]
	if not island then
		warn(("[FastTravel] å³¶ '%s' ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"):format(firstIslandName))
		return false
	end

	-- ãƒ¯ãƒ¼ãƒ—å®Ÿè¡Œ
	local success = ZoneManager.WarpPlayerToZone(
		player,
		continentName,
		island.centerX,
		island.baseY + 25,
		island.centerZ,
		true
	)

	if success then
		print(("[FastTravel] %s ã‚’ %s ã«ãƒ¯ãƒ¼ãƒ—ã—ã¾ã—ãŸ"):format(player.Name, continentName))

		-- ã€è¿½åŠ ã€‘ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã¨ãƒãƒ¼ã‚¿ãƒ«ã‚’ç”Ÿæˆ
		task.spawn(function()
			task.wait(1) -- ã‚¾ãƒ¼ãƒ³ãƒ­ãƒ¼ãƒ‰å®Œäº†ã‚’å¾…ã¤

			-- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ç”Ÿæˆ
			if _G.SpawnMonstersForZone then
				_G.SpawnMonstersForZone(continentName)
				print(("[FastTravel] %s ã®ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’ç”Ÿæˆã—ã¾ã—ãŸ"):format(continentName))
			else
				warn("[FastTravel] SpawnMonstersForZone ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
			end

			-- ãƒãƒ¼ã‚¿ãƒ«ç”Ÿæˆ
			if _G.CreatePortalsForZone then
				_G.CreatePortalsForZone(continentName)
				print(("[FastTravel] %s ã®ãƒãƒ¼ã‚¿ãƒ«ã‚’ç”Ÿæˆã—ã¾ã—ãŸ"):format(continentName))
			else
				warn("[FastTravel] CreatePortalsForZone ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
			end
		end)
	else
		warn(("[FastTravel] %s ã®ãƒ¯ãƒ¼ãƒ—ã«å¤±æ•—ã—ã¾ã—ãŸ"):format(player.Name))
	end

	return success
end

-- ã‚¤ãƒ™ãƒ³ãƒˆæ¥ç¶š
GetContinentsEvent.OnServerInvoke = function(player)
	return getContinentsList()
end

FastTravelEvent.OnServerEvent:Connect(function(player, continentName)
	handleFastTravel(player, continentName)
end)

print("[FastTravel] åˆæœŸåŒ–å®Œäº†")
===== ./ServerScriptService/PlayerStats.lua =====
-- ServerScriptService/PlayerStats.lua
-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’ç®¡ç†ã™ã‚‹ModuleScript
-- ã‚¹ãƒ†ãƒƒãƒ—2: SharedState/GameEventsçµ±åˆç‰ˆ

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- ã€ã‚¹ãƒ†ãƒƒãƒ—2ã€‘SharedStateã¨GameEventsã‚’ãƒ­ãƒ¼ãƒ‰
local SharedState = require(ReplicatedStorage:WaitForChild("SharedState"))
local GameEvents = require(ReplicatedStorage:WaitForChild("GameEvents"))

local DataStoreManager = require(script.Parent:WaitForChild("DataStoreManager"))

local PlayerStats = {}
local LoadedDataCache = {}

-- RemoteEventã‚’å–å¾—ã™ã‚‹é–¢æ•°
local function getRemoteEvent(name)
	return ReplicatedStorage:WaitForChild(name, 10)
end

-- ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
local DEFAULT_STATS = {
	Level = 1,
	Experience = 0,
	Gold = 100,  -- åˆæœŸã‚´ãƒ¼ãƒ«ãƒ‰100G

	MaxHP = 100,
	CurrentHP = 100,

	Speed = 10,      -- ç´ æ—©ã•
	Attack = 10,     -- æ”»æ’ƒåŠ›
	Defense = 10,    -- å®ˆå‚™åŠ›
	MonstersDefeated = 0,


	MonsterCounts = {}, 	-- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚«ã‚¦ãƒ³ãƒˆè¿½åŠ 
	CollectedItems = {},	-- å–å¾—æ¸ˆã¿ã‚¢ã‚¤ãƒ†ãƒ 
}

-- ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ã«å¿…è¦ãªçµŒé¨“å€¤ï¼ˆãƒ¬ãƒ™ãƒ« * 100)
local function getRequiredExp(level)
	return level * 100
end

-- å„ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’ä¿å­˜
local PlayerData = {}

-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’åˆæœŸåŒ–
function PlayerStats.initPlayer(player: Player)
	if PlayerData[player] then
		warn(("[PlayerStats] %s ã¯æ—¢ã«åˆæœŸåŒ–æ¸ˆã¿ã§ã™"):format(player.Name))
        -- æ—¢ã«åˆæœŸåŒ–æ¸ˆã¿ã®å ´åˆã¯Locationã‚’è¿”å´
        return PlayerData[player].Location or {
            ZoneName = "ContinentTown", X = DEFAULT_STATS.MaxHP, Y = DEFAULT_STATS.MaxHP, Z = DEFAULT_STATS.MaxHP
        }
	end

	-- ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã§ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’ä½œæˆ
	local stats = {}
	for key, value in pairs(DEFAULT_STATS) do
		stats[key] = value
	end

	-- â˜…DataStoreã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ­ãƒ¼ãƒ‰ï¼ˆãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ï¼‰
	local loadedData = DataStoreManager.LoadData(player)
	LoadedDataCache[player] = loadedData

	local loadedLocation = nil

	if loadedData and loadedData.PlayerState then
		local playerState = loadedData.PlayerState

		-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’é©ç”¨
		for key, value in pairs(playerState.Stats) do
			if stats[key] ~= nil then
				stats[key] = value
			end
		end

		-- Locationã‚’é©ç”¨
		if playerState.Location then
			loadedLocation = playerState.Location
			print(("[PlayerStats] %s ã®ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ã‚’é©ç”¨ã—ã¾ã—ãŸ: %s (%.0f, %.0f, %.0f)"):format(
				player.Name,
				loadedLocation.ZoneName,
				loadedLocation.X,
				loadedLocation.Y,
				loadedLocation.Z
			))
		end

		 stats.CollectedItems = loadedData.CollectedItems or {}

		print(("[PlayerStats] %s ã®å–å¾—æ¸ˆã¿ã‚¢ã‚¤ãƒ†ãƒ æ•°: %d"):format(
			player.Name,
			next(stats.CollectedItems) and #stats.CollectedItems or 0
		))
	else
		print(("[PlayerStats] %s ã®æ–°è¦ãƒ‡ãƒ¼ã‚¿ã€ã¾ãŸã¯ãƒ­ãƒ¼ãƒ‰å¤±æ•—ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ä½¿ç”¨ï¼‰"):format(player.Name))
	end

	PlayerData[player] = stats
	print(("[PlayerStats] %s ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’åˆæœŸåŒ–ã—ã¾ã—ãŸï¼ˆDataStoreé©ç”¨å¾Œï¼‰"):format(player.Name))

	-- ã€ã‚¹ãƒ†ãƒƒãƒ—2ã€‘SharedStateã«ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¾ãƒ¼ãƒ³ã‚’åˆæœŸåŒ–
	SharedState.PlayerZones[player] = nil
	-- â˜…ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸLocationæƒ…å ±ã‚’è¿”ã™
	return loadedLocation
end

function PlayerStats.getLastLoadedData(player: Player)
    return LoadedDataCache[player]
end

-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’å–å¾—
function PlayerStats.getStats(player: Player)
	return PlayerData[player]
end

-- ç‰¹å®šã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’å–å¾—
function PlayerStats.getStat(player: Player, statName: string)
	local stats = PlayerData[player]
	if not stats then
		warn(("[PlayerStats] %s ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"):format(player.Name))
		return nil
	end
	return stats[statName]
end

-- ç‰¹å®šã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’è¨­å®š
function PlayerStats.setStat(player: Player, statName: string, value)
	local stats = PlayerData[player]
	if not stats then
		warn(("[PlayerStats] %s ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"):format(player.Name))
		return
	end

	stats[statName] = value
	print(("[PlayerStats] %s ã® %s ã‚’ %s ã«è¨­å®š"):format(player.Name, statName, tostring(value)))
end

-- HPã‚’å›å¾©
function PlayerStats.healHP(player: Player, amount: number)
	local stats = PlayerData[player]
	if not stats then return end

	stats.CurrentHP = math.min(stats.CurrentHP + amount, stats.MaxHP)
	print(("[PlayerStats] %s ã®HPã‚’ %d å›å¾©ï¼ˆç¾åœ¨: %d/%d)"):format(
		player.Name, amount, stats.CurrentHP, stats.MaxHP
		))
end

-- HPã‚’å…¨å›å¾©
function PlayerStats.fullHeal(player: Player)
	local stats = PlayerData[player]
	if not stats then return end

	stats.CurrentHP = stats.MaxHP
	print(("[PlayerStats] %s ã®HPã‚’å…¨å›å¾©"):format(player.Name))
end

-- ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ã‚‹
function PlayerStats.takeDamage(player: Player, damage: number): boolean
	local stats = PlayerData[player]
	if not stats then return false end

	stats.CurrentHP = math.max(0, stats.CurrentHP - damage)
	print(("[PlayerStats] %s ãŒ %d ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ãŸï¼ˆæ®‹ã‚ŠHP: %d/%d)"):format(
		player.Name, damage, stats.CurrentHP, stats.MaxHP
		))

	-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°ã‚’é€ä¿¡
	local StatusUpdateEvent = getRemoteEvent("StatusUpdate")
	if StatusUpdateEvent then
		local expToNext = getRequiredExp(stats.Level)
		StatusUpdateEvent:FireClient(
			player,
			stats.CurrentHP,
			stats.MaxHP,
			stats.Level,
			stats.Experience,
			expToNext,
			stats.Gold
		)
	end

	-- æ­»äº¡åˆ¤å®š
	if stats.CurrentHP <= 0 then
		print(("[PlayerStats] %s ã¯å€’ã‚ŒãŸï¼"):format(player.Name))
		return true  -- æ­»äº¡
	end

	return false  -- ç”Ÿå­˜
end

-- çµŒé¨“å€¤ã‚’è¿½åŠ 
function PlayerStats.addExperience(player: Player, exp: number)
	local stats = PlayerData[player]
	if not stats then return end

	stats.Experience = stats.Experience + exp
	print(("[PlayerStats] %s ãŒçµŒé¨“å€¤ %d ã‚’ç²å¾—ï¼ˆåˆè¨ˆ: %d)"):format(
		player.Name, exp, stats.Experience
		))

	-- ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ãƒã‚§ãƒƒã‚¯
	local requiredExp = getRequiredExp(stats.Level)
	while stats.Experience >= requiredExp do
		PlayerStats.levelUp(player)
		requiredExp = getRequiredExp(stats.Level)
	end

	-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°ã‚’é€ä¿¡
	local StatusUpdateEvent = getRemoteEvent("StatusUpdate")
	if StatusUpdateEvent then
		local expToNext = getRequiredExp(stats.Level)
		StatusUpdateEvent:FireClient(
			player,
			stats.CurrentHP,
			stats.MaxHP,
			stats.Level,
			stats.Experience,
			expToNext,
			stats.Gold
		)
	end
end

-- ã‚´ãƒ¼ãƒ«ãƒ‰ã‚’è¿½åŠ 
function PlayerStats.addGold(player: Player, gold: number)
	local stats = PlayerData[player]
	if not stats then return end

	stats.Gold = stats.Gold + gold
	print(("[PlayerStats] %s ãŒã‚´ãƒ¼ãƒ«ãƒ‰ %d ã‚’ç²å¾—ï¼ˆåˆè¨ˆ: %d)"):format(
		player.Name, gold, stats.Gold
		))

	-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°ã‚’é€ä¿¡
	local StatusUpdateEvent = getRemoteEvent("StatusUpdate")
	if StatusUpdateEvent then
		local expToNext = getRequiredExp(stats.Level)
		StatusUpdateEvent:FireClient(
			player,
			stats.CurrentHP,
			stats.MaxHP,
			stats.Level,
			stats.Experience,
			expToNext,
			stats.Gold
		)
	end
end

-- ã‚´ãƒ¼ãƒ«ãƒ‰ã‚’æ¸›ã‚‰ã™
function PlayerStats.removeGold(player: Player, gold: number): boolean
	local stats = PlayerData[player]
	if not stats then return false end

	if stats.Gold < gold then
		print(("[PlayerStats] %s ã®ã‚´ãƒ¼ãƒ«ãƒ‰ãŒä¸è¶³ã—ã¦ã„ã¾ã™"):format(player.Name))
		return false
	end

	stats.Gold = stats.Gold - gold
	print(("[PlayerStats] %s ãŒã‚´ãƒ¼ãƒ«ãƒ‰ %d ã‚’å¤±ã£ãŸï¼ˆæ®‹ã‚Š: %d)"):format(
		player.Name, gold, stats.Gold
		))
	return true
end

-- å€’ã—ãŸãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æ•°ã‚’è¿½åŠ 
function PlayerStats.addMonstersDefeated(player: Player, count: number)
	print(("[PlayerStats] ========================================"):format())
	print(("[PlayerStats] addMonstersDefeated å‘¼ã³å‡ºã—"):format())
	print(("  ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼: %s"):format(player.Name))
	print(("  è¿½åŠ æ•°: %d"):format(count or 1))

	local stats = PlayerData[player]
	if not stats then
		warn(("[PlayerStats] âŒ %s ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ï¼ˆãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚«ã‚¦ãƒ³ãƒˆå¤±æ•—)"):format(player.Name))
		print(("[PlayerStats] ========================================"):format())
		return
	end

	local oldCount = stats.MonstersDefeated
	count = count or 1
	stats.MonstersDefeated = stats.MonstersDefeated + count

	print(("  å¤‰æ›´å‰: %d"):format(oldCount))
	print(("  å¤‰æ›´å¾Œ: %d"):format(stats.MonstersDefeated))
	print(("[PlayerStats] âœ… ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æ’ƒç ´æ•°æ›´æ–°æˆåŠŸ"):format())
	print(("[PlayerStats] ========================================"):format())
end

-- ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—
function PlayerStats.levelUp(player: Player)
	local stats = PlayerData[player]
	if not stats then return end

	local oldLevel = stats.Level
	stats.Level = stats.Level + 1

	-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚¢ãƒƒãƒ—
	stats.MaxHP = stats.MaxHP + 10
	stats.CurrentHP = stats.MaxHP  -- å…¨å›å¾©
	stats.Speed = stats.Speed + 2
	stats.Attack = stats.Attack + 2
	stats.Defense = stats.Defense + 2

	print(("[PlayerStats] ğŸ‰ %s ãŒãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ï¼ %d â†’ %d"):format(
		player.Name, oldLevel, stats.Level
		))
	print(("  HP: %d, ç´ æ—©ã•: %d, æ”»æ’ƒ: %d, å®ˆå‚™: %d"):format(
		stats.MaxHP, stats.Speed, stats.Attack, stats.Defense
		))

	-- ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—æ¼”å‡ºã‚’é€šçŸ¥
	local LevelUpEvent = getRemoteEvent("LevelUp")
	if LevelUpEvent then
		LevelUpEvent:FireClient(player, stats.Level, stats.MaxHP, stats.Speed, stats.Attack, stats.Defense)
	end

	-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°ã‚’é€ä¿¡
	local StatusUpdateEvent = getRemoteEvent("StatusUpdate")
	if StatusUpdateEvent then
		local expToNext = stats.Level * 100
		StatusUpdateEvent:FireClient(
			player,
			stats.CurrentHP,
			stats.MaxHP,
			stats.Level,
			stats.Experience,
			expToNext,
			stats.Gold
		)
	end
end

-- ã€ã‚¹ãƒ†ãƒƒãƒ—2ã€‘ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚«ã‚¦ãƒ³ãƒˆã‚’æ›´æ–°
function PlayerStats.updateMonsterCounts(player: Player, zoneName: string)
	local stats = PlayerData[player]
	if not stats then return end

	-- SharedStateã‹ã‚‰æœ€æ–°ã®ã‚«ã‚¦ãƒ³ãƒˆã‚’å–å¾—
	if SharedState.MonsterCounts[zoneName] then
		stats.MonsterCounts[zoneName] = SharedState.MonsterCounts[zoneName]
		print(("[PlayerStats] %s ã®ã‚¾ãƒ¼ãƒ³ %s ã®ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚«ã‚¦ãƒ³ãƒˆã‚’æ›´æ–°"):format(
			player.Name, zoneName
		))
	end
end

-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒé€€å‡ºã—ãŸã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¯ãƒªã‚¢
function PlayerStats.removePlayer(player: Player)
    PlayerData[player] = nil
    LoadedDataCache[player] = nil -- ã€è¿½åŠ ã€‘
    SharedState.PlayerZones[player] = nil
    print(("[PlayerStats] %s ã®ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã—ã¾ã—ãŸ"):format(player.Name))
end

-- åˆæœŸåŒ–
function PlayerStats.init()
	-- æ—¢å­˜ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’åˆæœŸåŒ–
	for _, player in ipairs(Players:GetPlayers()) do
		PlayerStats.initPlayer(player)
	end

	-- æ–°è¦å‚åŠ ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’åˆæœŸåŒ–
	Players.PlayerAdded:Connect(function(player)
		PlayerStats.initPlayer(player)
	end)

	-- é€€å‡ºæ™‚ã«ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¯ãƒªã‚¢
	Players.PlayerRemoving:Connect(function(player)
		PlayerStats.removePlayer(player)
	end)

	-- è©³ç´°ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒªã‚¯ã‚¨ã‚¹ãƒˆç”¨RemoteEvent
	local RequestStatsDetailEvent = ReplicatedStorage:FindFirstChild("RequestStatsDetail")
	if not RequestStatsDetailEvent then
		RequestStatsDetailEvent = Instance.new("RemoteEvent")
		RequestStatsDetailEvent.Name = "RequestStatsDetail"
		RequestStatsDetailEvent.Parent = ReplicatedStorage
	end

	RequestStatsDetailEvent.OnServerEvent:Connect(function(player)
		local stats = PlayerStats.getStats(player)
		if stats then
			-- StatsDetailEventã‚’å–å¾—ã¾ãŸã¯ä½œæˆ
			local StatsDetailEvent = ReplicatedStorage:FindFirstChild("StatsDetail")
			if not StatsDetailEvent then
				StatsDetailEvent = Instance.new("RemoteEvent")
				StatsDetailEvent.Name = "StatsDetail"
				StatsDetailEvent.Parent = ReplicatedStorage
				print("[PlayerStats] StatsDetailã‚¤ãƒ™ãƒ³ãƒˆã‚’ä½œæˆã—ã¾ã—ãŸ")
			end

			print(("[PlayerStats] è©³ç´°ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’é€ä¿¡: MonstersDefeated=%d"):format(stats.MonstersDefeated or 0))
			StatsDetailEvent:FireClient(player, stats)
		end
	end)

	print("[PlayerStats] åˆæœŸåŒ–å®Œäº†ï¼ˆã‚¹ãƒ†ãƒƒãƒ—2: SharedStateçµ±åˆç‰ˆï¼‰")
end

return PlayerStats
===== ./ServerScriptService/Bootstrap.server.lua =====
-- ServerScriptService/Bootstrap.server.lua
-- ã‚²ãƒ¼ãƒ åˆæœŸåŒ–ã‚¹ã‚¯ãƒªãƒ—ãƒˆï¼ˆæœ€çµ‚å®‰å®šç‰ˆ - DataStoreãƒ­ãƒ¼ãƒ‰å®‰å®šåŒ–ï¼‰

local ServerScriptService = game:GetService("ServerScriptService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

print("[Bootstrap] === ã‚²ãƒ¼ãƒ åˆæœŸåŒ–é–‹å§‹ (æœ€çµ‚å®‰å®šç‰ˆ) ===")

-- ZoneManagerã‚’èª­ã¿è¾¼ã¿ï¼ˆServerScriptServiceã®å…„å¼Ÿãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ï¼‰
local ZoneManager = require(script.Parent:WaitForChild("ZoneManager"))

-- PlayerStatsã®ModuleScriptã®å®Ÿè¡Œçµæœã‚’ãƒ­ãƒ¼ãƒ‰ï¼ˆServerScriptServiceã®å…„å¼Ÿãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ï¼‰
local PlayerStatsModule = require(script.Parent:WaitForChild("PlayerStats"))
local DataCollectors = require(script.Parent:WaitForChild("DataCollectors"))

local START_ZONE_NAME = "ContinentTown"
local LOAD_TIMEOUT = 10 -- DataStoreãƒ­ãƒ¼ãƒ‰ã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ(ç§’)

-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã”ã¨ã®ãƒ­ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ç®¡ç†
local LastLoadedLocation = {}
local LastLoadedData = {}

-- PlayerStatsã®åˆæœŸåŒ–ï¼ˆDataStoreãƒ­ãƒ¼ãƒ‰å‡¦ç†ã‚’å«ã‚€ï¼‰
PlayerStatsModule.init()

print("[Bootstrap] ã‚»ãƒ¼ãƒ–æ©Ÿèƒ½ã‚’åˆæœŸåŒ–ä¸­...")

local SaveGameEvent = ReplicatedStorage:FindFirstChild("SaveGame")
if not SaveGameEvent then
    SaveGameEvent = Instance.new("RemoteEvent")
    SaveGameEvent.Name = "SaveGame"
    SaveGameEvent.Parent = ReplicatedStorage
    print("[Bootstrap] âœ“ SaveGameã‚¤ãƒ™ãƒ³ãƒˆä½œæˆ")
end

local SaveSuccessEvent = ReplicatedStorage:FindFirstChild("SaveSuccess")
if not SaveSuccessEvent then
    SaveSuccessEvent = Instance.new("RemoteEvent")
    SaveSuccessEvent.Name = "SaveSuccess"
    SaveSuccessEvent.Parent = ReplicatedStorage
    print("[Bootstrap] âœ“ SaveSuccessã‚¤ãƒ™ãƒ³ãƒˆä½œæˆ")
end

-- DataStoreManagerã¨DataCollectorsã‚’ãƒ­ãƒ¼ãƒ‰
local DataStoreManager = require(ServerScriptService:WaitForChild("DataStoreManager"))
local DataCollectors = require(ServerScriptService:WaitForChild("DataCollectors"))

-- ã‚»ãƒ¼ãƒ–ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ã‚’ç™»éŒ²
SaveGameEvent.OnServerEvent:Connect(function(player)
    print(("[Bootstrap] ğŸ’¾ %s ã‹ã‚‰ã‚»ãƒ¼ãƒ–ãƒªã‚¯ã‚¨ã‚¹ãƒˆå—ä¿¡"):format(player.Name))

    -- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’å–å¾—
    local stats = PlayerStatsModule.getStats(player)
    if not stats then
        warn(("[Bootstrap] âŒ %s ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"):format(player.Name))
        SaveSuccessEvent:FireClient(player, false)
        return
    end

    -- ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆ
    local saveData = DataCollectors.createSaveData(player, stats)

    print(("[Bootstrap] ğŸ“¦ ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ä½œæˆå®Œäº†"):format())

    -- DataStoreã«ä¿å­˜
    local success = DataStoreManager.SaveData(player, saveData)

    if success then
        print(("[Bootstrap] âœ… %s ã®ã‚»ãƒ¼ãƒ–æˆåŠŸ"):format(player.Name))
    else
        warn(("[Bootstrap] âŒ %s ã®ã‚»ãƒ¼ãƒ–å¤±æ•—"):format(player.Name))
    end
end)

print("[Bootstrap] âœ“ ã‚»ãƒ¼ãƒ–æ©Ÿèƒ½ã®åˆæœŸåŒ–å®Œäº†")

print("[Bootstrap] è¡—ã‚’ç”Ÿæˆä¸­ï¼ˆéåŒæœŸï¼‰...")
task.spawn(function()
    ZoneManager.LoadZone(START_ZONE_NAME)
    print("[Bootstrap] åœ°å½¢ç”Ÿæˆå®Œäº†")
end)

-- è¡—ã®è¨­å®šã‚’å–å¾—
local IslandsRegistry = require(ReplicatedStorage.Islands.Registry)
local townConfig = nil
for _, island in ipairs(IslandsRegistry) do
	if island.name == "StartTown" then
		townConfig = island
		break
	end
end

if not townConfig then
	warn("[Bootstrap] StartTown ã®è¨­å®šãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ï¼")
	return
end


-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¹ãƒãƒ¼ãƒ³ä½ç½®ã‚’è¡—ã«è¨­å®š
local function setupPlayerSpawn(player)

    -- DataStoreã‹ã‚‰ã®ãƒ­ãƒ¼ãƒ‰å‡¦ç†ï¼ˆåŒæœŸçš„ã«å¾…ã¤ï¼‰
    local function loadDataAndPrepareSpawn()
        local startTime = os.clock()
        print(("[Bootstrap] %s ã®DataStoreãƒ­ãƒ¼ãƒ‰é–‹å§‹"):format(player.Name))

        local loadedLocation = PlayerStatsModule.initPlayer(player)
        local fullLoadedData = PlayerStatsModule.getLastLoadedData(player)

        print(("[Bootstrap] â±ï¸ DataStoreãƒ­ãƒ¼ãƒ‰å®Œäº†: %.2fç§’"):format(os.clock() - startTime))

        if not loadedLocation then
            warn(("[Bootstrap] %s ã®ãƒ­ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ãŒnilã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆä½¿ç”¨"):format(player.Name))
            loadedLocation = {
                ZoneName = "ContinentTown",
                X = townConfig.centerX,
                Y = townConfig.baseY + 25,
                Z = townConfig.centerZ
            }
        end

        LastLoadedData[player] = {
            Location = loadedLocation,
            FieldState = fullLoadedData and fullLoadedData.FieldState or nil,
            CurrentZone = fullLoadedData and fullLoadedData.CurrentZone or nil,
        }

        print(("[Bootstrap] %s ã®ãƒ­ãƒ¼ãƒ‰å®Œäº†: %s (%.0f, %.0f, %.0f)"):format(
            player.Name,
            loadedLocation.ZoneName,
            loadedLocation.X,
            loadedLocation.Y,
            loadedLocation.Z
        ))

        player:SetAttribute("ContinentName", loadedLocation.ZoneName)
        return LastLoadedData[player]
    end

    -- ãƒ¡ã‚¤ãƒ³å‡¦ç†
    task.spawn(function()
        local totalStartTime = os.clock()

        -- DataStoreãƒ­ãƒ¼ãƒ‰ã‚’å¾…ã¤
        local loadedData = loadDataAndPrepareSpawn()
        local loadedLocation = loadedData.Location
        local targetZone = loadedLocation.ZoneName

        -- ã€é‡è¦ã€‘ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ç”Ÿæˆå‰ã«ã‚¾ãƒ¼ãƒ³ã‚’ãƒ­ãƒ¼ãƒ‰
        if targetZone ~= START_ZONE_NAME then
            local zoneLoadStart = os.clock()
            print(("[Bootstrap] ã‚­ãƒ£ãƒ©ç”Ÿæˆå‰: %s ã®ã‚¾ãƒ¼ãƒ³ã‚’ãƒ­ãƒ¼ãƒ‰"):format(targetZone))
            ZoneManager.LoadZone(targetZone)
            task.wait(2) -- åœ°å½¢ç”Ÿæˆå®Œäº†ã‚’å¾…ã¤
            print(("[Bootstrap] â±ï¸ ã‚¾ãƒ¼ãƒ³ãƒ­ãƒ¼ãƒ‰å®Œäº†: %.2fç§’"):format(os.clock() - zoneLoadStart))
        end

        -- ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ç”Ÿæˆ
        local charGenStart = os.clock()
        print(("[Bootstrap] %s ã®ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ç”Ÿæˆã‚’é–‹å§‹"):format(player.Name))

        -- ã€è¿½åŠ ã€‘SpawnReadyEventã‚’å–å¾—/ä½œæˆ
        local SpawnReadyEvent = ReplicatedStorage:FindFirstChild("SpawnReady")
        if not SpawnReadyEvent then
            SpawnReadyEvent = Instance.new("RemoteEvent")
            SpawnReadyEvent.Name = "SpawnReady"
            SpawnReadyEvent.Parent = ReplicatedStorage
        end

        -- CharacterAddedã‚’å…ˆã«æ¥ç¶šï¼ˆç”Ÿæˆã¨åŒæ™‚ã«ãƒ¯ãƒ¼ãƒ—ã™ã‚‹ãŸã‚ï¼‰
        local connection
        connection = player.CharacterAdded:Connect(function(character)
            connection:Disconnect() -- ä¸€åº¦ã ã‘å®Ÿè¡Œ

            print(("[Bootstrap] â±ï¸ ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ç”Ÿæˆå®Œäº†: %.2fç§’"):format(os.clock() - charGenStart))

            -- å³åº§ã«ãƒ¯ãƒ¼ãƒ—ï¼ˆæç”»ã•ã‚Œã‚‹å‰ã«ï¼‰
            task.spawn(function()
                local hrpStart = os.clock()
                local hrp = character:WaitForChild("HumanoidRootPart", 5)
                print(("[Bootstrap] â±ï¸ HRPå–å¾—å®Œäº†: %.2fç§’"):format(os.clock() - hrpStart))

                if not hrp then
                    warn(("[Bootstrap] %s ã®HRPãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"):format(player.Name))
                    return
                end

                local targetX = loadedLocation.X
                local targetY = loadedLocation.Y
                local targetZ = loadedLocation.Z

                print(("[Bootstrap] å³åº§ã«ãƒ¯ãƒ¼ãƒ—: %s â†’ (%.0f, %.0f, %.0f)"):format(player.Name, targetX, targetY, targetZ))

                -- å³åº§ã«é…ç½®
                hrp.CFrame = CFrame.new(targetX, targetY, targetZ)
                ZoneManager.PlayerZones[player] = targetZone

                print(("[Bootstrap] %s ã‚’é…ç½®å®Œäº†"):format(player.Name))
                print(("[Bootstrap] â±ï¸ åˆè¨ˆæ™‚é–“: %.2fç§’"):format(os.clock() - totalStartTime))

                -- ã€è¿½åŠ ã€‘ãƒ¯ãƒ¼ãƒ—å®Œäº†å¾Œã€å³åº§ã«ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°è§£é™¤é€šçŸ¥
                SpawnReadyEvent:FireClient(player)
                print(("[Bootstrap] %s ã«ã‚¹ãƒãƒ¼ãƒ³æº–å‚™å®Œäº†ã‚’é€šçŸ¥ï¼ˆå³åº§ï¼‰"):format(player.Name))

                -- ã€ä¿®æ­£ã€‘ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã¨ãƒãƒ¼ã‚¿ãƒ«ã®å¾©å…ƒã‚’ä¸¦è¡Œå‡¦ç†ã«å¤‰æ›´
                task.spawn(function()
                    task.wait(1) -- å°‘ã—å¾…ã£ã¦ã‹ã‚‰å¾©å…ƒ

                    if loadedData.FieldState and loadedData.CurrentZone then
                        local zoneName = loadedData.CurrentZone
                        print(("[Bootstrap] %s ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰çŠ¶æ…‹ã‚’å¾©å…ƒ: %s"):format(player.Name, zoneName))

                        DataCollectors.restoreFieldState(zoneName, loadedData.FieldState)

                        if _G.CreatePortalsForZone then
                            _G.CreatePortalsForZone(zoneName)
                        end
                    else
                        print(("[Bootstrap] %s ã¯åˆå›ãƒ—ãƒ¬ã‚¤"):format(player.Name))

                        if targetZone ~= START_ZONE_NAME then
                            if _G.SpawnMonstersForZone then
                                _G.SpawnMonstersForZone(targetZone)
                            end
                            if _G.CreatePortalsForZone then
                                _G.CreatePortalsForZone(targetZone)
                            end
                        else
                            if _G.CreatePortalsForZone then
                                _G.CreatePortalsForZone(START_ZONE_NAME)
                            end
                        end
                    end

                    -- ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
                    LastLoadedData[player] = nil
                end)

                -- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°ï¼ˆä¸¦è¡Œå‡¦ç†ï¼‰
                task.spawn(function()
                    local stats = PlayerStatsModule.getStats(player)
                    if stats then
                        local expToNext = stats.Level * 100
                        local StatusUpdateEvent = ReplicatedStorage:FindFirstChild("StatusUpdate")
                        if StatusUpdateEvent then
                            StatusUpdateEvent:FireClient(
                                player,
                                stats.CurrentHP,
                                stats.MaxHP,
                                stats.Level,
                                stats.Experience,
                                expToNext,
                                stats.Gold
                            )
                        end
                    end
                end)

                print(("[Bootstrap] %s ã®ã‚¹ãƒãƒ¼ãƒ³å‡¦ç†å®Œäº†"):format(player.Name))
            end)
        end)

        -- ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ç”Ÿæˆ
        player:LoadCharacter()
    end)
end


-- æ—¢å­˜ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«é©ç”¨
for _, player in ipairs(Players:GetPlayers()) do
    setupPlayerSpawn(player)
end

-- æ–°è¦ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«é©ç”¨
Players.PlayerAdded:Connect(setupPlayerSpawn)

-- é€€å‡ºæ™‚ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
Players.PlayerRemoving:Connect(function(player)
    LastLoadedLocation[player] = nil
end)

-- åŠ¹æœéŸ³ã®åˆæœŸåŒ–
task.spawn(function()
    local soundsFolder = ReplicatedStorage:FindFirstChild("Sounds")
    if not soundsFolder then
        soundsFolder = Instance.new("Folder")
        soundsFolder.Name = "Sounds"
        soundsFolder.Parent = ReplicatedStorage
    end

    if not soundsFolder:FindFirstChild("TypingCorrect") then
        local typingCorrect = Instance.new("Sound")
        typingCorrect.Name = "TypingCorrect"
        typingCorrect.SoundId = "rbxassetid://159534615"
        typingCorrect.Volume = 0.4
        typingCorrect.Parent = soundsFolder
    end

    if not soundsFolder:FindFirstChild("TypingError") then
        local typingError = Instance.new("Sound")
        typingError.Name = "TypingError"
        typingError.SoundId = "rbxassetid://113721818600044"
        typingError.Volume = 0.5
        typingError.Parent = soundsFolder
    end

    print("[Bootstrap] Soundsãƒ•ã‚©ãƒ«ãƒ€ã‚’åˆæœŸåŒ–ã—ã¾ã—ãŸ")
end)

-- ã€è¿½åŠ ã€‘ã‚»ãƒ¼ãƒ–ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ã®ç™»éŒ²
local SaveGameEvent = ReplicatedStorage:FindFirstChild("SaveGame")
if not SaveGameEvent then
    SaveGameEvent = Instance.new("RemoteEvent")
    SaveGameEvent.Name = "SaveGame"
    SaveGameEvent.Parent = ReplicatedStorage
    print("[Bootstrap] SaveGameã‚¤ãƒ™ãƒ³ãƒˆã‚’ä½œæˆã—ã¾ã—ãŸ")
end

local DataStoreManager = require(ServerScriptService:WaitForChild("DataStoreManager"))
local DataCollectors = require(ServerScriptService:WaitForChild("DataCollectors"))

SaveGameEvent.OnServerEvent:Connect(function(player)
    print(("[Bootstrap] %s ã‹ã‚‰ã‚»ãƒ¼ãƒ–ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’å—ä¿¡"):format(player.Name))

    -- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’å–å¾—
    local stats = PlayerStatsModule.getStats(player)
    if not stats then
        warn(("[Bootstrap] %s ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"):format(player.Name))
        local SaveSuccessEvent = ReplicatedStorage:FindFirstChild("SaveSuccess")
        if SaveSuccessEvent then
            SaveSuccessEvent:FireClient(player, false)
        end
        return
    end

    -- ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆ
    local saveData = DataCollectors.createSaveData(player, stats)

    -- DataStoreã«ä¿å­˜
    local success = DataStoreManager.SaveData(player, saveData)

    if success then
        print(("[Bootstrap] %s ã®ã‚»ãƒ¼ãƒ–æˆåŠŸ"):format(player.Name))
    else
        warn(("[Bootstrap] %s ã®ã‚»ãƒ¼ãƒ–å¤±æ•—"):format(player.Name))
    end
end)

print("[Bootstrap] ã‚»ãƒ¼ãƒ–ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ã‚’ç™»éŒ²ã—ã¾ã—ãŸ")

print("[Bootstrap] === ã‚²ãƒ¼ãƒ åˆæœŸåŒ–å®Œäº† ===")
print(("[Bootstrap] ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯è¡—ï¼ˆ%sï¼‰ã‹ã‚‰ã‚¹ã‚¿ãƒ¼ãƒˆã—ã¾ã™"):format(START_ZONE_NAME))
===== ./ServerScriptService/LoadTest.server.lua =====
-- ServerScriptService/LoadTest (Script)
local startTime = os.clock()
local startMemory = gcinfo()

-- ã‚²ãƒ¼ãƒ é–‹å§‹ã‚’å¾…ã¤
-- task.wait(5)

-- local endTime = os.clock()
-- local endMemory = gcinfo()

-- print("=== è² è·ãƒ†ã‚¹ãƒˆçµæœ ===")
-- print(("åœ°å½¢ç”Ÿæˆæ™‚é–“: %.2fç§’"):format(endTime - startTime))
-- print(("ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡: %.2f MB"):format((endMemory - startMemory) / 1024))
-- print(("ç·ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæ•°: %d"):format(#workspace:GetDescendants()))

-- ç¶™ç¶šãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°
task.spawn(function()
	while true do
		task.wait(5)
		local fps = 1 / game:GetService("RunService").Heartbeat:Wait()
		print(("FPS: %.1f | ãƒ¡ãƒ¢ãƒª: %.1f MB"):format(fps, gcinfo() / 1024))
	end
end)
===== ./ServerScriptService/OceanSafety.server.lua =====
-- ServerScriptService/OceanSafety.server.lua
-- æµ·ã«è½ã¡ãŸæ™‚ã®å‡¦ç†

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- è¨­å®š
local WATER_LEVEL = -25  -- ã“ã®é«˜ã•ã‚ˆã‚Šä¸‹ã«è½ã¡ãŸã‚‰å‡¦ç†
local CHECK_INTERVAL = 0.5  -- ãƒã‚§ãƒƒã‚¯é–“éš”ï¼ˆç§’ï¼‰

-- å³¶ã®ä¸­å¿ƒï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ãƒªã‚¹ãƒãƒ¼ãƒ³ä½ç½®ï¼‰
local Islands = require(ReplicatedStorage.Islands.Registry)
local firstIsland = Islands[1]
local SPAWN_X = firstIsland.centerX
local SPAWN_Z = firstIsland.centerZ
local SPAWN_Y = firstIsland.baseY + 25  -- å³¶ã®ä¸Šç©º

print("[OceanSafety] åˆæœŸåŒ–å®Œäº†")

-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç›£è¦–
local function monitorPlayer(player)
	player.CharacterAdded:Connect(function(character)
		local hrp = character:WaitForChild("HumanoidRootPart")
		local humanoid = character:WaitForChild("Humanoid")

		local lastCheck = 0

		RunService.Heartbeat:Connect(function()
			if not character.Parent or not hrp.Parent then return end

			local now = os.clock()
			if now - lastCheck < CHECK_INTERVAL then return end
			lastCheck = now

			-- æ°´é¢ã‚ˆã‚Šä¸‹ã«è½ã¡ãŸã‹ãƒã‚§ãƒƒã‚¯
			if hrp.Position.Y < WATER_LEVEL then
				print(("[OceanSafety] %s ãŒæµ·ã«è½ã¡ã¾ã—ãŸã€‚ãƒªã‚¹ãƒãƒ¼ãƒ³ä¸­..."):format(player.Name))

				-- é€Ÿåº¦ã‚’ã‚¼ãƒ­ã«
				hrp.AssemblyLinearVelocity = Vector3.zero
				hrp.AssemblyAngularVelocity = Vector3.zero

				-- å³¶ã®ä¸­å¿ƒã«æˆ»ã™
				hrp.CFrame = CFrame.new(SPAWN_X, SPAWN_Y, SPAWN_Z)

				-- ä½“åŠ›ã‚’å°‘ã—æ¸›ã‚‰ã™ï¼ˆãƒšãƒŠãƒ«ãƒ†ã‚£ï¼‰
				if humanoid.Health > 10 then
					humanoid.Health = humanoid.Health - 10
				end
			end
		end)
	end)
end

-- æ—¢å­˜ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨æ–°è¦ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«é©ç”¨
for _, player in ipairs(Players:GetPlayers()) do
	monitorPlayer(player)
end
Players.PlayerAdded:Connect(monitorPlayer)

-- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã®ç›£è¦–
RunService.Heartbeat:Connect(function()
	for _, model in ipairs(workspace:GetChildren()) do
		if model:IsA("Model") and model:GetAttribute("IsEnemy") then
			local hrp = model:FindFirstChild("HumanoidRootPart")

			if hrp and hrp.Position.Y < WATER_LEVEL then
				-- print(("[OceanSafety] %s ãŒæµ·ã«è½ã¡ã¾ã—ãŸã€‚æ¶ˆå»ä¸­..."):format(model.Name))
				model:Destroy()
			end
		end
	end
end)
===== ./ServerScriptService/WarpPortal.server.lua =====
-- ===== ./ServerScriptService/WarpPortal.server.lua =====
-- ServerScriptService/WarpPortal.server.lua
-- ãƒ¯ãƒ¼ãƒ—ä¸­ã®ãƒãƒˆãƒ«é–‹å§‹ã‚’é˜²æ­¢ã™ã‚‹ä¿®æ­£ç‰ˆ

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

print("[WarpPortal] åˆæœŸåŒ–é–‹å§‹")

-- ã€ä¿®æ­£ã€‘warpEvent ã®ä½œæˆã‚’æœ€å„ªå…ˆã§å®Ÿè¡Œã™ã‚‹
local warpEvent = ReplicatedStorage:FindFirstChild("WarpEvent")
if not warpEvent then
	warpEvent = Instance.new("RemoteEvent")
	warpEvent.Name = "WarpEvent"
	warpEvent.Parent = ReplicatedStorage
end

local ZoneManager = require(script.Parent.ZoneManager)
local BattleSystem = require(script.Parent.BattleSystem)


local warpingPlayers = {}
local activePortals = {}

local IslandsRegistry = require(ReplicatedStorage.Islands.Registry)
local ContinentsRegistry = require(ReplicatedStorage.Continents.Registry)

local Islands = {}
for _, island in ipairs(IslandsRegistry) do
	Islands[island.name] = island
end

local Continents = {}
for _, continent in ipairs(ContinentsRegistry) do
	if continent and continent.name then
		Continents[continent.name] = continent
	else
		warn(("[WarpPortal] åå‰ãŒè¨­å®šã•ã‚Œã¦ã„ãªã„å¤§é™¸å®šç¾©ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã—ãŸ"):format(continent and continent.name or "nil"))
	end
end

local function resolveTemplate(pathArray: {string}): Model?
	local node: Instance = game
	for _, seg in ipairs(pathArray) do
		node = node:FindFirstChild(seg)
		if not node then return nil end
	end
	return (node and node:IsA("Model")) and node or nil
end

local function ensureHRP(model: Model): BasePart?
	local hrp = model:FindFirstChild("HumanoidRootPart")
	if hrp and hrp:IsA("BasePart") then
		if not model.PrimaryPart then model.PrimaryPart = hrp end
		return hrp
	end
	return nil
end

local function attachLabel(model: Model, maxDist: number)
	local hrp = model.PrimaryPart or model:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	local _, bboxSize = model:GetBoundingBox()
	local labelOffset = math.min(bboxSize.Y * 0.5 + 2, 15)

	local gui = Instance.new("BillboardGui")
	gui.Name = "DebugInfo"
	gui.Adornee = hrp
	gui.AlwaysOnTop = true
	gui.Size = UDim2.new(0, 150, 0, 50)
	gui.StudsOffset = Vector3.new(0, labelOffset, 0)
	gui.MaxDistance = maxDist
	gui.Parent = hrp

	local lb = Instance.new("TextLabel")
	lb.Name = "InfoText"
	lb.BackgroundTransparency = 1
	lb.TextScaled = true
	lb.Font = Enum.Font.GothamBold
	lb.TextColor3 = Color3.new(1, 1, 1)
	lb.TextStrokeTransparency = 0.5
	lb.Size = UDim2.fromScale(1, 1)
	lb.Text = "Ready"
	lb.Parent = gui
end

local function placeOnGround(model: Model, x: number, z: number)
	local hrp = model.PrimaryPart or model:FindFirstChild("HumanoidRootPart")
	if not hrp then
		warn("[MonsterSpawner] HumanoidRootPart ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: " .. model.Name)
		return
	end

	local groundY = FieldGen.raycastGroundY(x, z, 100)
		or FieldGen.raycastGroundY(x, z, 200)
		or FieldGen.raycastGroundY(x, z, 50)
		or 10

	local _, yaw = hrp.CFrame:ToOrientation()
	model:PivotTo(CFrame.new(x, groundY + 20, z) * CFrame.Angles(0, yaw, 0))

	local bboxCFrame, bboxSize = model:GetBoundingBox()
	local bottomY = bboxCFrame.Position.Y - (bboxSize.Y * 0.5)
	local offset = hrp.Position.Y - bottomY

	model:PivotTo(CFrame.new(x, groundY + offset, z) * CFrame.Angles(0, yaw, 0))
end

local function nearestPlayer(position: Vector3)
	local best, bestDist = nil, math.huge
	for _, pl in ipairs(Players:GetPlayers()) do
		local ch = pl.Character
		local hrp = ch and ch:FindFirstChild("HumanoidRootPart")
		if hrp then
			local d = (position - hrp.Position).Magnitude
			if d < bestDist then
				best, bestDist = pl, d
			end
		end
	end
	return best, bestDist
end

-- ã€ä¿®æ­£ã€‘ãƒãƒ¼ã‚¿ãƒ«ã‚¿ãƒƒãƒæ™‚ã€å³åº§ã«ãƒ¯ãƒ¼ãƒ—ä¸­ãƒ•ãƒ©ã‚°ã‚’è¨­å®š
local function createPortal(config, fromZone)
	-- Townå¤§é™¸ã®å ´åˆã€fromZoneã¯ContinentTownã ãŒã€ãƒãƒ¼ã‚¿ãƒ«åº§æ¨™ã¯islandNameã‚’å‚ç…§ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚
	local islandName = config.islandName or fromZone
	local zoneConfig = Islands[islandName]

	if not zoneConfig then
		warn(("[WarpPortal] ã‚¾ãƒ¼ãƒ³ '%s' ã®å³¶è¨­å®šãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"):format(islandName))
		return nil
	end

	-- ãƒãƒ¼ã‚¿ãƒ«ã‚µã‚¤ã‚ºã‚’ç¢ºå®šã€‚è¨­å®šãŒnilã®å ´åˆã€Vector3.new(8, 12, 8)ã‚’ä½¿ç”¨ã™ã‚‹ã€‚
    local portalSize = config.size or Vector3.new(8, 12, 8)
    local portalHeight = portalSize.Y -- ä¿®æ­£å¾Œã€portalSizeãŒnilã«ãªã‚‹ã“ã¨ã¯ãªã„

	local portalX = zoneConfig.centerX + (config.offsetX or 0)
	local portalZ = zoneConfig.centerZ + (config.offsetZ or 0)

	local FieldGen = require(ReplicatedStorage:WaitForChild("FieldGen"))
	local groundY = nil
	local maxRetries = 2

	for attempt = 1, maxRetries do
		-- Townã®BaseYã§ã¯ãªãã€æ¨å®šé«˜åº¦ã‹ã‚‰ãƒ¬ã‚¤ã‚­ãƒ£ã‚¹ãƒˆé–‹å§‹
		local rayStartY = zoneConfig.baseY + (zoneConfig.hillAmplitude or 20) + 100
		groundY = FieldGen.raycastGroundY(portalX, portalZ, rayStartY)
		if groundY then break end
		task.wait(0.05)
	end

	local portalY
	if groundY then
		-- ãƒãƒ¼ã‚¿ãƒ«ã®åº•é¢ (Y) ãŒåœ°é¢ (groundY) ã«ãªã‚‹ã‚ˆã†ã«è¨­å®š
		portalY = groundY + portalHeight / 2
		print(("[WarpPortal DEBUG] %s: åœ°é¢æ¤œå‡ºæˆåŠŸ (Y=%.1f), ãƒãƒ¼ã‚¿ãƒ«Y=%.1f"):format(config.name, groundY, portalY))
	else
		local estimatedHeight = zoneConfig.baseY + ((zoneConfig.hillAmplitude or 20) * 0.5)
		portalY = estimatedHeight + portalHeight / 2
		warn(("[WarpPortal DEBUG] %s: åœ°é¢æ¤œå‡ºå¤±æ•—ã€æ¨å®šé«˜åº¦ä½¿ç”¨ (Y=%.1f)"):format(config.name, portalY))
	end

	local portalPosition = Vector3.new(portalX, portalY, portalZ)

	local portal = Instance.new("Part")
	portal.Name = config.name
	portal.Size = portalSize -- ç¢ºå®šã—ãŸã‚µã‚¤ã‚ºã‚’ä½¿ç”¨
	portal.Position = portalPosition
	portal.Anchored = true
	portal.CanCollide = false
	portal.Transparency = 0.3
	portal.Color = config.color or Color3.fromRGB(255, 255, 255)
	portal.Material = Enum.Material.Neon

	portal:SetAttribute("FromZone", fromZone)
	portal:SetAttribute("ToZone", config.toZone)

	local bodyAngularVelocity = Instance.new("BodyAngularVelocity")
	bodyAngularVelocity.AngularVelocity = Vector3.new(0, 2, 0)
	bodyAngularVelocity.MaxTorque = Vector3.new(0, math.huge, 0)
	bodyAngularVelocity.P = 1000
	bodyAngularVelocity.Parent = portal

	local billboard = Instance.new("BillboardGui")
	billboard.Name = "PortalLabel"
	billboard.Size = UDim2.new(0, 200, 0, 50)
	billboard.StudsOffset = Vector3.new(0, 7, 0)
	billboard.AlwaysOnTop = true
	billboard.Parent = portal

	local label = Instance.new("TextLabel")
	label.Size = UDim2.new(1, 0, 1, 0)
	label.BackgroundTransparency = 1
	label.Text = config.label or ("â†’ " .. config.toZone)
	label.TextColor3 = Color3.new(1, 1, 1)
	label.TextScaled = true
	label.Font = Enum.Font.SourceSansBold
	label.TextStrokeTransparency = 0.5
	label.Parent = billboard

	local worldFolder = workspace:FindFirstChild("World")
	if not worldFolder then
		worldFolder = Instance.new("Folder")
		worldFolder.Name = "World"
		worldFolder.Parent = workspace
	end

	portal.Parent = worldFolder

	-- ã€é‡è¦ã€‘ãƒãƒ¼ã‚¿ãƒ«ã‚¿ãƒƒãƒå‡¦ç†
	portal.Touched:Connect(function(hit)
		local character = hit.Parent
		if not character then return end

		local player = Players:GetPlayerFromCharacter(character)
		if not player then return end

		-- ã€ä¿®æ­£1ã€‘ãƒ¯ãƒ¼ãƒ—ä¸­ãƒã‚§ãƒƒã‚¯
		if warpingPlayers[player.UserId] then
			return
		end

		-- ã€ä¿®æ­£2ã€‘ãƒãƒˆãƒ«ä¸­ãƒã‚§ãƒƒã‚¯
		if BattleSystem and BattleSystem.isInBattle and BattleSystem.isInBattle(player) then
			return
		end

		local actualFromZone = portal:GetAttribute("FromZone")
		local currentZone = ZoneManager.GetPlayerZone(player)

		if currentZone ~= actualFromZone then
			if not currentZone then
				ZoneManager.PlayerZones[player] = actualFromZone
			else
				return
			end
		end

		print(("[WarpPortal] %s ãŒ %s ã«å…¥ã‚Šã¾ã—ãŸ"):format(player.Name, config.name))

		-- ã€ä¿®æ­£3ã€‘å³åº§ã«ãƒ¯ãƒ¼ãƒ—ä¸­ãƒ•ãƒ©ã‚°ã‚’è¨­å®šï¼ˆæœ€å„ªå…ˆï¼‰
		warpingPlayers[player.UserId] = true
		character:SetAttribute("IsWarping", true)

		-- ã€ä¿®æ­£4-æ”¹3ã€‘ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚’å³åº§ã«é€æ˜åŒ–ï¼ˆä¸Šç©ºç§»å‹•ãªã—ï¼‰
		local originalTransparencies = {}
		for _, part in ipairs(character:GetDescendants()) do
			if part:IsA("BasePart") then
				originalTransparencies[part] = part.Transparency
				part.Transparency = 1
			elseif part:IsA("Decal") or part:IsA("Texture") then
				originalTransparencies[part] = part.Transparency
				part.Transparency = 1
			end
		end

		-- ç”»é¢ã‚’æš—è»¢
		warpEvent:FireClient(player, "StartLoading", config.toZone)
		task.wait(0.5)

		-- ãƒãƒˆãƒ«ã‚·ã‚¹ãƒ†ãƒ ãƒªã‚»ãƒƒãƒˆ
		if BattleSystem and BattleSystem.resetAllBattles then
			BattleSystem.resetAllBattles()
		end

		-- destroyPortalsForZone(actualFromZone)

		-- å‰ã®ã‚¾ãƒ¼ãƒ³ã®ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’å‰Šé™¤
		local IS_TOWN = actualFromZone == "ContinentTown"
		if not IS_TOWN and _G.DespawnMonstersForZone then
			_G.DespawnMonstersForZone(actualFromZone)
		end

		-- ã‚¾ãƒ¼ãƒ³åˆ‡ã‚Šæ›¿ãˆ
		local success = ZoneManager.WarpPlayerToZone(player, config.toZone)

		if success then
			-- é€æ˜åº¦ã‚’å…ƒã«æˆ»ã™
			for part, transparency in pairs(originalTransparencies) do
				if part and part.Parent then
					part.Transparency = transparency
				end
			end

			-- æ–°ã—ã„ã‚¾ãƒ¼ãƒ³ã®ãƒãƒ¼ã‚¿ãƒ«ã‚’ä½œæˆ
			createPortalsForZone(config.toZone)

			-- æ–°ã—ã„ã‚¾ãƒ¼ãƒ³ã®ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’ã‚¹ãƒãƒ¼ãƒ³
			local TO_IS_TOWN = config.toZone == "ContinentTown"
			if not TO_IS_TOWN and _G.SpawnMonstersForZone then
				_G.SpawnMonstersForZone(config.toZone)
			end

			task.wait(0.5)
			warpEvent:FireClient(player, "EndLoading")
		else
			warn(("[WarpPortal] %s ã®ãƒ¯ãƒ¼ãƒ—ã«å¤±æ•—"):format(player.Name))
			warpEvent:FireClient(player, "EndLoading")
		end

		-- ã€ä¿®æ­£5ã€‘ãƒ¯ãƒ¼ãƒ—ä¸­ãƒ•ãƒ©ã‚°ã‚’è§£é™¤
		task.wait(1) -- è¿½åŠ ã®å®‰å…¨ãƒãƒ¼ã‚¸ãƒ³
		warpingPlayers[player.UserId] = nil
		if character and character.Parent then
			character:SetAttribute("IsWarping", false)
		end
	end)

	return portal
end

function createPortalsForZone(zoneName)
    if activePortals[zoneName] then
        print(("[WarpPortal] %s ã®ãƒãƒ¼ã‚¿ãƒ«ã¯æ—¢ã«å­˜åœ¨ã—ã¾ã™"):format(zoneName))
        return
    end

    activePortals[zoneName] = {}

    local continent = Continents[zoneName]
    if continent and continent.portals then
        print(("[WarpPortal] %s ã®ãƒãƒ¼ã‚¿ãƒ«ã‚’ä¸¦åˆ—ç”Ÿæˆä¸­..."):format(zoneName))

        for _, portalConfig in ipairs(continent.portals) do
            task.spawn(function()
                local islandName = portalConfig.islandName
                if not Islands[islandName] then
                    warn(("[WarpPortal] å³¶ '%s' ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"):format(islandName))
                else
                    -- createPortalã®ç¬¬2å¼•æ•°ã¯ãƒãƒ¼ã‚¿ãƒ«ãŒå±ã™ã‚‹å¤§é™¸åï¼ˆzoneNameï¼‰
                    local portal = createPortal(portalConfig, zoneName)
                    if portal then
                        portal:SetAttribute("FromZone", zoneName)
                        table.insert(activePortals[zoneName], portal)
                        print(("[WarpPortal] ãƒãƒ¼ã‚¿ãƒ«ä½œæˆ: %s (é…ç½®: %s)"):format(portalConfig.name, islandName))
                    end
                end
            end)
        end
    else
        print(("[WarpPortal] %s ã®ãƒãƒ¼ã‚¿ãƒ«è¨­å®šãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"):format(zoneName))
    end
end

function destroyPortalsForZone(zoneName)
	if not activePortals[zoneName] then return end

	-- ä¸‡ãŒä¸€å³¶åãŒæ¸¡ã•ã‚ŒãŸå ´åˆã€å¤§é™¸åã«å¤‰æ›ã—ã¦å‰Šé™¤
    local actualZoneName = zoneName
    if actualZoneName == "StartTown" then
        actualZoneName = "ContinentTown"
    end

	for _, portal in ipairs(activePortals[actualZoneName] or {}) do
		if portal and portal.Parent then
			portal:Destroy()
		end
	end

	activePortals[actualZoneName] = nil
	print(("[WarpPortal] %s ã®ãƒãƒ¼ã‚¿ãƒ«ã‚’å‰Šé™¤ã—ã¾ã—ãŸ-"):format(actualZoneName))
end

task.spawn(function()
	local maxWait = 10
	local waited = 0

	while not _G.SpawnMonstersForZone and waited < maxWait do
		task.wait(0.5)
		waited = waited + 0.5
	end

	if _G.SpawnMonstersForZone then
		print("[WarpPortal] MonsterSpawneré–¢æ•°æ¤œå‡ºæˆåŠŸ")
	else
		warn("[WarpPortal] MonsterSpawneré–¢æ•°ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
	end
end)

task.wait(0.3)
createPortalsForZone("ContinentTown") -- â˜…ä¿®æ­£: StartTownã‹ã‚‰ContinentTownã«å¤‰æ›´

Players.PlayerRemoving:Connect(function(player)
	warpingPlayers[player.UserId] = nil
	ZoneManager.PlayerZones[player] = nil
end)

_G.CreatePortalsForZone = createPortalsForZone
_G.DestroyPortalsForZone = destroyPortalsForZone

print("[WarpPortal] åˆæœŸåŒ–å®Œäº†")
===== ./ServerScriptService/InteractionSystem.server.lua =====
-- ServerScriptService/InteractionSystem.server.lua
-- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ã‚·ã‚¹ãƒ†ãƒ ï¼ˆå®ç®±ã€NPCç­‰ï¼‰

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")
local HttpService = game:GetService("HttpService")

print("[InteractionSystem] åˆæœŸåŒ–é–‹å§‹")

-- ä¾å­˜ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
local PlayerStatsModule = require(ServerScriptService:WaitForChild("PlayerStats"))

-- RemoteEventä½œæˆ
local InteractEvent = ReplicatedStorage:FindFirstChild("InteractEvent")
if not InteractEvent then
	InteractEvent = Instance.new("RemoteEvent")
	InteractEvent.Name = "InteractEvent"
	InteractEvent.Parent = ReplicatedStorage
end

local InteractionResponseEvent = ReplicatedStorage:FindFirstChild("InteractionResponse")
if not InteractionResponseEvent then
	InteractionResponseEvent = Instance.new("RemoteEvent")
	InteractionResponseEvent.Name = "InteractionResponse"
	InteractionResponseEvent.Parent = ReplicatedStorage
end

-- å®ç®±ã‚’é–‹ã‘ã‚‹å‡¦ç†
local function handleChestInteraction(player, chestObject)
	print("[InteractionSystem DEBUG] ã‚¹ãƒ†ãƒƒãƒ—1: é–‹å§‹")

	local chestId = chestObject:GetAttribute("ChestId")
	if not chestId then
		warn("[InteractionSystem] ChestIdãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“")
		return false
	end

	print("[InteractionSystem DEBUG] ã‚¹ãƒ†ãƒƒãƒ—2: ChestIdå–å¾— =", chestId)

	-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’å–å¾—
	local stats = PlayerStatsModule.getStats(player)
	if not stats then
		warn(("[InteractionSystem] %s ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"):format(player.Name))
		return false
	end

	print("[InteractionSystem DEBUG] ã‚¹ãƒ†ãƒƒãƒ—3: ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å–å¾—å®Œäº†")

	-- æ—¢ã«å–å¾—æ¸ˆã¿ã‹ãƒã‚§ãƒƒã‚¯
	if stats.CollectedItems[chestId] then
		print(("[InteractionSystem] %s ã¯æ—¢ã« %s ã‚’å–å¾—æ¸ˆã¿"):format(player.Name, chestId))
		return false
	end

	print("[InteractionSystem DEBUG] ã‚¹ãƒ†ãƒƒãƒ—4: æœªå–å¾—ç¢ºèªå®Œäº†")

	-- è·é›¢ãƒã‚§ãƒƒã‚¯ï¼ˆä¸æ­£é˜²æ­¢ï¼‰
	local character = player.Character
	if not character then
		warn("[InteractionSystem DEBUG] ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãªã—")
		return false
	end

	local hrp = character:FindFirstChild("HumanoidRootPart")
	if not hrp then
		warn("[InteractionSystem DEBUG] HRPãªã—")
		return false
	end

	print("[InteractionSystem DEBUG] ã‚¹ãƒ†ãƒƒãƒ—5: ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ç¢ºèªå®Œäº†")

	local distance = (hrp.Position - chestObject.Position).Magnitude
	local range = chestObject:GetAttribute("InteractionRange") or 8

	if distance > range + 5 then
		warn(("[InteractionSystem] %s ãŒé ã™ãã¾ã™: %.1f > %d"):format(player.Name, distance, range))
		return false
	end

	print("[InteractionSystem DEBUG] ã‚¹ãƒ†ãƒƒãƒ—6: è·é›¢ãƒã‚§ãƒƒã‚¯å®Œäº†")
	print(("[InteractionSystem] %s ãŒ %s ã‚’é–‹ã‘ã¾ã™"):format(player.Name, chestId))

	-- å ±é…¬ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
	local rewardsJson = chestObject:GetAttribute("RewardsData")
	print("[InteractionSystem DEBUG] ã‚¹ãƒ†ãƒƒãƒ—7: RewardsData =", rewardsJson)

	local rewards = {}
	if rewardsJson then
		local success, decoded = pcall(function()
			return HttpService:JSONDecode(rewardsJson)
		end)
		if success then
			rewards = decoded
			print("[InteractionSystem DEBUG] ã‚¹ãƒ†ãƒƒãƒ—8: å ±é…¬ãƒ‡ã‚³ãƒ¼ãƒ‰æˆåŠŸ")
		else
			warn("[InteractionSystem DEBUG] ã‚¹ãƒ†ãƒƒãƒ—8: å ±é…¬ãƒ‡ã‚³ãƒ¼ãƒ‰å¤±æ•—")
		end
	end

	-- å ±é…¬ã‚’ä»˜ä¸
	for _, reward in ipairs(rewards) do
		if reward.item == "ã‚´ãƒ¼ãƒ«ãƒ‰" then
			stats.Gold = stats.Gold + reward.count
			print(("[InteractionSystem] %s ã«ã‚´ãƒ¼ãƒ«ãƒ‰ %d ã‚’ä»˜ä¸"):format(player.Name, reward.count))
		else
			-- å°†æ¥çš„ã«ã‚¢ã‚¤ãƒ†ãƒ ã‚·ã‚¹ãƒ†ãƒ ã¨é€£æº
			print(("[InteractionSystem] %s ã« %s x%d ã‚’ä»˜ä¸ï¼ˆæœªå®Ÿè£…ï¼‰"):format(
				player.Name, reward.item, reward.count
			))
		end
	end

	print("[InteractionSystem DEBUG] ã‚¹ãƒ†ãƒƒãƒ—9: å ±é…¬ä»˜ä¸å®Œäº†")

	-- å–å¾—æ¸ˆã¿ã«è¨­å®š
	stats.CollectedItems[chestId] = true

	-- ã‚»ãƒ¼ãƒ–ï¼ˆå³åº§ã«ä¿å­˜ï¼‰
	if _G.AutoSavePlayer then
		_G.AutoSavePlayer(player, "å®ç®±å–å¾—")
	end

	print("[InteractionSystem DEBUG] ã‚¹ãƒ†ãƒƒãƒ—10: ã‚»ãƒ¼ãƒ–å®Œäº†")

	-- ãƒ¢ãƒ‡ãƒ«ã‚’é–‹ã„ãŸçŠ¶æ…‹ã«åˆ‡ã‚Šæ›¿ãˆ
	local openedModelName = chestObject:GetAttribute("OpenedModel")
	if openedModelName then
		print("[InteractionSystem DEBUG] ã‚¹ãƒ†ãƒƒãƒ—11: ãƒ¢ãƒ‡ãƒ«åˆ‡ã‚Šæ›¿ãˆé–‹å§‹")
		task.spawn(function()
			local ServerStorage = game:GetService("ServerStorage")
			local fieldObjectsFolder = ServerStorage:FindFirstChild("FieldObjects")
			if fieldObjectsFolder then
				local openedTemplate = fieldObjectsFolder:FindFirstChild(openedModelName)
				if openedTemplate then
					-- é–‰ã˜ãŸå®ç®±ã‚’éè¡¨ç¤º
					chestObject.Transparency = 1
					for _, child in ipairs(chestObject:GetDescendants()) do
						if child:IsA("BasePart") then
							child.Transparency = 1
						end
					end

					-- é–‹ã„ãŸå®ç®±ã‚’é…ç½®
					local openedChest = openedTemplate:Clone()
					openedChest.CFrame = chestObject.CFrame
					openedChest.Anchored = true
					openedChest.CanCollide = false
					openedChest.Parent = chestObject.Parent

					print("[InteractionSystem DEBUG] é–‹ã„ãŸå®ç®±ã‚’é…ç½®")

					-- è¡¨ç¤ºæ™‚é–“å¾Œã«å‰Šé™¤
					local duration = chestObject:GetAttribute("DisplayDuration") or 3
					task.wait(duration)

					openedChest:Destroy()
					chestObject:Destroy()

					print(("[InteractionSystem] %s ã‚’å‰Šé™¤ã—ã¾ã—ãŸ"):format(chestId))
				else
					warn("[InteractionSystem DEBUG] é–‹ã„ãŸãƒ¢ãƒ‡ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“:", openedModelName)
				end
			else
				warn("[InteractionSystem DEBUG] FieldObjectsãƒ•ã‚©ãƒ«ãƒ€ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
			end
		end)
	end

	print("[InteractionSystem DEBUG] ã‚¹ãƒ†ãƒƒãƒ—12: ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆé€ä¿¡æº–å‚™")

	-- ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«å ±é…¬æƒ…å ±ã‚’é€ä¿¡
	local responseData = {
		success = true,
		type = "chest",
		rewards = rewards,
		displayDuration = chestObject:GetAttribute("DisplayDuration") or 3,
	}

	print(("[InteractionSystem DEBUG] é€ä¿¡ãƒ‡ãƒ¼ã‚¿: %s"):format(HttpService:JSONEncode(responseData)))

	InteractionResponseEvent:FireClient(player, responseData)

	print("[InteractionSystem DEBUG] ã‚¹ãƒ†ãƒƒãƒ—13: é€ä¿¡å®Œäº†")

	return true
end

-- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³å‡¦ç†ã®ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°
local function handleInteraction(player, object)
	print("[InteractionSystem DEBUG] handleInteractionå‘¼ã³å‡ºã—")

	if not object or not object:IsA("BasePart") then
		warn("[InteractionSystem DEBUG] ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒç„¡åŠ¹")
		return
	end

	print("[InteractionSystem DEBUG] ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ:", object.Name)

	local interactionType = object:GetAttribute("InteractionType")
	print("[InteractionSystem DEBUG] InteractionType:", interactionType)

	if interactionType == "chest" then
		handleChestInteraction(player, object)
	elseif interactionType == "npc" then
		-- å°†æ¥çš„ã«NPCå‡¦ç†
		print("[InteractionSystem] NPCå‡¦ç†ã¯æœªå®Ÿè£…")
	else
		warn(("[InteractionSystem] æœªçŸ¥ã®ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—: %s"):format(tostring(interactionType)))
	end
end

-- ã‚¤ãƒ™ãƒ³ãƒˆæ¥ç¶š
InteractEvent.OnServerEvent:Connect(function(player, object)
	print("[InteractionSystem DEBUG] InteractEventå—ä¿¡")
	handleInteraction(player, object)
end)

-- å–å¾—æ¸ˆã¿ã‚¢ã‚¤ãƒ†ãƒ ãƒªã‚¹ãƒˆã‚’è¿”ã™RemoteFunction
local GetCollectedItemsFunc = ReplicatedStorage:FindFirstChild("GetCollectedItems")
if not GetCollectedItemsFunc then
	GetCollectedItemsFunc = Instance.new("RemoteFunction")
	GetCollectedItemsFunc.Name = "GetCollectedItems"
	GetCollectedItemsFunc.Parent = ReplicatedStorage
end

GetCollectedItemsFunc.OnServerInvoke = function(player)
	local stats = PlayerStatsModule.getStats(player)
	if stats and stats.CollectedItems then
		print(("[InteractionSystem] %s ã®å–å¾—æ¸ˆã¿ãƒªã‚¹ãƒˆã‚’é€ä¿¡: %då€‹"):format(
			player.Name,
			next(stats.CollectedItems) and #stats.CollectedItems or 0
		))
		return stats.CollectedItems
	end
	return {}
end

print("[InteractionSystem] åˆæœŸåŒ–å®Œäº†")
===== ./ServerScriptService/DebugCommands.server.lua =====
-- ServerScriptService/DebugCommands.server.lua
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")

print("[DebugCommands] åˆæœŸåŒ–é–‹å§‹")

-- ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰ï¼ˆæœ¬ç•ªç’°å¢ƒã§ã¯falseã«ï¼‰
local DEBUG_MODE = true

if not DEBUG_MODE then
	print("[DebugCommands] ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰OFF")
	return
end

-- ã€ä¿®æ­£ã€‘RemoteEventã‚’å¿…ãšä½œæˆ
local DebugCommandEvent = Instance.new("RemoteEvent")
DebugCommandEvent.Name = "DebugCommand"
DebugCommandEvent.Parent = ReplicatedStorage
print("[DebugCommands] RemoteEventã‚’ä½œæˆã—ã¾ã—ãŸ")

-- ä¾å­˜ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
local PlayerStatsModule = require(ServerScriptService:WaitForChild("PlayerStats"))

-- ã‚³ãƒãƒ³ãƒ‰å‡¦ç†
DebugCommandEvent.OnServerEvent:Connect(function(player, command, ...)
	print(("[DebugCommands] %s ãŒå®Ÿè¡Œ: %s"):format(player.Name, command))

	if command == "reset_chests" then
		-- å®ç®±ãƒªã‚»ãƒƒãƒˆ
		print("[DebugCommands DEBUG] ãƒªã‚»ãƒƒãƒˆé–‹å§‹")

		local stats = PlayerStatsModule.getStats(player)
		if stats then
			print("[DebugCommands DEBUG] ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å–å¾—æˆåŠŸ")

			-- ãƒªã‚»ãƒƒãƒˆå‰ã®çŠ¶æ…‹
			local beforeCount = 0
			for _ in pairs(stats.CollectedItems) do beforeCount = beforeCount + 1 end
			print(("[DebugCommands DEBUG] ãƒªã‚»ãƒƒãƒˆå‰: %då€‹"):format(beforeCount))

			-- CollectedItemsã‚’ç©ºã«ã™ã‚‹
			stats.CollectedItems = {}

			-- ãƒªã‚»ãƒƒãƒˆå¾Œã®çŠ¶æ…‹
			local afterCount = 0
			for _ in pairs(stats.CollectedItems) do afterCount = afterCount + 1 end
			print(("[DebugCommands DEBUG] ãƒªã‚»ãƒƒãƒˆå¾Œ: %då€‹"):format(afterCount))

			print(("[DebugCommands] %s ã®å–å¾—æ¸ˆã¿ã‚¢ã‚¤ãƒ†ãƒ ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸ"):format(player.Name))

			-- å³åº§ã«ã‚»ãƒ¼ãƒ–
			if _G.AutoSavePlayer then
				print("[DebugCommands DEBUG] ã‚»ãƒ¼ãƒ–é–‹å§‹")
				_G.AutoSavePlayer(player, "ãƒ‡ãƒãƒƒã‚°ãƒªã‚»ãƒƒãƒˆ")
				task.wait(2)
				print("[DebugCommands DEBUG] ã‚»ãƒ¼ãƒ–å®Œäº†")
			else
				warn("[DebugCommands DEBUG] AutoSavePlayer ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ - æ‰‹å‹•ã‚»ãƒ¼ãƒ–ã‚’è©¦è¡Œ")

				-- ã€ä¿®æ­£ã€‘æ‰‹å‹•ã‚»ãƒ¼ãƒ–
				local success, err = pcall(function()
					local DataStoreManager = require(ServerScriptService:WaitForChild("DataStoreManager"))
					local DataCollectors = require(ServerScriptService:WaitForChild("DataCollectors"))

					-- statsã‚’ä½¿ã£ã¦ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆ
					local saveData = DataCollectors.createSaveData(player, stats)

					if saveData then
						print(("[DebugCommands DEBUG] ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ä½œæˆæˆåŠŸ: CollectedItems = %s"):format(
							game:GetService("HttpService"):JSONEncode(saveData.CollectedItems or {})
						))

						DataStoreManager.SavePlayerData(player, saveData)
						print("[DebugCommands DEBUG] æ‰‹å‹•ã‚»ãƒ¼ãƒ–å®Œäº†")
					else
						warn("[DebugCommands DEBUG] ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ä½œæˆå¤±æ•—")
					end
				end)

				if not success then
					warn(("[DebugCommands DEBUG] æ‰‹å‹•ã‚»ãƒ¼ãƒ–ã‚¨ãƒ©ãƒ¼: %s"):format(tostring(err)))
				end
			end
		else
			warn(("[DebugCommands] %s ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"):format(player.Name))
		end
	else
		warn(("[DebugCommands] æœªçŸ¥ã®ã‚³ãƒãƒ³ãƒ‰: %s"):format(command))
	end
end)

print("[DebugCommands] åˆæœŸåŒ–å®Œäº†")
===== ./ServerScriptService/DataStoreManager.lua =====
-- ServerScriptService/DataStoreManager.lua
-- DataStoreã®åŸºæœ¬æ“ä½œã‚’ç®¡ç†ã™ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«

local DataStoreService = game:GetService("DataStoreService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local DataStoreManager = {}

-- DataStoreã®å®šç¾© (ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç®¡ç†ã®ãŸã‚V1)
local PLAYER_DATA_STORE = DataStoreService:GetDataStore("TypingQuestPlayerSaveData_V1")

-- â˜…ä¿®æ­£: WaitForChildã‚’å»ƒæ­¢ã—ã€éãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ã®FindFirstChildã‚’ä½¿ç”¨
local SAVE_SUCCESS_EVENT = ReplicatedStorage:FindFirstChild("SaveSuccess")
local LOAD_GAME_EVENT = ReplicatedStorage:FindFirstChild("LoadGame")

-- DataStoreã‚µãƒ¼ãƒ“ã‚¹å–å¾—
local success, DataStoreService = pcall(function()
	return game:GetService("DataStoreService")
end)

if not success then
	warn("[DataStoreManager] DataStoreãŒç„¡åŠ¹ã§ã™ã€‚Studioè¨­å®šã§æœ‰åŠ¹åŒ–ã—ã¦ãã ã•ã„ã€‚")
	-- ãƒ€ãƒŸãƒ¼ã®DataStoreã‚’è¿”ã™
	return {
		SavePlayerData = function() warn("[DataStore] ä¿å­˜ã‚¹ã‚­ãƒƒãƒ—ï¼ˆç„¡åŠ¹ï¼‰") end,
		LoadPlayerData = function() warn("[DataStore] èª­è¾¼ã‚¹ã‚­ãƒƒãƒ—ï¼ˆç„¡åŠ¹ï¼‰") return nil end,
	}
else
	print("[DataStoreManager] âœ… DataStoreè¨­å®š: æœ‰åŠ¹")
end

local PlayerDataStore = DataStoreService:GetDataStore("PlayerData_v1")

-- ãƒ‡ãƒ¼ã‚¿ã®ä¿å­˜ (éåŒæœŸ)
function DataStoreManager.SaveData(player: Player, data: table)
    local success, err = pcall(function()
        -- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®UserIdã‚’ã‚­ãƒ¼ã¨ã—ã¦ä½¿ç”¨
        PLAYER_DATA_STORE:SetAsync(player.UserId, data)
    end)

    -- ã€ä¿®æ­£ã€‘æ¯å›SaveSuccessEventã‚’å–å¾—
    local SaveSuccessEvent = ReplicatedStorage:FindFirstChild("SaveSuccess")

    if success then
        print(("[DataStoreManager] %s ã®ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜ã—ã¾ã—ãŸã€‚ã‚­ãƒ¼: %d"):format(player.Name, player.UserId))

        -- ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«ä¿å­˜æˆåŠŸã‚’é€šçŸ¥
        if SaveSuccessEvent then
            SaveSuccessEvent:FireClient(player, true)
        end
    else
        warn(("[DataStoreManager] %s ã®ãƒ‡ãƒ¼ã‚¿ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ: %s"):format(player.Name, err))

        -- ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«ä¿å­˜å¤±æ•—ã‚’é€šçŸ¥
        if SaveSuccessEvent then
            SaveSuccessEvent:FireClient(player, false)
        end
    end
    return success
end

-- ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ (éåŒæœŸ)
function DataStoreManager.LoadData(player: Player)
    local data = nil
    local success, err = pcall(function()
        -- ãƒ‡ãƒ¼ã‚¿ã®å–å¾— (ç¢ºå®Ÿã«UserIdã‚’ä½¿ç”¨)
        data = PLAYER_DATA_STORE:GetAsync(player.UserId)
    end)

    if success then
        print(("[DataStoreManager] %s ã®ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸã€‚ã‚­ãƒ¼: %d"):format(player.Name, player.UserId))

        -- ãƒ‡ãƒ¼ã‚¿ãŒnilã®å ´åˆã€æ–°è¦ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã—ã¦ç©ºã®ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’è¿”ã™
        return data or {}
    else
        warn(("[DataStoreManager] %s ã®ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: %s"):format(player.Name, err))
        return {} -- å¤±æ•—ã—ãŸå ´åˆã¯ç©ºã®ãƒ‡ãƒ¼ã‚¿ã‚’è¿”ã—ã€ã‚²ãƒ¼ãƒ ã‚’ç¶™ç¶šã•ã›ã‚‹
    end
end

-- æ‰‹å‹•ãƒ­ãƒ¼ãƒ‰è¦æ±‚ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ (ãƒ­ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³æŠ¼ä¸‹æ™‚)
if LOAD_GAME_EVENT then
    LOAD_GAME_EVENT.OnServerEvent:Connect(function(player)
        -- ç¾çŠ¶ã€ç‰¹åˆ¥ãªå‡¦ç†ã¯ä¸è¦ï¼ˆæ¬¡ã®æ¥ç¶šæ™‚ã«è‡ªå‹•ãƒ­ãƒ¼ãƒ‰ã•ã‚Œã‚‹ãŸã‚ï¼‰
        print(("[DataStoreManager] %s ã‹ã‚‰ãƒ­ãƒ¼ãƒ‰è¦æ±‚ã‚’å—ä¿¡ã—ã¾ã—ãŸã€‚"):format(player.Name))
    end)
else
    warn("[DataStoreManager] LOAD_GAME_EVENT ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚ãƒ­ãƒ¼ãƒ‰è¦æ±‚ãƒªã‚¹ãƒŠãƒ¼ã¯æ©Ÿèƒ½ã—ã¾ã›ã‚“ã€‚")
end

return DataStoreManager
===== ./ServerScriptService/BattleSystem.lua =====
-- ServerScriptService/BattleSystem.lua
-- ãƒãƒˆãƒ«ã‚·ã‚¹ãƒ†ãƒ ã®ç®¡ç†ï¼ˆæ•µã®å®šæœŸæ”»æ’ƒå¯¾å¿œç‰ˆï¼‰
-- ã‚¹ãƒ†ãƒƒãƒ—4: SharedStateçµ±åˆç‰ˆ

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")

-- ã€ã‚¹ãƒ†ãƒƒãƒ—4ã€‘SharedStateã¨GameEventsã‚’ãƒ­ãƒ¼ãƒ‰
local SharedState = require(ReplicatedStorage:WaitForChild("SharedState"))
local GameEvents = require(ReplicatedStorage:WaitForChild("GameEvents"))

local BattleSystem = {}

-- PlayerStatsãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ãƒ­ãƒ¼ãƒ‰
local PlayerStats = require(ServerScriptService:WaitForChild("PlayerStats"))

-- ã€ã‚¹ãƒ†ãƒƒãƒ—4ã€‘ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã‚’SharedStateã«ç§»è¡Œ
-- SharedState.ActiveBattles = {}  -- æ—¢ã«SharedStateã§å®šç¾©æ¸ˆã¿
-- SharedState.GlobalBattleActive = false  -- è¿½åŠ ãŒå¿…è¦
-- SharedState.EndingBattles = {}  -- è¿½åŠ ãŒå¿…è¦
-- SharedState.DefeatedByMonster = {}  -- è¿½åŠ ãŒå¿…è¦

-- åˆæœŸåŒ–ï¼ˆSharedStateã«è¿½åŠ ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’è¨­å®šï¼‰
if not SharedState.GlobalBattleActive then
	SharedState.GlobalBattleActive = false
end
if not SharedState.EndingBattles then
	SharedState.EndingBattles = {}
end
if not SharedState.DefeatedByMonster then
	SharedState.DefeatedByMonster = {}
end

-- ãƒãƒˆãƒ«çµ‚äº†ç›´å¾Œã®ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³
local LastBattleEndTime = 0
local BATTLE_COOLDOWN = 0.5

-- RemoteEvent ã®ä½œæˆ/å–å¾—
local function getOrCreateRemoteEvent(name)
	local event = ReplicatedStorage:FindFirstChild(name)
	if not event then
		event = Instance.new("RemoteEvent")
		event.Name = name
		event.Parent = ReplicatedStorage
		-- print(("[BattleSystem] RemoteEventä½œæˆ: %s"):format(name))
	end
	return event
end

-- RemoteEventsã‚’ä½œæˆ
local BattleStartEvent = getOrCreateRemoteEvent("BattleStart")
local BattleEndEvent = getOrCreateRemoteEvent("BattleEnd")
local BattleVictoryEvent = getOrCreateRemoteEvent("BattleVictory")
local BattleDamageEvent = getOrCreateRemoteEvent("BattleDamage")
local BattleHPUpdateEvent = getOrCreateRemoteEvent("BattleHPUpdate")
local PlayerHPUpdateEvent = getOrCreateRemoteEvent("PlayerHPUpdate")
local StatusUpdateEvent = getOrCreateRemoteEvent("StatusUpdate")
local RequestStatusEvent = getOrCreateRemoteEvent("RequestStatus")
local LevelUpEvent = getOrCreateRemoteEvent("LevelUp")
local ShowDeathUIEvent = getOrCreateRemoteEvent("ShowDeathUI")
local DeathChoiceEvent = getOrCreateRemoteEvent("DeathChoice")
local TypingMistakeEvent = getOrCreateRemoteEvent("TypingMistake")

print("[BattleSystem] RemoteEventsæº–å‚™å®Œäº†")

-- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼å®šç¾©ã‚’å–å¾—
local MonstersRegistry = require(ReplicatedStorage:WaitForChild("Monsters"):WaitForChild("Registry"))

-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«é€ä¿¡
local function sendStatusUpdate(player: Player)
	local stats = PlayerStats.getStats(player)
	if not stats then return end

	local expToNext = stats.Level * 100  -- ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ã«å¿…è¦ãªçµŒé¨“å€¤

	StatusUpdateEvent:FireClient(
		player,
		stats.CurrentHP,
		stats.MaxHP,
		stats.Level,
		stats.Experience,
		expToNext,
		stats.Gold
	)
end

-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒæˆ¦é—˜ä¸­ã‹ãƒã‚§ãƒƒã‚¯
function BattleSystem.isInBattle(player: Player): boolean
	return SharedState.ActiveBattles[player] ~= nil
end

-- ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªãƒãƒˆãƒ«çŠ¶æ…‹ã‚’å–å¾—
function BattleSystem.isAnyBattleActive(): boolean
	return SharedState.GlobalBattleActive
end

-- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼å®šç¾©ã‚’åå‰ã‹ã‚‰å–å¾—
local function getMonsterDef(monsterName)
	for _, def in ipairs(MonstersRegistry) do
		if def.Name == monsterName then
			return def
		end
	end
	return nil
end

-- ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’è¨ˆç®—ï¼ˆæ•µâ†’ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼‰
local function calculateDamage(attackerAttack: number, defenderDefense: number): number
	-- åŸºæœ¬ãƒ€ãƒ¡ãƒ¼ã‚¸ = æ”»æ’ƒåŠ› * 0.5 - å®ˆå‚™åŠ› * 0.25
	local baseDamage = attackerAttack * 0.5 - defenderDefense * 0.25
	baseDamage = math.max(1, baseDamage)  -- æœ€ä½1ãƒ€ãƒ¡ãƒ¼ã‚¸

	-- Â±10%ã®ãƒ©ãƒ³ãƒ€ãƒ å¹…
	local randomMultiplier = 0.9 + math.random() * 0.2  -- 0.9 ~ 1.1
	local finalDamage = baseDamage * randomMultiplier

	return math.floor(finalDamage)  -- æ•´æ•°ã«ä¸¸ã‚ã‚‹
end

-- æ”»æ’ƒé–“éš”ã‚’è¨ˆç®—
local function calculateAttackInterval(playerSpeed: number, enemySpeed: number): number
	-- æ”»æ’ƒé–“éš” = 1 + (ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç´ æ—©ã• / æ•µç´ æ—©ã• - 1) * 0.5
	local interval = 1 + (playerSpeed / enemySpeed - 1) * 0.5
	return math.max(0.5, interval)  -- æœ€ä½0.5ç§’
end

-- æ•µã®æ”»æ’ƒå‡¦ç†
local function enemyAttack(player: Player, battleData)
	if not SharedState.ActiveBattles[player] or SharedState.EndingBattles[player] then
		return  -- ãƒãƒˆãƒ«çµ‚äº†æ¸ˆã¿
	end

	local monsterDef = battleData.monsterDef
	local playerStats = PlayerStats.getStats(player)

	if not playerStats then
		warn(("[BattleSystem] %s ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"):format(player.Name))
		return
	end

	-- ãƒ€ãƒ¡ãƒ¼ã‚¸è¨ˆç®—
	local damage = calculateDamage(monsterDef.Attack, playerStats.Defense)

	print(("[BattleSystem] %s ãŒ %s ã‹ã‚‰ %d ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ãŸ"):format(
		player.Name, battleData.monster.Name, damage
		))

	-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ãƒ€ãƒ¡ãƒ¼ã‚¸
	local isDead = PlayerStats.takeDamage(player, damage)

	-- HPã‚’ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«é€šçŸ¥
	PlayerHPUpdateEvent:FireClient(player, playerStats.CurrentHP, playerStats.MaxHP)

	-- æ­»äº¡åˆ¤å®š
	if isDead then
		print(("[BattleSystem] %s ã¯å€’ã‚ŒãŸï¼"):format(player.Name))
		BattleSystem.endBattle(player, false)  -- æ•—åŒ—
		return
	end

	-- æ¬¡ã®æ”»æ’ƒã‚’ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«
	local attackInterval = calculateAttackInterval(playerStats.Speed, monsterDef.Speed)
	battleData.nextAttackTime = tick() + attackInterval

	print(("[BattleSystem] æ¬¡ã®æ”»æ’ƒã¾ã§ %.1f ç§’"):format(attackInterval))
end

-- ãƒãƒˆãƒ«é–‹å§‹
function BattleSystem.startBattle(player: Player, monster: Model)
	print(("[BattleSystem] startBattleå‘¼ã³å‡ºã—: %s vs %s"):format(player.Name, monster.Name))

	-- ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ãƒã‚§ãƒƒã‚¯
	local timeSinceLastBattle = tick() - LastBattleEndTime
	if timeSinceLastBattle < BATTLE_COOLDOWN then
		return false
	end

	-- äºŒé‡ãƒã‚§ãƒƒã‚¯
	if SharedState.GlobalBattleActive then
		return false
	end

	if BattleSystem.isInBattle(player) then
		return false
	end

	-- çµ‚äº†å‡¦ç†ä¸­ãƒã‚§ãƒƒã‚¯
	if SharedState.EndingBattles[player] then
		print(("[BattleSystem] %s ã¯çµ‚äº†å‡¦ç†ä¸­ã§ã™"):format(player.Name))
		return false
	end

	local character = player.Character
	if not character then
		return false
	end

	local humanoid = character:FindFirstChildOfClass("Humanoid")
	local hrp = character:FindFirstChild("HumanoidRootPart")
	local monsterHumanoid = monster:FindFirstChildOfClass("Humanoid")
	local monsterHrp = monster.PrimaryPart

	if not humanoid or not hrp or not monsterHumanoid or not monsterHrp then
		return false
	end

	-- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã®ç¨®é¡ã‚’å–å¾—
	local monsterKind = monster:GetAttribute("MonsterKind") or "Unknown"
	local monsterDef = getMonsterDef(monsterKind)

	if not monsterDef then
		warn(("[BattleSystem] ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼å®šç¾©ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: %s"):format(monsterKind))
		return false
	end

	-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’å–å¾—
	local playerStats = PlayerStats.getStats(player)
	if not playerStats then
		warn(("[BattleSystem] %s ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"):format(player.Name))
		return false
	end

	print(("[BattleSystem] ãƒãƒˆãƒ«é–‹å§‹: %s vs %s"):format(player.Name, monster.Name))
	print(("  ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼: HP %d/%d, ç´ æ—©ã• %d, æ”»æ’ƒ %d, å®ˆå‚™ %d"):format(
		playerStats.CurrentHP, playerStats.MaxHP,
		playerStats.Speed, playerStats.Attack, playerStats.Defense
		))
	print(("  ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼: HP %d, ç´ æ—©ã• %d, æ”»æ’ƒ %d, å®ˆå‚™ %d"):format(
		monsterDef.HP, monsterDef.Speed, monsterDef.Attack, monsterDef.Defense
		))

	-- ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒãƒˆãƒ«ãƒ•ãƒ©ã‚°ã‚’ON
	SharedState.GlobalBattleActive = true

	-- å…ƒã®é€Ÿåº¦ã‚’ä¿å­˜
	local originalPlayerSpeed = humanoid.WalkSpeed
	local originalJumpPower = humanoid.JumpPower
	local originalMonsterSpeed = monsterHumanoid.WalkSpeed

	-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å®Œå…¨åœæ­¢
	humanoid.WalkSpeed = 0
	humanoid.JumpPower = 0
	humanoid.JumpHeight = 0

	-- ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Œå…¨åœæ­¢
	for _, track in pairs(humanoid:GetPlayingAnimationTracks()) do
		track:Stop(0)
	end

	humanoid:ChangeState(Enum.HumanoidStateType.Physics)
	task.wait(0.05)
	humanoid:ChangeState(Enum.HumanoidStateType.Running)
	hrp.Anchored = true
	hrp.AssemblyLinearVelocity = Vector3.zero
	hrp.AssemblyAngularVelocity = Vector3.zero

	-- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’å®Œå…¨åœæ­¢
	monsterHumanoid.WalkSpeed = 0
	monsterHumanoid.JumpPower = 0
	monsterHumanoid:MoveTo(monsterHrp.Position)

	-- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã®å…¨ãƒ‘ãƒ¼ãƒ„ã‚’Anchor
	for _, part in ipairs(monster:GetDescendants()) do
		if part:IsA("BasePart") then
			part.Anchored = true
		end
	end

	-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®1æ–‡å­—ã‚ãŸã‚Šã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’è¨ˆç®—
	local damagePerKey = math.floor(playerStats.Attack * 0.8)
	damagePerKey = math.max(1, damagePerKey)  -- æœ€ä½1ãƒ€ãƒ¡ãƒ¼ã‚¸

	-- æ•µã®æœ€åˆã®æ”»æ’ƒã‚¿ã‚¤ãƒŸãƒ³ã‚°ã‚’è¨ˆç®—
	local attackInterval = calculateAttackInterval(playerStats.Speed, monsterDef.Speed)
	local nextAttackTime = tick() + attackInterval

	-- æˆ¦é—˜ãƒ‡ãƒ¼ã‚¿ã‚’è¨˜éŒ²
	SharedState.ActiveBattles[player] = {
		monster = monster,
		monsterDef = monsterDef,
		monsterHP = monsterDef.HP,
		monsterMaxHP = monsterDef.HP,
		damagePerKey = damagePerKey,
		nextAttackTime = nextAttackTime,
		startTime = tick(),
		originalPlayerSpeed = originalPlayerSpeed,
		originalJumpPower = originalJumpPower,
		originalMonsterSpeed = originalMonsterSpeed
	}

	-- ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«ãƒãƒˆãƒ«é–‹å§‹ã‚’é€šçŸ¥
	BattleStartEvent:FireClient(
		player,
		monster.Name,
		monsterDef.HP,
		monsterDef.HP,
		damagePerKey,
		monsterDef.TypingLevels or {{level = "level_1", weight = 100}},
		playerStats.CurrentHP,
		playerStats.MaxHP
	)

	-- æ•µã®æ”»æ’ƒãƒ«ãƒ¼ãƒ—ã‚’é–‹å§‹
	task.spawn(function()
		while SharedState.ActiveBattles[player] and not SharedState.EndingBattles[player] do
			local battleData = SharedState.ActiveBattles[player]
			if not battleData then break end

			-- æ”»æ’ƒã‚¿ã‚¤ãƒŸãƒ³ã‚°ã‚’ãƒã‚§ãƒƒã‚¯
			if tick() >= battleData.nextAttackTime then
				enemyAttack(player, battleData)
			end

			task.wait(0.1)  -- 0.1ç§’ã”ã¨ã«ãƒã‚§ãƒƒã‚¯
		end
	end)

	return true
end

-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‹ã‚‰ã®ãƒ€ãƒ¡ãƒ¼ã‚¸å‡¦ç†
local function onDamageReceived(player, damageAmount)
	-- ãƒãƒˆãƒ«çµ‚äº†å‡¦ç†ä¸­ã¯ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ç„¡è¦–
	if SharedState.EndingBattles[player] then
		print(("[BattleSystem] %s ã¯çµ‚äº†å‡¦ç†ä¸­ã®ãŸã‚ã€ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ç„¡è¦–"):format(player.Name))
		return
	end

	local battleData = SharedState.ActiveBattles[player]
	if not battleData then
		warn(("[BattleSystem] %s ã¯ãƒãƒˆãƒ«ä¸­ã§ã¯ã‚ã‚Šã¾ã›ã‚“ï¼ˆãƒ€ãƒ¡ãƒ¼ã‚¸ç„¡è¦–ï¼‰"):format(player.Name))
		return
	end

	-- HPã‚’æ¸›ã‚‰ã™
	local oldHP = battleData.monsterHP
	battleData.monsterHP = math.max(0, battleData.monsterHP - damageAmount)

	print(("[BattleSystem] ========================================"):format())
	print(("[BattleSystem] ãƒ€ãƒ¡ãƒ¼ã‚¸å‡¦ç†"):format())
	print(("  ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼: %s"):format(player.Name))
	print(("  ãƒ€ãƒ¡ãƒ¼ã‚¸é‡: %d"):format(damageAmount))
	print(("  HPå¤‰åŒ–: %d â†’ %d"):format(oldHP, battleData.monsterHP))
	print(("  æœ€å¤§HP: %d"):format(battleData.monsterMaxHP))
	print(("[BattleSystem] ========================================"):format())

	-- ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«HPæ›´æ–°ã‚’é€šçŸ¥
	BattleHPUpdateEvent:FireClient(player, battleData.monsterHP)

	-- HPãŒ0ã«ãªã£ãŸã‚‰å‹åˆ©
	if battleData.monsterHP <= 0 then
		print(("[BattleSystem] ========================================"):format())
		print(("[BattleSystem] ğŸ‰ å‹åˆ©æ¡ä»¶é”æˆï¼"):format())
		print(("  %s ãŒ %s ã‚’å€’ã—ã¾ã—ãŸï¼"):format(player.Name, battleData.monster.Name))
		print(("  ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼HP: %d"):format(battleData.monsterHP))
		print(("[BattleSystem] endBattle(true) ã‚’å‘¼ã³å‡ºã—ã¾ã™"):format())
		print(("[BattleSystem] ========================================"):format())

		BattleSystem.endBattle(player, true)

		print(("[BattleSystem] endBattle(true) å‘¼ã³å‡ºã—å®Œäº†"):format())
	end
end

-- ãƒãƒˆãƒ«çµ‚äº†
function BattleSystem.endBattle(player: Player, victory: boolean)
	print(("[BattleSystem] ãƒãƒˆãƒ«çµ‚äº†: %s - %s"):format(
		player.Name, victory and "å‹åˆ©" or "æ•—åŒ—"
		))

	-- äºŒé‡çµ‚äº†ãƒã‚§ãƒƒã‚¯
	if SharedState.EndingBattles[player] then
		warn(("[BattleSystem] %s ã¯æ—¢ã«çµ‚äº†å‡¦ç†ä¸­ã§ã™"):format(player.Name))
		return
	end

	-- çµ‚äº†å‡¦ç†ä¸­ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹
	SharedState.EndingBattles[player] = true

	-- ã€é‡è¦ã€‘å‹åˆ©æ™‚ã®ã¿ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒãƒˆãƒ«ãƒ•ãƒ©ã‚°ã‚’OFF
	-- æ•—åŒ—æ™‚ã¯æ­»äº¡é¸æŠãŒå®Œäº†ã™ã‚‹ã¾ã§ç¶­æŒ
	if victory then
		SharedState.GlobalBattleActive = false
	end

	-- ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³é–‹å§‹
	LastBattleEndTime = tick()

	local battleData = SharedState.ActiveBattles[player]
	if not battleData then
		warn("[BattleSystem] battleDataãŒå­˜åœ¨ã—ã¾ã›ã‚“ï¼")

		-- æœ€ä½é™ã®å¾©å…ƒ
		local character = player.Character
		if character then
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			local hrp = character:FindFirstChild("HumanoidRootPart")
			if humanoid then
				humanoid.WalkSpeed = 16
				humanoid.JumpPower = 50
				humanoid.JumpHeight = 7.2
			end
			if hrp then
				hrp.Anchored = false
			end
		end

		BattleEndEvent:FireClient(player, victory)
		SharedState.ActiveBattles[player] = nil

		-- çµ‚äº†å‡¦ç†å®Œäº†å¾Œã«ãƒ•ãƒ©ã‚°ã‚’è§£é™¤
		task.delay(1, function()
			SharedState.EndingBattles[player] = nil
		end)

		return
	end

	local character = player.Character
	local monster = battleData.monster
	local monsterDef = battleData.monsterDef

	-- å‹åˆ©æ™‚ã®å‡¦ç†
	if victory then
		-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç§»å‹•ã‚’å¾©å…ƒ
		if character then
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			local hrp = character:FindFirstChild("HumanoidRootPart")
			if humanoid then
				humanoid.WalkSpeed = battleData.originalPlayerSpeed or 16
				humanoid.JumpPower = battleData.originalJumpPower or 50
				humanoid.JumpHeight = 7.2
			end
			if hrp then
				hrp.Anchored = false
			end
		end

		-- çµŒé¨“å€¤ã¨ã‚´ãƒ¼ãƒ«ãƒ‰ã‚’ä»˜ä¸
		if monsterDef.Experience then
			print(("[BattleSystem] çµŒé¨“å€¤ %d ã‚’ä»˜ä¸"):format(monsterDef.Experience))
			PlayerStats.addExperience(player, monsterDef.Experience)
		end
		if monsterDef.Gold then
			print(("[BattleSystem] ã‚´ãƒ¼ãƒ«ãƒ‰ %d ã‚’ä»˜ä¸"):format(monsterDef.Gold))
			PlayerStats.addGold(player, monsterDef.Gold)
		end

		print(("[BattleSystem] ========================================"):format())
		print(("[BattleSystem] ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æ’ƒç ´ã‚«ã‚¦ãƒ³ãƒˆå‡¦ç†é–‹å§‹"):format())
		print(("[BattleSystem] ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼: %s"):format(player.Name))
		print(("[BattleSystem] ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼: %s"):format(battleData.monster.Name))


		PlayerStats.addMonstersDefeated(player, 1)

		print(("[BattleSystem] ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æ’ƒç ´ã‚«ã‚¦ãƒ³ãƒˆå‡¦ç†å®Œäº†"):format())
		print(("[BattleSystem] ========================================"):format())


		-- å°‘ã—å¾…ã£ã¦ã‹ã‚‰ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°ã‚’é€ä¿¡ï¼ˆå¿µã®ãŸã‚ï¼‰
		task.wait(0.1)
		sendStatusUpdate(player)

		-- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’éè¡¨ç¤º
		monster:SetAttribute("Defeated", true)

		for _, part in ipairs(monster:GetDescendants()) do
			if part:IsA("BasePart") then
				part.Transparency = 1
			end
		end

		local hrp = monster:FindFirstChild("HumanoidRootPart")
		if hrp then
			local gui = hrp:FindFirstChild("DebugInfo")
			if gui then
				gui.Enabled = false
			end
		end

		-- 1ç§’å¾Œã«å‰Šé™¤
		task.delay(1, function()
			if monster and monster.Parent then
				monster:Destroy()
			end
		end)
	else
		-- æ•—åŒ—æ™‚ï¼šãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯ç§»å‹•åˆ¶é™ã‚’ç¶­æŒï¼ˆæ­»äº¡é¸æŠUIã§é¸ã‚“ã å¾Œã«å¾©å…ƒï¼‰
		-- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’å¾©å…ƒ
		monster:SetAttribute("InBattle", false)

		local monsterHumanoid = monster:FindFirstChildOfClass("Humanoid")
		if monsterHumanoid then
			monsterHumanoid.WalkSpeed = battleData.originalMonsterSpeed or 14
		end

		-- Anchorè§£é™¤
		local partsToUnanchor = {}
		for _, part in ipairs(monster:GetDescendants()) do
			if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
				table.insert(partsToUnanchor, part)
			end
		end

		for _, part in ipairs(partsToUnanchor) do
			part.Anchored = false
		end

		if monster.PrimaryPart then
			task.wait(0.1)
			monster.PrimaryPart.Anchored = false
		end

		-- æ­»äº¡æ™‚ã®é¸æŠUIã‚’è¡¨ç¤º
		local playerStats = PlayerStats.getStats(player)
		if playerStats then
			local reviveCost = math.floor(playerStats.Level * 50)  -- ãƒ¬ãƒ™ãƒ« * 50ã‚´ãƒ¼ãƒ«ãƒ‰
			print(("[BattleSystem] ========================================"):format())
			print(("[BattleSystem] æ­»äº¡UIè¡¨ç¤ºã‚’é€ä¿¡"):format())
			print(("[BattleSystem] æ‰€æŒé‡‘: %d G, å¾©æ´»ã‚³ã‚¹ãƒˆ: %d G"):format(playerStats.Gold, reviveCost))
			print(("[BattleSystem] ========================================"):format())

			-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«æ­»äº¡ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹ï¼ˆãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ãŒæ¥è§¦ã—ãªã„ã‚ˆã†ã«ï¼‰
			if character then
				character:SetAttribute("IsDead", true)
				print(("[BattleSystem] %s ã«æ­»äº¡ãƒ•ãƒ©ã‚°ã‚’è¨­å®š"):format(player.Name))
			end

			-- ã€é‡è¦ã€‘å€’ã—ãŸãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’è¨˜éŒ²ï¼ˆé¸æŠå¾Œã«æ¶ˆå»ã™ã‚‹ãŸã‚ï¼‰
			SharedState.DefeatedByMonster[player] = monster
			print(("[BattleSystem] å€’ã—ãŸãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ %s ã‚’è¨˜éŒ²"):format(monster.Name))

			ShowDeathUIEvent:FireClient(player, playerStats.Gold, reviveCost)
		else
			warn("[BattleSystem] ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ï¼")
		end
	end

	-- ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«é€šçŸ¥
	BattleEndEvent:FireClient(player, victory)

	-- å‹åˆ©æ™‚ã¯æˆ¦é—˜ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¯ãƒªã‚¢ã—ã¦çµ‚äº†å‡¦ç†ãƒ•ãƒ©ã‚°ã‚‚è§£é™¤
	if victory then
		SharedState.ActiveBattles[player] = nil

		-- çµ‚äº†å‡¦ç†å®Œäº†å¾Œã«ãƒ•ãƒ©ã‚°ã‚’è§£é™¤ï¼ˆ1ç§’å¾Œï¼‰
		task.delay(1, function()
			SharedState.EndingBattles[player] = nil
			print(("[BattleSystem] %s ã®çµ‚äº†å‡¦ç†ãƒ•ãƒ©ã‚°ã‚’è§£é™¤"):format(player.Name))
		end)
	else
		-- æ•—åŒ—æ™‚ã¯æˆ¦é—˜ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¯ãƒªã‚¢ã™ã‚‹ãŒã€çµ‚äº†å‡¦ç†ãƒ•ãƒ©ã‚°ã¯ç¶­æŒ
		-- ï¼ˆæ­»äº¡é¸æŠUIã§é¸ã‚“ã å¾Œã«è§£é™¤ã™ã‚‹ï¼‰
		SharedState.ActiveBattles[player] = nil
		print(("[BattleSystem] æ•—åŒ— - çµ‚äº†å‡¦ç†ãƒ•ãƒ©ã‚°ã‚’ç¶­æŒã—ã¾ã™ï¼ˆé¸æŠã¾ã§ï¼‰"))
	end
end

-- åˆæœŸåŒ–
function BattleSystem.init()
	-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚¤ãƒ™ãƒ³ãƒˆ
	RequestStatusEvent.OnServerEvent:Connect(function(player)
		print(("[BattleSystem] %s ãŒã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’è¦æ±‚ã—ã¾ã—ãŸ"):format(player.Name))
		sendStatusUpdate(player)
	end)

	-- ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚¤ãƒ™ãƒ³ãƒˆ
	BattleDamageEvent.OnServerEvent:Connect(function(player, damageAmount)
		print(("[BattleSystem] ãƒ€ãƒ¡ãƒ¼ã‚¸é€šçŸ¥å—ä¿¡: %s -> %d"):format(player.Name, damageAmount))
		onDamageReceived(player, damageAmount)
	end)

	-- å‹åˆ©ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆå¿µã®ãŸã‚æ®‹ã—ã¦ãŠãï¼‰
	BattleVictoryEvent.OnServerEvent:Connect(function(player)
		print(("[BattleSystem] å‹åˆ©é€šçŸ¥å—ä¿¡: %s"):format(player.Name))

		if BattleSystem.isInBattle(player) then
			BattleSystem.endBattle(player, true)
		end
	end)

	-- æ­»äº¡æ™‚ã®é¸æŠã‚¤ãƒ™ãƒ³ãƒˆ
	DeathChoiceEvent.OnServerEvent:Connect(function(player, choice)
		print(("[BattleSystem] %s ãŒé¸æŠ: %s"):format(player.Name, choice))

		-- ã€é‡è¦ã€‘ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒãƒˆãƒ«ãƒ•ãƒ©ã‚°ã‚’è§£é™¤ï¼ˆæ•—åŒ—æ™‚ã«ç¶­æŒã—ã¦ã„ãŸï¼‰
		SharedState.GlobalBattleActive = false
		print("[BattleSystem] ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒãƒˆãƒ«ãƒ•ãƒ©ã‚°ã‚’è§£é™¤")

		-- ã€é‡è¦ã€‘çµ‚äº†å‡¦ç†ãƒ•ãƒ©ã‚°ã‚’è§£é™¤ï¼ˆãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ãŒæ¥è§¦ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ï¼‰
		SharedState.EndingBattles[player] = nil
		print(("[BattleSystem] %s ã®çµ‚äº†å‡¦ç†ãƒ•ãƒ©ã‚°ã‚’è§£é™¤"):format(player.Name))

		local playerStats = PlayerStats.getStats(player)
		if not playerStats then return end

		-- æ­»äº¡ãƒ•ãƒ©ã‚°ã‚’è§£é™¤
		local character = player.Character
		if character then
			character:SetAttribute("IsDead", false)
			print(("[BattleSystem] %s ã®æ­»äº¡ãƒ•ãƒ©ã‚°ã‚’è§£é™¤"):format(player.Name))
		end

		-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç§»å‹•åˆ¶é™ã‚’è§£é™¤
		if character then
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			local hrp = character:FindFirstChild("HumanoidRootPart")
			if humanoid then
				humanoid.WalkSpeed = 16
				humanoid.JumpPower = 50
				humanoid.JumpHeight = 7.2
			end
			if hrp then
				hrp.Anchored = false
			end
		end

		-- ã€é‡è¦ã€‘å€’ã—ãŸãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’æ¶ˆå»ï¼ˆä¸¡æ–¹ã®é¸æŠè‚¢ã§æ¶ˆå»ï¼‰
		local defeatedMonster = SharedState.DefeatedByMonster[player]
		if defeatedMonster and defeatedMonster.Parent then
			print(("[BattleSystem] å€’ã—ãŸãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ %s ã‚’æ¶ˆå»"):format(defeatedMonster.Name))

			-- éè¡¨ç¤ºåŒ–
			defeatedMonster:SetAttribute("Defeated", true)
			for _, part in ipairs(defeatedMonster:GetDescendants()) do
				if part:IsA("BasePart") then
					part.Transparency = 1
				end
			end

			-- ãƒ©ãƒ™ãƒ«éè¡¨ç¤º
			local hrp = defeatedMonster:FindFirstChild("HumanoidRootPart")
			if hrp then
				local gui = hrp:FindFirstChild("DebugInfo")
				if gui then
					gui.Enabled = false
				end
			end

			-- å‰Šé™¤
			task.delay(0.5, function()
				if defeatedMonster and defeatedMonster.Parent then
					defeatedMonster:Destroy()
				end
			end)
		end

		-- è¨˜éŒ²ã‚’ã‚¯ãƒªã‚¢
		SharedState.DefeatedByMonster[player] = nil

		if choice == "return" then
			-- è¡—ã«æˆ»ã‚‹
			print(("[BattleSystem] %s ã‚’è¡—ã«æˆ»ã—ã¾ã™"):format(player.Name))

			-- HPã‚’å…¨å›å¾©
			PlayerStats.fullHeal(player)

			-- StartTownã®åº§æ¨™ã‚’å–å¾—
			print("[BattleSystem] StartTownã®åº§æ¨™ã‚’å–å¾—ä¸­...")
			local IslandsRegistry = require(ReplicatedStorage:WaitForChild("Islands"):WaitForChild("Registry"))
			print(("[BattleSystem] IslandsRegistryå–å¾—å®Œäº†ã€‚å³¶ã®æ•°: %d"):format(#IslandsRegistry))

			local townConfig = nil
			for i, island in ipairs(IslandsRegistry) do
				print(("[BattleSystem] å³¶ %d: name=%s"):format(i, tostring(island.name)))
				if island.name == "StartTown" then
					townConfig = island
					print("[BattleSystem] StartTownã‚’ç™ºè¦‹ï¼")
					break
				end
			end

			-- è¡—ã«ãƒ†ãƒ¬ãƒãƒ¼ãƒˆ
			if character and townConfig then
				local hrp = character:FindFirstChild("HumanoidRootPart")
				if hrp then
					local spawnX = townConfig.centerX
					local spawnZ = townConfig.centerZ
					local spawnY = townConfig.baseY + 50  -- é«˜ã‚ã«è¨­å®š
					print(("[BattleSystem] ãƒ†ãƒ¬ãƒãƒ¼ãƒˆåº§æ¨™: X=%.0f, Y=%.0f, Z=%.0f"):format(
						spawnX, spawnY, spawnZ
						))

					-- ãƒ†ãƒ¬ãƒãƒ¼ãƒˆå®Ÿè¡Œ
					hrp.CFrame = CFrame.new(spawnX, spawnY, spawnZ)

					-- å°‘ã—å¾…ã£ã¦ã‹ã‚‰å†åº¦è¨­å®šï¼ˆä»–ã®ã‚·ã‚¹ãƒ†ãƒ ã®å¹²æ¸‰ã‚’é˜²ãï¼‰
					task.wait(0.1)
					hrp.CFrame = CFrame.new(spawnX, spawnY, spawnZ)

					print(("[BattleSystem] %s ã‚’è¡—ã«ãƒ†ãƒ¬ãƒãƒ¼ãƒˆå®Œäº†"):format(player.Name))

					-- ZoneManagerã«ã‚‚é€šçŸ¥
					local ZoneManager = require(ServerScriptService:WaitForChild("ZoneManager"))
					ZoneManager.PlayerZones[player] = "StartTown"
					print("[BattleSystem] ZoneManagerã«StartTownã‚’è¨˜éŒ²")

					-- ã€é‡è¦ã€‘StartTownã®ãƒãƒ¼ã‚¿ãƒ«ã‚’å†ç”Ÿæˆ
					if _G.CreatePortalsForZone then
						print("[BattleSystem] StartTownã®ãƒãƒ¼ã‚¿ãƒ«ã‚’å†ç”Ÿæˆ")
						_G.CreatePortalsForZone("StartTown")
					else
						warn("[BattleSystem] CreatePortalsForZoneé–¢æ•°ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
					end
				end
			elseif character then
				-- ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼štownConfigãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆ
				warn("[BattleSystem] StartTownãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ï¼")
				print("[BattleSystem] ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼šåŸç‚¹ã«ãƒ†ãƒ¬ãƒãƒ¼ãƒˆ")
				local hrp = character:FindFirstChild("HumanoidRootPart")
				if hrp then
					hrp.CFrame = CFrame.new(0, 50, 0)
				end
			end

			-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°
			sendStatusUpdate(player)

		elseif choice == "revive" then
			-- ã‚´ãƒ¼ãƒ«ãƒ‰ã§å¾©æ´»
			local reviveCost = math.floor(playerStats.Level * 50)

			if PlayerStats.removeGold(player, reviveCost) then
				print(("[BattleSystem] %s ãŒã‚´ãƒ¼ãƒ«ãƒ‰ %d ã§å¾©æ´»"):format(player.Name, reviveCost))

				-- HPã‚’å…¨å›å¾©
				PlayerStats.fullHeal(player)

				-- ã€é‡è¦ã€‘å¾©æ´»å¾Œã®ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ã‚’è¨­å®šï¼ˆ3ç§’é–“ãƒãƒˆãƒ«ä¸å¯ï¼‰
				LastBattleEndTime = tick()
				print("[BattleSystem] å¾©æ´»å¾Œã®ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³é–‹å§‹")

				-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°
				sendStatusUpdate(player)
			else
				warn(("[BattleSystem] %s ã®ã‚´ãƒ¼ãƒ«ãƒ‰ãŒä¸è¶³ã—ã¦ã„ã¾ã™"):format(player.Name))
			end
		end
	end)

	-- ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚¤ãƒ™ãƒ³ãƒˆ
	BattleDamageEvent.OnServerEvent:Connect(function(player, damageAmount)
		print(("[BattleSystem] ãƒ€ãƒ¡ãƒ¼ã‚¸é€šçŸ¥å—ä¿¡: %s -> %d"):format(player.Name, damageAmount))
		onDamageReceived(player, damageAmount)
	end)

	-- ã‚¿ã‚¤ãƒ—ãƒŸã‚¹ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆæ–°è¦è¿½åŠ ï¼‰
	TypingMistakeEvent.OnServerEvent:Connect(function(player)
		print(("[BattleSystem] ã‚¿ã‚¤ãƒ—ãƒŸã‚¹å—ä¿¡: %s"):format(player.Name))

		local battleData = SharedState.ActiveBattles[player]
		if not battleData then
			warn(("[BattleSystem] %s ã¯ãƒãƒˆãƒ«ä¸­ã§ã¯ã‚ã‚Šã¾ã›ã‚“ï¼ˆã‚¿ã‚¤ãƒ—ãƒŸã‚¹ç„¡è¦–ï¼‰"):format(player.Name))
			return
		end

		local monsterDef = battleData.monsterDef
		local playerStats = PlayerStats.getStats(player)

		if not playerStats then
			warn(("[BattleSystem] %s ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"):format(player.Name))
			return
		end

		-- ã‚¿ã‚¤ãƒ—ãƒŸã‚¹ãƒ€ãƒ¡ãƒ¼ã‚¸ = æ•µã®é€šå¸¸æ”»æ’ƒã®åŠåˆ†
		local normalDamage = calculateDamage(monsterDef.Attack, playerStats.Defense)
		local mistakeDamage = math.floor(normalDamage * 0.5)
		mistakeDamage = math.max(1, mistakeDamage)  -- æœ€ä½1ãƒ€ãƒ¡ãƒ¼ã‚¸

		print(("[BattleSystem] %s ãŒã‚¿ã‚¤ãƒ—ãƒŸã‚¹ã§ %d ãƒ€ãƒ¡ãƒ¼ã‚¸"):format(player.Name, mistakeDamage))

		-- ãƒ€ãƒ¡ãƒ¼ã‚¸å‡¦ç†
		local isDead = PlayerStats.takeDamage(player, mistakeDamage)

		-- HPã‚’ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«é€šçŸ¥
		PlayerHPUpdateEvent:FireClient(player, playerStats.CurrentHP, playerStats.MaxHP)

		-- æ­»äº¡åˆ¤å®š
		if isDead then
			print(("[BattleSystem] %s ã¯ã‚¿ã‚¤ãƒ—ãƒŸã‚¹ã§å€’ã‚ŒãŸï¼"):format(player.Name))
			BattleSystem.endBattle(player, false)  -- æ•—åŒ—
		end
	end)

	-- å‹åˆ©ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆå¿µã®ãŸã‚æ®‹ã—ã¦ãŠãï¼‰

	-- ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯æ¤œå‡º
	task.spawn(function()
		while true do
			task.wait(5)

			for player, battleData in pairs(SharedState.ActiveBattles) do
				local duration = tick() - battleData.startTime

				if duration > 60 then
					warn(("[BattleSystem] ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯æ¤œå‡ºï¼ %s ã®ãƒãƒˆãƒ«ã‚’å¼·åˆ¶çµ‚äº†"):format(player.Name))
					BattleSystem.endBattle(player, false)
				end
			end
		end
	end)

	print("[BattleSystem] åˆæœŸåŒ–å®Œäº†ï¼ˆæ•µæ”»æ’ƒã‚·ã‚¹ãƒ†ãƒ å¯¾å¿œï¼‰")
end

-- ãƒãƒˆãƒ«çŠ¶æ…‹ã‚’å¼·åˆ¶ãƒªã‚»ãƒƒãƒˆ
function BattleSystem.resetAllBattles()
	print("[BattleSystem] å…¨ãƒãƒˆãƒ«çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ")

	SharedState.GlobalBattleActive = false

	for player, _ in pairs(SharedState.ActiveBattles) do
		SharedState.ActiveBattles[player] = nil
		SharedState.EndingBattles[player] = nil

		if player.Character then
			player.Character:SetAttribute("InBattle", false)

			local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
			local hrp = player.Character:FindFirstChild("HumanoidRootPart")
			if humanoid then
				humanoid.WalkSpeed = 16
				humanoid.JumpPower = 50
				humanoid.JumpHeight = 7.2
			end
			if hrp then
				hrp.Anchored = false
			end
		end
	end

	local monstersFolder = workspace:FindFirstChild("Monsters")
	if monstersFolder then
		for _, model in ipairs(monstersFolder:GetChildren()) do
			if model:IsA("Model") then
				model:SetAttribute("InBattle", false)
				model:SetAttribute("Defeated", false)
			end
		end
	end

	for _, model in ipairs(workspace:GetChildren()) do
		if model:IsA("Model") and model:GetAttribute("IsEnemy") then
			model:SetAttribute("InBattle", false)
			model:SetAttribute("Defeated", false)
		end
	end

	print("[BattleSystem] ãƒªã‚»ãƒƒãƒˆå®Œäº†")
end

return BattleSystem
===== ./ServerScriptService/MonsterSpawner.server.lua =====
-- ServerScriptService/MonsterSpawner.server.lua
-- ã‚¾ãƒ¼ãƒ³å¯¾å¿œç‰ˆãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼é…ç½®ã‚·ã‚¹ãƒ†ãƒ ï¼ˆãƒãƒˆãƒ«é«˜é€ŸåŒ–ç‰ˆã€å¾˜å¾ŠAIä¿®æ­£ç‰ˆï¼‰

local ServerStorage = game:GetService("ServerStorage")
local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local FieldGen = require(ReplicatedStorage:WaitForChild("FieldGen"))
local ZoneManager = require(script.Parent.ZoneManager)

local SharedState = require(ReplicatedStorage:WaitForChild("SharedState"))
local GameEvents = require(ReplicatedStorage:WaitForChild("GameEvents"))
local ContinentsRegistry = require(ReplicatedStorage.Continents.Registry)

-- BattleSystemèª­è¾¼ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒŠãƒ«ï¼‰
local BattleSystem = nil
local battleSystemScript = script.Parent:FindFirstChild("BattleSystem")
if battleSystemScript then
	local success, result = pcall(function()
		return require(battleSystemScript)
	end)
	if success then
		BattleSystem = result
		print("[MonsterSpawner] BattleSystemèª­ã¿è¾¼ã¿æˆåŠŸ")
	else
		warn("[MonsterSpawner] BattleSystemèª­ã¿è¾¼ã¿å¤±æ•—:", result)
	end
else
	warn("[MonsterSpawner] BattleSystemãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ - ãƒãƒˆãƒ«æ©Ÿèƒ½ã¯ç„¡åŠ¹ã§ã™")
end

-- Registryèª­è¾¼
local MonstersFolder = ReplicatedStorage:WaitForChild("Monsters")
local Registry = require(MonstersFolder:WaitForChild("Registry"))

-- å³¶ã®è¨­å®šã‚’èª­ã¿è¾¼ã¿
local IslandsRegistry = require(ReplicatedStorage.Islands.Registry)
local Islands = {}
for _, island in ipairs(IslandsRegistry) do
	Islands[island.name] = island
end

-- ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
local ActiveMonsters = {}
local UpdateInterval = 0.05
local MonsterCounts = {}
local TemplateCache = {}
local RespawnQueue = {}

-- å®‰å…¨åœ°å¸¯ãƒã‚§ãƒƒã‚¯
local function isSafeZone(zoneName)
	local island = Islands[zoneName]
	if island and island.safeZone then
		return true
	end
	return false
end

-- ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°
local function resolveTemplate(pathArray: {string}): Model?
	local node: Instance = game
	for _, seg in ipairs(pathArray) do
		node = node:FindFirstChild(seg)
		if not node then return nil end
	end
	return (node and node:IsA("Model")) and node or nil
end

local function ensureHRP(model: Model): BasePart?
	local hrp = model:FindFirstChild("HumanoidRootPart")
	if hrp and hrp:IsA("BasePart") then
		if not model.PrimaryPart then model.PrimaryPart = hrp end
		return hrp
	end
	return nil
end

local function attachLabel(model: Model, maxDist: number)
	local hrp = model.PrimaryPart or model:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	local _, bboxSize = model:GetBoundingBox()
	local labelOffset = math.min(bboxSize.Y * 0.5 + 2, 15)

	local gui = Instance.new("BillboardGui")
	gui.Name = "DebugInfo"
	gui.Adornee = hrp
	gui.AlwaysOnTop = true
	gui.Size = UDim2.new(0, 150, 0, 50)
	gui.StudsOffset = Vector3.new(0, labelOffset, 0)
	gui.MaxDistance = maxDist
	gui.Parent = hrp

	local lb = Instance.new("TextLabel")
	lb.Name = "InfoText"
	lb.BackgroundTransparency = 1
	lb.TextScaled = true
	lb.Font = Enum.Font.GothamBold
	lb.TextColor3 = Color3.new(1, 1, 1)
	lb.TextStrokeTransparency = 0.5
	lb.Size = UDim2.fromScale(1, 1)
	lb.Text = "Ready"
	lb.Parent = gui
end

local function placeOnGround(model: Model, x: number, z: number)
	local hrp = model.PrimaryPart or model:FindFirstChild("HumanoidRootPart")
	if not hrp then
		warn("[MonsterSpawner] HumanoidRootPart ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: " .. model.Name)
		return
	end

	local groundY = FieldGen.raycastGroundY(x, z, 100)
		or FieldGen.raycastGroundY(x, z, 200)
		or FieldGen.raycastGroundY(x, z, 50)
		or 10

	local _, yaw = hrp.CFrame:ToOrientation()
	model:PivotTo(CFrame.new(x, groundY + 20, z) * CFrame.Angles(0, yaw, 0))

	local bboxCFrame, bboxSize = model:GetBoundingBox()
	local bottomY = bboxCFrame.Position.Y - (bboxSize.Y * 0.5)
	local offset = hrp.Position.Y - bottomY

	model:PivotTo(CFrame.new(x, groundY + offset, z) * CFrame.Angles(0, yaw, 0))
end

local function nearestPlayer(position: Vector3)
	local best, bestDist = nil, math.huge
	for _, pl in ipairs(Players:GetPlayers()) do
		local ch = pl.Character
		local hrp = ch and ch:FindFirstChild("HumanoidRootPart")
		if hrp then
			local d = (position - hrp.Position).Magnitude
			if d < bestDist then
				best, bestDist = pl, d
			end
		end
	end
	return best, bestDist
end

-- AIçŠ¶æ…‹ç®¡ç†ï¼ˆé«˜é€ŸåŒ–ç‰ˆï¼‰
local AIState = {}
AIState.__index = AIState

function AIState.new(monster, def)
	local self = setmetatable({}, AIState)
	self.monster = monster
	self.def = def
	self.humanoid = monster:FindFirstChildOfClass("Humanoid")
	self.root = monster.PrimaryPart
	self.courage = math.random()
	self.brave = (self.courage > 0.5)
	self.wanderGoal = nil
	self.nextWanderAt = 0
	self.lastUpdateTime = 0
	self.lastDistanceLog = 0
	self.updateRate = def.AiTickRate or 0.3
	self.nearUpdateRate = 0.05 -- 0.05ç§’ã«é«˜é€ŸåŒ–ï¼ˆãƒãƒˆãƒ«åˆ¤å®šãŒé€Ÿããªã‚‹ï¼‰
	self.farUpdateRate = 0.5 -- 0.5ç§’ã«é«˜é€ŸåŒ–

	self.originalSpeed = self.humanoid.WalkSpeed
	self.wasInBattle = false

    -- ã€ä¿®æ­£ç‚¹1ã€‘å¾˜å¾Šã‚¹ãƒ†ãƒ¼ãƒˆç®¡ç†ã‚’æ•´ç†
    self.isMoving = false     -- ç§»å‹•çŠ¶æ…‹ã‹
    self.isWaiting = false    -- å¾…æ©ŸçŠ¶æ…‹ã‹ (åœæ­¢çŠ¶æ…‹)
    self.waitEndTime = 0      -- å¾…æ©Ÿçµ‚äº†æ™‚åˆ»
    -- ã€ä¿®æ­£ç‚¹1 çµ‚ã‚ã‚Šã€‘

	return self
end

function AIState:shouldUpdate(currentTime)
	local _, dist = nearestPlayer(self.root.Position)
	-- è¿‘è·é›¢åˆ¤å®šã‚’150ã‚¹ã‚¿ãƒƒãƒ‰ã«æ‹¡å¤§ï¼ˆãƒãƒˆãƒ«åˆ¤å®šã‚’ã‚ˆã‚Šé »ç¹ã«ï¼‰
	local rate = dist < 150 and self.nearUpdateRate or self.farUpdateRate
	return (currentTime - self.lastUpdateTime) >= rate
end

function AIState:update()
	if not self.monster.Parent or not self.humanoid or not self.root then
		return false
	end

	if self.monster:GetAttribute("Defeated") then
		if not self.loggedDefeated then
			-- print(("[AI DEBUG] %s - DefeatedçŠ¶æ…‹ã®ãŸã‚ã‚¹ã‚­ãƒƒãƒ—"):format(self.monster.Name))
			self.loggedDefeated = true
		end
		return false
	end

	-- ãƒãƒˆãƒ«çŠ¶æ…‹ã‚’ç¢ºèª
	local isGlobalBattle = BattleSystem and BattleSystem.isAnyBattleActive and BattleSystem.isAnyBattleActive()
	local isThisMonsterInBattle = self.monster:GetAttribute("InBattle")
	local isAnyBattle = isGlobalBattle or isThisMonsterInBattle

	-- ã„ãšã‚Œã‹ã®ãƒãƒˆãƒ«ãŒé€²è¡Œä¸­ãªã‚‰åœæ­¢
	if isAnyBattle then
		self.humanoid.WalkSpeed = 0
		self.humanoid:MoveTo(self.root.Position)
		self.wasInBattle = true
		return true
	end

	-- ãƒãƒˆãƒ«ãŒçµ‚äº†ã—ãŸã‚‰é€Ÿåº¦ã‚’å¾©å…ƒ
	if self.wasInBattle and not isAnyBattle then
		-- print(("[AI DEBUG] %s - ãƒãƒˆãƒ«çµ‚äº†ã€é€Ÿåº¦å¾©å…ƒ: %.1f"):format(self.monster.Name, self.originalSpeed))
		self.humanoid.WalkSpeed = self.originalSpeed
		self.wasInBattle = false
		self.loggedDefeated = false
	end

	local p, dist = nearestPlayer(self.root.Position)
	local chaseRange = self.def.ChaseDistance or 60
	local now = os.clock()

	-- ãƒãƒˆãƒ«åˆ¤å®šï¼ˆé«˜é€ŸåŒ–ãƒ»è·é›¢æ‹¡å¤§ï¼‰
	if BattleSystem and p and dist <= 7 then -- 7ã‚¹ã‚¿ãƒƒãƒ‰ã«æ‹¡å¤§
		-- print(("[AI DEBUG] %s - æ¥è§¦æ¤œå‡ºï¼è·é›¢=%.1f"):format(self.monster.Name, dist))

		if BattleSystem.isInBattle(p) then
			self.humanoid:MoveTo(self.root.Position)
			return true
		end

		if BattleSystem.isAnyBattleActive and BattleSystem.isAnyBattleActive() then
			self.humanoid:MoveTo(self.root.Position)
			return true
		end

		if self.monster:GetAttribute("InBattle") then
			return true
		end

		local character = p.Character
		if character then
			-- ã€é‡è¦ã€‘å³åº§ã«ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’åœæ­¢ï¼ˆãƒãƒˆãƒ«é–‹å§‹å‰ï¼‰
			local playerHumanoid = character:FindFirstChildOfClass("Humanoid")
			local playerHrp = character:FindFirstChild("HumanoidRootPart")

			if playerHumanoid and playerHrp then
				-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å³åº§ã«åœæ­¢
				playerHumanoid.WalkSpeed = 0
				playerHumanoid.JumpPower = 0
				playerHrp.Anchored = true
			end

			self.monster:SetAttribute("InBattle", true)
			self.humanoid.WalkSpeed = 0
			self.humanoid:MoveTo(self.root.Position)

			local battleStarted = BattleSystem.startBattle(p, self.monster)
			-- print(("[AI DEBUG] ãƒãƒˆãƒ«é–‹å§‹çµæœ: %s"):format(tostring(battleStarted)))

			if not battleStarted then
				-- ãƒãƒˆãƒ«é–‹å§‹å¤±æ•—æ™‚ã¯ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚‚è§£æ”¾
				self.monster:SetAttribute("InBattle", false)
				self.humanoid.WalkSpeed = self.originalSpeed

				if playerHumanoid and playerHrp then
					playerHumanoid.WalkSpeed = 16
					playerHumanoid.JumpPower = 50
					playerHrp.Anchored = false
				end
			end

			return true
		else
			self.monster:SetAttribute("InBattle", false)
		end
	end

	-- æµ·ãƒã‚§ãƒƒã‚¯
	local isInWater = self.root.Position.Y < 0 or self.humanoid:GetState() == Enum.HumanoidStateType.Swimming

	-- ãƒ©ãƒ™ãƒ«æ›´æ–°
	local label = self.root:FindFirstChild("DebugInfo")
		and self.root.DebugInfo:FindFirstChild("InfoText")
	if label then
		local behavior = self.brave and "CHASE" or "FLEE"
		label.Text = string.format("%s\n%s | %.1fm", self.monster.Name, behavior, dist or 999)
	end

	local gui = self.root:FindFirstChild("DebugInfo")
	if gui then
		gui.Enabled = not isInWater
	end

    -- ã€ä¿®æ­£ç‚¹2ã€‘å¾˜å¾Šãƒ­ã‚¸ãƒƒã‚¯ã‚’å†æ§‹ç¯‰
    local function wanderLogic()
        local w = self.def.Wander or {}
        local minWait = w.MinWait or 2
        local maxWait = w.MaxWait or 5
        local minRadius = w.MinRadius or 20
        local maxRadius = w.MaxRadius or 60
        local stopDistance = 5 -- ç›®æ¨™åˆ°é”ã¨è¦‹ãªã™è·é›¢

        local isGoalReached = self.wanderGoal and (self.root.Position - self.wanderGoal).Magnitude < stopDistance
        local isWaitFinished = self.isWaiting and now >= self.waitEndTime

        if self.isWaiting then
            -- ã‚¹ãƒ†ãƒ¼ãƒˆ: å¾…æ©Ÿä¸­ï¼ˆåœæ­¢ï¼‰
            self.humanoid:MoveTo(self.root.Position) -- åœæ­¢ã‚’ç¶­æŒ
            self.isMoving = false

            if isWaitFinished then
                -- å¾…æ©Ÿçµ‚äº†ã€‚æ¬¡ã®ç›®æ¨™è¨­å®šã¸
                self.isWaiting = false
                self.wanderGoal = nil
            end
        elseif isGoalReached or not self.wanderGoal then
            -- ã‚¹ãƒ†ãƒ¼ãƒˆ: ç›®æ¨™åˆ°é” or ç›®æ¨™ãªã— -> æ–°ç›®æ¨™è¨­å®š & ç§»å‹•é–‹å§‹

            -- ç›®æ¨™ã«åˆ°é”ã—ãŸã‚‰å¾…æ©Ÿãƒ¢ãƒ¼ãƒ‰ã«ç§»è¡Œ
            if isGoalReached then
                self.isWaiting = true
                self.waitEndTime = now + math.random(minWait * 10, maxWait * 10) / 10
                self.humanoid:MoveTo(self.root.Position) -- åœæ­¢
                return
            end

            -- æ–°ã—ã„ç›®æ¨™ã‚’è¨­å®š
            local ang = math.random() * math.pi * 2
            local rad = math.random(minRadius, maxRadius)
            local gx = self.root.Position.X + math.cos(ang) * rad
            local gz = self.root.Position.Z + math.sin(ang) * rad

            local gy = FieldGen.raycastGroundY(gx, gz, 100) or self.root.Position.Y + 5 -- è¦‹ã¤ã‹ã‚‰ãªã‘ã‚Œã°ç¾åœ¨ã®Y+5

            self.wanderGoal = Vector3.new(gx, gy, gz)
            self.isMoving = true

            self.humanoid:MoveTo(self.wanderGoal)

        else
            -- ã‚¹ãƒ†ãƒ¼ãƒˆ: ç§»å‹•ä¸­ï¼ˆç¶™ç¶šï¼‰
            self.isMoving = true
            self.humanoid:MoveTo(self.wanderGoal)
        end
    end
    -- ã€ä¿®æ­£ç‚¹2 çµ‚ã‚ã‚Šã€‘

	-- è¡Œå‹•æ±ºå®š
	if not p then
		-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒã„ãªã„ï¼šå¾˜å¾Šã®ã¿
		wanderLogic()
	elseif dist < chaseRange then
		-- è¿½è·¡ or é€ƒèµ°
		self.wanderGoal = nil
        self.isMoving = false
        self.isWaiting = false -- è¿½è·¡ä¸­ã¯å¾˜å¾Šã‚¹ãƒ†ãƒ¼ãƒˆã‚’å¼·åˆ¶è§£é™¤
		if self.brave then
			self.humanoid:MoveTo(p.Character.HumanoidRootPart.Position)
		else
			local away = (self.root.Position - p.Character.HumanoidRootPart.Position).Unit
			self.humanoid:MoveTo(self.root.Position + away * 80)
		end
	else
		-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒé ã„ï¼šå¾˜å¾Š
		wanderLogic()
	end

	self.lastUpdateTime = now
	return true
end

-- ã‚¹ãƒãƒ¼ãƒ³å‡¦ç†ï¼ˆå³¶æŒ‡å®šç‰ˆï¼‰
local function spawnMonster(template: Model, index: number, def, islandName)
	local m = template:Clone()
	m.Name = (def.Name or template.Name) .. "_" .. index

	local hum = m:FindFirstChildOfClass("Humanoid")
	local hrp = ensureHRP(m)

	if not hum or not hrp then
		warn("[MonsterSpawner] Humanoid ã¾ãŸã¯ HRP ãŒã‚ã‚Šã¾ã›ã‚“: " .. m.Name)
		m:Destroy()
		return
	end

	m:SetAttribute("IsEnemy", true)
	m:SetAttribute("MonsterKind", def.Name or "Monster")
	m:SetAttribute("ChaseDistance", def.ChaseDistance or 60)
	m:SetAttribute("SpawnZone", islandName)
	m:SetAttribute("SpawnIsland", islandName)

	local speedMin = def.SpeedMin or 0.7
	local speedMax = def.SpeedMax or 1.3
	local speedMult = speedMin + math.random() * (speedMax - speedMin)
	hum.WalkSpeed = (def.WalkSpeed or 14) * speedMult
	hum.HipHeight = 0

	hrp.Anchored = true
	hrp.CanCollide = false
	hrp.Transparency = 1

	for _, descendant in ipairs(m:GetDescendants()) do
		if descendant:IsA("BasePart") and descendant ~= hrp then
			descendant.CanCollide = true
			descendant.Anchored = false

			for _, child in ipairs(descendant:GetChildren()) do
				if child:IsA("WeldConstraint") or child:IsA("Weld") then
					child:Destroy()
				end
			end

			local weld = Instance.new("WeldConstraint")
			weld.Part0 = hrp
			weld.Part1 = descendant
			weld.Parent = descendant
		end
	end

	m.Parent = Workspace

	local island = Islands[islandName]
	if not island then
		warn(("[MonsterSpawner] å³¶ '%s' ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"):format(islandName))
		m:Destroy()
		return
	end

	local spawnRadius
	if def.radiusPercent then
		spawnRadius = (island.sizeXZ / 2) * (def.radiusPercent / 100)
	else
		spawnRadius = def.spawnRadius or 50
	end

	local rx = island.centerX + math.random(-spawnRadius, spawnRadius)
	local rz = island.centerZ + math.random(-spawnRadius, spawnRadius)

	placeOnGround(m, rx, rz)
	-- attachLabel(m, def.LabelMaxDistance or 250)

	task.wait(0.05)
	hrp.Anchored = false

	local aiState = AIState.new(m, def)
	table.insert(ActiveMonsters, aiState)

	local monsterName = def.Name or "Monster"
	if not MonsterCounts[islandName] then
		MonsterCounts[islandName] = {}
	end
	MonsterCounts[islandName][monsterName] = (MonsterCounts[islandName][monsterName] or 0) + 1

	-- print(("[MonsterSpawner] %s ã‚’ %s ã«ã‚¹ãƒãƒ¼ãƒ³"):format(m.Name, islandName))
end

-- ã‚¾ãƒ¼ãƒ³å†…ã®ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚«ã‚¦ãƒ³ãƒˆã‚’å–å¾—
local function getZoneMonsterCounts(zoneName)
    local counts = {}

    -- å¤§é™¸åã‹ã‚‰å³¶ã®ãƒªã‚¹ãƒˆã‚’å–å¾—
    local islandNames = {}

    -- ContinentsRegistryã‚’ãƒ­ãƒ¼ãƒ‰ï¼ˆã¾ã ãƒ­ãƒ¼ãƒ‰ã•ã‚Œã¦ã„ãªã„å ´åˆï¼‰
    if not ContinentsRegistry then
        local ContinentsFolder = ReplicatedStorage:FindFirstChild("Continents")
        if ContinentsFolder then
            local RegistryModule = ContinentsFolder:FindFirstChild("Registry")
            if RegistryModule then
                ContinentsRegistry = require(RegistryModule)
                print("[MonsterSpawner] ContinentsRegistryã‚’ãƒ­ãƒ¼ãƒ‰ã—ã¾ã—ãŸ")
            end
        end
    end

    -- å¤§é™¸ã®å ´åˆã¯ã€å«ã¾ã‚Œã‚‹å³¶ã‚’ã™ã¹ã¦å–å¾—
    local continent = nil
    if ContinentsRegistry then
        for _, cont in ipairs(ContinentsRegistry) do
            if cont.name == zoneName then
                continent = cont
                break
            end
        end
    end

    if continent and continent.islands then
        -- å¤§é™¸å†…ã®å…¨å³¶ã‚’å¯¾è±¡ã«ã™ã‚‹
        for _, islandName in ipairs(continent.islands) do
            table.insert(islandNames, islandName)
        end
        print(("[MonsterSpawner] å¤§é™¸ %s ã®å³¶ãƒªã‚¹ãƒˆ: %s"):format(
            zoneName,
            table.concat(islandNames, ", ")
        ))
    else
        -- å¤§é™¸ã§ãªã„å ´åˆã¯ã€ã‚¾ãƒ¼ãƒ³åè‡ªä½“ã‚’å³¶åã¨ã™ã‚‹
        table.insert(islandNames, zoneName)
        print(("[MonsterSpawner] %s ã¯å³¶ã¨ã—ã¦æ‰±ã„ã¾ã™"):format(zoneName))
    end

    -- å„å³¶ã®ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚«ã‚¦ãƒ³ãƒˆã‚’é›†è¨ˆ
    for _, islandName in ipairs(islandNames) do
        if MonsterCounts[islandName] then
            for monsterName, count in pairs(MonsterCounts[islandName]) do
                counts[monsterName] = (counts[monsterName] or 0) + count
            end
        end
    end

    print(("[MonsterSpawner] ã‚¾ãƒ¼ãƒ³ %s ã®ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚«ã‚¦ãƒ³ãƒˆ: %s"):format(
        zoneName,
        game:GetService("HttpService"):JSONEncode(counts)
    ))

    return counts
end

-- å…¨ã‚¾ãƒ¼ãƒ³ã®ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æ•°ã‚’SharedStateã«ä¿å­˜
local function updateAllMonsterCounts()
	print("[MonsterSpawner] å…¨ã‚¾ãƒ¼ãƒ³ã®ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚«ã‚¦ãƒ³ãƒˆã‚’æ›´æ–°ä¸­...")

	-- ä¸€æ—¦ã‚¯ãƒªã‚¢
	SharedState.MonsterCounts = {}

	-- ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚¾ãƒ¼ãƒ³ã”ã¨ã«ã‚«ã‚¦ãƒ³ãƒˆ
	local ZoneManager = require(script.Parent.ZoneManager)
	for zoneName, _ in pairs(ZoneManager.ActiveZones) do
		SharedState.MonsterCounts[zoneName] = getZoneMonsterCounts(zoneName)
	end

	print("[MonsterSpawner] ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚«ã‚¦ãƒ³ãƒˆæ›´æ–°å®Œäº†")
end

-- ã‚«ã‚¹ã‚¿ãƒ ã‚«ã‚¦ãƒ³ãƒˆã§ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’ã‚¹ãƒãƒ¼ãƒ³ï¼ˆãƒ­ãƒ¼ãƒ‰æ™‚ç”¨ï¼‰
local function spawnMonstersWithCounts(zoneName, customCounts)
	if isSafeZone(zoneName) then
		print(("[MonsterSpawner] %s ã¯å®‰å…¨åœ°å¸¯ã§ã™ã€‚ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’ã‚¹ãƒãƒ¼ãƒ³ã—ã¾ã›ã‚“"):format(zoneName))
		return
	end

	if not customCounts or type(customCounts) ~= "table" then
		print(("[MonsterSpawner] ã‚«ã‚¹ã‚¿ãƒ ã‚«ã‚¦ãƒ³ãƒˆãŒç„¡åŠ¹ã§ã™ã€‚é€šå¸¸ã‚¹ãƒãƒ¼ãƒ³ã‚’å®Ÿè¡Œ: %s"):format(zoneName))
		spawnMonstersForZone(zoneName)
		return
	end

	print(("[MonsterSpawner] ã‚«ã‚¹ã‚¿ãƒ ã‚«ã‚¦ãƒ³ãƒˆã§ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’ã‚¹ãƒãƒ¼ãƒ³: %s"):format(zoneName))
	print(("[MonsterSpawner] ã‚«ã‚¦ãƒ³ãƒˆ: %s"):format(
		game:GetService("HttpService"):JSONEncode(customCounts)
	))

	-- ã‚«ã‚¹ã‚¿ãƒ ã‚«ã‚¦ãƒ³ãƒˆã«åŸºã¥ã„ã¦ã‚¹ãƒãƒ¼ãƒ³
	for monsterName, count in pairs(customCounts) do
		local template = TemplateCache[monsterName]
		local def = nil

		-- å®šç¾©ã‚’å–å¾—
		for _, regDef in ipairs(Registry) do
			if regDef.Name == monsterName then
				def = regDef
				break
			end
		end

		if template and def and count > 0 then
			print(("[MonsterSpawner] %s ã‚’ %d ä½“ã‚¹ãƒãƒ¼ãƒ³"):format(monsterName, count))

			-- å„ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã®é…ç½®å…ˆã‚’æ±ºå®š
			if def.SpawnLocations then
				-- å„ãƒ­ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã«å‡ç­‰é…åˆ†
				local locationsInZone = {}
				for _, location in ipairs(def.SpawnLocations) do
					-- ã“ã®ã‚¾ãƒ¼ãƒ³ã«å«ã¾ã‚Œã‚‹å³¶ã‹ãƒã‚§ãƒƒã‚¯
					local isInZone = false

					-- å¤§é™¸ã®å ´åˆ
					local Continents = {}
					for _, continent in ipairs(ContinentsRegistry) do
						Continents[continent.name] = continent
					end

					if Continents[zoneName] then
						for _, islandName in ipairs(Continents[zoneName].islands) do
							if islandName == location.islandName then
								isInZone = true
								break
							end
						end
					elseif zoneName == location.islandName then
						isInZone = true
					end

					if isInZone then
						table.insert(locationsInZone, location.islandName)
					end
				end

				-- å„ãƒ­ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã«é…åˆ†
				if #locationsInZone > 0 then
					local countPerLocation = math.ceil(count / #locationsInZone)

					for _, islandName in ipairs(locationsInZone) do
						for i = 1, math.min(countPerLocation, count) do
							local spawnDef = {}
							for k, v in pairs(def) do
								spawnDef[k] = v
							end

							spawnMonster(template, i, spawnDef, islandName)
							count = count - 1

							if count <= 0 then break end
							if i % 5 == 0 then task.wait() end
						end

						if count <= 0 then break end
					end
				end
			end
		else
			if not template then
				warn(("[MonsterSpawner] ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆæœªç™ºè¦‹: %s"):format(monsterName))
			end
			if not def then
				warn(("[MonsterSpawner] å®šç¾©æœªç™ºè¦‹: %s"):format(monsterName))
			end
		end
	end
end

-- ã‚¾ãƒ¼ãƒ³ã«ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’ã‚¹ãƒãƒ¼ãƒ³ã™ã‚‹ï¼ˆå¤§é™¸å¯¾å¿œç‰ˆï¼‰
function spawnMonstersForZone(zoneName)
	if isSafeZone(zoneName) then
		print(("[MonsterSpawner] %s ã¯å®‰å…¨åœ°å¸¯ã§ã™ã€‚ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’ã‚¹ãƒãƒ¼ãƒ³ã—ã¾ã›ã‚“"):format(zoneName))
		return
	end

	print(("[MonsterSpawner] %s ã«ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’é…ç½®ä¸­..."):format(zoneName))

	local islandsInZone = {}

	local ContinentsRegistry = require(ReplicatedStorage.Continents.Registry)
	local Continents = {}
	for _, continent in ipairs(ContinentsRegistry) do
		Continents[continent.name] = continent
	end

	if Continents[zoneName] then
		local continent = Continents[zoneName]
		for _, islandName in ipairs(continent.islands) do
			islandsInZone[islandName] = true
		end
		print(("[MonsterSpawner] å¤§é™¸ %s ã®å³¶: %s"):format(zoneName, table.concat(continent.islands, ", ")))
	else
		islandsInZone[zoneName] = true
	end

	for _, def in ipairs(Registry) do
		local monsterName = def.Name or "Monster"
		local template = TemplateCache[monsterName]

		if template then
			if def.SpawnLocations then
				for _, location in ipairs(def.SpawnLocations) do
					local islandName = location.islandName

					if islandsInZone[islandName] then
						local radiusText = location.radiusPercent or 100
						print(("[MonsterSpawner] %s ã‚’ %s ã«é…ç½®ä¸­ (æ•°: %d, ç¯„å›²: %d%%)"):format(
							monsterName, islandName, location.count, radiusText
							))

						if not MonsterCounts[islandName] then
							MonsterCounts[islandName] = {}
						end
						MonsterCounts[islandName][monsterName] = 0

						for i = 1, (location.count or 0) do
							local spawnDef = {}
							for k, v in pairs(def) do
								spawnDef[k] = v
							end
							spawnDef.radiusPercent = location.radiusPercent
							spawnDef.spawnRadius = location.spawnRadius

							spawnMonster(template, i, spawnDef, islandName)
							if i % 5 == 0 then task.wait() end
						end
					end
				end
			else
				warn(("[MonsterSpawner] %s ã¯æ—§å½¢å¼ã§ã™ã€‚SpawnLocationså½¢å¼ã«ç§»è¡Œã—ã¦ãã ã•ã„"):format(monsterName))
			end
		end
	end
end

-- ãƒªã‚¹ãƒãƒ¼ãƒ³å‡¦ç†ï¼ˆå³¶å¯¾å¿œç‰ˆï¼‰
local function scheduleRespawn(monsterName, def, islandName)
	local respawnTime = def.RespawnTime or 10
	if respawnTime <= 0 then return end

	local respawnData = {
		monsterName = monsterName,
		def = def,
		islandName = islandName,
		respawnAt = os.clock() + respawnTime
	}
	table.insert(RespawnQueue, respawnData)
end

local function processRespawnQueue()
	task.spawn(function()
		while true do
			local now = os.clock()

			for i = #RespawnQueue, 1, -1 do
				local data = RespawnQueue[i]
				if now >= data.respawnAt then
					local isActive = false
					for zoneName, _ in pairs(ZoneManager.ActiveZones) do
						isActive = true
						break
					end

					if isActive then
						local template = TemplateCache[data.monsterName]
						if template and MonsterCounts[data.islandName] then
							local nextIndex = (MonsterCounts[data.islandName][data.monsterName] or 0) + 1
							spawnMonster(template, nextIndex, data.def, data.islandName)
							-- print(("[MonsterSpawner] %s ãŒ %s ã«ãƒªã‚¹ãƒãƒ¼ãƒ³"):format(data.monsterName, data.islandName))
						end
					end
					table.remove(RespawnQueue, i)
				end
			end

			task.wait(1)
		end
	end)
end

-- AIæ›´æ–°ãƒ«ãƒ¼ãƒ—ï¼ˆé«˜é€ŸåŒ–ï¼‰
local function startGlobalAILoop()
	print("[MonsterSpawner] AIæ›´æ–°ãƒ«ãƒ¼ãƒ—é–‹å§‹ï¼ˆé«˜é€ŸåŒ–ç‰ˆï¼‰")

	task.spawn(function()
		while true do
			if #ActiveMonsters > 0 then
				local currentTime = os.clock()

				for i = #ActiveMonsters, 1, -1 do
					local state = ActiveMonsters[i]

					if state:shouldUpdate(currentTime) then
						local success, result = pcall(function()
							return state:update()
						end)

						if not success then
							warn(("[MonsterSpawner ERROR] AIæ›´æ–°ã‚¨ãƒ©ãƒ¼: %s - %s"):format(
								state.monster.Name, tostring(result)
								))
						elseif not result then
							local monsterDef = state.def
							local monsterName = monsterDef.Name or "Unknown"
							local zoneName = state.monster:GetAttribute("SpawnZone") or "Unknown"

							if MonsterCounts[zoneName] and MonsterCounts[zoneName][monsterName] then
								MonsterCounts[zoneName][monsterName] = MonsterCounts[zoneName][monsterName] - 1
							end

							table.remove(ActiveMonsters, i)
							scheduleRespawn(monsterName, monsterDef, zoneName)
						end
					end
				end
			end

			task.wait(UpdateInterval)
		end
	end)
end

-- ã‚¾ãƒ¼ãƒ³ã®ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’å‰Šé™¤ã™ã‚‹
function despawnMonstersForZone(zoneName)
	print(("[MonsterSpawner] %s ã®ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’å‰Šé™¤ä¸­..."):format(zoneName))

	local removedCount = 0

	for i = #ActiveMonsters, 1, -1 do
		local state = ActiveMonsters[i]
		local monsterZone = state.monster:GetAttribute("SpawnZone")

		if monsterZone == zoneName then
			state.monster:Destroy()
			table.remove(ActiveMonsters, i)
			removedCount = removedCount + 1
		end
	end

	for i = #RespawnQueue, 1, -1 do
		if RespawnQueue[i].zoneName == zoneName then
			table.remove(RespawnQueue, i)
		end
	end

	MonsterCounts[zoneName] = nil

	print(("[MonsterSpawner] %s ã®ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’ %dä½“ å‰Šé™¤ã—ã¾ã—ãŸ"):format(zoneName, removedCount))
end

-- åˆæœŸåŒ–
print("[MonsterSpawner] === ã‚¹ã‚¯ãƒªãƒ—ãƒˆé–‹å§‹ï¼ˆãƒãƒˆãƒ«é«˜é€ŸåŒ–ç‰ˆï¼‰===")

if BattleSystem then
	BattleSystem.init()
	print("[MonsterSpawner] BattleSystemåˆæœŸåŒ–å®Œäº†")
else
	print("[MonsterSpawner] BattleSystemãªã—ã§èµ·å‹•")
end

-- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚«ã‚¦ãƒ³ãƒˆãƒªã‚¯ã‚¨ã‚¹ãƒˆã«å¿œç­”
GameEvents.MonsterCountRequest.Event:Connect(function(zoneName)
	print(("[MonsterSpawner] ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚«ã‚¦ãƒ³ãƒˆãƒªã‚¯ã‚¨ã‚¹ãƒˆå—ä¿¡: %s"):format(zoneName or "å…¨ã‚¾ãƒ¼ãƒ³"))

	if zoneName then
		-- ç‰¹å®šã‚¾ãƒ¼ãƒ³ã®ã¿
		SharedState.MonsterCounts[zoneName] = getZoneMonsterCounts(zoneName)
	else
		-- å…¨ã‚¾ãƒ¼ãƒ³
		updateAllMonsterCounts()
	end

	-- å®Œäº†é€šçŸ¥
	GameEvents.MonsterCountResponse:Fire()
end)

print("[MonsterSpawner] GameEventsã¸ã®å¿œç­”ç™»éŒ²å®Œäº†")

Workspace:WaitForChild("World", 10)
print("[MonsterSpawner] World ãƒ•ã‚©ãƒ«ãƒ€æ¤œå‡º")

task.wait(1)

print("[MonsterSpawner] ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥ä¸­...")
for _, def in ipairs(Registry) do
	local template = resolveTemplate(def.TemplatePath)
	if template then
		local monsterName = def.Name or "Monster"
		TemplateCache[monsterName] = template
		print(("[MonsterSpawner] ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚­ãƒ£ãƒƒã‚·ãƒ¥: %s"):format(monsterName))
	else
		warn(("[MonsterSpawner] ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆæœªç™ºè¦‹: %s"):format(def.Name or "?"))
	end
end

startGlobalAILoop()
processRespawnQueue()

print("[MonsterSpawner] === åˆæœŸåŒ–å®Œäº†ï¼ˆãƒãƒˆãƒ«å³åº§é–‹å§‹å¯¾å¿œï¼‰===")

_G.SpawnMonstersForZone = spawnMonstersForZone
_G.DespawnMonstersForZone = despawnMonstersForZone
_G.SpawnMonstersWithCounts = spawnMonstersWithCounts
_G.GetZoneMonsterCounts = getZoneMonsterCounts
_G.UpdateAllMonsterCounts = updateAllMonsterCounts

print("[MonsterSpawner] ã‚°ãƒ­ãƒ¼ãƒãƒ«é–¢æ•°ç™»éŒ²å®Œäº†ï¼ˆã‚«ã‚¦ãƒ³ãƒˆæ©Ÿèƒ½ä»˜ãï¼‰")
===== ./ServerScriptService/DataCollectors.lua =====
-- ServerScriptService/DataCollectors.lua
-- ã‚»ãƒ¼ãƒ–/ãƒ­ãƒ¼ãƒ‰ã«å¿…è¦ãªãƒ‡ãƒ¼ã‚¿ã‚’åé›†ãƒ»é©ç”¨ã™ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")
local HttpService = game:GetService("HttpService")

local DataCollectors = {}

-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®çŠ¶æ…‹ã‚’åé›†
function DataCollectors.collectPlayerState(player: Player, playerStats)
    local character = player.Character or player.CharacterAdded:Wait()
    local hrp = character:WaitForChild("HumanoidRootPart", 5)

    local zoneManager = require(script.Parent.ZoneManager)
    local currentZone = zoneManager.GetPlayerZone(player)

    local playerState = {
        -- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ (PlayerStatsã‹ã‚‰å–å¾—)
        Stats = {
            Level = playerStats.Level,
            Experience = playerStats.Experience,
            Gold = playerStats.Gold,
            CurrentHP = playerStats.CurrentHP,
            MonstersDefeated = playerStats.MonstersDefeated,
        },
        -- ä½ç½®æƒ…å ±
        Location = {
            ZoneName = currentZone or "ContinentTown", -- ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ã‚¿ã‚¦ãƒ³
            X = hrp and hrp.Position.X or 0,
            Y = hrp and hrp.Position.Y or 50, -- Yã¯åœ°å½¢ã‹ã‚‰å°‘ã—ä¸Šã®ä½ç½®
            Z = hrp and hrp.Position.Z or 0,
        },
    }

    return playerState
end

-- ã€ä¿®æ­£ã€‘ãƒ¯ãƒ¼ãƒ«ãƒ‰ã®çŠ¶æ…‹ï¼ˆãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚«ã‚¦ãƒ³ãƒˆã®ã¿ï¼‰ã‚’åé›†
function DataCollectors.collectFieldState(zoneName)
    local fieldState = {
        MonsterCounts = {}
    }

    -- MonsterSpawnerã®ã‚°ãƒ­ãƒ¼ãƒãƒ«é–¢æ•°ã‚’ä½¿ã£ã¦ã‚«ã‚¦ãƒ³ãƒˆå–å¾—
    if _G.GetZoneMonsterCounts then
        local counts = _G.GetZoneMonsterCounts(zoneName)
        if counts then
            fieldState.MonsterCounts = counts
            print(("[DataCollectors] %s ã®ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚«ã‚¦ãƒ³ãƒˆåé›†: %s"):format(
                zoneName,
                HttpService:JSONEncode(counts)
            ))
        else
            print(("[DataCollectors] %s ã«ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚«ã‚¦ãƒ³ãƒˆãŒã‚ã‚Šã¾ã›ã‚“"):format(zoneName))
        end
    else
        warn("[DataCollectors] _G.GetZoneMonsterCounts ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“")
    end

    return fieldState
end

-- ã€ä¿®æ­£ã€‘ãƒ¯ãƒ¼ãƒ«ãƒ‰ã®çŠ¶æ…‹ã‚’å¾©å…ƒ (ãƒ­ãƒ¼ãƒ‰æ™‚ã«ä½¿ç”¨)
function DataCollectors.restoreFieldState(zoneName, fieldState)
    if not fieldState then
        warn("[DataCollectors] å¾©å…ƒã™ã‚‹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰çŠ¶æ…‹ãŒã‚ã‚Šã¾ã›ã‚“")
        return false
    end

    if not fieldState.MonsterCounts or next(fieldState.MonsterCounts) == nil then
        print(("[DataCollectors] %s ã«å¾©å…ƒã™ã‚‹ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ãŒã‚ã‚Šã¾ã›ã‚“"):format(zoneName))
        return false
    end

    print(("[DataCollectors] %s ã®ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’å¾©å…ƒä¸­: %s"):format(
        zoneName,
        HttpService:JSONEncode(fieldState.MonsterCounts)
    ))

    -- MonsterSpawnerã®ã‚°ãƒ­ãƒ¼ãƒãƒ«é–¢æ•°ã‚’ä½¿ã£ã¦ã‚¹ãƒãƒ¼ãƒ³
    if _G.SpawnMonstersWithCounts then
        _G.SpawnMonstersWithCounts(zoneName, fieldState.MonsterCounts)
        print(("[DataCollectors] %s ã®ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼å¾©å…ƒå®Œäº†"):format(zoneName))
        return true
    else
        warn("[DataCollectors] _G.SpawnMonstersWithCounts ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“")
        return false
    end
end

-- ç·åˆã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆ
function DataCollectors.createSaveData(player: Player, playerStats)
    local currentZone = (require(script.Parent.ZoneManager)).GetPlayerZone(player)

    local saveData = {
        PlayerState = DataCollectors.collectPlayerState(player, playerStats),
        CurrentZone = currentZone,
        FieldState = (currentZone ~= "ContinentTown") and DataCollectors.collectFieldState(currentZone) or nil,
        CollectedItems = playerStats.CollectedItems or {},
        SaveTime = os.time(),
    }

    return saveData
end

return DataCollectors
===== ./ServerScriptService/TowerPlacement.server.lua =====
-- ServerScriptService/TowerPlacement.server.lua
-- StartTownã«ã‚¿ãƒ¯ãƒ¼ã‚’é…ç½®

local ServerStorage = game:GetService("ServerStorage")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
print("[TowerPlacement] ã‚¿ãƒ¯ãƒ¼é…ç½®ã‚’ã‚¹ã‚­ãƒƒãƒ—")
-- print("[TowerPlacement] ã‚¿ãƒ¯ãƒ¼é…ç½®é–‹å§‹")

-- -- StartTownã®è¨­å®šã‚’å–å¾—
-- local IslandsRegistry = require(ReplicatedStorage.Islands.Registry)
-- local townConfig = nil
-- for _, island in ipairs(IslandsRegistry) do
-- 	if island.name == "StartTown" then
-- 		townConfig = island
-- 		break
-- 	end
-- end

-- if not townConfig then
-- 	warn("[TowerPlacement] StartTownã®è¨­å®šãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
-- 	return
-- end

-- -- é…ç½®ä½ç½®ï¼ˆStartTownã®ä¸­å¿ƒã‹ã‚‰æ±ã«50ã‚¹ã‚¿ãƒƒãƒ‰ï¼‰
-- local TOWER_OFFSET_X = 400  -- â˜…ä¿®æ­£: 400ã«å¤‰æ›´ (-100 + 400 = 300)
-- local TOWER_OFFSET_Z = -100 -- â˜…ä¿®æ­£: -100ã«å¤‰æ›´ (100 + (-100) = 0)

-- -- åœ°å½¢ç”Ÿæˆã‚’å¾…ã¤
-- task.wait(1)

-- -- ServerStorage/Buildingsã‹ã‚‰ã‚¿ãƒ¯ãƒ¼ã®ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’å–å¾—
-- local buildingsFolder = ServerStorage:FindFirstChild("Buildings")
-- if not buildingsFolder then
-- 	warn("[TowerPlacement] ServerStorage ã« 'Buildings' ãƒ•ã‚©ãƒ«ãƒ€ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
-- 	return
-- end

-- local towerTemplate = buildingsFolder:FindFirstChild("Tower")
-- if not towerTemplate then
-- 	warn("[TowerPlacement] ServerStorage/Buildings ã« 'Tower' ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
-- 	warn("[TowerPlacement] Toolboxã‹ã‚‰ Asset ID 12127172596 ã‚’ ServerStorage/Buildings ã«é…ç½®ã—ã¦ãã ã•ã„")
-- 	return
-- end

-- -- ã‚¿ãƒ¯ãƒ¼ã‚’è¤‡è£½
-- local tower = towerTemplate:Clone()
-- tower.Parent = workspace

-- print("[TowerPlacement] ã‚¿ãƒ¯ãƒ¼ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ:", tower.Name)

-- -- é…ç½®ä½ç½®ã‚’è¨ˆç®—
-- local towerX = townConfig.centerX + TOWER_OFFSET_X
-- local towerZ = townConfig.centerZ + TOWER_OFFSET_Z

-- -- åœ°é¢ã®é«˜ã•ã‚’å–å¾—
-- local FieldGen = require(ReplicatedStorage:WaitForChild("FieldGen"))
-- local groundY = FieldGen.raycastGroundY(towerX, towerZ, townConfig.baseY + 100)

-- if not groundY then
-- 	-- ãƒ¬ã‚¤ã‚­ãƒ£ã‚¹ãƒˆãŒå¤±æ•—ã—ãŸå ´åˆã¯æ¨å®šé«˜åº¦ã‚’ä½¿ç”¨
-- 	groundY = townConfig.baseY + 5
-- 	warn("[TowerPlacement] åœ°é¢æ¤œå‡ºå¤±æ•—ã€æ¨å®šé«˜åº¦ã‚’ä½¿ç”¨:", groundY)
-- end

-- -- ã‚¿ãƒ¯ãƒ¼ã®åº•é¢ã‚’åœ°é¢ã«åˆã‚ã›ã‚‹
-- if tower:IsA("Model") then
-- 	-- Modelã®å ´åˆï¼šæœ€ä¸‹ç‚¹ã‚’åœ°é¢ã«åˆã‚ã›ã‚‹
-- 	local primaryPart = tower.PrimaryPart
-- 	if not primaryPart then
-- 		for _, part in ipairs(tower:GetDescendants()) do
-- 			if part:IsA("BasePart") then
-- 				tower.PrimaryPart = part
-- 				primaryPart = part
-- 				print("[TowerPlacement] PrimaryPartã‚’è‡ªå‹•è¨­å®š:", part.Name)
-- 				break
-- 			end
-- 		end
-- 	end

-- 	if primaryPart then
-- 		-- ã¾ãšç›®æ¨™ä½ç½®ã«é…ç½®
-- 		tower:SetPrimaryPartCFrame(CFrame.new(towerX, groundY, towerZ))

-- 		-- æœ€ä¸‹ç‚¹ã‚’æ¢ã™
-- 		local lowestY = math.huge
-- 		local lowestPartName = ""
-- 		for _, part in ipairs(tower:GetDescendants()) do
-- 			if part:IsA("BasePart") then
-- 				local partBottom = part.Position.Y - (part.Size.Y / 2)
-- 				if partBottom < lowestY then
-- 					lowestY = partBottom
-- 					lowestPartName = part.Name
-- 				end
-- 			end
-- 		end

-- 		print(("[TowerPlacement] ãƒ‡ãƒãƒƒã‚°æƒ…å ±:"):format())
-- 		print(("  åœ°é¢ã®é«˜ã• (groundY): %.1f"):format(groundY))
-- 		print(("  æœ€ä¸‹ç‚¹ãƒ‘ãƒ¼ãƒ„: %s"):format(lowestPartName))
-- 		print(("  æœ€ä¸‹ç‚¹ã®é«˜ã• (é…ç½®å‰): %.1f"):format(lowestY))

-- 		-- æœ€ä¸‹ç‚¹ãŒåœ°é¢ã«ãªã‚‹ã‚ˆã†èª¿æ•´
-- 		local adjustment = groundY - lowestY
-- 		local currentCFrame = tower:GetPrimaryPartCFrame()
-- 		tower:SetPrimaryPartCFrame(currentCFrame + Vector3.new(0, adjustment, 0))

-- 		-- èª¿æ•´å¾Œã®æœ€ä¸‹ç‚¹ã‚’ç¢ºèª
-- 		local newLowestY = math.huge
-- 		for _, part in ipairs(tower:GetDescendants()) do
-- 			if part:IsA("BasePart") then
-- 				local partBottom = part.Position.Y - (part.Size.Y / 2)
-- 				if partBottom < newLowestY then
-- 					newLowestY = partBottom
-- 				end
-- 			end
-- 		end

-- 		local _, size = tower:GetBoundingBox()
-- 		print("[TowerPlacement] ã‚¿ãƒ¯ãƒ¼ã‚’é…ç½®ã—ã¾ã—ãŸ (Model):")
-- 		print(("  ä½ç½®: X=%.1f, Y=%.1f, Z=%.1f"):format(towerX, groundY, towerZ))
-- 		print(("  ã‚µã‚¤ã‚º: %.1f x %.1f x %.1f"):format(size.X, size.Y, size.Z))
-- 		print(("  èª¿æ•´: %.1f ã‚¹ã‚¿ãƒƒãƒ‰ä¸Šã«ç§»å‹•"):format(adjustment))
-- 		print(("  èª¿æ•´å¾Œã®æœ€ä¸‹ç‚¹: %.1f (ç›®æ¨™: %.1f)"):format(newLowestY, groundY))
-- 	else
-- 		local cf, size = tower:GetBoundingBox()
-- 		local lowestY = cf.Position.Y - (size.Y / 2)
-- 		local adjustment = groundY - lowestY
-- 		tower:PivotTo(CFrame.new(towerX, groundY + adjustment, towerZ))
-- 		print("[TowerPlacement] PivotToã§é…ç½®ã—ã¾ã—ãŸ:")
-- 		print(("  ä½ç½®: X=%.1f, Y=%.1f, Z=%.1f"):format(towerX, groundY, towerZ))
-- 	end
-- elseif tower:IsA("BasePart") then
-- 	-- MeshPartãªã©å˜ä¸€ãƒ‘ãƒ¼ãƒ„ã®å ´åˆ
-- 	local size = tower.Size
-- 	local offsetY = size.Y / 2
-- 	tower.CFrame = CFrame.new(towerX, groundY + offsetY, towerZ)
-- 	print("[TowerPlacement] ã‚¿ãƒ¯ãƒ¼ã‚’é…ç½®ã—ã¾ã—ãŸ (BasePart):")
-- 	print(("  ä½ç½®: X=%.1f, Y=%.1f, Z=%.1f"):format(towerX, groundY + offsetY, towerZ))
-- 	print(("  ã‚µã‚¤ã‚º: %.1f x %.1f x %.1f"):format(size.X, size.Y, size.Z))
-- else
-- 	warn("[TowerPlacement] æœªå¯¾å¿œã®å‹:", tower.ClassName)
-- 	return
-- end

-- -- ã‚¿ãƒ¯ãƒ¼ã‚’å›ºå®š
-- for _, part in ipairs(tower:GetDescendants()) do
-- 	if part:IsA("BasePart") then
-- 		part.Anchored = true
-- 	end
-- end

-- print("[TowerPlacement] é…ç½®å®Œäº†")
===== ./ReplicatedStorage/Continents/Greenland.lua =====
return {
name = "VerdantPlateau",
displayName = "ç·‘ã®å¤§é™¸",
islands = {
"VerdantPlateau_C1",
"VerdantPlateau_C2",
"VerdantPlateau_C3",
"VerdantPlateau_C4",
},
paths = {
{
name = "MainRoad01",
points = {
{2720, 10, -220},
{2850, 10, -120},
{3000, 10, 0},
{3150, 10, 40},
{3280, 10, 60},
},
width = 20,
method = "terrain",
material = Enum.Material.Ground,
step = 3,
alignToSlope = false,
groundOffset = 0.05
},
},
		{
			model = "Tree1",
			position = {2783.8, 25.5, -62.1},
			size = 1.8,
			rotation = {0, 180, 0},
			stickToGround = true,   -- çœç•¥å¯ï¼ˆtrueãŒæ—¢å®šï¼‰
			groundOffset  = 0.15,   -- èŠç”Ÿã§å°‘ã—æµ®ã‹ã›ãŸã„æ™‚
			alignToSlope  = true,  -- æ–œé¢ã«æœ¨ã‚’å‚¾ã‘ãŸããªã„ãªã‚‰false
		},
        {
			model = "Chest",
			position = {2799.3, 25.2, -99.8},
			size = 1.8,
			rotation = {0, 180, 0},
			stickToGround = true,   -- çœç•¥å¯ï¼ˆtrueãŒæ—¢å®šï¼‰
			groundOffset  = 0.15,   -- èŠç”Ÿã§å°‘ã—æµ®ã‹ã›ãŸã„æ™‚
			alignToSlope  = true,  -- æ–œé¢ã«æœ¨ã‚’å‚¾ã‘ãŸããªã„ãªã‚‰false
		},

fieldObjects = {},
BGM = "",
BGMVolume = 0.2
}
===== ./ReplicatedStorage/Continents/Registry.lua =====
-- ReplicatedStorage/Continents/Registry.lua
local RS = game:GetService("ReplicatedStorage")
local ContinentsFolder = RS:WaitForChild("Continents")

return {
    require(ContinentsFolder.ContientTown),
    require(ContinentsFolder.ContinentHokkaido),
    require(ContinentsFolder.ContinentShikoku),
    require(ContinentsFolder.ContinentKyushu),
    require(ContinentsFolder.Snowland),
    require(ContinentsFolder.Greenland),
}
===== ./ReplicatedStorage/Continents/Snowland.lua =====
return {
name = "SnowCrescent",
displayName = "é›ªã®ä¸‰æ—¥æœˆ",
islands = {
"SnowCrescent_C1",
"SnowCrescent_C2",
"SnowCrescent_C3",
"SnowCrescent_C4",
"SnowCrescent_C5",
"SnowCrescent_C6",
"SnowCrescent_C7",
"SnowCrescent_C8",
"SnowCrescent_C9",
"SnowCrescent_C10",
"SnowCrescent_C11",
"SnowCrescent_C12",
"SnowCrescent_C13",
"SnowCrescent_C14",
"SnowCrescent_C15",
},
paths = {
{
name = "MainRoad_NS",
points = {
{2850, 14, -560},
{2855, 15, -420},
{2850, 15, -260},
{2845, 16, -120},
{2850, 16, 0},
{2855, 17, 140},
{2850, 18, 300},
{2850, 19, 460},
},
width = 20,
method = "terrain",
material = Enum.Material.Ground,
step = 3,
alignToSlope = false,
groundOffset = 0.05
},
},
fieldObjects = {},
BGM = "",
BGMVolume = 0.2
}
===== ./ReplicatedStorage/Continents/ContinentHokkaido.lua =====
return {
	name = "ContinentHokkaido",
	displayName = "Hokkaido Continent",

	islands = {
		"Hokkaido_W1", "Hokkaido_C1", "Hokkaido_C2", "Hokkaido_C3",
		"Hokkaido_C4", "Hokkaido_C5", "Hokkaido_E1",
		"Hokkaido_N1", "Hokkaido_N2", "Hokkaido_N3", "Hokkaido_N4",
		"Hokkaido_NE1", "Hokkaido_NE2",
		"Hokkaido_S1", "Hokkaido_S2",
		"Hokkaido_SW1", "Hokkaido_SW2",
	},

	bridges = {},

	portals = {
			{
				name = "Hokkaido_to_Town",
				toZone = "ContinentTown",
				islandName = "Hokkaido_C3",
				offsetX = 0,
				offsetZ = 0,
				label = "â†’ Town",
				color = Color3.fromRGB(255, 200, 100),
			},
		},

	fieldObjects = {
		{
			model = "Tree1",
			position = {3237.0, 22.0, -10.8},
			size = 1.5,
			rotation = {0, 0, 0},
			stickToGround = true,   -- çœç•¥å¯ï¼ˆtrueãŒæ—¢å®šï¼‰
			groundOffset  = 0.15,   -- èŠç”Ÿã§å°‘ã—æµ®ã‹ã›ãŸã„æ™‚
			alignToSlope  = true,  -- æ–œé¢ã«æœ¨ã‚’å‚¾ã‘ãŸããªã„ãªã‚‰false
		},
		{
			model = "Tree1",
			position = {3092.5, 9.1, -175.5},
			size = 1.0,
			rotation = {0, 0, 0},
			stickToGround = true,   -- çœç•¥å¯ï¼ˆtrueãŒæ—¢å®šï¼‰
			groundOffset  = 0.15,   -- èŠç”Ÿã§å°‘ã—æµ®ã‹ã›ãŸã„æ™‚
			alignToSlope  = true,  -- æ–œé¢ã«æœ¨ã‚’å‚¾ã‘ãŸããªã„ãªã‚‰false
		},

		{
			model = "Tree1",
			position = {3118.2, 7.3, -182.6},
			size = 1.0,
			rotation = {0, 30, 0},
			stickToGround = true,   -- çœç•¥å¯ï¼ˆtrueãŒæ—¢å®šï¼‰
			groundOffset  = 0.15,   -- èŠç”Ÿã§å°‘ã—æµ®ã‹ã›ãŸã„æ™‚
			alignToSlope  = true,  -- æ–œé¢ã«æœ¨ã‚’å‚¾ã‘ãŸããªã„ãªã‚‰false
		},

		{
			model = "Small House",
			position = {3080.8, 32.0, -162.8},
			size = 1.8,
			rotation = {0, 180, 0},
			stickToGround = false,   -- çœç•¥å¯ï¼ˆtrueãŒæ—¢å®šï¼‰
			groundOffset  = 0.15,   -- èŠç”Ÿã§å°‘ã—æµ®ã‹ã›ãŸã„æ™‚
			alignToSlope  = false,  -- æ–œé¢ã«æœ¨ã‚’å‚¾ã‘ãŸããªã„ãªã‚‰false
		},

		{
			-- model = "Chest",
			model = "koki3D",
			position = {-0.0, 56.3, -12.0},
			size = 1.0,
			rotation = {0, 0, 0},
			stickToGround = true,   -- çœç•¥å¯ï¼ˆtrueãŒæ—¢å®šï¼‰
			groundOffset  = 0,   -- èŠç”Ÿã§å°‘ã—æµ®ã‹ã›ãŸã„æ™‚
			alignToSlope  = true,  -- æ–œé¢ã«æœ¨ã‚’å‚¾ã‘ãŸããªã„ãªã‚‰false
		},

		{
			model = "box_closed",
			position = {3152.0, 59.5, -75.2},
            mode = "ground",
			size = 1,
			rotation = {0, 0, 0},
			stickToGround = false,   -- çœç•¥å¯ï¼ˆtrueãŒæ—¢å®šï¼‰
			groundOffset  = 0,   -- èŠç”Ÿã§å°‘ã—æµ®ã‹ã›ãŸã„æ™‚
			alignToSlope  = false,  -- æ–œé¢ã«æœ¨ã‚’å‚¾ã‘ãŸããªã„ãªã‚‰false

            interaction = {
                type = "chest",           -- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—
                action = "é–‹ã‘ã‚‹",         -- ãƒœã‚¿ãƒ³ã«è¡¨ç¤ºã•ã‚Œã‚‹ãƒ†ã‚­ã‚¹ãƒˆ
                key = "E",                -- ã‚­ãƒ¼ãƒã‚¤ãƒ³ãƒ‰
                range = 8,                -- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³å¯èƒ½è·é›¢ï¼ˆã‚¹ã‚¿ãƒƒãƒ‰ï¼‰

                -- å®ç®±å›ºæœ‰ã®æƒ…å ±
                chestId = "hokkaido_chest_01",          -- ãƒ¦ãƒ‹ãƒ¼ã‚¯ID
                openedModel = "box_opened",         -- é–‹ã„ãŸçŠ¶æ…‹ã®ãƒ¢ãƒ‡ãƒ«å
                rewards = {
                    {item = "ãƒãƒ¼ã‚·ãƒ§ãƒ³", count = 2},
					{item = "ã‚´ãƒ¼ãƒ«ãƒ‰", count = 45},
                },
                displayDuration = 3,      -- å ±é…¬è¡¨ç¤ºæ™‚é–“ï¼ˆç§’ï¼‰
            },
		},

				{
			model = "box_closed",
			position = {2997.1, 26.9, 10.8},
            mode = "ground",
			size = 1,
			rotation = {0, 0, 0},
			stickToGround = false,   -- çœç•¥å¯ï¼ˆtrueãŒæ—¢å®šï¼‰
			groundOffset  = 0,   -- èŠç”Ÿã§å°‘ã—æµ®ã‹ã›ãŸã„æ™‚
			alignToSlope  = false,  -- æ–œé¢ã«æœ¨ã‚’å‚¾ã‘ãŸããªã„ãªã‚‰false

            interaction = {
                type = "chest",           -- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—
                action = "é–‹ã‘ã‚‹",         -- ãƒœã‚¿ãƒ³ã«è¡¨ç¤ºã•ã‚Œã‚‹ãƒ†ã‚­ã‚¹ãƒˆ
                key = "E",                -- ã‚­ãƒ¼ãƒã‚¤ãƒ³ãƒ‰
                range = 8,                -- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³å¯èƒ½è·é›¢ï¼ˆã‚¹ã‚¿ãƒƒãƒ‰ï¼‰

                -- å®ç®±å›ºæœ‰ã®æƒ…å ±
                chestId = "hokkaido_chest_02",          -- ãƒ¦ãƒ‹ãƒ¼ã‚¯ID
                openedModel = "box_opened",         -- é–‹ã„ãŸçŠ¶æ…‹ã®ãƒ¢ãƒ‡ãƒ«å
                rewards = {
                    {item = "ãƒãƒ¼ã‚·ãƒ§ãƒ³", count = 2}
                },
                displayDuration = 10,      -- å ±é…¬è¡¨ç¤ºæ™‚é–“ï¼ˆç§’ï¼‰
            },
		},

				{
			model = "box_closed",
			position = {3125.8, 47.2, -60.7},
            mode = "ground",
			size = 1,
			rotation = {0, 0, 0},
			stickToGround = false,   -- çœç•¥å¯ï¼ˆtrueãŒæ—¢å®šï¼‰
			groundOffset  = 0,   -- èŠç”Ÿã§å°‘ã—æµ®ã‹ã›ãŸã„æ™‚
			alignToSlope  = false,  -- æ–œé¢ã«æœ¨ã‚’å‚¾ã‘ãŸããªã„ãªã‚‰false

            interaction = {
                type = "chest",           -- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—
                action = "é–‹ã‘ã‚‹",         -- ãƒœã‚¿ãƒ³ã«è¡¨ç¤ºã•ã‚Œã‚‹ãƒ†ã‚­ã‚¹ãƒˆ
                key = "E",                -- ã‚­ãƒ¼ãƒã‚¤ãƒ³ãƒ‰
                range = 8,                -- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³å¯èƒ½è·é›¢ï¼ˆã‚¹ã‚¿ãƒƒãƒ‰ï¼‰

                -- å®ç®±å›ºæœ‰ã®æƒ…å ±
                chestId = "hokkaido_chest_03",          -- ãƒ¦ãƒ‹ãƒ¼ã‚¯ID
                openedModel = "box_opened",         -- é–‹ã„ãŸçŠ¶æ…‹ã®ãƒ¢ãƒ‡ãƒ«å
                rewards = {
					{item = "ã‚´ãƒ¼ãƒ«ãƒ‰", count = 120},
                },
                displayDuration = 3,      -- å ±é…¬è¡¨ç¤ºæ™‚é–“ï¼ˆç§’ï¼‰
            },
		},
	},

	paths = {
		{
			name = "MainRoad01",
			points = {                 -- åˆ¶å¾¡ç‚¹ï¼šãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ï¼ˆYã¯ã ã„ãŸã„ã§OKï¼‰
				{92826.4, 19.0, -298.5},
				{92936.1, 26.6, -285.1},
				{92989.4, 26.8, -184.7},
				{93105.4, 23.2, -127.4},
				{93156.3, 19.7, -74.9},
				{93221.8, 30.4, -4.7},
				{93265.4, 24.1, 38.0},
				{93303.9, 20.1, 70.1},
				{93371.1, 20.4, 99.7},
				{93431.9, 20.1, 112.4},
				{93470.7, 19.7, 151.1},
				{93471.7, 18.8, 204.7},
				{93402.1, 19.2, 225.3},
			},
			width = 24,                -- é“ã®å¹…ï¼ˆstudï¼‰
			method = "terrain",        -- "terrain"ï¼ˆåœ°å½¢ã‚’å¡—ã‚‹ï¼‰ or "parts"ï¼ˆãƒ‘ãƒ¼ãƒ„æ•·ãï¼‰
			material = Enum.Material.Ground,  -- method="terrain"æ™‚ã®å¡—ã‚Šæè³ª
			step = 3,                  -- ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°é–“éš”ï¼ˆå°ã•ã„ã»ã©æ»‘ã‚‰ã‹ï¼†é‡ã„ï¼‰
			alignToSlope = false,      -- æ–œé¢ã«é“é¢ã‚’å‚¾ã‘ã‚‹ã‹ï¼ˆè¦‹ãŸç›®ï¼štrueã€æ­©ãã‚„ã™ã•ï¼šfalseï¼‰
			groundOffset = 2.8,       -- ã‚ã‚Šè¾¼ã¿å›é¿ã®å¾®å°ã‚ªãƒ•ã‚»ãƒƒãƒˆ
		},

	},
	fieldObjects = {
		{
			model = "box_closed",
			position = {92895.2, 46.2, -205.6},
			mode = "ground",
			size = 1,
			rotation = {0, 0, 0},
			stickToGround = false,   -- çœç•¥å¯ï¼ˆtrueãŒæ—¢å®šï¼‰
			groundOffset  = 0,   -- èŠç”Ÿã§å°‘ã—æµ®ã‹ã›ãŸã„æ™‚
			alignToSlope  = false,  -- æ–œé¢ã«æœ¨ã‚’å‚¾ã‘ãŸããªã„ãªã‚‰false

			interaction = {
				type = "chest",           -- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—
				action = "é–‹ã‘ã‚‹",         -- ãƒœã‚¿ãƒ³ã«è¡¨ç¤ºã•ã‚Œã‚‹ãƒ†ã‚­ã‚¹ãƒˆ
				key = "E",                -- ã‚­ãƒ¼ãƒã‚¤ãƒ³ãƒ‰
				range = 8,                -- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³å¯èƒ½è·é›¢ï¼ˆã‚¹ã‚¿ãƒƒãƒ‰ï¼‰

				-- å®ç®±å›ºæœ‰ã®æƒ…å ±
				chestId = "kyushu_chest_01",          -- ãƒ¦ãƒ‹ãƒ¼ã‚¯ID
				openedModel = "box_opened",         -- é–‹ã„ãŸçŠ¶æ…‹ã®ãƒ¢ãƒ‡ãƒ«å
				rewards = {
					{item = "ãƒãƒ¼ã‚·ãƒ§ãƒ³", count = 1},
				},
				displayDuration = 2,      -- å ±é…¬è¡¨ç¤ºæ™‚é–“ï¼ˆç§’ï¼‰
			},
		},
	},

	BGM = "rbxassetid://115666507179769",  -- å¾Œã§ã‚¢ã‚»ãƒƒãƒˆIDã«å¤‰æ›´
	BGMVolume = 0.2,  -- éŸ³é‡ï¼ˆ0.0-1.0ï¼‰
}
===== ./ReplicatedStorage/Continents/ContinentShikoku.lua =====
-- ===== ./ReplicatedStorage/Continents/ContinentShikoku.lua (æ–°è¦) =====
return {
	name = "ContinentShikoku",
	displayName = "Shikoku Region",

	islands = {
		"Shikoku_N1", "Shikoku_C1", "Shikoku_S1",
		"Shikoku_E1", "Shikoku_W1",
	},

	bridges = {},

	portals = {
		{
			name = "Shikoku_to_Town",
			toZone = "ContinentTown",
			islandName = "Shikoku_C1", -- ä¸­å¤®ã®å³¶ã‹ã‚‰ãƒãƒ¼ã‚¿ãƒ«
			offsetX = 0,
			offsetZ = 0,
			label = "â†’ Town",
			color = Color3.fromRGB(150, 255, 150), -- ç·‘è‰²ã®ãƒãƒ¼ã‚¿ãƒ«
		}
	},

	BGM = "rbxassetid://139951867631287", -- å¾Œã§ã‚¢ã‚»ãƒƒãƒˆIDã«å¤‰æ›´
	BGMVolume = 0.3,
}
===== ./ReplicatedStorage/Continents/ContinentKyushu.lua =====
--- Continents ---
return {
name = "ContinentKyushu",
displayName = "ContinentKyushu",
islands = {
"ContinentKyushu_C1",
"ContinentKyushu_C2",
"ContinentKyushu_C3",
"ContinentKyushu_C4",
"ContinentKyushu_C5",
"ContinentKyushu_C6",
"ContinentKyushu_C7",
"ContinentKyushu_C8",
"ContinentKyushu_C9",
"ContinentKyushu_C10",
"ContinentKyushu_C11",
"ContinentKyushu_C12",
"ContinentKyushu_C13",
"ContinentKyushu_C14",
"ContinentKyushu_C15",
"ContinentKyushu_C16",
"ContinentKyushu_C17",
"ContinentKyushu_C18",
"ContinentKyushu_C19",
"ContinentKyushu_C20",
"ContinentKyushu_C21",
"ContinentKyushu_C22",
"ContinentKyushu_C23",
"ContinentKyushu_C24",
},
paths = {
	points = {
			{93300, 10, -560},
			{93320, 10, -460},
			{93340, 10, -360},
			{93360, 10, -240},
			{93380, 10, -120},
			{93390, 10, 0},
			{93380, 10, 120},
			{93360, 10, 240},
			{93340, 10, 360},
			{93300, 10, 480},
	},
	width = 24,                -- é“ã®å¹…ï¼ˆstudï¼‰
	method = "terrain",        -- "terrain"ï¼ˆåœ°å½¢ã‚’å¡—ã‚‹ï¼‰ or "parts"ï¼ˆãƒ‘ãƒ¼ãƒ„æ•·ãï¼‰
	material = Enum.Material.Ground,  -- method="terrain"æ™‚ã®å¡—ã‚Šæè³ª
	step = 3,                  -- ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°é–“éš”ï¼ˆå°ã•ã„ã»ã©æ»‘ã‚‰ã‹ï¼†é‡ã„ï¼‰
	alignToSlope = false,      -- æ–œé¢ã«é“é¢ã‚’å‚¾ã‘ã‚‹ã‹ï¼ˆè¦‹ãŸç›®ï¼štrueã€æ­©ãã‚„ã™ã•ï¼šfalseï¼‰
	groundOffset = 4.8,       -- ã‚ã‚Šè¾¼ã¿å›é¿ã®å¾®å°ã‚ªãƒ•ã‚»ãƒƒãƒˆ
},

--93080.8, 38.0, 166.2
portals = {
		{
			name = "Kyushu_to_Town",
			toZone = "ContinentTown",
			islandName = "ContinentKyushu_C20",
			offsetX = 100,
			offsetZ = 100,
			label = "â†’ Town",
			color = Color3.fromRGB(255, 255, 255),
		},
		{
			name = "Kyushu_to_Town",
			toZone = "Hokkaido_SW2",
			islandName = "ContinentKyushu_C22",
			offsetX = 100,
			offsetZ = 100,
			label = "â†’ Hokkaido",
			color = Color3.fromRGB(255, 255, 255),
		}
},


fieldObjects = {
		{
			model = "box_closed",
			position = {92895.2, 46.2, -205.6},
			mode = "ground",
			size = 1,
			rotation = {0, -90, 0},
			stickToGround = false,   -- çœç•¥å¯ï¼ˆtrueãŒæ—¢å®šï¼‰
			groundOffset  = 0,   -- èŠç”Ÿã§å°‘ã—æµ®ã‹ã›ãŸã„æ™‚
			alignToSlope  = false,  -- æ–œé¢ã«æœ¨ã‚’å‚¾ã‘ãŸããªã„ãªã‚‰false

			interaction = {
				type = "chest",           -- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—
				action = "é–‹ã‘ã‚‹",         -- ãƒœã‚¿ãƒ³ã«è¡¨ç¤ºã•ã‚Œã‚‹ãƒ†ã‚­ã‚¹ãƒˆ
				key = "E",                -- ã‚­ãƒ¼ãƒã‚¤ãƒ³ãƒ‰
				range = 18,                -- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³å¯èƒ½è·é›¢ï¼ˆã‚¹ã‚¿ãƒƒãƒ‰ï¼‰

				-- å®ç®±å›ºæœ‰ã®æƒ…å ±
				chestId = "kyushu_chest_01",          -- ãƒ¦ãƒ‹ãƒ¼ã‚¯ID
				openedModel = "box_opened",         -- é–‹ã„ãŸçŠ¶æ…‹ã®ãƒ¢ãƒ‡ãƒ«å
				rewards = {
					{item = "ãƒãƒ¼ã‚·ãƒ§ãƒ³", count = 1},
				},
				displayDuration = 2,      -- å ±é…¬è¡¨ç¤ºæ™‚é–“ï¼ˆç§’ï¼‰
			},
		},
	},

BGM = "",
BGMVolume = 0.2
}
===== ./ReplicatedStorage/Continents/ContientTown.lua =====
-- ===== ./ReplicatedStorage/Continents/ContientTown.lua =====
return {
	name = "ContinentTown",
	displayName = "Start Town",

	islands = {
        "StartTown",
        "Town_NE",
        "Town_SW",
        "Town_SE",
	},

	bridges = {},

	-- â˜…ä¿®æ­£: åŒ—æµ·é“ã€å››å›½ã€ä¹å·ã¸ã®ãƒãƒ¼ã‚¿ãƒ«ã‚’è¿½åŠ 
	portals = {
		{
            name = "Town_to_Hokkaido",
            toZone = "ContinentHokkaido",
            islandName = "StartTown",
            offsetX = 0,
            offsetZ = -50,
            size = Vector3.new(8, 12, 8),
            color = Color3.fromRGB(200, 200, 255),
            label = "â†’ Hokkaido"
        },
        {
            name = "Town_to_Shikoku", -- â˜…æ–°è¦ãƒãƒ¼ã‚¿ãƒ«
            toZone = "ContinentShikoku",
            islandName = "Town_NE",
            offsetX = 0,
            offsetZ = 0,
            size = Vector3.new(8, 12, 8),
            color = Color3.fromRGB(150, 255, 150),
            label = "â†’ Shikoku"
        },
        {
            name = "Town_to_Kyushu",  -- â˜…æ–°è¦ãƒãƒ¼ã‚¿ãƒ«
            toZone = "ContinentKyushu",
            islandName = "Town_SE",
            offsetX = 0,
            offsetZ = 0,
            size = Vector3.new(8, 12, 8),
            color = Color3.fromRGB(255, 100, 100),
            label = "â†’ Kyushu"
        },
	},

    fieldObjects = {
		{
			model = "Chest",
			position = {55, 78, -5.8},
             mode = "ground",
			size = 1.5,
			rotation = {0, 0, 0},
			groundOffset  = 0,   -- èŠç”Ÿã§å°‘ã—æµ®ã‹ã›ãŸã„æ™‚
			alignToSlope  = true,  -- æ–œé¢ã«æœ¨ã‚’å‚¾ã‘ãŸããªã„ãªã‚‰false
		},
		{
			model = "koki3D",
			position = {58.7, 78, -5.8},
            mode = "ground",
			size = 1,
			rotation = {0, 0, 0},
			stickToGround = false,   -- çœç•¥å¯ï¼ˆtrueãŒæ—¢å®šï¼‰
			groundOffset  = 0,   -- èŠç”Ÿã§å°‘ã—æµ®ã‹ã›ãŸã„æ™‚
			alignToSlope  = true,  -- æ–œé¢ã«æœ¨ã‚’å‚¾ã‘ãŸããªã„ãªã‚‰false
		},

		{
			model = "koki3D",
			position = {26.1, 57.6, -9.5},
            mode = "ground",
			size = 0.2,
			rotation = {0, 0, 0},
			stickToGround = false,   -- çœç•¥å¯ï¼ˆtrueãŒæ—¢å®šï¼‰
			groundOffset  = 0,   -- èŠç”Ÿã§å°‘ã—æµ®ã‹ã›ãŸã„æ™‚
			alignToSlope  = true,  -- æ–œé¢ã«æœ¨ã‚’å‚¾ã‘ãŸããªã„ãªã‚‰false
		},

        {
			model = "muichiro",
			position = {23.2, 57.5, -15.2},
            mode = "fixed",
			size = 0.2,
			rotation = {0, 0, 0},
			stickToGround = false,   -- çœç•¥å¯ï¼ˆtrueãŒæ—¢å®šï¼‰
			groundOffset  = 10,   -- èŠç”Ÿã§å°‘ã—æµ®ã‹ã›ãŸã„æ™‚
			alignToSlope  = true,  -- æ–œé¢ã«æœ¨ã‚’å‚¾ã‘ãŸããªã„ãªã‚‰false
            -- upAxis = "",
		}, --

         {
			model = "box_closed",
			position = {42.4, 56.5, 10.9},
            mode = "ground",
			size = 1,
			rotation = {0, 0, 0},
			stickToGround = false,   -- çœç•¥å¯ï¼ˆtrueãŒæ—¢å®šï¼‰
			groundOffset  = 0,   -- èŠç”Ÿã§å°‘ã—æµ®ã‹ã›ãŸã„æ™‚
			alignToSlope  = false,  -- æ–œé¢ã«æœ¨ã‚’å‚¾ã‘ãŸããªã„ãªã‚‰false

            interaction = {
                type = "chest",           -- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—
                action = "é–‹ã‘ã‚‹",         -- ãƒœã‚¿ãƒ³ã«è¡¨ç¤ºã•ã‚Œã‚‹ãƒ†ã‚­ã‚¹ãƒˆ
                key = "E",                -- ã‚­ãƒ¼ãƒã‚¤ãƒ³ãƒ‰
                range = 8,                -- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³å¯èƒ½è·é›¢ï¼ˆã‚¹ã‚¿ãƒƒãƒ‰ï¼‰

                -- å®ç®±å›ºæœ‰ã®æƒ…å ±
                chestId = "town_chest_01",          -- ãƒ¦ãƒ‹ãƒ¼ã‚¯ID
                openedModel = "box_opened",         -- é–‹ã„ãŸçŠ¶æ…‹ã®ãƒ¢ãƒ‡ãƒ«å
                rewards = {
                    {item = "ãƒãƒ¼ã‚·ãƒ§ãƒ³", count = 3},
                    {item = "ã‚´ãƒ¼ãƒ«ãƒ‰", count = 50},
                },
                displayDuration = 3,      -- å ±é…¬è¡¨ç¤ºæ™‚é–“ï¼ˆç§’ï¼‰
            },
		},

		{
			model = "box_closed",
			position = {42.4, 56.5, 20.9},
            mode = "ground",
			size = 1,
			rotation = {0, 0, 0},
			stickToGround = false,   -- çœç•¥å¯ï¼ˆtrueãŒæ—¢å®šï¼‰
			groundOffset  = 0,   -- èŠç”Ÿã§å°‘ã—æµ®ã‹ã›ãŸã„æ™‚
			alignToSlope  = false,  -- æ–œé¢ã«æœ¨ã‚’å‚¾ã‘ãŸããªã„ãªã‚‰false

            interaction = {
                type = "chest",           -- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—
                action = "é–‹ã‘ã‚‹",         -- ãƒœã‚¿ãƒ³ã«è¡¨ç¤ºã•ã‚Œã‚‹ãƒ†ã‚­ã‚¹ãƒˆ
                key = "E",                -- ã‚­ãƒ¼ãƒã‚¤ãƒ³ãƒ‰
                range = 8,                -- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³å¯èƒ½è·é›¢ï¼ˆã‚¹ã‚¿ãƒƒãƒ‰ï¼‰

                -- å®ç®±å›ºæœ‰ã®æƒ…å ±
                chestId = "town_chest_02",          -- ãƒ¦ãƒ‹ãƒ¼ã‚¯ID
                openedModel = "box_opened",         -- é–‹ã„ãŸçŠ¶æ…‹ã®ãƒ¢ãƒ‡ãƒ«å
                rewards = {
                    {item = "ãƒãƒ¼ã‚·ãƒ§ãƒ³", count = 1},
					{item = "ã‚´ãƒ¼ãƒ«ãƒ‰", count = 25},
                },
                displayDuration = 3,      -- å ±é…¬è¡¨ç¤ºæ™‚é–“ï¼ˆç§’ï¼‰
            },
		},

        {
			model = "box_closed",
			position = {31.9, 56.5, 10.9},
            mode = "ground",
			size = 1,
			rotation = {0, 0, 0},
			stickToGround = false,   -- çœç•¥å¯ï¼ˆtrueãŒæ—¢å®šï¼‰
			alignToSlope  = false,  -- æ–œé¢ã«æœ¨ã‚’å‚¾ã‘ãŸããªã„ãªã‚‰false
		},
	},
--m

	BGM = "rbxassetid://139951867631287",  -- å¾Œã§ã‚¢ã‚»ãƒƒãƒˆIDã«å¤‰æ›´
	BGMVolume = 0.2,
}
===== ./ReplicatedStorage/Islands/Bridges.lua =====
return {
	{
		name = "Bridge_Start_to_Forest",
		fromIsland = 1,
		toIsland = 2,
		width = 15,  -- 20ã‹ã‚‰15ã«å¤‰æ›´ï¼ˆæ©‹ã‚‚å°‘ã—ç´°ãï¼‰
		height = 5,
	},
}
===== ./ReplicatedStorage/Islands/Greenland.lua =====
return {
{
name = "VerdantPlateau_C1",
centerX = 3000,
centerZ = 0,
sizeXZ = 300,
baseY = 8,
thickness = 14,
grid = 14,
hillAmplitude = 6,
hillScale = 160,
seed = 41021,
generateOcean = false,
baseMaterial = Enum.Material.Grass,
},
{
name = "VerdantPlateau_C2",
centerX = 3280,
centerZ = -120,
sizeXZ = 290,
baseY = 8,
thickness = 14,
grid = 14,
hillAmplitude = 6,
hillScale = 160,
seed = 51239,
generateOcean = false,
baseMaterial = Enum.Material.Grass,
},
{
name = "VerdantPlateau_C3",
centerX = 2720,
centerZ = -100,
sizeXZ = 280,
baseY = 8,
thickness = 14,
grid = 14,
hillAmplitude = 6,
hillScale = 160,
seed = 63917,
generateOcean = false,
baseMaterial = Enum.Material.Grass,
},
{
name = "VerdantPlateau_C4",
centerX = 3000,
centerZ = 260,
sizeXZ = 270,
baseY = 8,
thickness = 14,
grid = 14,
hillAmplitude = 6,
hillScale = 160,
seed = 74288,
generateOcean = false,
baseMaterial = Enum.Material.Grass,
},
}
===== ./ReplicatedStorage/Islands/Town.lua =====
-- ReplicatedStorage/Islands/Town.lua (4ã¤ã®å³¶ã§æ§‹æˆã•ã‚Œã‚‹Townã‚¨ãƒªã‚¢ - é‡è¤‡ç‰ˆ)

return {
    -- 1. StartTown (North-West, ãƒ¡ã‚¤ãƒ³ã‚¹ãƒãƒ¼ãƒ³åœ°ç‚¹)
    {
        name = "StartTown",
        centerX = -50, -- â˜…ä¿®æ­£: -100ã‹ã‚‰-50ã¸ (X:-150ã€œ150)
        centerZ = 50,  -- â˜…ä¿®æ­£: 100ã‹ã‚‰50ã¸ (Z:-150ã€œ150)
        sizeXZ = 200,
        baseY = 50,
        thickness = 8,
        grid = 10,
        hillAmplitude = 3,
        hillScale = 80,
        seed = 77777,
        generateOcean = false,
        safeZone = true,
        baseMaterial = Enum.Material.Slate,
    },

    -- 2. Town_NE (North-East)
    {
        name = "Town_NE",
        centerX = 50, -- â˜…ä¿®æ­£: 100ã‹ã‚‰50ã¸
        centerZ = 50, -- â˜…ä¿®æ­£: 100ã‹ã‚‰50ã¸
        sizeXZ = 200,
        baseY = 50,
        thickness = 8,
        grid = 10,
        hillAmplitude = 3,
        hillScale = 80,
        seed = 77778,
        generateOcean = false,
        safeZone = true,
        baseMaterial = Enum.Material.Slate,
    },

    -- 3. Town_SW (South-West)
    {
        name = "Town_SW",
        centerX = -50, -- â˜…ä¿®æ­£: -100ã‹ã‚‰-50ã¸
        centerZ = -50, -- â˜…ä¿®æ­£: -100ã‹ã‚‰-50ã¸
        sizeXZ = 200,
        baseY = 50,
        thickness = 8,
        grid = 10,
        hillAmplitude = 3,
        hillScale = 80,
        seed = 77779,
        generateOcean = false,
        safeZone = true,
        baseMaterial = Enum.Material.Slate,
    },

    -- 4. Town_SE (South-East)
    {
        name = "Town_SE",
        centerX = 50, -- â˜…ä¿®æ­£: 100ã‹ã‚‰50ã¸
        centerZ = -50, -- â˜…ä¿®æ­£: -100ã‹ã‚‰-50ã¸
        sizeXZ = 200,
        baseY = 50,
        thickness = 8,
        grid = 10,
        hillAmplitude = 3,
        hillScale = 80,
        seed = 77780,
        generateOcean = false,
        safeZone = true,
        baseMaterial = Enum.Material.Slate,
    },
}
===== ./ReplicatedStorage/Islands/HokkaidoIslands.lua =====
-- ReplicatedStorage/Islands/HokkaidoIslands
return {
	-- ä¸­å¤®éƒ¨
	{name = "Hokkaido_W1", centerX = 3000, centerZ = 0, sizeXZ = 160, baseY = 10, thickness = 40, grid = 10, hillAmplitude = 15, hillScale = 1, seed = 0, generateOcean = false, baseMaterial = Enum.Material.LeafyGrass, },
	{name = "Hokkaido_C1", centerX = 3080, centerZ = 0, sizeXZ = 160, baseY = 10, thickness = 40, grid = 10, hillAmplitude = 15, hillScale = 1, seed = 0, generateOcean = false, baseMaterial = Enum.Material.LeafyGrass, },
	{name = "Hokkaido_C2", centerX = 3160, centerZ = 0, sizeXZ = 160, baseY = 10, thickness = 40, grid = 10, hillAmplitude = 15, hillScale = 1, seed = 0, generateOcean = false, baseMaterial = Enum.Material.LeafyGrass, },
	{name = "Hokkaido_C3", centerX = 3240, centerZ = 0, sizeXZ = 160, baseY = 10, thickness = 40, grid = 10, hillAmplitude = 15, hillScale = 1, seed = 0, generateOcean = false, baseMaterial = Enum.Material.LeafyGrass, },
	{name = "Hokkaido_C4", centerX = 3320, centerZ = 0, sizeXZ = 160, baseY = 10, thickness = 40, grid = 10, hillAmplitude = 15, hillScale = 1, seed = 0, generateOcean = false, baseMaterial = Enum.Material.LeafyGrass, },
	{name = "Hokkaido_C5", centerX = 3400, centerZ = 0, sizeXZ = 160, baseY = 10, thickness = 40, grid = 10, hillAmplitude = 15, hillScale = 1, seed = 0, generateOcean = false, baseMaterial = Enum.Material.LeafyGrass, },
	{name = "Hokkaido_E1", centerX = 3480, centerZ = 0, sizeXZ = 160, baseY = 10, thickness = 40, grid = 2, hillAmplitude = 160, hillScale = 160, seed = 0, generateOcean = false, baseMaterial = Enum.Material.LeafyGrass, },

	-- åŒ—éƒ¨
	{name = "Hokkaido_N1", centerX = 3080, centerZ = 80, sizeXZ = 160, baseY = 10, thickness = 10, grid = 10, hillAmplitude = 1, hillScale = 500, seed = 0, generateOcean = false, baseMaterial = Enum.Material.LeafyGrass, },
	{name = "Hokkaido_N2", centerX = 3160, centerZ = 80, sizeXZ = 160, baseY = 10, thickness = 10, grid = 10, hillAmplitude = 1, hillScale = 500, seed = 0, generateOcean = false, baseMaterial = Enum.Material.LeafyGrass, },
	{name = "Hokkaido_N3", centerX = 3240, centerZ = 80, sizeXZ = 160, baseY = 10, thickness = 10, grid = 10, hillAmplitude = 1, hillScale = 500, seed = 0, generateOcean = false, baseMaterial = Enum.Material.LeafyGrass, },
	{name = "Hokkaido_N4", centerX = 3320, centerZ = 80, sizeXZ = 160, baseY = 10, thickness = 10, grid = 10, hillAmplitude = 1, hillScale = 500, seed = 0, generateOcean = false, baseMaterial = Enum.Material.LeafyGrass, },

	-- åŒ—æ±éƒ¨ï¼ˆçŸ¥åºŠï¼‰
	{name = "Hokkaido_NE1", centerX = 3320, centerZ = 160, sizeXZ = 160, baseY = 10, thickness = 10, grid = 10, hillAmplitude = 10, hillScale = 500, seed = 50000, generateOcean = false, baseMaterial = Enum.Material.LeafyGrass, },
	{name = "Hokkaido_NE2", centerX = 3400, centerZ = 160, sizeXZ = 160, baseY = 10, thickness = 10, grid = 10, hillAmplitude = 10, hillScale = 500, seed = 50000, generateOcean = false, baseMaterial = Enum.Material.LeafyGrass, },

	-- å—éƒ¨
	{name = "Hokkaido_S1", centerX = 3160, centerZ = -80, sizeXZ = 200, baseY = 10, thickness = 10, grid = 2, hillAmplitude = 120, hillScale = 100, seed = 50000, generateOcean = false, baseMaterial = Enum.Material.LeafyGrass, },
	{name = "Hokkaido_S2", centerX = 3240, centerZ = -80, sizeXZ = 200, baseY = 10, thickness = 10, grid = 1, hillAmplitude = 200, hillScale = 200, seed = 50000, generateOcean = false, baseMaterial = Enum.Material.LeafyGrass, },

	-- å—è¥¿éƒ¨ï¼ˆæ¸¡å³¶ï¼‰
	{name = "Hokkaido_SW1", centerX = 3080, centerZ = -160, sizeXZ = 160, baseY = 10, thickness = 10, grid = 1, hillAmplitude = 300, hillScale = 160, seed = 50000, generateOcean = false, baseMaterial = Enum.Material.LeafyGrass, },
	{name = "Hokkaido_SW2", centerX = 3160, centerZ = -160, sizeXZ = 160, baseY = 10, thickness = 10, grid = 1, hillAmplitude = 400, hillScale = 20, seed = 50000, generateOcean = true, baseMaterial = Enum.Material.LeafyGrass, oceanRadius = 2000},
}
===== ./ReplicatedStorage/Islands/Registry.lua =====
-- ===== ./ReplicatedStorage/Islands/Registry.lua =====
-- ReplicatedStorage/Islands/Registry.lua (å…¨ã‚³ãƒ¼ãƒ‰)
local RS = game:GetService("ReplicatedStorage")
local IslandsFolder = RS:WaitForChild("Islands")

local allIslands = {}

-- å³¶å®šç¾©ã®ãƒªã‚¹ãƒˆ
local islandModules = {
    IslandsFolder:WaitForChild("Town"),           -- ã€ä¿®æ­£ã€‘Town.lua ã‚’å‚ç…§
    IslandsFolder:WaitForChild("HokkaidoIslands"),
    IslandsFolder:WaitForChild("ShikokuIslands"),
    IslandsFolder:WaitForChild("KyushuIslands"),
    IslandsFolder:WaitForChild("Snowland"),
     IslandsFolder:WaitForChild("Greenland"),
}

-- å„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’èª­ã¿è¾¼ã¿
for _, module in ipairs(islandModules) do
    local result = require(module)

    -- Town (å˜ä¸€ãƒ†ãƒ¼ãƒ–ãƒ«) ã¨ Hokkaido (é…åˆ—) ã®ä¸¡æ–¹ã‚’å‡¦ç†
    if result and result.name then
        -- å˜ä¸€ã®å³¶å®šç¾© (Town)
        table.insert(allIslands, result)
    elseif type(result) == "table" and #result > 0 then
        -- è¤‡æ•°ã®å³¶å®šç¾©ï¼ˆé…åˆ—, Hokkaidoï¼‰
        for _, island in ipairs(result) do
            if island and island.name then
                table.insert(allIslands, island)
            else
                warn(("[Islands/Registry] '%s' ã‹ã‚‰å–å¾—ã—ãŸãƒªã‚¹ãƒˆã«ç„¡åŠ¹ãªè¦ç´ ãŒã‚ã‚Šã¾ã™"):format(module.Name))
            end
        end
    else
        warn(("[Islands/Registry] ä¸æ­£ãªå³¶å®šç¾©: '%s'"):format(module.Name))
    end
end

print(("[Islands/Registry] åˆè¨ˆ %d å€‹ã®å³¶ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ"):format(#allIslands))

return allIslands
===== ./ReplicatedStorage/Islands/Snowland.lua =====
return {
{
name = "SnowCrescent_C1",
centerX = 2880,
centerZ = -550,
sizeXZ = 200,
baseY = 400,
thickness = 60,
grid = 12,
hillAmplitude = 8,
hillScale = 150,
seed = 18431,
generateOcean = true,
oceanRadius = 1000,
baseMaterial = Enum.Material.Snow,
},
{
name = "SnowCrescent_C2",
centerX = 2860,
centerZ = -480,
sizeXZ = 210,
baseY = 400,
thickness = 60,
grid = 12,
hillAmplitude = 7,
hillScale = 150,
seed = 29455,
generateOcean = true,
oceanRadius = 1000,
baseMaterial = Enum.Material.Snow,
},
{
name = "SnowCrescent_C3",
centerX = 2850,
centerZ = -420,
sizeXZ = 220,
baseY = 400,
thickness = 62,
grid = 12,
hillAmplitude = 9,
hillScale = 150,
seed = 37512,
generateOcean = true,
oceanRadius = 1000,
baseMaterial = Enum.Material.Snow,
},
{
name = "SnowCrescent_C4",
centerX = 2840,
centerZ = -360,
sizeXZ = 220,
baseY = 400,
thickness = 62,
grid = 12,
hillAmplitude = 8,
hillScale = 150,
seed = 51234,
generateOcean = true,
oceanRadius = 1000,
baseMaterial = Enum.Material.Snow,
},
{
name = "SnowCrescent_C5",
centerX = 2830,
centerZ = -300,
sizeXZ = 210,
baseY = 400,
thickness = 62,
grid = 12,
hillAmplitude = 7,
hillScale = 150,
seed = 63821,
generateOcean = true,
oceanRadius = 1000,
baseMaterial = Enum.Material.Snow,
},
{
name = "SnowCrescent_C6",
centerX = 2825,
centerZ = -230,
sizeXZ = 200,
baseY = 400,
thickness = 64,
grid = 12,
hillAmplitude = 6,
hillScale = 150,
seed = 74092,
generateOcean = true,
oceanRadius = 1000,
baseMaterial = Enum.Material.Snow,
},
{
name = "SnowCrescent_C7",
centerX = 2815,
centerZ = -170,
sizeXZ = 190,
baseY = 400,
thickness = 64,
grid = 12,
hillAmplitude = 6,
hillScale = 150,
seed = 81937,
generateOcean = true,
oceanRadius = 1000,
baseMaterial = Enum.Material.Snow,
},
{
name = "SnowCrescent_C8",
centerX = 2805,
centerZ = -110,
sizeXZ = 190,
baseY = 400,
thickness = 64,
grid = 12,
hillAmplitude = 6,
hillScale = 150,
seed = 92741,
generateOcean = true,
oceanRadius = 1000,
baseMaterial = Enum.Material.Snow,
},
{
name = "SnowCrescent_C9",
centerX = 2800,
centerZ = -50,
sizeXZ = 190,
baseY = 400,
thickness = 66,
grid = 12,
hillAmplitude = 6,
hillScale = 150,
seed = 103885,
generateOcean = true,
oceanRadius = 1000,
baseMaterial = Enum.Material.Snow,
},
{
name = "SnowCrescent_C10",
centerX = 2805,
centerZ = 10,
sizeXZ = 190,
baseY = 400,
thickness = 66,
grid = 12,
hillAmplitude = 7,
hillScale = 150,
seed = 118234,
generateOcean = true,
oceanRadius = 1000,
baseMaterial = Enum.Material.Snow,
},
{
name = "SnowCrescent_C11",
centerX = 2815,
centerZ = 70,
sizeXZ = 200,
baseY = 400,
thickness = 70,
grid = 12,
hillAmplitude = 32,
hillScale = 160,
seed = 129776,
generateOcean = true,
oceanRadius = 1000,
baseMaterial = Enum.Material.Snow,
},
{
name = "SnowCrescent_C12",
centerX = 2825,
centerZ = 140,
sizeXZ = 210,
baseY = 400,
thickness = 72,
grid = 12,
hillAmplitude = 36,
hillScale = 165,
seed = 130992,
generateOcean = true,
oceanRadius = 1000,
baseMaterial = Enum.Material.Snow,
},
{
name = "SnowCrescent_C13",
centerX = 2835,
centerZ = 220,
sizeXZ = 220,
baseY = 400,
thickness = 74,
grid = 12,
hillAmplitude = 38,
hillScale = 170,
seed = 145332,
generateOcean = true,
oceanRadius = 1000,
baseMaterial = Enum.Material.Snow,
},
{
name = "SnowCrescent_C14",
centerX = 2850,
centerZ = 320,
sizeXZ = 220,
baseY = 400,
thickness = 76,
grid = 12,
hillAmplitude = 40,
hillScale = 170,
seed = 158221,
generateOcean = true,
oceanRadius = 1000,
baseMaterial = Enum.Material.Snow,
},
{
name = "SnowCrescent_C15",
centerX = 2870,
centerZ = 440,
sizeXZ = 220,
baseY = 400,
thickness = 78,
grid = 12,
hillAmplitude = 40,
hillScale = 175,
seed = 169554,
generateOcean = true,
oceanRadius = 1000,
baseMaterial = Enum.Material.Snow,
},
}
===== ./ReplicatedStorage/Islands/ShikokuIslands.lua =====
-- ===== ./ReplicatedStorage/Islands/ShikokuIslands.lua (æ–°è¦) =====
return {
	-- åŒ—éƒ¨
	{
        name = "Shikoku_N1", centerX = 550, centerZ = 50, sizeXZ = 150, baseY = 10, thickness = 10, grid = 10,
        hillAmplitude = 15, hillScale = 100, seed = 60001, generateOcean = false, baseMaterial = Enum.Material.Sand,
    },
    -- ä¸­å¤®
	{
        name = "Shikoku_C1", centerX = 600, centerZ = 0, sizeXZ = 180, baseY = 10, thickness = 10, grid = 10,
        hillAmplitude = 20, hillScale = 120, seed = 60002, generateOcean = false, baseMaterial = Enum.Material.Sand,
    },
    -- å—éƒ¨
	{
        name = "Shikoku_S1", centerX = 650, centerZ = -50, sizeXZ = 150, baseY = 10, thickness = 10, grid = 10,
        hillAmplitude = 15, hillScale = 100, seed = 60003, generateOcean = false, baseMaterial = Enum.Material.Sand,
    },
    -- æ±éƒ¨
	{
        name = "Shikoku_E1", centerX = 650, centerZ = 50, sizeXZ = 100, baseY = 10, thickness = 10, grid = 10,
        hillAmplitude = 10, hillScale = 80, seed = 60004, generateOcean = false, baseMaterial = Enum.Material.Sand,
    },
    -- è¥¿éƒ¨
	{
        name = "Shikoku_W1", centerX = 550, centerZ = -50, sizeXZ = 100, baseY = 10, thickness = 10, grid = 10,
        hillAmplitude = 10, hillScale = 80, seed = 60005, generateOcean = true, oceanRadius = 1000, baseMaterial = Enum.Material.Sand,
    },
}
===== ./ReplicatedStorage/Islands/KyushuIslands.lua =====
--- Islands ---
return {
{
name = "ContinentKyushu_C1",
centerX = 92900,
centerZ = -520,
sizeXZ = 320,
baseY = 10,
thickness = 30,
grid = 5,
hillAmplitude = 64,
hillScale = 260,
seed = 0,
generateOcean = true,
oceanRadius = 2000,
baseMaterial = Enum.Material.LeafyGrass,
},
{
name = "ContinentKyushu_C2",
centerX = 93050,
centerZ = -520,
sizeXZ = 340,
baseY = 10,
thickness = 30,
grid = 5,
hillAmplitude = 68,
hillScale = 260,
seed = 0,
generateOcean = true,
oceanRadius = 2000,
baseMaterial = Enum.Material.LeafyGrass,
},
{
name = "ContinentKyushu_C3",
centerX = 93200,
centerZ = -480,
sizeXZ = 300,
baseY = 10,
thickness = 30,
grid = 5,
hillAmplitude = 60,
hillScale = 270,
seed = 0,
generateOcean = true,
oceanRadius = 2000,
baseMaterial = Enum.Material.LeafyGrass,
},
{
name = "ContinentKyushu_C4",
centerX = 93000,
centerZ = -420,
sizeXZ = 360,
baseY = 10,
thickness = 30,
grid = 5,
hillAmplitude = 72,
hillScale = 250,
seed = 0,
generateOcean = true,
oceanRadius = 2000,
baseMaterial = Enum.Material.LeafyGrass,
},
{
name = "ContinentKyushu_C5",
centerX = 92800,
centerZ = -420,
sizeXZ = 300,
baseY = 9,
thickness = 30,
grid = 5,
hillAmplitude = 60,
hillScale = 260,
seed = 0,
generateOcean = true,
oceanRadius = 2000,
baseMaterial = Enum.Material.LeafyGrass,
},
{
name = "ContinentKyushu_C6",
centerX = 93150,
centerZ = -360,
sizeXZ = 320,
baseY = 10,
thickness = 30,
grid = 5,
hillAmplitude = 64,
hillScale = 260,
seed = 0,
generateOcean = true,
oceanRadius = 2000,
baseMaterial = Enum.Material.LeafyGrass,
},
{
name = "ContinentKyushu_C7",
centerX = 92920,
centerZ = -340,
sizeXZ = 280,
baseY = 10,
thickness = 30,
grid = 5,
hillAmplitude = 56,
hillScale = 270,
seed = 0,
generateOcean = true,
oceanRadius = 2000,
baseMaterial = Enum.Material.LeafyGrass,
},
{
name = "ContinentKyushu_C8",
centerX = 93050,
centerZ = -240,
sizeXZ = 380,
baseY = 11,
thickness = 30,
grid = 2,
hillAmplitude = 80,
hillScale = 180,
seed = 0,
generateOcean = true,
oceanRadius = 2000,
baseMaterial = Enum.Material.LeafyGrass,
},
{
name = "ContinentKyushu_C9",
centerX = 93200,
centerZ = -200,
sizeXZ = 320,
baseY = 11,
thickness = 30,
grid = 5,
hillAmplitude = 60,
hillScale = 200,
seed = 0,
generateOcean = true,
oceanRadius = 2000,
baseMaterial = Enum.Material.LeafyGrass,
},
{
name = "ContinentKyushu_C10",
centerX = 92900,
centerZ = -200,
sizeXZ = 300,
baseY = 11,
thickness = 30,
grid = 6,
hillAmplitude = 50,
hillScale = 210,
seed = 0,
generateOcean = true,
oceanRadius = 2000,
baseMaterial = Enum.Material.LeafyGrass,
},
{
name = "ContinentKyushu_C11",
centerX = 93300,
centerZ = -80,
sizeXZ = 340,
baseY = 11,
thickness = 30,
grid = 5,
hillAmplitude = 70,
hillScale = 210,
seed = 0,
generateOcean = true,
oceanRadius = 2000,
baseMaterial = Enum.Material.LeafyGrass,
},
{
name = "ContinentKyushu_C12",
centerX = 93000,
centerZ = -40,
sizeXZ = 360,
baseY = 12,
thickness = 30,
grid = 6,
hillAmplitude = 80,
hillScale = 190,
seed = 0,
generateOcean = true,
oceanRadius = 2000,
baseMaterial = Enum.Material.LeafyGrass,
},
{
name = "ContinentKyushu_C13",
centerX = 93150,
centerZ = 60,
sizeXZ = 340,
baseY = 12,
thickness = 30,
grid = 6,
hillAmplitude = 70,
hillScale = 190,
seed = 0,
generateOcean = true,
oceanRadius = 2000,
baseMaterial = Enum.Material.LeafyGrass,
},
{
name = "ContinentKyushu_C14",
centerX = 93000,
centerZ = 160,
sizeXZ = 360,
baseY = 12,
thickness = 30,
grid = 8,
hillAmplitude = 80,
hillScale = 180,
seed = 0,
generateOcean = true,
oceanRadius = 2000,
baseMaterial = Enum.Material.LeafyGrass,
},
{
name = "ContinentKyushu_C15",
centerX = 92850,
centerZ = 220,
sizeXZ = 300,
baseY = 11,
thickness = 30,
grid = 5,
hillAmplitude = 50,
hillScale = 190,
seed = 0,
generateOcean = true,
oceanRadius = 2000,
baseMaterial = Enum.Material.LeafyGrass,
},
{
name = "ContinentKyushu_C16",
centerX = 93120,
centerZ = 300,
sizeXZ = 320,
baseY = 11,
thickness = 30,
grid = 5,
hillAmplitude = 60,
hillScale = 190,
seed = 0,
generateOcean = true,
oceanRadius = 2000,
baseMaterial = Enum.Material.LeafyGrass,
},
{
name = "ContinentKyushu_C17",
centerX = 93000,
centerZ = 380,
sizeXZ = 300,
baseY = 11,
thickness = 30,
grid = 8,
hillAmplitude = 50,
hillScale = 180,
seed = 0,
generateOcean = true,
oceanRadius = 2000,
baseMaterial = Enum.Material.LeafyGrass,
},
{
name = "ContinentKyushu_C18",
centerX = 93180,
centerZ = 470,
sizeXZ = 240,
baseY = 12,
thickness = 30,
grid = 2,
hillAmplitude = 140,
hillScale = 160,
seed = 0,
generateOcean = true,
oceanRadius = 2000,
baseMaterial = Enum.Material.Basalt,
},
{
name = "ContinentKyushu_C19",
centerX = 92760,
centerZ = -60,
sizeXZ = 220,
baseY = 10,
thickness = 30,
grid = 5,
hillAmplitude = 70,
hillScale = 220,
seed = 0,
generateOcean = true,
oceanRadius = 2000,
baseMaterial = Enum.Material.LeafyGrass,
},
{
name = "ContinentKyushu_C20",
centerX = 92700,
centerZ = 40,
sizeXZ = 200,
baseY = 10,
thickness = 30,
grid = 5,
hillAmplitude = 15,
hillScale = 220,
seed = 0,
generateOcean = true,
oceanRadius = 2000,
baseMaterial = Enum.Material.LeafyGrass,
},
{
name = "ContinentKyushu_C21",
centerX = 92680,
centerZ = 140,
sizeXZ = 180,
baseY = 10,
thickness = 30,
grid = 5,
hillAmplitude = 15,
hillScale = 220,
seed = 0,
generateOcean = true,
oceanRadius = 2000,
baseMaterial = Enum.Material.LeafyGrass,
},
{
name = "ContinentKyushu_C22",
centerX = 92750,
centerZ = 220,
sizeXZ = 200,
baseY = 10,
thickness = 30,
grid = 5,
hillAmplitude = 15,
hillScale = 220,
seed = 0,
generateOcean = true,
oceanRadius = 2000,
baseMaterial = Enum.Material.LeafyGrass,
},
{
name = "ContinentKyushu_C23",
centerX = 93350,
centerZ = 40,
sizeXZ = 320,
baseY = 10,
thickness = 30,
grid = 5,
hillAmplitude = 15,
hillScale = 260,
seed = 0,
generateOcean = true,
oceanRadius = 2000,
baseMaterial = Enum.Material.LeafyGrass,
},
{
name = "ContinentKyushu_C24",
centerX = 93420,
centerZ = 160,
sizeXZ = 300,
baseY = 9,
thickness = 30,
grid = 5,
hillAmplitude = 15,
hillScale = 270,
seed = 0,
generateOcean = true,
oceanRadius = 2000,
baseMaterial = Enum.Material.LeafyGrass,
},
}
===== ./ReplicatedStorage/TypingWords.lua =====
-- ReplicatedStorage/TypingWords
-- ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ç”¨ã®å˜èªãƒªã‚¹ãƒˆï¼ˆå¤šè¨€èªå¯¾å¿œï¼‰

return {
	level_1 = {
		{word = "cat", ja = "çŒ«", es = "gato", fr = "chat"},
		{word = "dog", ja = "çŠ¬", es = "perro", fr = "chien"},
		{word = "pen", ja = "ãƒšãƒ³", es = "pluma", fr = "stylo"},
		{word = "cup", ja = "ã‚«ãƒƒãƒ—", es = "taza", fr = "tasse"},
		{word = "sun", ja = "å¤ªé™½", es = "sol", fr = "soleil"},
		{word = "red", ja = "èµ¤", es = "rojo", fr = "rouge"},
		{word = "big", ja = "å¤§ãã„", es = "grande", fr = "grand"},
		{word = "run", ja = "èµ°ã‚‹", es = "correr", fr = "courir"},
		{word = "fly", ja = "é£›ã¶", es = "volar", fr = "voler"},
		{word = "eat", ja = "é£Ÿã¹ã‚‹", es = "comer", fr = "manger"},
	},
	level_2 = {
		{word = "apple", ja = "ã‚Šã‚“ã”", es = "manzana", fr = "pomme"},
		{word = "house", ja = "å®¶", es = "casa", fr = "maison"},
		{word = "water", ja = "æ°´", es = "agua", fr = "eau"},
		{word = "sleep", ja = "çœ ã‚‹", es = "dormir", fr = "dormir"},
		{word = "happy", ja = "å¹¸ã›", es = "feliz", fr = "heureux"},
		{word = "green", ja = "ç·‘", es = "verde", fr = "vert"},
		{word = "river", ja = "å·", es = "rÃ­o", fr = "riviÃ¨re"},
		{word = "night", ja = "å¤œ", es = "noche", fr = "nuit"},
		{word = "music", ja = "éŸ³æ¥½", es = "mÃºsica", fr = "musique"},
		{word = "stone", ja = "çŸ³", es = "piedra", fr = "pierre"},
	},
	level_3 = {
		{word = "banana", ja = "ãƒãƒŠãƒŠ", es = "plÃ¡tano", fr = "banane"},
		{word = "orange", ja = "ã‚ªãƒ¬ãƒ³ã‚¸", es = "naranja", fr = "orange"},
		{word = "yellow", ja = "é»„è‰²", es = "amarillo", fr = "jaune"},
		{word = "purple", ja = "ç´«", es = "morado", fr = "violet"},
		{word = "animal", ja = "å‹•ç‰©", es = "animal", fr = "animal"},
		{word = "window", ja = "çª“", es = "ventana", fr = "fenÃªtre"},
		{word = "garden", ja = "åº­", es = "jardÃ­n", fr = "jardin"},
		{word = "bridge", ja = "æ©‹", es = "puente", fr = "pont"},
		{word = "planet", ja = "æƒ‘æ˜Ÿ", es = "planeta", fr = "planÃ¨te"},
		{word = "forest", ja = "æ£®", es = "bosque", fr = "forÃªt"},
	},
	level_4 = {
		{word = "monday", ja = "æœˆæ›œæ—¥", es = "lunes", fr = "lundi"},
		{word = "sunday", ja = "æ—¥æ›œæ—¥", es = "domingo", fr = "dimanche"},
		{word = "friday", ja = "é‡‘æ›œæ—¥", es = "viernes", fr = "vendredi"},
		{word = "winter", ja = "å†¬", es = "invierno", fr = "hiver"},
		{word = "summer", ja = "å¤", es = "verano", fr = "Ã©tÃ©"},
		{word = "spring", ja = "æ˜¥", es = "primavera", fr = "printemps"},
		{word = "autumn", ja = "ç§‹", es = "otoÃ±o", fr = "automne"},
		{word = "dragon", ja = "ãƒ‰ãƒ©ã‚´ãƒ³", es = "dragÃ³n", fr = "dragon"},
		{word = "castle", ja = "åŸ", es = "castillo", fr = "chÃ¢teau"},
		{word = "warrior", ja = "æˆ¦å£«", es = "guerrero", fr = "guerrier"},
	},
	level_5 = {
		{word = "mountain", ja = "å±±", es = "montaÃ±a", fr = "montagne"},
		{word = "keyboard", ja = "ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰", es = "teclado", fr = "clavier"},
		{word = "computer", ja = "ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿", es = "computadora", fr = "ordinateur"},
		{word = "adventure", ja = "å†’é™º", es = "aventura", fr = "aventure"},
		{word = "beautiful", ja = "ç¾ã—ã„", es = "hermoso", fr = "beau"},
		{word = "champion", ja = "ãƒãƒ£ãƒ³ãƒ”ã‚ªãƒ³", es = "campeÃ³n", fr = "champion"},
		{word = "treasure", ja = "å®ç‰©", es = "tesoro", fr = "trÃ©sor"},
		{word = "butterfly", ja = "è¶", es = "mariposa", fr = "papillon"},
		{word = "elephant", ja = "è±¡", es = "elefante", fr = "Ã©lÃ©phant"},
		{word = "challenge", ja = "æŒ‘æˆ¦", es = "desafÃ­o", fr = "dÃ©fi"},
	},
}
===== ./ReplicatedStorage/GameEvents.lua =====
-- ReplicatedStorage/GameEvents.lua
-- ã‚¤ãƒ™ãƒ³ãƒˆé§†å‹•é€šä¿¡ã‚·ã‚¹ãƒ†ãƒ ï¼ˆå¾ªç’°ä¾å­˜ã‚’é˜²ããŸã‚ã®é€šä¿¡ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼‰

local GameEvents = {}

local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- ã‚¤ãƒ™ãƒ³ãƒˆæ ¼ç´ç”¨ãƒ•ã‚©ãƒ«ãƒ€ã‚’ä½œæˆ
local eventFolder = ReplicatedStorage:FindFirstChild("GameEventBindables")
if not eventFolder then
	eventFolder = Instance.new("Folder")
	eventFolder.Name = "GameEventBindables"
	eventFolder.Parent = ReplicatedStorage
end

-- ã‚¤ãƒ™ãƒ³ãƒˆã‚’å–å¾—ã¾ãŸã¯ä½œæˆ
local function getOrCreateEvent(name)
	local event = eventFolder:FindFirstChild(name)
	if not event then
		event = Instance.new("BindableEvent")
		event.Name = name
		event.Parent = eventFolder
		print(("[GameEvents] Created event: %s"):format(name))
	end
	return event
end

-- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼é–¢é€£ã‚¤ãƒ™ãƒ³ãƒˆ
GameEvents.MonsterCountRequest = getOrCreateEvent("MonsterCountRequest")
GameEvents.MonsterCountResponse = getOrCreateEvent("MonsterCountResponse")
GameEvents.MonsterSpawned = getOrCreateEvent("MonsterSpawned")
GameEvents.MonsterDespawned = getOrCreateEvent("MonsterDespawned")

-- ã‚»ãƒ¼ãƒ–/ãƒ­ãƒ¼ãƒ‰é–¢é€£ã‚¤ãƒ™ãƒ³ãƒˆ
GameEvents.SaveRequest = getOrCreateEvent("SaveRequest")
GameEvents.SaveComplete = getOrCreateEvent("SaveComplete")
GameEvents.LoadComplete = getOrCreateEvent("LoadComplete")

-- ã‚¾ãƒ¼ãƒ³é–¢é€£ã‚¤ãƒ™ãƒ³ãƒˆ
GameEvents.ZoneChanged = getOrCreateEvent("ZoneChanged")
GameEvents.ZoneLoadStart = getOrCreateEvent("ZoneLoadStart")
GameEvents.ZoneLoadComplete = getOrCreateEvent("ZoneLoadComplete")

-- ãƒãƒˆãƒ«é–¢é€£ã‚¤ãƒ™ãƒ³ãƒˆ
GameEvents.BattleStateChanged = getOrCreateEvent("BattleStateChanged")

-- ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°ï¼šã‚¤ãƒ™ãƒ³ãƒˆç™ºç«ï¼ˆãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°ä»˜ãï¼‰
function GameEvents.Fire(eventName, ...)
	local event = GameEvents[eventName]
	if event then
		print(("[GameEvents] Firing: %s"):format(eventName))
		event:Fire(...)
	else
		warn(("[GameEvents] Event not found: %s"):format(eventName))
	end
end

-- ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°ï¼šã‚¤ãƒ™ãƒ³ãƒˆå¾…æ©Ÿï¼ˆã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆä»˜ãï¼‰
function GameEvents.Wait(eventName, timeout)
	local event = GameEvents[eventName]
	if not event then
		warn(("[GameEvents] Event not found: %s"):format(eventName))
		return nil
	end

	timeout = timeout or 5
	local startTime = tick()
	local result = nil

	local connection
	connection = event.Event:Connect(function(...)
		result = {...}
	end)

	-- ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆå¾…æ©Ÿ
	while not result and (tick() - startTime) < timeout do
		task.wait(0.1)
	end

	connection:Disconnect()

	if not result then
		warn(("[GameEvents] Timeout waiting for: %s"):format(eventName))
	end

	return result and unpack(result) or nil
end

print("[GameEvents] Module initialized")

return GameEvents
===== ./ReplicatedStorage/FieldGen.lua =====
-- ReplicatedStorage/FieldGen

local FieldGen = {}

-- ãƒã‚¤ã‚ºé–¢æ•°ï¼ˆå¤‰æ›´ãªã—ï¼‰
local function noise2D(x, z, scale)
	local s = (x / scale + z / scale * 57)
	return (math.sin(s * 12.9898) * 43758.5453) % 1
end

local function smoothNoise(x, z, scale)
	local intX, intZ = math.floor(x / scale), math.floor(z / scale)
	local fracX, fracZ = (x / scale) - intX, (z / scale) - intZ

	local v1 = noise2D(intX, intZ, 1)
	local v2 = noise2D(intX + 1, intZ, 1)
	local v3 = noise2D(intX, intZ + 1, 1)
	local v4 = noise2D(intX + 1, intZ + 1, 1)

	local i1 = v1 * (1 - fracX) + v2 * fracX
	local i2 = v3 * (1 - fracX) + v4 * fracX

	return i1 * (1 - fracZ) + i2 * fracZ
end

-- ã€æœ€é©åŒ–1ã€‘ãƒãƒƒãƒç”Ÿæˆã‚·ã‚¹ãƒ†ãƒ 
local function fillTerrainBatch(terrain, blocks)
	local batchSize = 200  -- ä¸€åº¦ã«å‡¦ç†ã™ã‚‹æ•°
	local totalBlocks = #blocks
print("[FieldGen] ãƒãƒƒãƒç”Ÿæˆã‚¹ã‚¿ãƒ¼ãƒˆ");
	for i = 1, totalBlocks, batchSize do
		local endIdx = math.min(i + batchSize - 1, totalBlocks)

		for j = i, endIdx do
			local block = blocks[j]
			terrain:FillBlock(block.cframe, block.size, block.material)
		end

		-- ã‚µãƒ¼ãƒãƒ¼ã®è² è·åˆ†æ•£
		if i % 2000 == 0 then
			task.wait()
			print(("[FieldGen] é€²è¡ŒçŠ¶æ³: %d/%d (%.1f%%)"):format(i, totalBlocks, i/totalBlocks*100))
		end
	end
	print("[FieldGen] ãƒãƒƒãƒç”Ÿæˆçµ‚äº†");
end

-- ReplicatedStorage/FieldGen.lua
-- ã€ä¿®æ­£ã€‘generateIsland é–¢æ•°å…¨ä½“
function FieldGen.generateIsland(config)
	local terrain = workspace.Terrain

	local cfg = {
		name = config.name or "Island",
		centerX = config.centerX or 0,
		centerZ = config.centerZ or 0,
		sizeXZ = config.sizeXZ or 500,
		baseY = config.baseY or 0,
		thickness = config.thickness or 10,
		hillAmplitude = config.hillAmplitude or 20,
		hillScale = config.hillScale or 150,
		seed = config.seed or 12345,
		generateOcean = config.generateOcean ~= false,
		oceanRadius = config.oceanRadius or 1500,
		grid = config.grid or 12,

        -- ã€ä¿®æ­£ç‚¹ Aã€‘æ–°ã—ã„ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’å–å¾—ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ Grass ã«è¨­å®š
        baseMaterial = config.baseMaterial or Enum.Material.Grass,
	}

	-- print(("[FieldGen] ç”Ÿæˆé–‹å§‹: %s at (%.0f, %.0f, Material: %s)"):format(cfg.name, cfg.centerX, cfg.centerZ, tostring(cfg.baseMaterial)))

	math.randomseed(cfg.seed)

	local halfSize = cfg.sizeXZ / 2
	local oceanY = cfg.baseY - 10
	local cliffHeight = oceanY + 8

	-- ã€é‡è¦ã€‘ãƒ–ãƒ­ãƒƒã‚¯ã‚’é…åˆ—ã«æºœã‚ã¦ã‹ã‚‰ãƒãƒƒãƒå‡¦ç†
	local terrainBlocks = {}
	local waterBlocks = {}

	-- åœ°å½¢ãƒ–ãƒ­ãƒƒã‚¯ã‚’æº–å‚™
	for x = -halfSize, halfSize, cfg.grid do
		for z = -halfSize, halfSize, cfg.grid do
			local worldX = cfg.centerX + x
			local worldZ = cfg.centerZ + z

			local distFromCenter = math.sqrt(x*x + z*z)
			local normalizedDist = distFromCenter / halfSize
			local edgeFade = math.max(0, 1 - normalizedDist * 1.2)

			if edgeFade > 0 then
				local height = smoothNoise(worldX + cfg.seed, worldZ + cfg.seed, cfg.hillScale)
				local hillY = cfg.baseY + (height * cfg.hillAmplitude * edgeFade)
				local targetY = math.max(hillY, cliffHeight)

				table.insert(terrainBlocks, {
					cframe = CFrame.new(worldX, targetY - cfg.thickness/2, worldZ),
					size = Vector3.new(cfg.grid, cfg.thickness, cfg.grid),

                    -- ã€ä¿®æ­£ç‚¹ Bã€‘ãƒãƒ¼ãƒ‰ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸ Material ã‚’è¨­å®šå€¤ã«ç½®ãæ›ãˆ
					material = cfg.baseMaterial
				})
			end
		end
	end

	-- print(("[FieldGen] åœ°å½¢ãƒ–ãƒ­ãƒƒã‚¯æ•°: %d"):format(#terrainBlocks))
	fillTerrainBatch(terrain, terrainBlocks)

	-- æµ·ã®ç”Ÿæˆ
	if cfg.generateOcean then
		local oceanGrid = 20
		local oceanHalfSize = cfg.oceanRadius / 2
		local maxDistWithTerrain = halfSize * 0.8

		for x = -oceanHalfSize, oceanHalfSize, oceanGrid do
			for z = -oceanHalfSize, oceanHalfSize, oceanGrid do
				local dist = math.sqrt(x*x + z*z)
				if dist > maxDistWithTerrain then
					table.insert(waterBlocks, {
						cframe = CFrame.new(cfg.centerX + x, oceanY, cfg.centerZ + z),
						size = Vector3.new(oceanGrid, 20, oceanGrid),
						material = Enum.Material.Water
					})
				end
			end
		end

		print(("[FieldGen] æµ·ãƒ–ãƒ­ãƒƒã‚¯æ•°: %d"):format(#waterBlocks))
		fillTerrainBatch(terrain, waterBlocks)
	end

	-- ãƒãƒ¼ã‚«ãƒ¼ä½œæˆ
	local worldFolder = workspace:FindFirstChild("World")
	if not worldFolder then
		worldFolder = Instance.new("Folder")
		worldFolder.Name = "World"
		worldFolder.Parent = workspace
	end

	local marker = Instance.new("Part")
	marker.Name = cfg.name .. "_Center"
	marker.Size = Vector3.new(10, 1, 10)
	marker.Position = Vector3.new(cfg.centerX, cfg.baseY + 5, cfg.centerZ)
	marker.Anchored = true
	marker.CanCollide = false
	marker.Transparency = 0.5
	marker.BrickColor = BrickColor.new("Bright blue")
	marker.Parent = worldFolder

print("[FieldGen] æœ¨ã‚„å²©ã‚’è¼‰ã›ã‚‹")
		-- ãƒãƒ¼ã‚«ãƒ¼ä½œæˆï¼ˆã“ã“ã¾ã§æ—¢å­˜ï¼‰
	local marker = Instance.new("Part")
	marker.Name = cfg.name .. "_Center"
	marker.Size = Vector3.new(10, 1, 10)
	marker.Position = Vector3.new(cfg.centerX, cfg.baseY + 5, cfg.centerZ)
	marker.Anchored = true
	marker.CanCollide = false
	marker.Transparency = 0.5
	marker.BrickColor = BrickColor.new("Bright blue")
	marker.Parent = worldFolder

	-- ğŸŒ³ã€è¿½åŠ ã€‘FieldObjectsï¼ˆæœ¨ã‚„å²©ãªã©ï¼‰ã‚’é…ç½®ã™ã‚‹
	if config.fieldObjects then
		print("[FieldGen]config.fieldObjetsã«å…¥ã‚Šã¾ã—ãŸ")
		local templateFolder = game:GetService("ServerStorage"):FindFirstChild("FieldObjectTemplates")
		if not templateFolder then
			warn("[FieldGen] FieldObjectTemplates ãƒ•ã‚©ãƒ«ãƒ€ãŒ ServerStorage ã«å­˜åœ¨ã—ã¾ã›ã‚“")
			return
		end

		local fieldFolder = workspace:FindFirstChild("FieldObjects")
		if not fieldFolder then
			fieldFolder = Instance.new("Folder")
			fieldFolder.Name = "FieldObjects"
			fieldFolder.Parent = workspace
		end

		for _, obj in ipairs(config.fieldObjects) do
			local template = templateFolder:FindFirstChild(obj.model)
			if template then
				local instance = template:Clone()
				instance.Anchored = true
				instance.Position = Vector3.new(unpack(obj.position))

				if obj.size then
					instance.Size = instance.Size * obj.size
				end

				if obj.rotationY then
					instance.Orientation = Vector3.new(0, obj.rotationY, 0)
				end

				instance.Parent = fieldFolder
			else
				warn(("[FieldGen] ãƒ¢ãƒ‡ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: %s"):format(obj.model))
			end
		end
	end

	-- print(("[FieldGen] å®Œäº†: %s"):format(cfg.name))

end

-- ãƒ¬ã‚¤ã‚­ãƒ£ã‚¹ãƒˆï¼ˆå¤‰æ›´ãªã—ï¼‰
function FieldGen.raycastGroundY(x, z, startY)
	startY = startY or 500

	local params = RaycastParams.new()
	params.FilterType = Enum.RaycastFilterType.Include
	params.FilterDescendantsInstances = {workspace.Terrain}
	params.IgnoreWater = false

	local origin = Vector3.new(x, startY, z)
	local direction = Vector3.new(0, -startY - 500, 0)

	local result = workspace:Raycast(origin, direction, params)
	return result and result.Position.Y or nil
end

-- æ©‹ã®ç”Ÿæˆï¼ˆãƒãƒƒãƒå‡¦ç†ç‰ˆï¼‰
function FieldGen.generateBridge(fromIsland, toIsland, config)
	local terrain = workspace.Terrain

	local cfg = {
		name = config.name or "Bridge",
		width = config.width or 20,
		height = config.height or 5,
		thickness = config.thickness or 5,
	}

	print(("[FieldGen] æ©‹ã‚’ç”Ÿæˆä¸­: %s"):format(cfg.name))

	local x1, z1 = fromIsland.centerX, fromIsland.centerZ
	local x2, z2 = toIsland.centerX, toIsland.centerZ

	local dx = x2 - x1
	local dz = z2 - z1
	local distance = math.sqrt(dx*dx + dz*dz)

	local bridgeY = ((fromIsland.baseY or 0) + (toIsland.baseY or 0)) / 2 + cfg.height
	local segments = math.ceil(distance / 10)

	local bridgeBlocks = {}

	for i = 0, segments do
		local t = i / segments
		local x = x1 + dx * t
		local z = z1 + dz * t

		local perpX = -dz / distance
		local perpZ = dx / distance

		for w = -cfg.width/2, cfg.width/2, 8 do
			local worldX = x + perpX * w
			local worldZ = z + perpZ * w

			table.insert(bridgeBlocks, {
				cframe = CFrame.new(worldX, bridgeY, worldZ),
				size = Vector3.new(8, cfg.thickness, 8),
				material = Enum.Material.Slate
			})
		end
	end

	fillTerrainBatch(terrain, bridgeBlocks)
	print(("[FieldGen] æ©‹ç”Ÿæˆå®Œäº†: %s (è·é›¢: %.1f)"):format(cfg.name, distance))
end

-- ===== Field Objects Placement =====
local ServerStorage = game:GetService("ServerStorage")

local function ensureFolder(parent: Instance, name: string): Instance
	local f = parent:FindFirstChild(name)
	if not f then
		f = Instance.new("Folder")
		f.Name = name
		f.Parent = parent
	end
	return f
end

local function setAnchoredAll(inst: Instance, anchored: boolean)
	for _, d in ipairs(inst:GetDescendants()) do
		if d:IsA("BasePart") then
			d.Anchored = anchored
		end
	end
end

local function ensurePrimaryPart(model: Model)
	if model.PrimaryPart then return end
	local pp = model:FindFirstChild("HumanoidRootPart") or model:FindFirstChildWhichIsA("BasePart")
	if pp then
		model.PrimaryPart = pp
	end
end

local function pivotModel(model: Model, cf: CFrame)
	ensurePrimaryPart(model)
	if model.PrimaryPart then
		model:PivotTo(cf)
	else
		-- ã©ã†ã—ã¦ã‚‚PrimaryPartãŒç„¡ã„å ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
		for _, d in ipairs(model:GetDescendants()) do
			if d:IsA("BasePart") then
				d.CFrame = cf
			end
		end
	end
end

function FieldGen.placeFieldObjects(continentName: string?, objects: {any}, player: Player?)
	if not objects or #objects == 0 then return end

	task.wait(1)

	-- ã€ä¿®æ­£ã€‘å…¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å–å¾—æ¸ˆã¿ã‚¢ã‚¤ãƒ†ãƒ ã‚’åé›†
	local allCollectedItems = {}
	local Players = game:GetService("Players")
	local ServerScriptService = game:GetService("ServerScriptService")

	local success, PlayerStatsModule = pcall(function()
		return require(ServerScriptService:WaitForChild("PlayerStats"))
	end)

	if success then
		-- å…¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ãƒ«ãƒ¼ãƒ—
		for _, plr in ipairs(Players:GetPlayers()) do
			local stats = PlayerStatsModule.getStats(plr)
			if stats and stats.CollectedItems then
				-- å…¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å–å¾—æ¸ˆã¿ã‚¢ã‚¤ãƒ†ãƒ ã‚’ãƒãƒ¼ã‚¸
				for chestId, _ in pairs(stats.CollectedItems) do
					allCollectedItems[chestId] = true
				end

				print(("[FieldGen] %s ã®å–å¾—æ¸ˆã¿ã‚¢ã‚¤ãƒ†ãƒ ã‚’èª­ã¿è¾¼ã¿"):format(plr.Name))
			end
		end

		-- ã€ãƒ‡ãƒãƒƒã‚°ã€‘å–å¾—æ¸ˆã¿ã‚¢ã‚¤ãƒ†ãƒ ç·æ•°ã‚’è¡¨ç¤º
		local count = 0
		for _ in pairs(allCollectedItems) do count = count + 1 end
		print(("[FieldGen] å…¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å–å¾—æ¸ˆã¿ã‚¢ã‚¤ãƒ†ãƒ ç·æ•°: %d"):format(count))

		-- å…·ä½“çš„ãªIDã‚’è¡¨ç¤º
		for chestId, _ in pairs(allCollectedItems) do
			print(("[FieldGen] å–å¾—æ¸ˆã¿: %s"):format(chestId))
		end
	else
		warn("[FieldGen] PlayerStatsModuleã®èª­ã¿è¾¼ã¿ã«å¤±æ•—")
	end

	local ServerStorage = game:GetService("ServerStorage")
	local templatesRoot = ServerStorage:FindFirstChild("FieldObjects")
	if not templatesRoot then
		warn("[FieldGen] ServerStorage/FieldObjects ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚é…ç½®ã‚¹ã‚­ãƒƒãƒ—")
		return
	end

	local function ensureFolder(parent: Instance, name: string): Instance
		local f = parent:FindFirstChild(name)
		if not f then
			f = Instance.new("Folder"); f.Name = name; f.Parent = parent
		end
		return f
	end

	local function setAnchoredAll(inst: Instance, anchored: boolean)
		for _, d in ipairs(inst:GetDescendants()) do
			if d:IsA("BasePart") then d.Anchored = anchored end
		end
	end

	local function ensurePrimaryPart(model: Model)
		if model.PrimaryPart then return end
		local pp = model:FindFirstChild("HumanoidRootPart") or model:FindFirstChildWhichIsA("BasePart")
		if pp then model.PrimaryPart = pp end
	end

	local function pivotModel(model: Model, cf: CFrame)
		ensurePrimaryPart(model)
		if model.PrimaryPart then model:PivotTo(cf)
		else
			for _, d in ipairs(model:GetDescendants()) do
				if d:IsA("BasePart") then d.CFrame = cf end
			end
		end
	end

	local root = ensureFolder(workspace, "FieldObjects")
	local parentFolder = continentName and ensureFolder(root, continentName) or root

	-- åœ°é¢ãƒ¬ã‚¤ã‚­ãƒ£ã‚¹ãƒˆï¼ˆæ³•ç·šã‚‚å–å¾—ï¼‰
	local function rayToTerrain(x: number, z: number, startY: number)
		local params = RaycastParams.new()
		params.FilterType = Enum.RaycastFilterType.Include
		params.FilterDescendantsInstances = {workspace.Terrain}
		params.IgnoreWater = false
		local origin = Vector3.new(x, startY, z)
		local result = workspace:Raycast(origin, Vector3.new(0, -startY - 1000, 0), params)
		return result -- result.Position, result.Normal ã‚’æŒã¤
	end

	for _, obj in ipairs(objects) do
		-- å–å¾—æ¸ˆã¿ã‚¢ã‚¤ãƒ†ãƒ ã¯ã‚¹ã‚­ãƒƒãƒ—
		if obj.interaction and obj.interaction.chestId then
			local chestId = obj.interaction.chestId

			if allCollectedItems[chestId] then
				print(("[FieldGen] â­ï¸ å–å¾—æ¸ˆã¿ã®ãŸã‚é…ç½®ã‚¹ã‚­ãƒƒãƒ—: %s"):format(chestId))
				continue
			else
				print(("[FieldGen] âœ… é…ç½®ã—ã¾ã™: %s"):format(chestId))
			end
		end

		local template = templatesRoot:FindFirstChild(tostring(obj.model or ""))
		if not template then
			warn(("[FieldGen] ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: %s"):format(tostring(obj.model)))
			continue
		end

		local p = obj.position or {0,0,0}
		local x, y, z = p[1] or 0, p[2] or 0, p[3] or 0

		local clone = template:Clone()
		setAnchoredAll(clone, true) -- ãƒ‡ãƒ•ã‚©ã§ã‚¢ãƒ³ã‚«ãƒ¼å›ºå®š

		-- ã‚¹ã‚±ãƒ¼ãƒ«
		local scale = tonumber(obj.size) or 1
		if clone:IsA("Model") then
			if scale ~= 1 then pcall(function() clone:ScaleTo(scale) end) end
		elseif clone:IsA("BasePart") then
			if scale ~= 1 then clone.Size = clone.Size * scale end
		end

		-- Upè»¸è£œæ­£
		local upAxis = tostring(obj.upAxis or "Y")
		local baseRot = CFrame.new()
		if upAxis == "Z" then
			baseRot = CFrame.Angles(math.rad(-90), 0, 0)
		elseif upAxis == "X" then
			baseRot = CFrame.Angles(0, 0, math.rad(90))
		end

		-- è¿½åŠ å›è»¢ï¼ˆrotation = {x,y,z} or å€‹åˆ¥æŒ‡å®šï¼‰
		local rot = obj.rotation or {}
		local rx = math.rad(rot[1] or obj.rotationX or 0)
		local ry = math.rad(rot[2] or obj.rotationY or 0)
		local rz = math.rad(rot[3] or obj.rotationZ or 0)
		local userRot = CFrame.Angles(rx, ry, rz)

		-- === é…ç½®ãƒ¢ãƒ¼ãƒ‰å‡¦ç† ===
		local mode = obj.mode or "ground"  -- æ—¢å®š: ground
		local offset = tonumber(obj.groundOffset) or 0
		local align = (obj.alignToSlope == true)

		if mode == "fixed" then
			-- ===== åº§æ¨™å›ºå®šãƒ¢ãƒ¼ãƒ‰ =====
			-- æŒ‡å®šåº§æ¨™ã«ãã®ã¾ã¾é…ç½®ï¼ˆç©ºä¸­ã‚‚å¯èƒ½ï¼‰
			local finalCF = CFrame.new(x, y, z) * baseRot * userRot

			if clone:IsA("Model") then
				pivotModel(clone, finalCF)
			elseif clone:IsA("BasePart") then
				clone.CFrame = finalCF
			end

			print(("[FieldGen] '%s' å›ºå®šé…ç½® at (%.1f, %.1f, %.1f)"):format(
				tostring(obj.model), x, y, z
			))

		else
			-- ===== åœ°é¢æ¥åœ°ãƒ¢ãƒ¼ãƒ‰ï¼ˆæ—¢å®šï¼‰ =====
			local startY = 3000
			local hit = nil
			do
				local params = RaycastParams.new()
				params.FilterType = Enum.RaycastFilterType.Include
				params.FilterDescendantsInstances = {workspace.Terrain}
				params.IgnoreWater = false
				hit = workspace:Raycast(Vector3.new(x, startY, z), Vector3.new(0, -6000, 0), params)
			end

			if hit then
				local groundY = hit.Position.Y
				local up = align and hit.Normal or Vector3.yAxis

				print(("[FieldGen] '%s' æ¥åœ° at (%.1f, _, %.1f), groundY=%.1f, offset=%.2f"):format(
					tostring(obj.model), x, z, groundY, offset
				))

				if clone:IsA("Model") then
					-- Step 1: å›è»¢ã®ã¿é©ç”¨ã—ã¦ä»®é…ç½®
					local tempCF = CFrame.new(x, groundY + 100, z) * baseRot * userRot
					pivotModel(clone, tempCF)

					-- Step 2: ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹ã®åº•é¢ã‚’å–å¾—
					local bbCFrame, bbSize = clone:GetBoundingBox()
					local bottomY = bbCFrame.Position.Y - (bbSize.Y * 0.5)

					-- Step 3: åº•é¢ãŒåœ°é¢ã«æ¥ã™ã‚‹ã‚ˆã†ã«èª¿æ•´
					local deltaY = (groundY + offset) - bottomY

					if align then
						-- æ–œé¢å¯¾å¿œ
						local look = clone:GetPivot().LookVector
						local tangent = (look - look:Dot(up) * up).Unit
						local right = tangent:Cross(up).Unit
						local pos = bbCFrame.Position + Vector3.new(0, deltaY, 0)
						local newCF = CFrame.fromMatrix(pos, right, up)
						pivotModel(clone, newCF)
					else
						-- å‚ç›´é…ç½®
						pivotModel(clone, clone:GetPivot() + Vector3.new(0, deltaY, 0))
					end

				elseif clone:IsA("BasePart") then
					-- MeshPartã®å ´åˆ
					local height = clone.Size.Y * 0.5

					if align then
						local right = clone.CFrame.RightVector
						local forward = right:Cross(up).Unit
						right = up:Cross(forward).Unit
						clone.CFrame = CFrame.fromMatrix(
							Vector3.new(x, groundY + height + offset, z),
							right, up
						)
					else
						clone.CFrame = CFrame.new(x, groundY + height + offset, z) * (baseRot * userRot)
					end
				end
			else
				warn(("[FieldGen] åœ°é¢æ¤œå‡ºå¤±æ•— at (%.1f, %.1f) for '%s'"):format(x, z, tostring(obj.model)))
			end
		end

		-- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³æƒ…å ±ã‚’Attributeã«è¨­å®š
		if obj.interaction then
			local interaction = obj.interaction

			-- åŸºæœ¬æƒ…å ±
			clone:SetAttribute("HasInteraction", true)
			clone:SetAttribute("InteractionType", interaction.type or "unknown")
			clone:SetAttribute("InteractionAction", interaction.action or "èª¿ã¹ã‚‹")
			clone:SetAttribute("InteractionKey", interaction.key or "E")
			clone:SetAttribute("InteractionRange", interaction.range or 8)

			-- ã‚¿ã‚¤ãƒ—åˆ¥ã®æƒ…å ±
			if interaction.type == "chest" then
				clone:SetAttribute("ChestId", interaction.chestId)
				clone:SetAttribute("OpenedModel", interaction.openedModel)
				clone:SetAttribute("DisplayDuration", interaction.displayDuration or 5)

				-- å ±é…¬æƒ…å ±ã‚’JSONåŒ–ã—ã¦ä¿å­˜
				local HttpService = game:GetService("HttpService")
				local rewardsJson = HttpService:JSONEncode(interaction.rewards or {})
				clone:SetAttribute("RewardsData", rewardsJson)

				print(("[FieldGen] ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³è¨­å®š: %s (ChestId: %s, Range: %d)"):format(
					interaction.action,
					interaction.chestId,
					interaction.range
				))

				-- è¨­å®šå¾Œã«ç¢ºèª
				task.wait(0.1)
				if not clone:GetAttribute("HasInteraction") then
					warn(("[FieldGen] âš ï¸ å±æ€§ãŒæ¶ˆãˆãŸ: %s"):format(interaction.chestId))
				end
			end
		end

		clone.Parent = parentFolder
	end
end

--=====================================================
-- Paths (MVP): Catmull-Rom spline -> Terrain FillBlock
--=====================================================

-- {x,y,z} -> Vector3
local function v3(arr)
	return Vector3.new(arr[1] or 0, arr[2] or 0, arr[3] or 0)
end

-- Catmull-Rom è£œé–“ï¼ˆMVP: æ¨™æº–ä¿‚æ•°0.5ï¼‰
local function catmullRom(p0, p1, p2, p3, t: number)
	local t2, t3 = t*t, t*t*t
	-- 0.5 * (2P1 + (-P0+P2)t + (2P0-5P1+4P2-P3)t^2 + (-P0+3P1-3P2+P3)t^3)
	return 0.5 * (
		(2 * p1)
		+ (-p0 + p2) * t
		+ (2*p0 - 5*p1 + 4*p2 - p3) * t2
		+ (-p0 + 3*p1 - 3*p2 + p3) * t3
	)
end

-- åŒºé–“é•·ã«å¿œã˜ã¦ã‚µãƒ³ãƒ—ãƒ«æ•°ã‚’æ±ºã‚ã‚‹ï¼ˆç­‰é–“éš”ã£ã½ãï¼‰
local function sampleSegment(p1, p2, stepStuds)
	local dist = (p2 - p1).Magnitude
	local n = math.max(2, math.floor(dist / math.max(0.1, stepStuds)))
	return n
end

-- pointsç«¯ã®ã‚¬ãƒ¼ãƒ‰ï¼ˆp[-1]=p[0], p[n+1]=p[n]ï¼‰
local function getPoint(points, i)
	if i < 1 then return points[1]
	elseif i > #points then return points[#points]
	else return points[i]
	end
end

-- é“ãƒ–ãƒ­ãƒƒã‚¯1æšã‚’Terrainã«å¡—ã‚‹
local function fillRoadSlice(terrain, centerPos: Vector3, forward: Vector3, up: Vector3, width: number, length: number, thickness: number, material)
	-- ç›´äº¤åŸºåº•
	local fwd = forward.Magnitude > 0 and forward.Unit or Vector3.zAxis
	local upv = up.Magnitude > 0 and up.Unit or Vector3.yAxis
	local right = fwd:Cross(upv)
	if right.Magnitude < 1e-6 then
		-- ã»ã¼å¹³è¡Œãªã‚‰å³ã‚’Xè»¸ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
		right = Vector3.xAxis
	end
	right = right.Unit
	upv = right:Cross(fwd).Unit

	-- CFrame.fromMatrix(pos, right, up, back)
	local cf = CFrame.fromMatrix(centerPos, right, upv, -fwd)
	local size = Vector3.new(length, thickness, width)
	terrain:FillBlock(cf, size, material)
end

-- å…¬é–‹APIï¼šå¤§é™¸åï¼ˆãƒ­ã‚°/è¦ªãƒ•ã‚©ãƒ«ãƒ€åç”¨ï¼‰ã¨ paths é…åˆ—ã‚’å—ã‘å–ã‚Šã€é“ã‚’Terrainã«å¡—ã‚‹
function FieldGen.buildPaths(continentName: string?, paths: {any})
	if not paths or #paths == 0 then return end

	local terrain = workspace.Terrain
	local logPrefix = ("[FieldGen/Paths]%s "):format(continentName and ("["..continentName.."]") or "")

	for _, path in ipairs(paths) do
		local pts = path.points or {}
		if #pts < 2 then
			warn(logPrefix .. "points ãŒä¸è¶³ï¼ˆæœ€ä½2ç‚¹ï¼‰: " .. tostring(path.name))
			continue
		end

		-- æ—¢å®šå€¤
		local width  = tonumber(path.width) or 12
		local step   = tonumber(path.step) or 3        -- ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°é–“éš”ï¼ˆç›®å®‰ï¼‰
		local mat    = path.material or Enum.Material.Ground
		local stick  = (path.stickToGround ~= false)   -- æ—¢å®štrue
		local align  = (path.alignToSlope == true)     -- æ—¢å®šfalse
		local yOffset= tonumber(path.groundOffset) or 0.05
		local thick  = 2                               -- åœ°å½¢å¡—ã‚Šåšã¿ï¼ˆåŸ‹ã‚æ¼ã‚Œé˜²æ­¢ï¼‰

		-- Vector3åˆ—ã«å¤‰æ›ï¼ˆYã¯é©å½“ã§ã‚‚OKã€‚ä¸‹ã§å¸ç€ã™ã‚‹ï¼‰
		local P = table.create(#pts)
		for i=1, #pts do P[i] = v3(pts[i]) end

		local slices = 0
		for seg = 1, #P - 1 do
			-- ã‚»ã‚°ãƒ¡ãƒ³ãƒˆ p1->p2 ã‚’Catmull-Romã§è£œé–“
			local p0 = getPoint(P, seg - 1)
			local p1 = getPoint(P, seg)
			local p2 = getPoint(P, seg + 1)
			local p3 = getPoint(P, seg + 2)

			local n = sampleSegment(p1, p2, step)
			for j = 0, n-1 do
				local t0 = j / n
				local t1 = (j + 1) / n

				local a = catmullRom(p0, p1, p2, p3, t0)
				local b = catmullRom(p0, p1, p2, p3, t1)
				local mid = (a + b) * 0.5
				local dir = (b - a)
				if dir.Magnitude < 1e-6 then
					dir = Vector3.zAxis
				end

				-- åœ°é¢ã«å¸ç€ï¼ˆã‚µãƒ³ãƒ—ãƒ«åŒºé–“ã®ä¸­å¿ƒç‚¹ï¼‰
local useY = mid.Y
local up = Vector3.yAxis
if stick then
	local startY = 1000
	local params = RaycastParams.new()
	params.FilterType = Enum.RaycastFilterType.Include
	params.FilterDescendantsInstances = {workspace.Terrain}
	params.IgnoreWater = false

	local res = workspace:Raycast(Vector3.new(mid.X, startY, mid.Z), Vector3.new(0, -2000, 0), params)
	if res then
		useY = res.Position.Y + (yOffset or -3)
		if align then up = res.Normal end
	else
		warn(("åœ°é¢æœªæ¤œå‡º: (%.1f, %.1f)"):format(mid.X, mid.Z))
	end
end

-- ãƒ–ãƒ­ãƒƒã‚¯ã®ä¸­å¿ƒã‚’åŠåˆ†æ²ˆã‚ã¦è¨­ç½®
local centerY = useY - (thick / 2) - 5
fillRoadSlice(terrain, Vector3.new(mid.X, centerY, mid.Z), dir.Unit, up, width, (b - a).Magnitude, thick, mat)

				slices += 1
			end
		end

		print(("%sdraw path '%s': points=%d, slices=%d, width=%.1f, step=%.1f"):format(logPrefix, tostring(path.name or "?"), #P, slices, width, step))
	end
end




return FieldGen
===== ./ReplicatedStorage/SharedState.lua =====
-- ReplicatedStorage/SharedState.lua
-- å…±æœ‰çŠ¶æ…‹ç®¡ç†ï¼ˆå¾ªç’°ä¾å­˜ã‚’é˜²ããŸã‚ã®ä¸­å¤®ãƒ‡ãƒ¼ã‚¿ã‚¹ãƒˆã‚¢ï¼‰

local SharedState = {}

-- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼é–¢é€£
SharedState.MonsterCounts = {}
-- å½¢å¼: {[zoneName] = {[monsterName] = count}}
-- ä¾‹: {["ContinentA"] = {["Slime"] = 5, ["Mage"] = 3}}

SharedState.SpawnQueue = {}
-- ãƒªã‚¹ãƒãƒ¼ãƒ³å¾…ã¡ã®ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æƒ…å ±

-- ãƒãƒˆãƒ«é–¢é€£
SharedState.ActiveBattles = {}
-- å½¢å¼: {[player] = battleData}

-- ã‚¾ãƒ¼ãƒ³é–¢é€£
SharedState.PlayerZones = {}
-- å½¢å¼: {[player] = zoneName}

-- ãƒ­ãƒƒã‚¯ç®¡ç†ï¼ˆéåŒæœŸå‡¦ç†ã®æ’ä»–åˆ¶å¾¡ç”¨ï¼‰
SharedState.Locks = {}
-- å½¢å¼: {[lockName] = boolean}

-- ãƒ‡ãƒãƒƒã‚°ç”¨
function SharedState.printState()
	print("[SharedState] === Current State ===")
	print("MonsterCounts:", game:GetService("HttpService"):JSONEncode(SharedState.MonsterCounts))
	print("ActiveBattles:", #SharedState.ActiveBattles)
	print("PlayerZones:", game:GetService("HttpService"):JSONEncode(SharedState.PlayerZones))
	print("Locks:", game:GetService("HttpService"):JSONEncode(SharedState.Locks))
end

print("[SharedState] Module initialized")

return SharedState
===== ./ReplicatedStorage/Monsters/Registry.lua =====
local RS = game:GetService("ReplicatedStorage")
local Monsters = RS:WaitForChild("Monsters")

return {
	require(Monsters.Slime),
	require(Monsters.Slime_pink),
	-- å°†æ¥è¿½åŠ ã™ã‚‹ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼:
	-- require(Monsters.Dragon),
	-- require(Monsters.Goblin),
}
===== ./ReplicatedStorage/Monsters/Slime.lua =====
-- ReplicatedStorage/Monsters/Slime.lua
-- ReplicatedStorage/Monsters/Slime
-- ã‚¹ãƒ©ã‚¤ãƒ ã®å®šç¾©ï¼ˆã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ‹¡å¼µç‰ˆï¼‰

return {
	Name = "Slime",
	TemplatePath = {"ServerStorage", "EnemyTemplates", "Slime"},
	WalkSpeed = 10,
	RespawnTime = 10,

	-- ã€æ–°ã€‘ãƒãƒˆãƒ«ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
	HP = 50,           -- ãƒ©ã‚¤ãƒ•
	Speed = 5,         -- ç´ æ—©ã•
	Attack = 20,        -- æ”»æ’ƒåŠ›
	Defense = 5,       -- å®ˆå‚™åŠ›

	-- ã€æ–°ã€‘å ±é…¬
	Experience = 20,   -- å€’ã—ãŸæ™‚ã«å¾—ã‚‰ã‚Œã‚‹çµŒé¨“å€¤
	Gold = 10,         -- å€’ã—ãŸæ™‚ã«å¾—ã‚‰ã‚Œã‚‹ã‚´ãƒ¼ãƒ«ãƒ‰

	-- ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ãƒ¬ãƒ™ãƒ«ï¼ˆé‡ã¿ä»˜ãï¼‰
	TypingLevels = {
		{level = "level_1", weight = 70},  -- 70%ã®ç¢ºç‡ã§ãƒ¬ãƒ™ãƒ«1
		{level = "level_2", weight = 30},  -- 30%ã®ç¢ºç‡ã§ãƒ¬ãƒ™ãƒ«2
	},

	-- æ—§è¨­å®šï¼ˆäº’æ›æ€§ã®ãŸã‚æ®‹ã™ï¼‰
	Damage = 1,  -- å¾Œã§å‰Šé™¤äºˆå®š

	-- ã‚¹ãƒãƒ¼ãƒ³è¨­å®š
	SpawnLocations = {
		{
			islandName = "Hokkaido_N1",
			count = 7,
			radiusPercent = 95,  -- å³¶ã®ã‚µã‚¤ã‚ºã®75%ç¯„å›²å†…
		},
		{
			islandName = "Hokkaido_N4",
			count = 15,
			radiusPercent = 55,  -- å³¶ã®ã‚µã‚¤ã‚ºã®75%ç¯„å›²å†…
		},
				{
			islandName = "Kyushu_NE1",
			count = 5,
			radiusPercent = 55,  -- å³¶ã®ã‚µã‚¤ã‚ºã®75%ç¯„å›²å†…
		},

	},

	-- AIè¨­å®š
	ChaseDistance = 60,
	EscapeDistance = 80,
	WanderRadius = 30,
	UpdateNearby = 0.2,
	UpdateFar = 1.0,
}
===== ./ReplicatedStorage/Monsters/Slime_pink.lua =====
return {
	Name = "Slime_pink",
	TemplatePath = {"ServerStorage", "EnemyTemplates", "Slime_pink"},
	WalkSpeed = 5,
	RespawnTime = 5,

	-- ã€æ–°ã€‘ãƒãƒˆãƒ«ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
	HP = 80,           -- ãƒ©ã‚¤ãƒ•
	Speed = 8,         -- ç´ æ—©ã•
	Attack = 40,        -- æ”»æ’ƒåŠ›
	Defense = 12,       -- å®ˆå‚™åŠ›

	-- ã€æ–°ã€‘å ±é…¬
	Experience = 20,   -- å€’ã—ãŸæ™‚ã«å¾—ã‚‰ã‚Œã‚‹çµŒé¨“å€¤
	Gold = 10,         -- å€’ã—ãŸæ™‚ã«å¾—ã‚‰ã‚Œã‚‹ã‚´ãƒ¼ãƒ«ãƒ‰

	-- ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ãƒ¬ãƒ™ãƒ«ï¼ˆé‡ã¿ä»˜ãï¼‰
	TypingLevels = {
		{level = "level_1", weight = 30},  -- 70%ã®ç¢ºç‡ã§ãƒ¬ãƒ™ãƒ«1
		{level = "level_2", weight = 70},  -- 30%ã®ç¢ºç‡ã§ãƒ¬ãƒ™ãƒ«2
	},

	-- æ—§è¨­å®šï¼ˆäº’æ›æ€§ã®ãŸã‚æ®‹ã™ï¼‰
	Damage = 1,  -- å¾Œã§å‰Šé™¤äºˆå®š

	-- ã‚¹ãƒãƒ¼ãƒ³è¨­å®š
	SpawnLocations = {
		{
			islandName = "Hokkaido_N1",
			count = 7,
			radiusPercent = 65,  -- å³¶ã®ã‚µã‚¤ã‚ºã®75%ç¯„å›²å†…
		},
		{
			islandName = "Hokkaido_N4",
			count = 15,
			radiusPercent = 85,  -- å³¶ã®ã‚µã‚¤ã‚ºã®75%ç¯„å›²å†…
		},
				{
			islandName = "Kyushu_NE1",
			count = 5,
			radiusPercent = 55,  -- å³¶ã®ã‚µã‚¤ã‚ºã®75%ç¯„å›²å†…
		},
		{
			islandName = "Kyushu_C22",
			count = 5,
			radiusPercent = 55,  -- å³¶ã®ã‚µã‚¤ã‚ºã®75%ç¯„å›²å†…
		},
		{
			islandName = "ContinentKyushu_C20",
			count = 5,
			radiusPercent = 55,  -- å³¶ã®ã‚µã‚¤ã‚ºã®75%ç¯„å›²å†…
		},
		{
			islandName = "ContinentKyushu_C21",
			count = 5,
			radiusPercent = 55,  -- å³¶ã®ã‚µã‚¤ã‚ºã®75%ç¯„å›²å†…
		},
		{
			islandName = "ContinentKyushu_C22",
			count = 5,
			radiusPercent = 55,  -- å³¶ã®ã‚µã‚¤ã‚ºã®75%ç¯„å›²å†…
		},
--
	},

	-- AIè¨­å®š
	ChaseDistance = 60,
	EscapeDistance = 80,
	WanderRadius = 30,
	UpdateNearby = 0.2,
	UpdateFar = 1.0,
}
