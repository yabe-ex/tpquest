total 8
drwxr-xr-x  17 yabea  staff  544 10 18 00:27 ReplicatedStorage
drwxr-xr-x  19 yabea  staff  608 10 17 23:44 ServerScriptService
drwxr-xr-x  16 yabea  staff  512 10 18 00:28 StartPlayerScripts
-rwxr-xr-x   1 yabea  staff  976 10  4 11:52 go.sh
-rw-r--r--   1 yabea  staff    0 10 18 08:12 out.txt

./ReplicatedStorage:
total 96
-rw-r--r--   1 yabea  staff   1254 10 13 08:29 CombatMath_remove.lua
drwxr-xr-x   5 yabea  staff    160 10 17 22:24 Config
drwxr-xr-x  12 yabea  staff    384 10 17 22:24 Continents
-rw-r--r--   1 yabea  staff  29612 10 15 18:40 FieldGen.lua
drwxr-xr-x   2 yabea  staff     64 10 12 08:58 FieldObjects
-rw-r--r--   1 yabea  staff   2722 10  6 18:17 GameEvents.lua
drwxr-xr-x  12 yabea  staff    384 10 17 22:24 Islands
-rw-r--r--   1 yabea  staff   1946 10 18 00:27 LoadingHints.lua
drwxr-xr-x   7 yabea  staff    224 10 15 12:53 Monsters
drwxr-xr-x   2 yabea  staff     64 10 17 11:11 Remotes
-rw-r--r--   1 yabea  staff   1153 10  6 18:17 SharedState.lua
drwxr-xr-x   2 yabea  staff     64 10  4 10:07 Sounds
drwxr-xr-x   8 yabea  staff    256 10 14 10:28 Typing
drwxr-xr-x   3 yabea  staff     96 10 14 08:22 Util

./ReplicatedStorage/Config:
total 24
-rw-r--r--  1 yabea  staff   432 10 13 21:18 DebugConfig.lua
-rw-r--r--  1 yabea  staff  2310 10 17 22:24 DisplayConfig.lua
-rw-r--r--  1 yabea  staff   392 10 13 20:38 GameDebug.lua

./ReplicatedStorage/Continents:
total 112
-rw-r--r--  1 yabea  staff  4568 10 17 22:24 BananaLand.lua
-rw-r--r--  1 yabea  staff  5471 10 17 22:24 ContientTown.lua
-rw-r--r--  1 yabea  staff   501 10 17 16:07 ContinentArena.lua
-rw-r--r--  1 yabea  staff  8173 10 17 22:24 ContinentHokkaido.lua
-rw-r--r--  1 yabea  staff  2979 10 17 23:29 ContinentKyushu.lua
-rw-r--r--  1 yabea  staff   616 10 10 16:43 ContinentShikoku.lua
-rw-r--r--  1 yabea  staff  5444 10 17 16:53 ContinentTown.lua
-rw-r--r--  1 yabea  staff  1079 10 11 11:28 Greenland.lua
-rw-r--r--  1 yabea  staff   412 10 17 22:22 Registry.lua
-rw-r--r--  1 yabea  staff   726 10 11 10:50 Snowland.lua

./ReplicatedStorage/FieldObjects:
total 0

./ReplicatedStorage/Islands:
total 112
-rw-r--r--  1 yabea  staff    709 10 17 16:07 Arena.lua
-rw-r--r--  1 yabea  staff  12171 10 17 22:24 BananaLand.lua
-rw-r--r--  1 yabea  staff    162 10  3 18:05 Bridges.lua
-rw-r--r--  1 yabea  staff   1015 10 15 13:46 GreenLand.lua
-rw-r--r--  1 yabea  staff   4633 10 17 22:24 HokkaidoIslands.lua
-rw-r--r--  1 yabea  staff   6644 10 17 23:30 KyushuIslands.lua
-rw-r--r--  1 yabea  staff   1439 10 17 22:22 Registry.lua
-rw-r--r--  1 yabea  staff   1356 10  6 10:43 ShikokuIslands.lua
-rw-r--r--  1 yabea  staff   3679 10 11 11:06 Snowland.lua
-rw-r--r--  1 yabea  staff   1551 10 17 22:24 Town.lua

./ReplicatedStorage/Monsters:
total 40
-rw-r--r--  1 yabea  staff   287 10 15 12:53 Registry.lua
-rw-r--r--  1 yabea  staff  1360 10 14 00:27 Slime.lua
-rw-r--r--  1 yabea  staff  1712 10 14 09:07 Slime_pink.lua
-rw-r--r--  1 yabea  staff  1196 10 15 05:55 fire_slime.lua
-rw-r--r--  1 yabea  staff  1186 10 15 13:01 golem.lua

./ReplicatedStorage/Remotes:
total 0

./ReplicatedStorage/Sounds:
total 0

./ReplicatedStorage/Typing:
total 40
-rw-r--r--  1 yabea  staff   508 10 14 08:19 CategoryLabels.lua
drwxr-xr-x  5 yabea  staff   160 10 14 09:03 Levels
-rw-r--r--  1 yabea  staff  3512 10 14 09:04 TypingWords copy.lua
-rw-r--r--  1 yabea  staff   930 10 14 10:49 TypingWords.lua
-rw-r--r--  1 yabea  staff   418 10 14 10:28 WordInfo.lua
-rw-r--r--  1 yabea  staff   854 10 14 10:23 WordPicker.lua

./ReplicatedStorage/Typing/Levels:
total 24
-rw-r--r--  1 yabea  staff  2335 10 14 16:11 level_1.lua
-rw-r--r--  1 yabea  staff  2146 10 14 10:17 level_2.lua
-rw-r--r--  1 yabea  staff  2187 10 14 10:19 level_3.lua

./ReplicatedStorage/Util:
total 16
-rw-r--r--  1 yabea  staff  5029 10 13 21:16 Logger.lua

./ServerScriptService:
total 352
-rw-r--r--  1 yabea  staff  31769 10 14 00:22 BattleSystem.lua
-rw-r--r--@ 1 yabea  staff  14805 10 15 17:42 Bootstrap.server.lua
-rw-r--r--  1 yabea  staff   3932 10 12 11:46 DataCollectors.lua
-rw-r--r--  1 yabea  staff   3617 10 12 06:34 DataStoreManager.lua
-rw-r--r--  1 yabea  staff   4289 10 18 08:03 FastTravelSystem.server.lua
-rw-r--r--  1 yabea  staff   7911 10 12 21:53 InteractionSystem.server.lua
-rw-r--r--  1 yabea  staff    708 10  9 15:11 LoadTest.server.lua
-rw-r--r--  1 yabea  staff   1713 10 17 23:50 MemoryMonitor.server.lua
-rw-r--r--  1 yabea  staff  28155 10 18 00:06 MonsterSpawner.server.lua
-rw-r--r--  1 yabea  staff   3949 10 17 23:26 OceanSafety.server.lua
-rw-r--r--  1 yabea  staff  14094 10 14 06:08 PlayerStats.lua
-rw-r--r--  1 yabea  staff   3532 10 14 01:03 ResetSave.server.lua
-rw-r--r--  1 yabea  staff    916 10 14 19:26 SettingsService.server.lua
-rw-r--r--  1 yabea  staff   1011 10 13 12:23 SoundRegistry.server.lua
-rw-r--r--  1 yabea  staff   5612 10  5 20:34 TowerPlacement.server.lua
-rw-r--r--  1 yabea  staff  10298 10 18 07:40 WarpPortal.server.lua
-rw-r--r--  1 yabea  staff  12937 10 17 23:33 ZoneManager.lua

./StartPlayerScripts:
total 400
-rw-r--r--  1 yabea  staff   5876 10 14 18:09 BGMManager.client.lua
-rw-r--r--  1 yabea  staff  50174 10 14 16:24 BattleUI.client.lua
-rw-r--r--  1 yabea  staff   7575 10  3 18:05 DeathUI.client.lua
-rw-r--r--  1 yabea  staff   3155 10 12 22:32 DebugButtons.client.lua
-rw-r--r--  1 yabea  staff   7800 10 18 08:06 FastTravelUI.client.lua
-rw-r--r--  1 yabea  staff   5920 10 12 21:52 InteractionUI.client.lua
-rw-r--r--  1 yabea  staff   6133 10 14 00:24 LevelUpUI.client.lua
-rw-r--r--@ 1 yabea  staff   4961 10 18 08:11 LoadingScreen.client.lua
-rw-r--r--  1 yabea  staff   6333 10 18 07:57 LoadingUI.client.lua
-rw-r--r--  1 yabea  staff  41732 10 14 19:20 MenuUI.client.lua
-rw-r--r--  1 yabea  staff  20619 10 17 22:24 Minimap.client.lua
-rw-r--r--  1 yabea  staff   5948 10 12 18:45 RewardPopup.client.lua
-rw-r--r--  1 yabea  staff   6847 10  9 13:33 StatusUI.client.lua
-rw-r--r--  1 yabea  staff   2045 10  6 10:49 WarpUI.client.lua
===== ./StartPlayerScripts/DebugButtons.client.lua =====
-- StarterPlayer/StarterPlayerScripts/DebugButtons.client.lua
-- ãƒ‡ãƒãƒƒã‚°ç”¨ãƒœã‚¿ãƒ³ï¼ˆé–‹ç™ºæ™‚ã®ã¿ä½¿ç”¨ï¼‰

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

print("[DebugButtons] åˆæœŸåŒ–é–‹å§‹")

-- ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰ï¼ˆæœ¬ç•ªç’°å¢ƒã§ã¯falseã«ï¼‰
local DEBUG_MODE = true

if not DEBUG_MODE then
	print("[DebugButtons] ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰OFF")
	return
end

-- RemoteEventå–å¾—ï¼ˆã‚µãƒ¼ãƒãƒ¼ãŒä½œæˆã™ã‚‹ã¾ã§å¾…æ©Ÿï¼‰
local DebugCommandEvent = ReplicatedStorage:WaitForChild("DebugCommand", 10)
if not DebugCommandEvent then
	warn("[DebugButtons] DebugCommandEventãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
	return
end

print("[DebugButtons] RemoteEventã‚’å–å¾—ã—ã¾ã—ãŸ")

-- ScreenGuiä½œæˆ
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "DebugButtonsUI"
screenGui.ResetOnSpawn = false
screenGui.IgnoreGuiInset = true
screenGui.DisplayOrder = 300
screenGui.Parent = playerGui

-- ãƒœã‚¿ãƒ³ã‚³ãƒ³ãƒ†ãƒŠï¼ˆå³ä¸Šã‹ã‚‰å·¦ã«ä¸¦ã¶ï¼‰
local container = Instance.new("Frame")
container.Name = "ButtonContainer"
container.Size = UDim2.new(0, 600, 0, 50)
container.Position = UDim2.new(1, -620, 0, 20) -- å³ä¸Š
container.BackgroundTransparency = 1
container.Parent = screenGui

local listLayout = Instance.new("UIListLayout")
listLayout.FillDirection = Enum.FillDirection.Horizontal
listLayout.HorizontalAlignment = Enum.HorizontalAlignment.Right
listLayout.VerticalAlignment = Enum.VerticalAlignment.Top
listLayout.Padding = UDim.new(0, 10)
listLayout.Parent = container

-- ãƒ‡ãƒãƒƒã‚°ãƒœã‚¿ãƒ³ä½œæˆé–¢æ•°
local function createDebugButton(text, callback)
	local button = Instance.new("TextButton")
	button.Size = UDim2.new(0, 180, 0, 40)
	button.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
	button.BackgroundTransparency = 0.2
	button.BorderSizePixel = 2
	button.BorderColor3 = Color3.new(1, 1, 1)
	button.Text = text
	button.TextColor3 = Color3.new(1, 1, 1)
	button.TextSize = 16
	button.Font = Enum.Font.SourceSansBold
	button.AutoButtonColor = true
	button.Parent = container

	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 8)
	corner.Parent = button

	-- ãƒ›ãƒãƒ¼ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
	button.MouseEnter:Connect(function()
		button.BackgroundTransparency = 0
	end)

	button.MouseLeave:Connect(function()
		button.BackgroundTransparency = 0.2
	end)

	-- ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆ
	button.MouseButton1Click:Connect(callback)

	return button
end

-- ã€ãƒœã‚¿ãƒ³1ã€‘å®ç®±ãƒªã‚»ãƒƒãƒˆ
createDebugButton("ğŸ”„ å®ç®±ãƒªã‚»ãƒƒãƒˆ", function()
	print("[DebugButtons] å®ç®±ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯")
	DebugCommandEvent:FireServer("reset_chests")
	print("[DebugButtons] ã‚µãƒ¼ãƒãƒ¼ã«ãƒªã‚»ãƒƒãƒˆè¦æ±‚ã‚’é€ä¿¡ã—ã¾ã—ãŸ")
end)

-- ã€å°†æ¥è¿½åŠ äºˆå®šã®ãƒœã‚¿ãƒ³ä¾‹ã€‘
-- createDebugButton("ğŸ’° ã‚´ãƒ¼ãƒ«ãƒ‰+1000", function()
-- 	DebugCommandEvent:FireServer("add_gold", 1000)
-- end)

-- createDebugButton("â¬†ï¸ ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—", function()
-- 	DebugCommandEvent:FireServer("level_up")
-- end)

print("[DebugButtons] åˆæœŸåŒ–å®Œäº†")
===== ./StartPlayerScripts/Minimap.client.lua =====
-- StarterPlayer/StarterPlayerScripts/Minimap.client.lua
-- ãƒŸãƒ‹ãƒãƒƒãƒ—ã‚·ã‚¹ãƒ†ãƒ ï¼ˆã‚ºãƒ¼ãƒ æ©Ÿèƒ½ãƒ»ãƒãƒ¼ã‚¿ãƒ«è¡¨ç¤ºå¯¾å¿œç‰ˆï¼‰
local Logger = require(game.ReplicatedStorage.Util.Logger)
local log = Logger.get("Minimap.client")

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

log.debugf("åˆæœŸåŒ–é–‹å§‹")

-- ã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«è¨­å®š
local ZOOM_LEVELS = {
	{
		name = "è©³ç´°",
		scale = 2, -- æ—¢å­˜ã®ã¾ã¾ï¼ˆåº§æ¨™å¤‰æ›ã«å½±éŸ¿ã—ãªã„ï¼‰
		terrainGrid = 45, -- 45 â†’ 120ï¼ˆé«˜ç²¾ç´°ï¼‰
		terrainUpdateInterval = 0.25, -- æ›´æ–°é–“éš”ã¯å¾®èª¿æ•´
		iconUpdateInterval = 0.05,
		monsterIconSize = 7,
		portalIconSize = 9,
	},
	{
		name = "ä¸­é–“",
		scale = 4,
		terrainGrid = 70, -- 50 â†’ 90
		terrainUpdateInterval = 0.24,
		iconUpdateInterval = 0.05,
		monsterIconSize = 5,
		portalIconSize = 7,
	},
	{
		name = "åºƒåŸŸ",
		scale = 8,
		terrainGrid = 50, -- 40 â†’ 60
		terrainUpdateInterval = 0.35,
		iconUpdateInterval = 0.08,
		monsterIconSize = 3,
		portalIconSize = 5,
	},
}

local currentZoomLevel = 1

-- ç¾åœ¨ã®è¨­å®šã‚’å–å¾—
local function getCurrentSettings()
	return ZOOM_LEVELS[currentZoomLevel]
end

-- åŸºæœ¬è¨­å®š
local MINIMAP_SIZE = 200
local WATER_LEVEL = -15

-- è‰²è¨­å®š
local LAND_COLOR = Color3.fromRGB(60, 180, 90) -- æ˜ã‚‹ã‚ã®ç·‘
local SEA_COLOR = Color3.fromRGB(40, 110, 200) -- è½ã¡ç€ã„ãŸé’
local PLAYER_COLOR = Color3.fromRGB(100, 200, 255)
local MONSTER_COLOR = Color3.fromRGB(255, 50, 50)
local PORTAL_TOWN_COLOR = Color3.fromRGB(255, 200, 100)
local PORTAL_OTHER_COLOR = Color3.fromRGB(200, 100, 255)

-- ScreenGuiä½œæˆ
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "MinimapUI"
screenGui.ResetOnSpawn = false
screenGui.IgnoreGuiInset = true
screenGui.Parent = playerGui

-- ãƒŸãƒ‹ãƒãƒƒãƒ—ã®èƒŒæ™¯ãƒ•ãƒ¬ãƒ¼ãƒ 
local minimapFrame = Instance.new("Frame")
minimapFrame.Name = "MinimapFrame"
minimapFrame.Size = UDim2.new(0, MINIMAP_SIZE, 0, MINIMAP_SIZE)
minimapFrame.Position = UDim2.new(0, 20, 1, -MINIMAP_SIZE - 20)
minimapFrame.BackgroundColor3 = SEA_COLOR
minimapFrame.BackgroundTransparency = 0.2
minimapFrame.BorderSizePixel = 2
minimapFrame.BorderColor3 = Color3.fromRGB(255, 255, 255)
minimapFrame.Parent = screenGui
minimapFrame.ClipsDescendants = false

local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(0, 8)
corner.Parent = minimapFrame

-- åœ°å½¢ãƒ¬ã‚¤ãƒ¤ãƒ¼
local terrainLayer = Instance.new("Frame")
terrainLayer.Name = "TerrainLayer"
terrainLayer.Size = UDim2.new(1, 0, 1, 0)
terrainLayer.BackgroundTransparency = 0.05
terrainLayer.ClipsDescendants = true
terrainLayer.ZIndex = 1
terrainLayer.Parent = minimapFrame

-- ã‚¿ã‚¤ãƒˆãƒ«ï¼ˆã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«è¡¨ç¤ºï¼‰
local titleLabel = Instance.new("TextLabel")
titleLabel.Name = "Title"
titleLabel.Size = UDim2.new(1, 0, 0, 20)
titleLabel.Position = UDim2.new(0, 0, 1, 0)
titleLabel.BackgroundTransparency = 1
titleLabel.Text = "MAP [Z: è©³ç´°]"
titleLabel.TextColor3 = Color3.new(1, 1, 1)
titleLabel.TextSize = 14
titleLabel.Font = Enum.Font.SourceSansBold
titleLabel.TextStrokeTransparency = 0.5
titleLabel.Parent = minimapFrame

-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¢ã‚¤ã‚³ãƒ³ï¼ˆç¸¦é•·ã®çŸ¢å°å‹ï¼‰
-- local playerIconContainer = Instance.new("Frame")
-- playerIconContainer.Name = "PlayerIconContainer"
-- playerIconContainer.Size = UDim2.new(0, 12, 0, 18)
-- playerIconContainer.AnchorPoint = Vector2.new(0.5, 0.5)
-- playerIconContainer.Position = UDim2.new(0.5, 0, 0.5, 0)
-- playerIconContainer.BackgroundTransparency = 1
-- playerIconContainer.ZIndex = 10
-- playerIconContainer.Parent = minimapFrame
local playerIcon = Instance.new("ImageLabel")
playerIcon.Name = "PlayerIcon"
playerIcon.Size = UDim2.new(0, 24, 0, 24) -- ã‚µã‚¤ã‚ºã¯èª¿æ•´å¯èƒ½
playerIcon.AnchorPoint = Vector2.new(0.5, 0.5)
playerIcon.Position = UDim2.new(0.5, 0, 0.5, 0)
playerIcon.BackgroundTransparency = 1
playerIcon.Image = "rbxassetid://137204683713117" -- ä¸Šå‘
-- playerIcon.Image = "rbxassetid://88281133700630"
playerIcon.ImageColor3 = PLAYER_COLOR
playerIcon.ZIndex = 10
playerIcon.Parent = minimapFrame

-- ã‚¢ã‚¤ã‚³ãƒ³ã‚’æ ¼ç´ã™ã‚‹ãƒ•ã‚©ãƒ«ãƒ€
local monstersFolder = Instance.new("Folder")
monstersFolder.Name = "MonsterIcons"
monstersFolder.Parent = minimapFrame

local portalsFolder = Instance.new("Folder")
portalsFolder.Name = "PortalIcons"
portalsFolder.Parent = minimapFrame

-- åœ°å½¢ã‚¿ã‚¤ãƒ«ã®ãƒ—ãƒ¼ãƒ«
local terrainTilePool = {}
local activeTiles = {}

local function getTerrainTile()
	for _, tile in ipairs(terrainTilePool) do
		if not tile.Visible then
			tile.Visible = true
			return tile
		end
	end

	local tile = Instance.new("Frame")
	tile.Name = "TerrainTile"
	tile.BackgroundColor3 = LAND_COLOR
	tile.BackgroundTransparency = 0.2
	tile.BorderSizePixel = 0
	tile.ZIndex = 2
	tile.Parent = terrainLayer

	table.insert(terrainTilePool, tile)
	return tile
end

local function hideAllTerrainTiles()
	for _, tile in ipairs(terrainTilePool) do
		tile.Visible = false
	end
	activeTiles = {}
end

-- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚¢ã‚¤ã‚³ãƒ³ã®ãƒ—ãƒ¼ãƒ«
local monsterIconPool = {}

local function getMonsterIcon(size)
	for _, icon in ipairs(monsterIconPool) do
		if not icon.Visible then
			icon.Visible = true
			icon.Size = UDim2.new(0, size, 0, size)
			return icon
		end
	end

	local icon = Instance.new("Frame")
	icon.Name = "MonsterIcon"
	icon.Size = UDim2.new(0, size, 0, size)
	icon.AnchorPoint = Vector2.new(0.5, 0.5)
	icon.BackgroundColor3 = MONSTER_COLOR
	icon.BorderSizePixel = 0
	icon.ZIndex = 5
	icon.Parent = monstersFolder

	local iconCorner = Instance.new("UICorner")
	iconCorner.CornerRadius = UDim.new(1, 0)
	iconCorner.Parent = icon

	table.insert(monsterIconPool, icon)
	return icon
end

local function hideAllMonsterIcons()
	for _, icon in ipairs(monsterIconPool) do
		icon.Visible = false
	end
end

-- ãƒãƒ¼ã‚¿ãƒ«ã‚¢ã‚¤ã‚³ãƒ³ã®ãƒ—ãƒ¼ãƒ«
local portalIconPool = {}

local function getPortalIcon(size)
	for _, icon in ipairs(portalIconPool) do
		if not icon.Visible then
			icon.Visible = true
			icon.Size = UDim2.new(0, size, 0, size)
			return icon
		end
	end

	local icon = Instance.new("Frame")
	icon.Name = "PortalIcon"
	icon.Size = UDim2.new(0, size, 0, size)
	icon.AnchorPoint = Vector2.new(0.5, 0.5)
	icon.BackgroundColor3 = PORTAL_OTHER_COLOR
	icon.BorderSizePixel = 0
	icon.ZIndex = 6
	icon.Parent = portalsFolder

	local iconCorner = Instance.new("UICorner")
	iconCorner.CornerRadius = UDim.new(1, 0)
	iconCorner.Parent = icon

	table.insert(portalIconPool, icon)
	return icon
end

local function hideAllPortalIcons()
	for _, icon in ipairs(portalIconPool) do
		icon.Visible = false
	end
end

-- ãƒ¬ã‚¤ã‚­ãƒ£ã‚¹ãƒˆã§åœ°å½¢ãƒã‚§ãƒƒã‚¯
local function isLand(worldX, worldZ)
	local params = RaycastParams.new()
	params.FilterType = Enum.RaycastFilterType.Include
	params.FilterDescendantsInstances = { workspace.Terrain }
	params.IgnoreWater = false

	local origin = Vector3.new(worldX, 200, worldZ)
	local direction = Vector3.new(0, -250, 0)

	local result = workspace:Raycast(origin, direction, params)

	if result then
		if result.Material == Enum.Material.Water then
			return false
		end
		if result.Position.Y > WATER_LEVEL then
			return true
		end
	end

	return false
end

-- åœ°å½¢ãƒãƒƒãƒ—ã‚’æ›´æ–°
local lastTerrainUpdate = 0
local lastPlayerPos = nil

local function updateTerrainMap()
	local settings = getCurrentSettings()
	local now = os.clock()

	if now - lastTerrainUpdate < settings.terrainUpdateInterval then
		return
	end

	local character = player.Character
	if not character then
		return
	end

	local hrp = character:FindFirstChild("HumanoidRootPart")
	if not hrp then
		return
	end

	local playerPos = hrp.Position

	-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒã‚ã¾ã‚Šå‹•ã„ã¦ã„ãªã‘ã‚Œã°ã‚¹ã‚­ãƒƒãƒ—
	if lastPlayerPos then
		local distance = (playerPos - lastPlayerPos).Magnitude
		-- è©³ç´°ãƒ¢ãƒ¼ãƒ‰ã¯ç§»å‹•è·é›¢ã®é–¾å€¤ã‚’ä¸Šã’ã‚‹ï¼ˆé »ç¹ã«æ›´æ–°ã—ãªã„ï¼‰
		local threshold = (settings.name == "è©³ç´°") and 8 or 5
		if distance < threshold then
			return
		end
	end

	lastTerrainUpdate = now
	lastPlayerPos = playerPos

	-- ãƒãƒ©ã¤ãé˜²æ­¢ï¼šå¤ã„ã‚¿ã‚¤ãƒ«ã¯æ®‹ã—ãŸã¾ã¾ã€æ–°ã—ã„ã‚¿ã‚¤ãƒ«ã‚’é…ç½®
	local tileSize = MINIMAP_SIZE / settings.terrainGrid
	local newActiveTiles = {}
	local usedTileIndex = 1

	-- ä¸€æ°—ã«å‡¦ç†ï¼ˆtask.wait()ãªã—ï¼‰
	for gridX = 0, settings.terrainGrid - 1 do
		for gridZ = 0, settings.terrainGrid - 1 do
			local mapX = (gridX + 0.5) / settings.terrainGrid
			local mapZ = (gridZ + 0.5) / settings.terrainGrid

			local relativeX = (mapX - 0.5) * MINIMAP_SIZE * settings.scale
			local relativeZ = (mapZ - 0.5) * MINIMAP_SIZE * settings.scale

			local worldX = playerPos.X + relativeX
			local worldZ = playerPos.Z + relativeZ

			-- åœ°å½¢ãƒã‚§ãƒƒã‚¯
			if isLand(worldX, worldZ) then
				local tile = getTerrainTile()
				tile.Size = UDim2.new(0, tileSize + 1, 0, tileSize + 1)
				tile.Position = UDim2.new(0, gridX * tileSize, 0, gridZ * tileSize)
				table.insert(newActiveTiles, tile)
			end
		end
	end

	-- å¤ã„ã‚¿ã‚¤ãƒ«ã‚’éè¡¨ç¤ºï¼ˆæ–°ã—ã„ã‚¿ã‚¤ãƒ«ã‚’è¡¨ç¤ºã—ãŸå¾Œï¼‰
	for _, tile in ipairs(activeTiles) do
		local isStillActive = false
		for _, newTile in ipairs(newActiveTiles) do
			if tile == newTile then
				isStillActive = true
				break
			end
		end
		if not isStillActive then
			tile.Visible = false
		end
	end

	activeTiles = newActiveTiles
end

-- ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ã‚’ãƒŸãƒ‹ãƒãƒƒãƒ—åº§æ¨™ã«å¤‰æ›
local function worldToMinimap(worldPos, playerPos)
	local settings = getCurrentSettings()

	local relativeX = worldPos.X - playerPos.X
	local relativeZ = worldPos.Z - playerPos.Z

	local minimapX = (relativeX / settings.scale)
	-- local minimapZ = -(relativeZ / settings.scale)
	local minimapZ = (relativeZ / settings.scale)

	local normalizedX = 0.5 + (minimapX / MINIMAP_SIZE)
	local normalizedZ = 0.5 + (minimapZ / MINIMAP_SIZE)

	return normalizedX, normalizedZ
end

local function isInRange(worldPos, playerPos)
	local settings = getCurrentSettings()
	local range = (MINIMAP_SIZE * settings.scale) / 2

	local dx = worldPos.X - playerPos.X
	local dz = worldPos.Z - playerPos.Z
	local distance = math.sqrt(dx * dx + dz * dz)
	return distance <= range
end

-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¢ã‚¤ã‚³ãƒ³ã®å‘ãã‚’æ›´æ–°
local function updatePlayerRotation_debug()
	local character = player.Character
	if not character then
		return
	end

	local hrp = character:FindFirstChild("HumanoidRootPart")
	if not hrp then
		return
	end

	if not playerIcon then
		return
	end

	-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å‘ãã‚’å–å¾—
	local lookVector = hrp.CFrame.LookVector

	-- 8ãƒ‘ã‚¿ãƒ¼ãƒ³å…¨ã¦è©¦ã™
	local patterns = {
		{
			name = "ãƒ‘ã‚¿ãƒ¼ãƒ³1",
			calc = function()
				return math.atan2(lookVector.X, lookVector.Z)
			end,
		},
		{
			name = "ãƒ‘ã‚¿ãƒ¼ãƒ³2",
			calc = function()
				return math.atan2(lookVector.Z, lookVector.X)
			end,
		},
		{
			name = "ãƒ‘ã‚¿ãƒ¼ãƒ³3",
			calc = function()
				return math.atan2(-lookVector.X, lookVector.Z)
			end,
		},
		{
			name = "ãƒ‘ã‚¿ãƒ¼ãƒ³4",
			calc = function()
				return math.atan2(lookVector.X, -lookVector.Z)
			end,
		},
		{
			name = "ãƒ‘ã‚¿ãƒ¼ãƒ³5",
			calc = function()
				return math.atan2(-lookVector.Z, lookVector.X)
			end,
		},
		{
			name = "ãƒ‘ã‚¿ãƒ¼ãƒ³6",
			calc = function()
				return math.atan2(lookVector.Z, -lookVector.X)
			end,
		},
		{
			name = "ãƒ‘ã‚¿ãƒ¼ãƒ³7",
			calc = function()
				return math.atan2(-lookVector.X, -lookVector.Z)
			end,
		},
		{
			name = "ãƒ‘ã‚¿ãƒ¼ãƒ³8",
			calc = function()
				return math.atan2(-lookVector.Z, -lookVector.X)
			end,
		},
	}

	-- ãƒ‘ã‚¿ãƒ¼ãƒ³1ã‚’ä½¿ç”¨ï¼ˆå¾Œã§å¤‰æ›´ã§ãã‚‹ï¼‰
	local angle = patterns[1].calc()
	local degrees = math.deg(angle)

	-- å›è»¢ã‚’é©ç”¨
	playerIcon.Rotation = degrees

	-- 5ç§’ã«1å›ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã‚’è¡¨ç¤º
	if os.clock() % 5 < 0.1 then
		log.debugf(string.format("LookVector: (%.2f, %.2f, %.2f)", lookVector.X, lookVector.Y, lookVector.Z))
		log.debugf(string.format("è§’åº¦: %.1fåº¦", degrees))
	end
end

-- ãƒ‡ãƒãƒƒã‚°ç‰ˆï¼ˆæ–¹è§’åã‚‚è¡¨ç¤ºï¼‰
local function updatePlayerRotation_news()
	local character = player.Character
	if not character then
		return
	end

	local hrp = character:FindFirstChild("HumanoidRootPart")
	if not hrp then
		return
	end

	if not playerIcon then
		return
	end

	local lookVector = hrp.CFrame.LookVector

	-- æ–¹è§’ã‚’åˆ¤å®š
	local direction = ""
	if math.abs(lookVector.Z) > math.abs(lookVector.X) then
		direction = lookVector.Z < 0 and "åŒ—" or "å—"
	else
		direction = lookVector.X > 0 and "æ±" or "è¥¿"
	end

	local angle = math.atan2(lookVector.Z, lookVector.X)
	local degrees = math.deg(angle)

	playerIcon.Rotation = degrees

	if os.clock() % 5 < 0.1 then
		log.debugf(string.format("æ–¹è§’: %s", direction))
		log.debugf(string.format("LookVector: (%.2f, %.2f, %.2f)", lookVector.X, lookVector.Y, lookVector.Z))
		log.debugf(string.format("è§’åº¦: %.1fåº¦", degrees))
	end
end

local function updatePlayerRotation()
	local character = player.Character
	if not character then
		return
	end

	local hrp = character:FindFirstChild("HumanoidRootPart")
	if not hrp then
		return
	end

	if not playerIcon then
		return
	end

	-- ã€å¤‰æ›´ã€‘CFrameã‹ã‚‰ç›´æ¥Yè»¸å›è»¢ã‚’å–å¾—
	local _, yRotation, _ = hrp.CFrame:ToOrientation()
	local degrees = math.deg(yRotation)

	-- åº§æ¨™ç³»ã‚’åˆã‚ã›ã‚‹ï¼ˆåœ°å½¢ãƒãƒƒãƒ—ã¨åŒã˜åè»¢ï¼‰
	playerIcon.Rotation = -degrees
end

-- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚¢ã‚¤ã‚³ãƒ³ã‚’æ›´æ–°
local lastIconUpdate = 0
local function updateMonsterIcons()
	local settings = getCurrentSettings()
	local now = os.clock()

	if now - lastIconUpdate < settings.iconUpdateInterval then
		return
	end
	lastIconUpdate = now

	local character = player.Character
	if not character then
		return
	end

	local hrp = character:FindFirstChild("HumanoidRootPart")
	if not hrp then
		return
	end

	local playerPos = hrp.Position

	hideAllMonsterIcons()

	-- Monstersãƒ•ã‚©ãƒ«ãƒ€ã‹ã‚‰å–å¾—
	local monstersWorkspace = workspace:FindFirstChild("Monsters")
	if monstersWorkspace then
		for _, model in ipairs(monstersWorkspace:GetChildren()) do
			if model:IsA("Model") then
				local monsterHrp = model:FindFirstChild("HumanoidRootPart")
				if monsterHrp then
					local monsterPos = monsterHrp.Position
					if isInRange(monsterPos, playerPos) then
						local mapX, mapZ = worldToMinimap(monsterPos, playerPos)
						if mapX >= 0 and mapX <= 1 and mapZ >= 0 and mapZ <= 1 then
							local icon = getMonsterIcon(settings.monsterIconSize)
							icon.Position = UDim2.new(mapX, 0, mapZ, 0)
						end
					end
				end
			end
		end
	end

	-- æ—§å½¢å¼ï¼ˆIsEnemyå±æ€§ï¼‰ã«ã‚‚å¯¾å¿œ
	for _, model in ipairs(workspace:GetChildren()) do
		if model:IsA("Model") and model:GetAttribute("IsEnemy") then
			local monsterHrp = model:FindFirstChild("HumanoidRootPart")
			if monsterHrp then
				local monsterPos = monsterHrp.Position
				if isInRange(monsterPos, playerPos) then
					local mapX, mapZ = worldToMinimap(monsterPos, playerPos)
					if mapX >= 0 and mapX <= 1 and mapZ >= 0 and mapZ <= 1 then
						local icon = getMonsterIcon(settings.monsterIconSize)
						icon.Position = UDim2.new(mapX, 0, mapZ, 0)
					end
				end
			end
		end
	end

	-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å‘ãã‚’æ›´æ–°
	updatePlayerRotation()
end

-- ãƒãƒ¼ã‚¿ãƒ«ã‚¢ã‚¤ã‚³ãƒ³ã‚’æ›´æ–°
local portalDebugDone = false
local function updatePortalIcons()
	local settings = getCurrentSettings()
	local character = player.Character
	if not character then
		return
	end

	local hrp = character:FindFirstChild("HumanoidRootPart")
	if not hrp then
		return
	end

	local playerPos = hrp.Position

	hideAllPortalIcons()

	-- ãƒ‡ãƒãƒƒã‚°: ãƒãƒ¼ã‚¿ãƒ«ã®é…ç½®å ´æ‰€ã‚’ç¢ºèª
	if not portalDebugDone then
		log.debugf("ãƒãƒ¼ã‚¿ãƒ«æ¤œç´¢é–‹å§‹")

		-- workspace.Worldã®ä¸­èº«ã‚’ç¢ºèª
		local worldFolder = workspace:FindFirstChild("World")
		if worldFolder then
			log.debugf("workspace.Worldç™ºè¦‹: " .. #worldFolder:GetChildren() .. "å€‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ")
			local portalCount = 0
			for _, obj in ipairs(worldFolder:GetChildren()) do
				local toZone = obj:GetAttribute("ToZone")
				if toZone then
					portalCount = portalCount + 1
					log.debugf("  - " .. obj.Name .. " â†’ " .. toZone .. " (Pos: " .. tostring(obj.Position) .. ")")
				end
			end
			log.debugf("ãƒãƒ¼ã‚¿ãƒ«ç·æ•°: " .. portalCount)
		else
			log.debugf("workspace.WorldãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
		end

		portalDebugDone = true
	end

	-- workspace.Worldã‹ã‚‰ãƒãƒ¼ã‚¿ãƒ«ã‚’å–å¾—
	local worldFolder = workspace:FindFirstChild("World")
	if worldFolder then
		for _, portal in ipairs(worldFolder:GetChildren()) do
			-- ToZoneå±æ€§ãŒã‚ã‚‹ã‚‚ã®ã‚’ãƒãƒ¼ã‚¿ãƒ«ã¨ã—ã¦èªè­˜
			if portal:IsA("BasePart") and portal:GetAttribute("ToZone") then
				local portalPos = portal.Position
				if isInRange(portalPos, playerPos) then
					local mapX, mapZ = worldToMinimap(portalPos, playerPos)
					if mapX >= 0 and mapX <= 1 and mapZ >= 0 and mapZ <= 1 then
						local icon = getPortalIcon(settings.portalIconSize)
						icon.Position = UDim2.new(mapX, 0, mapZ, 0)

						-- Townã¸ã®ãƒãƒ¼ã‚¿ãƒ«ã‹ãã‚Œä»¥å¤–ã‹ã§è‰²åˆ†ã‘
						local toZone = portal:GetAttribute("ToZone")
						if toZone == "StartTown" then
							-- Townã¸ã®ãƒãƒ¼ã‚¿ãƒ« â†’ ã‚ªãƒ¬ãƒ³ã‚¸
							icon.BackgroundColor3 = PORTAL_TOWN_COLOR
						else
							-- ãã‚Œä»¥å¤–ï¼ˆä»–ã®å¤§é™¸ã¸ï¼‰ â†’ ãƒãƒ¼ã‚¿ãƒ«ã®è‰²ã¾ãŸã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆç´«
							icon.BackgroundColor3 = portal.Color or PORTAL_OTHER_COLOR
						end
					end
				end
			end
		end
	end
end

-- ã‚ºãƒ¼ãƒ åˆ‡ã‚Šæ›¿ãˆ
local function changeZoomLevel(delta)
	currentZoomLevel = math.clamp(currentZoomLevel + delta, 1, #ZOOM_LEVELS)
	local settings = getCurrentSettings()

	titleLabel.Text = "MAP [Z: " .. settings.name .. "]"

	-- åœ°å½¢ãƒãƒƒãƒ—ã‚’å³åº§ã«æ›´æ–°
	lastTerrainUpdate = 0
	lastPlayerPos = nil

	log.debugf("ã‚ºãƒ¼ãƒ å¤‰æ›´: " .. settings.name)
end

-- ãƒã‚¦ã‚¹ãƒ›ã‚¤ãƒ¼ãƒ«å…¥åŠ›
UserInputService.InputChanged:Connect(function(input, gameProcessed)
	if gameProcessed then
		return
	end

	if input.UserInputType == Enum.UserInputType.MouseWheel then
		local mousePos = UserInputService:GetMouseLocation()
		local framePos = minimapFrame.AbsolutePosition
		local frameSize = minimapFrame.AbsoluteSize

		if
			mousePos.X >= framePos.X
			and mousePos.X <= framePos.X + frameSize.X
			and mousePos.Y >= framePos.Y
			and mousePos.Y <= framePos.Y + frameSize.Y
		then
			if input.Position.Z > 0 then
				changeZoomLevel(-1)
			else
				changeZoomLevel(1)
			end
		end
	end
end)

-- Zã‚­ãƒ¼å…¥åŠ›
UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then
		return
	end

	if input.KeyCode == Enum.KeyCode.Z then
		local nextLevel = currentZoomLevel + 1
		if nextLevel > #ZOOM_LEVELS then
			nextLevel = 1
		end
		changeZoomLevel(nextLevel - currentZoomLevel)
	end
end)

-- ãƒ¡ã‚¤ãƒ³æ›´æ–°ãƒ«ãƒ¼ãƒ—
RunService.Heartbeat:Connect(function()
	updateTerrainMap()
	updateMonsterIcons()
	updatePlayerRotation()
end)

-- ãƒãƒ¼ã‚¿ãƒ«å°‚ç”¨ã®é«˜é€Ÿæ›´æ–°ãƒ«ãƒ¼ãƒ—ï¼ˆç‹¬ç«‹ï¼‰
task.spawn(function()
	while true do
		task.wait(0.1) -- 0.1ç§’ã”ã¨ã«æ›´æ–°ï¼ˆé«˜é€Ÿï¼‰
		updatePortalIcons()
	end
end)

-- åˆæœŸåŒ–æ™‚ã«å³åº§ã«ãƒãƒ¼ã‚¿ãƒ«ã‚’æ¤œç´¢
task.spawn(function()
	task.wait(0.5) -- å°‘ã—å¾…ã£ã¦ã‹ã‚‰ãƒãƒ¼ã‚¿ãƒ«æ¤œç´¢
	updatePortalIcons()
end)

-- workspace.Worldã®å¤‰åŒ–ã‚’ç›£è¦–ï¼ˆãƒãƒ¼ã‚¿ãƒ«è¿½åŠ æ™‚ã«å³åæ˜ ï¼‰
task.spawn(function()
	local worldFolder = workspace:WaitForChild("World", 10)
	if worldFolder then
		worldFolder.ChildAdded:Connect(function(child)
			if child:IsA("BasePart") and child:GetAttribute("ToZone") then
				log.debugf("æ–°ã—ã„ãƒãƒ¼ã‚¿ãƒ«æ¤œå‡º: " .. child.Name)
				task.wait(0.1)
				updatePortalIcons()
			end
		end)
	end
end)

UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then
		return
	end

	if input.KeyCode == Enum.KeyCode.P then
		local character = player.Character
		if not character then
			return
		end

		local hrp = character:FindFirstChild("HumanoidRootPart")
		if not hrp then
			return
		end

		local position = hrp.Position

		local continent = player:GetAttribute("ContinentName") or "?"
		local island = player:GetAttribute("IslandName") or "?"

		log.debugf("ğŸ“ ç¾åœ¨åœ°æƒ…å ± -------------------------")
		log.debugf("ğŸ—ºï¸ å¤§é™¸å: " .. continent)
		log.debugf(string.format("ğŸ“Œ åº§æ¨™: (%.1f, %.1f, %.1f)", position.X, position.Y, position.Z))
		log.debugf("--------------------------------------")
	end
end)

log.debugf("åˆæœŸåŒ–å®Œäº†ï¼ˆã‚ºãƒ¼ãƒ æ©Ÿèƒ½ä»˜ãï¼‰")

===== ./StartPlayerScripts/MenuUI.client.lua =====
-- StarterPlayer/StarterPlayerScripts/MenuUI.client.lua
-- ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚·ã‚¹ãƒ†ãƒ ï¼ˆã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã€ã‚¢ã‚¤ãƒ†ãƒ ã€ã‚¹ã‚­ãƒ«ç­‰ï¼‰
local Logger = require(game.ReplicatedStorage.Util.Logger)
local log = Logger.get("MenuUI.client")

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

log.debugf("åˆæœŸåŒ–ä¸­...")

-- çŠ¶æ…‹ç®¡ç†
local currentModal = nil
local isInBattle = false

-- RemoteEventå–å¾—
local RequestStatusEvent = ReplicatedStorage:WaitForChild("RequestStatus", 1)
local SaveGameEvent = ReplicatedStorage:WaitForChild("SaveGame", 1)
local SaveSuccessEvent = ReplicatedStorage:WaitForChild("SaveSuccess", 1)
local RequestLoadRespawnEvent = ReplicatedStorage:WaitForChild("RequestLoadRespawn", 1)

-- UIã‚³ãƒ³ãƒ†ãƒŠ
local menuGui = nil
local menuFrame = nil

-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚­ãƒ£ãƒƒã‚·ãƒ¥
local cachedStats = {
	Level = 1,
	MaxHP = 100,
	CurrentHP = 100,
	Speed = 10,
	Attack = 10,
	Defense = 10,
	Gold = 0,
	MonstersDefeated = 0,
}

-- === Settings helpers (UILang / VolBGM / VolSE) ===
local LANG_OPTIONS = { "ja", "es", "fr", "de", "tl" }
local DEFAULTS = { UILang = "ja", VolBGM = 0.60, VolSE = 0.70 }

local function getAttrOrDefault(name, default)
	local v = Players.LocalPlayer:GetAttribute(name)
	if v == nil then
		Players.LocalPlayer:SetAttribute(name, default)
		return default
	end
	return v
end

-- SEã®ãƒ™ãƒ¼ã‚¹éŸ³é‡ã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã—ã¦å€ç‡é©ç”¨
local SEBaseVolume = {} -- [sound] = baseVolume
local function applyVolSE(mult)
	mult = math.clamp(tonumber(mult) or DEFAULTS.VolSE, 0, 1)
	local soundsFolder = ReplicatedStorage:FindFirstChild("Sounds")
	if not soundsFolder then
		return
	end
	for _, inst in ipairs(soundsFolder:GetChildren()) do
		if inst:IsA("Sound") then
			if SEBaseVolume[inst] == nil then
				SEBaseVolume[inst] = inst.Volume
			end
			inst.Volume = SEBaseVolume[inst] * mult
		end
	end
end

-- VolBGM ã¯ BGMManager å´ãŒ Attribute ã‚’è³¼èª­ã—ã¦é©ç”¨ã™ã‚‹å‰æï¼ˆã“ã“ã§ã¯å±æ€§ã ã‘æ›´æ–°ï¼‰
local function applyVolBGM(mult)
	mult = math.clamp(tonumber(mult) or DEFAULTS.VolBGM, 0, 1)
	Players.LocalPlayer:SetAttribute("VolBGM", mult)
end

-- è¨€èªã¯ Attribute ã¸ã€‚BattleUI å´ã®ãƒªã‚¹ãƒŠãƒ¼ã§ã‚«ãƒ†ã‚´ãƒª/ç¿»è¨³ã«åæ˜ æ¸ˆã¿
local function applyUILang(code)
	code = table.find(LANG_OPTIONS, code) and code or DEFAULTS.UILang
	Players.LocalPlayer:SetAttribute("UILang", code)
end

-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°ã‚’å—ä¿¡ (æ—¢å­˜ãƒ­ã‚¸ãƒƒã‚¯)
local StatusUpdateEvent = ReplicatedStorage:FindFirstChild("StatusUpdate")
if StatusUpdateEvent then
	StatusUpdateEvent.OnClientEvent:Connect(function(hp, maxHP, level, exp, expToNext, gold)
		cachedStats.CurrentHP = hp or cachedStats.CurrentHP
		cachedStats.MaxHP = maxHP or cachedStats.MaxHP
		cachedStats.Level = level or cachedStats.Level
		cachedStats.Gold = gold or cachedStats.Gold
	end)
end

-- æˆ¦æ­´æ›´æ–°ã‚’å—ä¿¡ (æ—¢å­˜ãƒ­ã‚¸ãƒƒã‚¯)
task.spawn(function()
	log.debugf("StatsDetailã‚¤ãƒ™ãƒ³ãƒˆæ¥ç¶šã‚’é–‹å§‹...")

	local StatsDetailEvent = ReplicatedStorage:WaitForChild("StatsDetail", 5)
	if not StatsDetailEvent then
		log.warnf("StatsDetailã‚¤ãƒ™ãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ï¼")
		return
	end

	log.debugf("StatsDetailã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºè¦‹ã—ã¾ã—ãŸ")

	StatsDetailEvent.OnClientEvent:Connect(function(stats)
		log.debugf("========================================")
		log.debugf("ğŸ¯ StatsDetailå—ä¿¡ã‚¤ãƒ™ãƒ³ãƒˆç™ºç«ï¼")
		if stats then
			for key, value in pairs(stats) do
				cachedStats[key] = value
			end
			log.debugf("âœ… ã‚­ãƒ£ãƒƒã‚·ãƒ¥æ›´æ–°å®Œäº†")
		else
			log.warnf("âŒ statsãŒnilã§ã™ï¼")
		end
		log.debugf("========================================")
	end)

	log.debugf("StatsDetailã‚¤ãƒ™ãƒ³ãƒˆæ¥ç¶šå®Œäº†")
end)

-- ãƒãƒˆãƒ«çŠ¶æ…‹ã‚’ç›£è¦– (æ—¢å­˜ãƒ­ã‚¸ãƒƒã‚¯)
local BattleStartEvent = ReplicatedStorage:FindFirstChild("BattleStart")
local BattleEndEvent = ReplicatedStorage:FindFirstChild("BattleEnd")

if BattleStartEvent then
	BattleStartEvent.OnClientEvent:Connect(function()
		isInBattle = true
		if menuFrame then
			for _, button in ipairs(menuFrame:GetChildren()) do
				if button:IsA("TextButton") then
					button.Active = false
					button.BackgroundTransparency = 0.7
					button.TextTransparency = 0.5
				end
			end
		end
		if currentModal then
			closeModal()
		end
	end)
end

if BattleEndEvent then
	BattleEndEvent.OnClientEvent:Connect(function()
		isInBattle = false
		if menuFrame then
			for _, button in ipairs(menuFrame:GetChildren()) do
				if button:IsA("TextButton") then
					button.Active = true
					button.BackgroundTransparency = 0.2
					button.TextTransparency = 0
				end
			end
		end
	end)
end

-- ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’é–‰ã˜ã‚‹ (æ—¢å­˜ãƒ­ã‚¸ãƒƒã‚¯)
function closeModal()
	if not currentModal then
		return
	end -- é˜²å¾¡çš„ãªæ—©æœŸçµ‚äº†

	local modalToDestroy = currentModal
	currentModal = nil -- â˜…å³åº§ã«nilã«è¨­å®šã—ã€ä»–ã®å‡¦ç†ã«ã‚ˆã‚‹ç«¶åˆã‚’é˜²æ­¢

	if modalToDestroy then
		local background = modalToDestroy:FindFirstChild("Background")
		if background then
			local tween = TweenService:Create(background, TweenInfo.new(0.2), {
				BackgroundTransparency = 1,
			})
			tween:Play()
		end

		local panel = modalToDestroy:FindFirstChild("Panel")
		if panel then
			local tween = TweenService:Create(panel, TweenInfo.new(0.2), {
				BackgroundTransparency = 1,
			})
			tween:Play()

			for _, child in ipairs(panel:GetDescendants()) do
				if child:IsA("TextLabel") or child:IsA("TextButton") then
					TweenService:Create(child, TweenInfo.new(0.2), {
						TextTransparency = 1,
					}):Play()
				end
			end
		end

		task.wait(0.2)
		modalToDestroy:Destroy() -- â˜…ãƒ­ãƒ¼ã‚«ãƒ«å‚ç…§ã‚’ä½¿ç”¨
	end
end

-- ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’ä½œæˆ (æ—¢å­˜ãƒ­ã‚¸ãƒƒã‚¯)
local function createModal(title, contentBuilder)
	if currentModal then
		closeModal()
	end

	local modal = Instance.new("ScreenGui")
	modal.DisplayOrder = 1000 -- ä»–UIã‚ˆã‚Šå‰é¢ã«
	modal.Name = "ModalUI"
	modal.ResetOnSpawn = false
	modal.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	modal.Parent = playerGui

	-- èƒŒæ™¯ï¼ˆæš—è»¢ï¼‰
	local background = Instance.new("Frame")
	background.Name = "Background"
	background.Size = UDim2.fromScale(1, 1)
	background.BackgroundColor3 = Color3.new(0, 0, 0)
	background.BackgroundTransparency = 1
	background.BorderSizePixel = 0
	background.ZIndex = 50
	background.Parent = modal

	TweenService:Create(background, TweenInfo.new(0.2), {
		BackgroundTransparency = 0.5,
	}):Play()

	-- ãƒ‘ãƒãƒ«
	local panel = Instance.new("Frame")
	panel.ClipsDescendants = false
	panel.Name = "Panel"
	panel.Size = UDim2.new(0, 500, 0, 400)
	panel.Position = UDim2.fromScale(0.5, 0.5)
	panel.AnchorPoint = Vector2.new(0.5, 0.5)
	panel.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
	panel.BackgroundTransparency = 1
	panel.BorderSizePixel = 0
	panel.ZIndex = 51
	panel.Parent = modal

	TweenService:Create(panel, TweenInfo.new(0.2), {
		BackgroundTransparency = 0.1,
	}):Play()

	local panelCorner = Instance.new("UICorner")
	panelCorner.CornerRadius = UDim.new(0, 12)
	panelCorner.Parent = panel

	-- ã‚¿ã‚¤ãƒˆãƒ«
	local titleLabel = Instance.new("TextLabel")
	titleLabel.Name = "Title"
	titleLabel.Size = UDim2.new(1, -20, 0, 40)
	titleLabel.Position = UDim2.new(0, 10, 0, 10)
	titleLabel.BackgroundTransparency = 1
	titleLabel.TextColor3 = Color3.fromRGB(255, 215, 0)
	titleLabel.TextStrokeTransparency = 0.5
	titleLabel.Font = Enum.Font.GothamBold
	titleLabel.TextSize = 24
	titleLabel.Text = title
	titleLabel.TextXAlignment = Enum.TextXAlignment.Left
	titleLabel.TextTransparency = 1
	titleLabel.ZIndex = 52
	titleLabel.Parent = panel

	TweenService:Create(titleLabel, TweenInfo.new(0.2), {
		TextTransparency = 0,
		TextStrokeTransparency = 0.5,
	}):Play()

	-- é–‰ã˜ã‚‹ãƒœã‚¿ãƒ³
	local closeButton = Instance.new("TextButton")
	closeButton.Name = "CloseButton"
	closeButton.Size = UDim2.new(0, 40, 0, 40)
	closeButton.Position = UDim2.new(1, -50, 0, 10)
	closeButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
	closeButton.BackgroundTransparency = 1
	closeButton.BorderSizePixel = 0
	closeButton.Font = Enum.Font.GothamBold
	closeButton.TextSize = 24
	closeButton.Text = "X"
	closeButton.TextColor3 = Color3.new(1, 1, 1)
	closeButton.TextTransparency = 1
	closeButton.ZIndex = 52
	closeButton.Parent = panel

	TweenService:Create(closeButton, TweenInfo.new(0.2), {
		BackgroundTransparency = 0.2,
		TextTransparency = 0,
	}):Play()

	local closeCorner = Instance.new("UICorner")
	closeCorner.CornerRadius = UDim.new(0, 8)
	closeCorner.Parent = closeButton

	closeButton.MouseButton1Click:Connect(function()
		closeModal()
	end)

	closeButton.MouseEnter:Connect(function()
		closeButton.BackgroundColor3 = Color3.fromRGB(255, 70, 70)
	end)
	closeButton.MouseLeave:Connect(function()
		closeButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
	end)

	-- ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¨ãƒªã‚¢
	local contentFrame = Instance.new("Frame")
	contentFrame.ClipsDescendants = false
	contentFrame.Name = "Content"
	contentFrame.Size = UDim2.new(1, -20, 1, -70)
	contentFrame.Position = UDim2.new(0, 10, 0, 60)
	contentFrame.BackgroundTransparency = 1
	contentFrame.ZIndex = 52
	contentFrame.Parent = panel

	if contentBuilder then
		contentBuilder(contentFrame)
	end

	-- background.InputBegan:Connect(function(input)
	-- 	if input.UserInputType == Enum.UserInputType.MouseButton1 then
	-- 		closeModal()
	-- 	end
	-- end)

	currentModal = modal
	return modal
end

local function showSaveModal()
	if not SaveGameEvent or not SaveSuccessEvent then
		createModal("ã‚»ãƒ¼ãƒ–ã‚¨ãƒ©ãƒ¼", function(content)
			local label = Instance.new("TextLabel")
			label.Size = UDim2.fromScale(1, 1)
			label.BackgroundTransparency = 1
			label.TextColor3 = Color3.fromRGB(255, 100, 100)
			label.TextStrokeTransparency = 0.7
			label.Font = Enum.Font.Gotham
			label.TextSize = 18
			label.Text = "ã‚»ãƒ¼ãƒ–æ©Ÿèƒ½ãŒã‚µãƒ¼ãƒãƒ¼ã§åˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚"
			label.Parent = content
		end)
		return
	end

	-- ã‚»ãƒ¼ãƒ–ã‚¤ãƒ™ãƒ³ãƒˆã‚’ã‚µãƒ¼ãƒãƒ¼ã«é€ä¿¡
	SaveGameEvent:FireServer()

	local connection = nil -- â˜…FIX 1: connectionã‚’ãƒ­ãƒ¼ã‚«ãƒ«å®£è¨€

	createModal("ã‚»ãƒ¼ãƒ–ä¸­", function(content)
		local label = Instance.new("TextLabel")
		label.Size = UDim2.fromScale(1, 1)
		label.BackgroundTransparency = 1
		label.TextColor3 = Color3.fromRGB(255, 255, 255)
		label.TextStrokeTransparency = 0.7
		label.Font = Enum.Font.Gotham
		label.TextSize = 18
		label.Text = "ğŸ’¾ ã‚»ãƒ¼ãƒ–ä¸­..."
		label.Parent = content
		-- ... (label setup)

		-- ã‚»ãƒ¼ãƒ–å®Œäº†ã®ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã‚’å¾…æ©Ÿ
		connection = SaveSuccessEvent.OnClientEvent:Connect(function(success)
			if connection and connection.Connected then
				connection:Disconnect()
			end -- â˜…FIX 2: Disconnectå‰ã«nil/Connectedãƒã‚§ãƒƒã‚¯

			if success then
				label.Text = "âœ… ã‚»ãƒ¼ãƒ–å®Œäº†ï¼"
				label.TextColor3 = Color3.fromRGB(46, 204, 113)
			else
				label.Text = "âŒ ã‚»ãƒ¼ãƒ–å¤±æ•—..."
				label.TextColor3 = Color3.fromRGB(231, 76, 60)
			end
			task.wait(1.5)
			closeModal()
		end)

		-- ãƒ¢ãƒ¼ãƒ€ãƒ«ãŒå¼·åˆ¶çµ‚äº†ã•ã‚ŒãŸå ´åˆã€æ¥ç¶šã‚’è§£é™¤
		-- é–‰ã˜ã‚‹ãƒœã‚¿ãƒ³ï¼ˆâœ•ï¼‰ã®ã‚¤ãƒ™ãƒ³ãƒˆæ¥ç¶šã‚’å†åˆ©ç”¨
		local closeButton = content.Parent:FindFirstChild("CloseButton")
		if closeButton then
			closeButton.MouseButton1Click:Connect(function()
				if connection and connection.Connected then
					connection:Disconnect()
				end -- â˜…FIX 3: çµ‚äº†ãƒœã‚¿ãƒ³ã‚‚nil/Connectedãƒã‚§ãƒƒã‚¯
				closeModal()
			end)
		end

		-- èƒŒæ™¯ã‚¯ãƒªãƒƒã‚¯ï¼ˆå¼·åˆ¶çµ‚äº†ï¼‰ã®ã‚¤ãƒ™ãƒ³ãƒˆæ¥ç¶šã‚’å†åˆ©ç”¨
		local background = content.Parent.Parent:FindFirstChild("Background")
		if background then
			background.InputBegan:Connect(function(input)
				if input.UserInputType == Enum.UserInputType.MouseButton1 then
					if connection and connection.Connected then
						connection:Disconnect()
					end
					closeModal()
				end
			end)
		end
	end)
end

local function showLoadModal()
	createModal("ãƒ­ãƒ¼ãƒ‰", function(content)
		local warningLabel = Instance.new("TextLabel")
		warningLabel.Size = UDim2.new(1, 0, 0, 60)
		warningLabel.Position = UDim2.new(0, 0, 0, 20)
		warningLabel.BackgroundTransparency = 1
		warningLabel.TextColor3 = Color3.fromRGB(255, 255, 100)
		warningLabel.TextStrokeTransparency = 0.7
		warningLabel.Font = Enum.Font.Gotham
		warningLabel.TextSize = 18
		warningLabel.Text =
			"ç¾åœ¨ã€ãƒ­ãƒ¼ãƒ‰ã¯å†æ¥ç¶šã«ã‚ˆã£ã¦è¡Œã‚ã‚Œã¾ã™ã€‚\nã‚²ãƒ¼ãƒ ã‚’å†èµ·å‹•ã—ã¾ã™ã‹ï¼Ÿ"
		warningLabel.TextWrapped = true
		warningLabel.TextTransparency = 1
		warningLabel.ZIndex = 53
		warningLabel.Parent = content

		TweenService:Create(warningLabel, TweenInfo.new(0.2), { TextTransparency = 0, TextStrokeTransparency = 0.7 })
			:Play()

		-- ãƒ­ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ (ã‚µãƒ¼ãƒãƒ¼ã«ãƒ­ãƒ¼ãƒ‰è¦æ±‚ã‚’é€ã‚Šã€ã‚­ãƒƒã‚¯ã™ã‚‹)
		local loadButton = Instance.new("TextButton")
		loadButton.Size = UDim2.new(0, 150, 0, 50)
		loadButton.Position = UDim2.new(0.5, -160, 1, -70)
		loadButton.BackgroundColor3 = Color3.fromRGB(52, 152, 219)
		loadButton.BackgroundTransparency = 0.2
		loadButton.BorderSizePixel = 0
		loadButton.Font = Enum.Font.GothamBold
		loadButton.TextSize = 18
		loadButton.Text = "ã‚²ãƒ¼ãƒ ã‚’å†èµ·å‹•"
		loadButton.TextColor3 = Color3.new(1, 1, 1)
		loadButton.TextTransparency = 1
		loadButton.ZIndex = 53
		loadButton.Parent = content

		TweenService
			:Create(loadButton, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0.1), {
				BackgroundTransparency = 0.2,
				TextTransparency = 0,
			})
			:Play()

		local loadCorner = Instance.new("UICorner")
		loadCorner.CornerRadius = UDim.new(0, 8)
		loadCorner.Parent = loadButton

		-- ãƒ­ãƒ¼ãƒ‰å‡¦ç†ã¯ã‚­ãƒƒã‚¯ã‚’å®Ÿè¡Œ
		loadButton.MouseButton1Click:Connect(function()
			closeModal()

			-- â˜…ä¿®æ­£ãƒ–ãƒ­ãƒƒã‚¯é–‹å§‹: Studioã¨å®Ÿç’°å¢ƒã§å‡¦ç†ã‚’åˆ†ã‘ã‚‹
			if game:GetService("RunService"):IsStudio() then
				if RequestLoadRespawnEvent then
					-- Studioã®å ´åˆã€ã‚µãƒ¼ãƒãƒ¼ã«ãƒªã‚¹ãƒãƒ¼ãƒ³ã‚’è¦æ±‚
					RequestLoadRespawnEvent:FireServer()
					log.debugf("Studioãƒ¢ãƒ¼ãƒ‰: ã‚µãƒ¼ãƒãƒ¼ã«ãƒ­ãƒ¼ãƒ‰ãƒªã‚¹ãƒãƒ¼ãƒ³ã‚’è¦æ±‚ã—ã¾ã—ãŸ")
				else
					log.warnf("RequestLoadRespawnEventãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ï¼")
				end
			else
				-- å®Ÿéš›ã®ã‚²ãƒ¼ãƒ ã®å ´åˆã€ã‚­ãƒƒã‚¯ã—ã¦å†æ¥ç¶šã‚’ä¿ƒã™
				player:Kick("ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ãŸã‚å†èµ·å‹•ã—ã¾ã™")
			end
			-- â˜…ä¿®æ­£ãƒ–ãƒ­ãƒƒã‚¯çµ‚äº†
		end)

		-- ã‚­ãƒ£ãƒ³ã‚»ãƒ«ãƒœã‚¿ãƒ³ (showLogoutã‹ã‚‰æµç”¨)
		local cancelButton = Instance.new("TextButton")
		cancelButton.Size = UDim2.new(0, 150, 0, 50)
		cancelButton.Position = UDim2.new(0.5, 10, 1, -70)
		cancelButton.BackgroundColor3 = Color3.fromRGB(149, 165, 166)
		cancelButton.BackgroundTransparency = 0.2
		cancelButton.BorderSizePixel = 0
		cancelButton.Font = Enum.Font.GothamBold
		cancelButton.TextSize = 18
		cancelButton.Text = "ã‚­ãƒ£ãƒ³ã‚»ãƒ«"
		cancelButton.TextColor3 = Color3.new(1, 1, 1)
		cancelButton.TextTransparency = 1
		cancelButton.ZIndex = 53
		cancelButton.Parent = content

		TweenService
			:Create(cancelButton, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0.15), {
				BackgroundTransparency = 0.2,
				TextTransparency = 0,
			})
			:Play()

		local cancelCorner = Instance.new("UICorner")
		cancelCorner.CornerRadius = UDim.new(0, 8)
		cancelCorner.Parent = cancelButton

		cancelButton.MouseButton1Click:Connect(function()
			closeModal()
		end)
	end)
end

-- â˜…æ–°è¦æ©Ÿèƒ½: åˆæœŸåŒ–å‡¦ç†
local function showResetModal()
	createModal("ãƒ‡ãƒ¼ã‚¿åˆæœŸåŒ–", function(content)
		local warningLabel = Instance.new("TextLabel")
		warningLabel.Size = UDim2.new(1, 0, 0, 60)
		warningLabel.Position = UDim2.new(0, 0, 0, 20)
		warningLabel.BackgroundTransparency = 1
		warningLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
		warningLabel.TextStrokeTransparency = 0.7
		warningLabel.Font = Enum.Font.Gotham
		warningLabel.TextSize = 18
		warningLabel.Text = "!! è­¦å‘Š !!\nã™ã¹ã¦ã®é€²è¡ŒçŠ¶æ³ã‚’å¤±ã„ã¾ã™ã€‚æœ¬å½“ã«åˆæœŸåŒ–ã—ã¾ã™ã‹ï¼Ÿ"
		warningLabel.TextWrapped = true
		warningLabel.TextTransparency = 1
		warningLabel.ZIndex = 53
		warningLabel.Parent = content
		TweenService:Create(warningLabel, TweenInfo.new(0.2), { TextTransparency = 0, TextStrokeTransparency = 0.7 })
			:Play()

		-- é€²æ—/çµæœãƒ©ãƒ™ãƒ«
		local resultLabel = Instance.new("TextLabel")
		resultLabel.Size = UDim2.new(1, 0, 0, 28)
		resultLabel.Position = UDim2.new(0, 0, 1, -110)
		resultLabel.BackgroundTransparency = 1
		resultLabel.Font = Enum.Font.Gotham
		resultLabel.TextSize = 18
		resultLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
		resultLabel.TextStrokeTransparency = 0.7
		resultLabel.Text = ""
		resultLabel.ZIndex = 53
		resultLabel.Parent = content

		local resetButton = Instance.new("TextButton")
		resetButton.Size = UDim2.new(0, 150, 0, 50)
		resetButton.Position = UDim2.new(0.5, -160, 1, -70)
		resetButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
		resetButton.BackgroundTransparency = 0.2
		resetButton.BorderSizePixel = 0
		resetButton.Font = Enum.Font.GothamBold
		resetButton.TextSize = 18
		resetButton.Text = "åˆæœŸåŒ–ã™ã‚‹"
		resetButton.TextColor3 = Color3.new(1, 1, 1)
		resetButton.TextTransparency = 1
		resetButton.ZIndex = 53
		resetButton.Parent = content
		local resetCorner = Instance.new("UICorner")
		resetCorner.CornerRadius = UDim.new(0, 8)
		resetCorner.Parent = resetButton
		TweenService
			:Create(resetButton, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0.1), {
				BackgroundTransparency = 0.2,
				TextTransparency = 0,
			})
			:Play()

		local cancelButton = Instance.new("TextButton")
		cancelButton.Size = UDim2.new(0, 150, 0, 50)
		cancelButton.Position = UDim2.new(0.5, 10, 1, -70)
		cancelButton.BackgroundColor3 = Color3.fromRGB(149, 165, 166)
		cancelButton.BackgroundTransparency = 0.2
		cancelButton.BorderSizePixel = 0
		cancelButton.Font = Enum.Font.GothamBold
		cancelButton.TextSize = 18
		cancelButton.Text = "ã‚­ãƒ£ãƒ³ã‚»ãƒ«"
		cancelButton.TextColor3 = Color3.new(1, 1, 1)
		cancelButton.TextTransparency = 1
		cancelButton.ZIndex = 53
		cancelButton.Parent = content
		local cancelCorner = Instance.new("UICorner")
		cancelCorner.CornerRadius = UDim.new(0, 8)
		cancelCorner.Parent = cancelButton
		TweenService
			:Create(cancelButton, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0.15), {
				BackgroundTransparency = 0.2,
				TextTransparency = 0,
			})
			:Play()
		cancelButton.MouseButton1Click:Connect(function()
			closeModal()
		end)

		-- RemoteEvents
		local ReplicatedStorage = game:GetService("ReplicatedStorage")
		local ResetSaveRequest = ReplicatedStorage:FindFirstChild("ResetSaveRequest")
		local ResetSaveResult = ReplicatedStorage:FindFirstChild("ResetSaveResult")

		resetButton.MouseButton1Click:Connect(function()
			if not ResetSaveRequest or not ResetSaveResult then
				resultLabel.Text = "âŒ ã‚µãƒ¼ãƒå´ã®åˆæœŸåŒ–æ©Ÿèƒ½ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"
				resultLabel.TextColor3 = Color3.fromRGB(231, 76, 60)
				return
			end

			-- äºŒåº¦æŠ¼ã—é˜²æ­¢
			resetButton.Active = false
			resetButton.AutoButtonColor = false
			resultLabel.Text = "ğŸ”„ åˆæœŸåŒ–ã—ã¦ã„ã¾ã™..."
			resultLabel.TextColor3 = Color3.fromRGB(255, 255, 255)

			-- çµæœå¾…ã¡ã®æ¥ç¶šï¼ˆãƒ¯ãƒ³ã‚·ãƒ§ãƒƒãƒˆï¼‰
			local conn
			conn = ResetSaveResult.OnClientEvent:Connect(function(success, message)
				if conn and conn.Connected then
					conn:Disconnect()
				end
				if success then
					resultLabel.Text = "âœ… åˆæœŸåŒ–å®Œäº†ï¼ˆãƒ¬ãƒ™ãƒ«1ã¸ï¼‰"
					resultLabel.TextColor3 = Color3.fromRGB(46, 204, 113)
					task.wait(1.2)
					closeModal()
					-- å®Ÿç’°å¢ƒã§ã¯å†æ¥ç¶šã—ã¦ã‚¯ãƒªãƒ¼ãƒ³ã«èª­ã¿ç›´ã—ï¼ˆStudioã¯ã‚­ãƒƒã‚¯ã—ãªã„ï¼‰
					if not game:GetService("RunService"):IsStudio() then
						Players.LocalPlayer:Kick("ãƒ‡ãƒ¼ã‚¿ã‚’åˆæœŸåŒ–ã—ã¾ã—ãŸã€‚å†æ¥ç¶šã—ã¦ãã ã•ã„ã€‚")
					end
				else
					resultLabel.Text = "âŒ åˆæœŸåŒ–å¤±æ•—: " .. (message or "ä¸æ˜ãªã‚¨ãƒ©ãƒ¼")
					resultLabel.TextColor3 = Color3.fromRGB(231, 76, 60)
					resetButton.Active = true
					resetButton.AutoButtonColor = true
				end
			end)

			-- ã‚µãƒ¼ãƒã¸è¦æ±‚
			ResetSaveRequest:FireServer()
		end)
	end)
end

-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ç”»é¢ (æ—¢å­˜ãƒ­ã‚¸ãƒƒã‚¯)
local function showStatus()
	createModal("ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹", function(content)
		local stats = {
			{ "ãƒ¬ãƒ™ãƒ«", cachedStats.Level },
			{ "æœ€å¤§HP", cachedStats.MaxHP },
			{ "æ”»æ’ƒåŠ›", cachedStats.Attack },
			{ "é˜²å¾¡åŠ›", cachedStats.Defense },
			{ "ç´ æ—©ã•", cachedStats.Speed },
		}

		for i, stat in ipairs(stats) do
			local label = Instance.new("TextLabel")
			label.Size = UDim2.new(1, 0, 0, 40)
			label.Position = UDim2.new(0, 0, 0, (i - 1) * 50)
			label.BackgroundTransparency = 1
			label.TextColor3 = Color3.fromRGB(255, 255, 255)
			label.TextStrokeTransparency = 0.7
			label.Font = Enum.Font.Gotham
			label.TextSize = 20
			label.Text = string.format("%s: %d", stat[1], stat[2])
			label.TextXAlignment = Enum.TextXAlignment.Left
			label.TextTransparency = 1
			label.ZIndex = 53
			label.Parent = content

			TweenService
				:Create(
					label,
					TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, i * 0.05),
					{
						TextTransparency = 0,
						TextStrokeTransparency = 0.7,
					}
				)
				:Play()
		end
	end)
end

-- ã‚¢ã‚¤ãƒ†ãƒ ç”»é¢ (æ—¢å­˜ãƒ­ã‚¸ãƒƒã‚¯)
local function showItems()
	createModal("ã‚¢ã‚¤ãƒ†ãƒ ", function(content)
		local emptyLabel = Instance.new("TextLabel")
		emptyLabel.Size = UDim2.fromScale(1, 1)
		emptyLabel.BackgroundTransparency = 1
		emptyLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
		emptyLabel.TextStrokeTransparency = 0.7
		emptyLabel.Font = Enum.Font.Gotham
		emptyLabel.TextSize = 18
		emptyLabel.Text = "ã‚¢ã‚¤ãƒ†ãƒ ãŒã‚ã‚Šã¾ã›ã‚“"
		emptyLabel.TextTransparency = 1
		emptyLabel.ZIndex = 53
		emptyLabel.Parent = content

		TweenService:Create(emptyLabel, TweenInfo.new(0.2), {
			TextTransparency = 0,
			TextStrokeTransparency = 0.7,
		}):Play()
	end)
end

-- ã‚¹ã‚­ãƒ«ç”»é¢ (æ—¢å­˜ãƒ­ã‚¸ãƒƒã‚¯)
local function showSkills()
	createModal("ã‚¹ã‚­ãƒ«", function(content)
		local emptyLabel = Instance.new("TextLabel")
		emptyLabel.Size = UDim2.fromScale(1, 1)
		emptyLabel.BackgroundTransparency = 1
		emptyLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
		emptyLabel.TextStrokeTransparency = 0.7
		emptyLabel.Font = Enum.Font.Gotham
		emptyLabel.TextSize = 18
		emptyLabel.Text = "ç¿’å¾—æ¸ˆã¿ã‚¹ã‚­ãƒ«ãªã—"
		emptyLabel.TextTransparency = 1
		emptyLabel.ZIndex = 53
		emptyLabel.Parent = content

		TweenService:Create(emptyLabel, TweenInfo.new(0.2), {
			TextTransparency = 0,
			TextStrokeTransparency = 0.7,
		}):Play()
	end)
end

-- æˆ¦æ­´ç”»é¢ (æ—¢å­˜ãƒ­ã‚¸ãƒƒã‚¯)
local function showRecords()
	createModal("æˆ¦æ­´", function(content)
		log.debugf("========================================")
		log.debugf("æˆ¦æ­´ç”»é¢ã‚’é–‹ãã¾ã—ãŸ")
		log.debugf("ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã•ã‚ŒãŸå€¤:", cachedStats.MonstersDefeated or 0)

		-- ãƒ©ãƒ™ãƒ«ã‚’å…ˆã«ä½œæˆ
		local label = Instance.new("TextLabel")
		label.Size = UDim2.new(1, 0, 0, 40)
		label.Position = UDim2.new(0, 0, 0, 0)
		label.BackgroundTransparency = 1
		label.TextColor3 = Color3.fromRGB(255, 255, 255)
		label.TextStrokeTransparency = 0.7
		label.Font = Enum.Font.Gotham
		label.TextSize = 20
		label.Text = string.format("å€’ã—ãŸãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æ•°: %d (å–å¾—ä¸­...)", cachedStats.MonstersDefeated or 0)
		label.TextXAlignment = Enum.TextXAlignment.Left
		label.TextTransparency = 1
		label.ZIndex = 53
		label.Parent = content

		TweenService:Create(label, TweenInfo.new(0.2), {
			TextTransparency = 0,
			TextStrokeTransparency = 0.7,
		}):Play()

		-- ã‚µãƒ¼ãƒãƒ¼ã«æœ€æ–°ã®æˆ¦æ­´ã‚’ãƒªã‚¯ã‚¨ã‚¹ãƒˆ
		local RequestStatsDetailEvent = ReplicatedStorage:FindFirstChild("RequestStatsDetail")
		if RequestStatsDetailEvent then
			log.debugf("ã‚µãƒ¼ãƒãƒ¼ã«è©³ç´°ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’ãƒªã‚¯ã‚¨ã‚¹ãƒˆä¸­...")
			RequestStatsDetailEvent:FireServer()

			-- 0.5ç§’å¾Œã«ãƒ©ãƒ™ãƒ«ã‚’æ›´æ–°ï¼ˆã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰ã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’å¾…ã¤ï¼‰
			task.delay(0.5, function()
				if label and label.Parent then
					label.Text = string.format("å€’ã—ãŸãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æ•°: %d", cachedStats.MonstersDefeated or 0)
					log.debugf("ãƒ©ãƒ™ãƒ«æ›´æ–°: MonstersDefeated =", cachedStats.MonstersDefeated)
				end
			end)
		else
			log.warnf("RequestStatsDetailEventãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
		end

		log.debugf("========================================")
	end)
end

-- è¨­å®šç”»é¢
local function showSettings()
	createModal("ã‚·ã‚¹ãƒ†ãƒ è¨­å®š", function(content)
		-- åˆæœŸå€¤ï¼ˆå±æ€§ or æ—¢å®šï¼‰
		local curLang = getAttrOrDefault("UILang", DEFAULTS.UILang)
		local curBGM = getAttrOrDefault("VolBGM", DEFAULTS.VolBGM) -- 0..1
		local curSE = getAttrOrDefault("VolSE", DEFAULTS.VolSE) -- 0..1

		-- ãƒœãƒ‡ã‚£ï¼šã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
		local scroll = Instance.new("ScrollingFrame")
		scroll.ClipsDescendants = false
		scroll.ZIndex = 200
		scroll.Name = "SettingsList"
		scroll.Size = UDim2.new(1, 0, 1, -60)
		scroll.Position = UDim2.new(0, 0, 0, 0)
		scroll.BackgroundTransparency = 1
		scroll.ScrollBarThickness = 8
		scroll.CanvasSize = UDim2.new(0, 0, 0, 0)
		scroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
		scroll.ZIndex = 53
		scroll.Parent = content

		local pad = Instance.new("UIPadding")
		pad.PaddingTop = UDim.new(0, 12)
		pad.PaddingBottom = UDim.new(0, 12)
		pad.PaddingLeft = UDim.new(0, 12)
		pad.PaddingRight = UDim.new(0, 12)
		pad.Parent = scroll

		local list = Instance.new("UIListLayout")
		list.FillDirection = Enum.FillDirection.Vertical
		list.Padding = UDim.new(0, 8)
		list.SortOrder = Enum.SortOrder.LayoutOrder
		list.Parent = scroll

		-- è¡Œãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆä½œæˆãƒ˜ãƒ«ãƒ‘
		local function makeRow(height)
			local row = Instance.new("Frame")
			row.BackgroundColor3 = Color3.fromRGB(35, 38, 50)
			row.BackgroundTransparency = 0.1
			row.BorderSizePixel = 0
			row.Size = UDim2.new(1, 0, 0, height or 54)
			row.ZIndex = 53
			row.ClipsDescendants = false
			row.ZIndex = 210 -- scrollã‚ˆã‚Šå‰ã«

			local corner = Instance.new("UICorner")
			corner.CornerRadius = UDim.new(0, 10)
			corner.Parent = row

			local stroke = Instance.new("UIStroke")
			stroke.Thickness = 1
			stroke.Transparency = 0.5
			stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
			stroke.Parent = row

			row.Parent = scroll
			return row
		end

		local function addLabel(parent, text)
			local label = Instance.new("TextLabel")
			label.BackgroundTransparency = 1
			label.Size = UDim2.new(0.45, -12, 1, 0)
			label.Position = UDim2.new(0, 12, 0, 0)
			label.Font = Enum.Font.GothamMedium
			label.TextXAlignment = Enum.TextXAlignment.Left
			label.TextYAlignment = Enum.TextYAlignment.Center
			label.TextSize = 18
			label.TextColor3 = Color3.fromRGB(230, 240, 255)
			label.TextStrokeTransparency = 0.7
			label.Text = text
			label.ZIndex = 54
			label.Parent = parent
			return label
		end

		-- â–¼ è¨€èªï¼ˆãƒ‰ãƒ­ãƒƒãƒ—ãƒ€ã‚¦ãƒ³é¢¨ï¼‰
		do
			local row = makeRow(54)
			addLabel(row, "è¨€èª / Language")

			local langBtn = Instance.new("TextButton")
			langBtn.Size = UDim2.new(0.45, -12, 0, 36)
			langBtn.Position = UDim2.new(0.55, 0, 0.5, -18)
			langBtn.BackgroundColor3 = Color3.fromRGB(52, 86, 139)
			langBtn.BackgroundTransparency = 0.15
			langBtn.BorderSizePixel = 0
			langBtn.Font = Enum.Font.GothamBold
			langBtn.TextSize = 18
			langBtn.TextColor3 = Color3.new(1, 1, 1)
			langBtn.AutoButtonColor = true
			langBtn.ZIndex = 54
			langBtn.Parent = row

			local langCorner = Instance.new("UICorner")
			langCorner.CornerRadius = UDim.new(0, 8)
			langCorner.Parent = langBtn

			local function labelOf(code)
				-- è¡¨ç¤ºåï¼ˆå¿…è¦ãªã‚‰è¾æ›¸ã«å¤‰æ›´å¯ï¼‰
				local map = { ja = "æ—¥æœ¬èª", es = "EspaÃ±ol", fr = "FranÃ§ais", de = "Deutsch", tl = "Tagalog" }
				return map[code] or code
			end

			local current = curLang
			langBtn.Text = labelOf(current)

			-- ç°¡æ˜“ãƒ‰ãƒ­ãƒƒãƒ—ãƒ€ã‚¦ãƒ³ï¼ˆãƒ¢ãƒ¼ãƒ€ãƒ«å†…ã«ãƒŸãƒ‹ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’å‡ºã™ã ã‘ï¼‰
			langBtn.MouseButton1Click:Connect(function()
				-- æ—¢å­˜ã‚’ã¤ã¶ã•ãªã„ãŸã‚ç°¡æ˜“ã«ï¼šãƒˆã‚°ãƒ«å¼ã®å°ãƒ‘ãƒãƒ«
				local dd = row:FindFirstChild("LangDD")
				if dd then
					dd:Destroy()
					return
				end

				dd = Instance.new("Frame")
				dd.Name = "LangDD"
				dd.Size = UDim2.new(0, langBtn.AbsoluteSize.X, 0, #LANG_OPTIONS * 34 + 10)
				dd.Position = UDim2.new(0.55, 0, 1, 4)
				dd.BackgroundColor3 = Color3.fromRGB(25, 26, 36)
				dd.BackgroundTransparency = 0.05
				dd.BorderSizePixel = 0
				dd.ZIndex = 1000
				dd.ClipsDescendants = false
				-- â˜… è¦ªã¯ panel ã®ã¾ã¾ã§OKï¼ˆãƒ‘ãƒãƒ«åŸºæº–ã§çµ¶å¯¾ä½ç½®ã‚’ç®—å‡ºï¼‰
				dd.Parent = content.Parent -- (= panel)

				-- â˜… ãƒœã‚¿ãƒ³ç›´ä¸‹ã«ç½®ããŸã‚ã®æ­£ç¢ºãªä½ç½®ç®—å‡º
				local panelAbs = content.Parent.AbsolutePosition
				local btnAbs = langBtn.AbsolutePosition
				local x = btnAbs.X - panelAbs.X
				local y = (btnAbs.Y - panelAbs.Y) + langBtn.AbsoluteSize.Y + 6
				dd.Position = UDim2.fromOffset(x, y)

				local corner = Instance.new("UICorner")
				corner.CornerRadius = UDim.new(0, 8)
				corner.Parent = dd

				local list = Instance.new("UIListLayout")
				list.FillDirection = Enum.FillDirection.Vertical
				list.Padding = UDim.new(0, 4)
				list.Parent = dd

				local pad = Instance.new("UIPadding")
				pad.PaddingTop = UDim.new(0, 6)
				pad.PaddingBottom = UDim.new(0, 6)
				pad.PaddingLeft = UDim.new(0, 6)
				pad.PaddingRight = UDim.new(0, 6)
				pad.Parent = dd

				for _, code in ipairs(LANG_OPTIONS) do
					local opt = Instance.new("TextButton")
					opt.Size = UDim2.new(1, 0, 0, 30)
					opt.BackgroundColor3 = Color3.fromRGB(35, 38, 50)
					opt.BackgroundTransparency = (code == current) and 0.0 or 0.15
					opt.BorderSizePixel = 0
					opt.Font = Enum.Font.Gotham
					opt.TextSize = 16
					opt.TextColor3 = Color3.new(1, 1, 1)
					opt.Text = labelOf(code)
					opt.ZIndex = 1001
					opt.Parent = dd

					local oc = Instance.new("UICorner")
					oc.CornerRadius = UDim.new(0, 6)
					oc.Parent = opt

					opt.MouseButton1Click:Connect(function()
						current = code
						curLang = code -- â˜…ã“ã‚ŒãŒç„¡ã„ã¨ä¿å­˜ã«åæ˜ ã•ã‚Œãªã„
						langBtn.Text = labelOf(current)
						applyUILang(current)
						dd:Destroy()
					end)
				end
			end)
		end

		local UIS = game:GetService("UserInputService")

		local function sliderRow(labelText, init01, onChange)
			local row = makeRow(58)
			addLabel(row, labelText)

			-- åˆæœŸå€¤ã‚’ 0..1 ã«ä¸¸ã‚ã‚‹ï¼ˆnil å¯¾ç­–ï¼‰
			init01 = tonumber(init01) or 1
			if init01 < 0 then
				init01 = 0
			elseif init01 > 1 then
				init01 = 1
			end

			-- track
			local track = Instance.new("Frame")
			track.Size = UDim2.new(0.55, -12, 0, 8)
			track.Position = UDim2.new(0.40, 0, 0.5, 0)
			track.BackgroundColor3 = Color3.fromRGB(70, 80, 100)
			track.BackgroundTransparency = 0.2
			track.BorderSizePixel = 0
			track.ClipsDescendants = false
			track.ZIndex = 54
			track.Parent = row
			local tc = Instance.new("UICorner")
			tc.CornerRadius = UDim.new(0, 4)
			tc.Parent = track

			-- fill
			local fill = Instance.new("Frame")
			fill.Size = UDim2.new(init01, 0, 1, 0)
			fill.BackgroundColor3 = Color3.fromRGB(100, 200, 255)
			fill.BorderSizePixel = 0
			fill.ZIndex = 55
			fill.Parent = track
			local fc = Instance.new("UICorner")
			fc.CornerRadius = UDim.new(0, 4)
			fc.Parent = fill

			-- knob
			local knob = Instance.new("Frame")
			knob.Size = UDim2.new(0, 16, 0, 16)
			knob.AnchorPoint = Vector2.new(0.5, 0.5)
			knob.Position = UDim2.new(init01, 0, 0.5, 0)
			knob.BackgroundColor3 = Color3.fromRGB(220, 230, 255)
			knob.BorderSizePixel = 0
			knob.ZIndex = 56
			knob.Parent = track
			local kc = Instance.new("UICorner")
			kc.CornerRadius = UDim.new(1, 0)
			kc.Parent = knob

			-- % ãƒ©ãƒ™ãƒ«ï¼ˆtrack ã®â€œã™ãå³å†…å´â€å›ºå®šï¼‰
			local pct = Instance.new("TextLabel")
			pct.Name = "Percent"
			pct.AutomaticSize = Enum.AutomaticSize.X
			pct.Size = UDim2.new(0, 0, 0, 16) -- é«˜ã•ã®ã¿
			pct.AnchorPoint = Vector2.new(1, 0.5) -- å³ç«¯åŸºæº–
			pct.Position = UDim2.new(1, -4, 0.5, 0) -- å³ç«¯ã‹ã‚‰ 4px å·¦
			pct.BackgroundTransparency = 1
			pct.Font = Enum.Font.Gotham
			pct.TextSize = 16
			pct.TextColor3 = Color3.fromRGB(220, 230, 255)
			pct.TextXAlignment = Enum.TextXAlignment.Right
			pct.TextYAlignment = Enum.TextYAlignment.Center
			pct.ZIndex = 56
			pct.Text = string.format("%d%%", math.floor(init01 * 100 + 0.5))
			pct.Parent = track

			-- åˆæœŸãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã‚’2å›é©ç”¨ï¼ˆç¸¦ã‚ºãƒ¬é˜²æ­¢ï¼‰
			local function layoutInit()
				knob.Position = UDim2.new(init01, 0, 0.5, 0)
				fill.Size = UDim2.new(init01, 0, 1, 0)
				pct.Position = UDim2.new(1, -4, 0.5, 0)
			end
			layoutInit()
			track:GetPropertyChangedSignal("AbsoluteSize"):Connect(layoutInit)
			task.defer(layoutInit)

			-- ãƒ‰ãƒ©ãƒƒã‚°
			local dragging = false
			local function setValueFromX(x)
				local rel = math.clamp((x - track.AbsolutePosition.X) / math.max(1, track.AbsoluteSize.X), 0, 1)
				fill.Size = UDim2.new(rel, 0, 1, 0)
				knob.Position = UDim2.new(rel, 0, 0.5, 0)
				pct.Text = string.format("%d%%", math.floor(rel * 100 + 0.5))
				if onChange then
					onChange(rel)
				end
			end

			track.InputBegan:Connect(function(input)
				if input.UserInputType == Enum.UserInputType.MouseButton1 then
					dragging = true
					setValueFromX(input.Position.X)
				end
			end)
			knob.InputBegan:Connect(function(input)
				if input.UserInputType == Enum.UserInputType.MouseButton1 then
					dragging = true
				end
			end)
			track.InputEnded:Connect(function(input)
				if input.UserInputType == Enum.UserInputType.MouseButton1 then
					dragging = false
				end
			end)
			knob.InputEnded:Connect(function(input)
				if input.UserInputType == Enum.UserInputType.MouseButton1 then
					dragging = false
				end
			end)
			UIS.InputChanged:Connect(function(input)
				if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
					setValueFromX(input.Position.X)
				end
			end)

			return row
		end

		local curLang = Players.LocalPlayer:GetAttribute("UILang") or "ja"
		local curBGM = tonumber(Players.LocalPlayer:GetAttribute("VolBGM")) or 1.0
		local curSE = tonumber(Players.LocalPlayer:GetAttribute("VolSE")) or 1.0

		-- â–¼ BGM / SE ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ï¼ˆè¨€èªè¡Œã®ç›´å¾Œã«ç½®ãï¼‰
		sliderRow("BGMéŸ³é‡", curBGM, function(v)
			curBGM = v
			applyVolBGM(v) -- ãã®å ´ã§è©¦è´
			Players.LocalPlayer:SetAttribute("VolBGM", v) -- å³æ™‚ä¿å­˜ï¼ˆä»»æ„ï¼‰
		end)

		sliderRow("SEéŸ³é‡", curSE, function(v)
			curSE = v
			applyVolSE(v)
			Players.LocalPlayer:SetAttribute("VolSE", v)
		end)

		-- ãƒ•ãƒƒã‚¿ãƒ¼ãƒœã‚¿ãƒ³ï¼ˆæˆ»ã‚‹/æ—¢å®šã«æˆ»ã™/ä¿å­˜ï¼‰
		local footer = Instance.new("Frame")
		footer.Size = UDim2.new(1, 0, 0, 52)
		footer.Position = UDim2.new(0, 0, 1, -52)
		footer.BackgroundTransparency = 1
		footer.ZIndex = 54
		footer.Parent = content

		local function makeBtn(text, anchorX)
			local b = Instance.new("TextButton")
			b.Size = UDim2.new(0, 120, 0, 40)
			b.AnchorPoint = Vector2.new(anchorX, 0.5)
			b.Position = UDim2.new(anchorX, 0, 0.5, 0)
			b.BackgroundColor3 = Color3.fromRGB(60, 70, 85)
			b.BackgroundTransparency = 0.1
			b.BorderSizePixel = 0
			b.Font = Enum.Font.GothamBold
			b.TextSize = 18
			b.Text = text
			b.TextColor3 = Color3.new(1, 1, 1)
			b.ZIndex = 55
			local c = Instance.new("UICorner")
			c.CornerRadius = UDim.new(0, 8)
			c.Parent = b
			b.Parent = footer
			return b
		end

		local reset = makeBtn("æ—¢å®šã«æˆ»ã™", 0.0)
		reset.Position = UDim2.new(0, 10, 0.5, 0)
		local save = makeBtn("ä¿å­˜", 1.0)
		save.Position = UDim2.new(1, -10, 0.5, 0)
		save.Position = UDim2.new(1, -10, 0.5, 0)

		reset.MouseButton1Click:Connect(function()
			curLang = DEFAULTS.UILang
			curBGM = DEFAULTS.VolBGM
			curSE = DEFAULTS.VolSE
			applyUILang(curLang)
			applyVolBGM(curBGM)
			applyVolSE(curSE)
			-- UI å´ã®è¡¨ç¤ºæ›´æ–°ï¼ˆç°¡æ˜“ï¼šé–‰ã˜ã¦é–‹ãç›´ã™ã®ã‚‚å¯ï¼‰
			closeModal()
			task.defer(showSettings)
		end)

		save.MouseButton1Click:Connect(function()
			-- ã„ã¾ã¯ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå±æ€§ã¸ã®ä¿å­˜ã®ã¿ï¼ˆ0.0ã€œ1.0ã§ä¿æŒï¼‰
			applyUILang(curLang)
			applyVolBGM(curBGM)
			applyVolSE(curSE)
			-- å°†æ¥ï¼šRemoteEventã§DataStoreã«æ°¸ç¶šåŒ–ï¼ˆå¿…è¦ãªã‚‰å¾Œã§è¶³ã™ï¼‰
			closeModal()
		end)

		-- åˆæœŸåæ˜ ï¼ˆUIã‚’é–‹ã„ãŸç¬é–“ã«ã‚‚ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼åæ˜ ï¼‰
		applyUILang(curLang)
		applyVolBGM(curBGM)
		applyVolSE(curSE)
	end)
end

-- â˜…æ–°è¦æ©Ÿèƒ½: ã‚·ã‚¹ãƒ†ãƒ ãƒ¡ãƒ‹ãƒ¥ãƒ¼ (2x2ã‚°ãƒªãƒƒãƒ‰)
local function showSystem()
	createModal("ã‚·ã‚¹ãƒ†ãƒ ", function(content)
		-- ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’åŸºæº–ã«ã€2x2ã‚°ãƒªãƒƒãƒ‰ã‚’ä¸­å¤®ã«é…ç½®
		local systemFrame = Instance.new("Frame")
		systemFrame.Size = UDim2.new(1, 0, 1, 0)
		systemFrame.BackgroundTransparency = 1
		systemFrame.Parent = content

		local systemButtons = {
			{ name = "ã‚»ãƒ¼ãƒ–", func = showSaveModal, row = 0, col = 0, color = Color3.fromRGB(46, 204, 113) }, -- ç·‘
			{ name = "ãƒ­ãƒ¼ãƒ‰", func = showLoadModal, row = 0, col = 1, color = Color3.fromRGB(52, 152, 219) }, -- é’
			{ name = "åˆæœŸåŒ–", func = showResetModal, row = 1, col = 0, color = Color3.fromRGB(231, 76, 60) }, -- èµ¤
			{
				name = "ãƒ­ã‚°ã‚¢ã‚¦ãƒˆ",
				func = showLogoutInner,
				row = 1,
				col = 1,
				color = Color3.fromRGB(149, 165, 166),
			}, -- ç°è‰²
		}

		local buttonWidth = 160
		local buttonHeight = 65
		local spacing = 15

		local totalWidth = buttonWidth * 2 + spacing
		local totalHeight = buttonHeight * 2 + spacing

		for _, btnData in ipairs(systemButtons) do
			local button = Instance.new("TextButton")
			button.Name = btnData.name .. "Button"
			button.Size = UDim2.new(0, buttonWidth, 0, buttonHeight)

			-- ã‚°ãƒªãƒƒãƒ‰ã®ä¸­å¿ƒã«é…ç½®ã™ã‚‹ãŸã‚ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆè¨ˆç®—ï¼ˆæ‰‹å‹•èª¿æ•´ãŒå®¹æ˜“ãªã‚ˆã†ã«AnchorPointã‚’ä½¿ç”¨ã—ãªã„ï¼‰
			local gridX = btnData.col * (buttonWidth + spacing)
			local gridY = btnData.row * (buttonHeight + spacing)

			-- AbsoluteSizeã¯å®Ÿè¡Œæ™‚ã«ã—ã‹ç¢ºå®šã—ãªã„ãŸã‚ã€AnchorPoint 0.5ã§ç›¸å¯¾ä½ç½®ã‚’è¨ˆç®—
			button.Position = UDim2.new(0.5, gridX - totalWidth / 2, 0.5, gridY - totalHeight / 2)

			button.BackgroundColor3 = btnData.color
			button.BackgroundTransparency = 0.2
			button.BorderSizePixel = 0
			button.Font = Enum.Font.GothamBold
			button.TextSize = 18
			button.Text = btnData.name
			button.TextColor3 = Color3.new(1, 1, 1)
			button.TextStrokeTransparency = 0.7
			button.ZIndex = 53
			button.Parent = systemFrame

			local corner = Instance.new("UICorner")
			corner.CornerRadius = UDim.new(0, 8)
			corner.Parent = button

			button.MouseButton1Click:Connect(function()
				if not isInBattle then
					-- Systemãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã¦ã‹ã‚‰ã€æ¬¡ã®ãƒ¢ãƒ¼ãƒ€ãƒ«ã¾ãŸã¯ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œ
					-- showLogoutInnerã¯å†…éƒ¨ã§closeModalã‚’å‘¼ã°ãªã„ãŸã‚ã€ã“ã“ã§closeModalã™ã‚‹
					if btnData.name ~= "ãƒ­ã‚°ã‚¢ã‚¦ãƒˆ" and btnData.name ~= "åˆæœŸåŒ–" then
						closeModal()
					end
					btnData.func()
				end
			end)

			button.MouseEnter:Connect(function()
				if not isInBattle then
					button.BackgroundColor3 = btnData.color:Lerp(Color3.new(1, 1, 1), 0.3)
				end
			end)
			button.MouseLeave:Connect(function()
				button.BackgroundColor3 = btnData.color
			end)
		end
	end)
end

-- ãƒ¡ãƒ‹ãƒ¥ãƒ¼UIä½œæˆ
local function createMenuUI()
	menuGui = Instance.new("ScreenGui")
	menuGui.Name = "MenuUI"
	menuGui.ResetOnSpawn = false
	menuGui.Parent = playerGui

	menuFrame = Instance.new("Frame")
	menuFrame.Name = "MenuFrame"
	menuFrame.Size = UDim2.new(0, 250, 0, 120)
	menuFrame.Position = UDim2.new(1, -270, 1, -270)
	menuFrame.BackgroundTransparency = 1
	menuFrame.Parent = menuGui

	local menuButtons = {
		{ name = "ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹", func = showStatus, row = 0, col = 0 },
		{ name = "ã‚¢ã‚¤ãƒ†ãƒ ", func = showItems, row = 0, col = 1 },
		{ name = "ã‚¹ã‚­ãƒ«", func = showSkills, row = 0, col = 2 },
		{ name = "æˆ¦æ­´", func = showRecords, row = 1, col = 0 },
		{ name = "è¨­å®š", func = showSettings, row = 1, col = 1 },
		{ name = "ã‚·ã‚¹ãƒ†ãƒ ", func = showSystem, row = 1, col = 2 }, -- â˜…ä¿®æ­£: ãƒ­ã‚°ã‚¢ã‚¦ãƒˆã‚’ã‚·ã‚¹ãƒ†ãƒ ã«ç½®ãæ›ãˆ
	}

	local buttonWidth = 80
	local buttonHeight = 50
	local spacing = 5

	for _, btnData in ipairs(menuButtons) do
		local button = Instance.new("TextButton")
		button.Name = btnData.name .. "Button"
		button.Size = UDim2.new(0, buttonWidth, 0, buttonHeight)
		button.Position = UDim2.new(0, btnData.col * (buttonWidth + spacing), 0, btnData.row * (buttonHeight + spacing))
		button.BackgroundColor3 = Color3.fromRGB(50, 50, 60)
		button.BackgroundTransparency = 0.2
		button.BorderSizePixel = 0
		button.Font = Enum.Font.GothamBold
		button.TextSize = 14
		button.Text = btnData.name
		button.TextColor3 = Color3.new(1, 1, 1)
		button.TextStrokeTransparency = 0.7
		button.Parent = menuFrame

		local corner = Instance.new("UICorner")
		corner.CornerRadius = UDim.new(0, 8)
		corner.Parent = button

		button.MouseButton1Click:Connect(function()
			if not isInBattle then
				btnData.func()
			end
		end)

		button.MouseEnter:Connect(function()
			if not isInBattle then
				button.BackgroundColor3 = Color3.fromRGB(70, 70, 80)
			end
		end)
		button.MouseLeave:Connect(function()
			button.BackgroundColor3 = Color3.fromRGB(50, 50, 60)
		end)
	end

	log.debugf("ãƒ¡ãƒ‹ãƒ¥ãƒ¼UIä½œæˆå®Œäº†")
end

createMenuUI()

if RequestStatusEvent then
	task.wait(1)
	RequestStatusEvent:FireServer()
end

log.debugf("åˆæœŸåŒ–å®Œäº†")

===== ./StartPlayerScripts/LevelUpUI.client.lua =====
-- StarterPlayer/StarterPlayerScripts/LevelUpUI.client.lua
-- ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—æ¼”å‡º

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

print("[LevelUpUI] åˆæœŸåŒ–ä¸­...")

-- UIè¦ç´ 
local levelUpGui = nil

-- ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—æ¼”å‡ºã‚’è¡¨ç¤º
local function showLevelUp(level, maxHP, speed, attack, defense)
	print(("[LevelUpUI] ========================================"):format())
	print(("[LevelUpUI] ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—æ¼”å‡ºé–‹å§‹ï¼"):format())
	print(("[LevelUpUI] Lv.%d, HP:%d, ç´ æ—©ã•:%d, æ”»æ’ƒ:%d, å®ˆå‚™:%d"):format(
		level, maxHP, speed, attack, defense
		))
	print(("[LevelUpUI] ========================================"):format())

	-- æ—¢å­˜ã®GUIã‚’å‰Šé™¤
	if levelUpGui then
		levelUpGui:Destroy()
	end

	-- æ–°ã—ã„GUIã‚’ä½œæˆ
	levelUpGui = Instance.new("ScreenGui")
	levelUpGui.Name = "LevelUpUI"
	levelUpGui.ResetOnSpawn = false
	levelUpGui.Parent = playerGui

	-- èƒŒæ™¯ï¼ˆæš—ã„ï¼‰
	local background = Instance.new("Frame")
	background.Size = UDim2.fromScale(1, 1)
	background.Position = UDim2.fromScale(0, 0)
	background.BackgroundColor3 = Color3.new(0, 0, 0)
	background.BackgroundTransparency = 1
	background.BorderSizePixel = 0
	background.ZIndex = 100
	background.Parent = levelUpGui

	-- èƒŒæ™¯ã‚’æš—ãã™ã‚‹
	local bgTween = TweenService:Create(background, TweenInfo.new(0.3), {
		BackgroundTransparency = 0.5
	})
	bgTween:Play()

	-- ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ãƒ†ã‚­ã‚¹ãƒˆ
	local levelUpText = Instance.new("TextLabel")
	levelUpText.Size = UDim2.new(0, 600, 0, 100)
	levelUpText.Position = UDim2.new(0.5, -300, 0.35, -50)
	levelUpText.BackgroundTransparency = 1
	levelUpText.TextColor3 = Color3.fromRGB(255, 215, 0)
	levelUpText.TextStrokeTransparency = 0
	levelUpText.TextStrokeColor3 = Color3.new(0, 0, 0)
	levelUpText.Font = Enum.Font.GothamBold
	levelUpText.TextSize = 60
	levelUpText.Text = "LEVEL UP!"
	levelUpText.TextTransparency = 1
	levelUpText.ZIndex = 101
	levelUpText.Parent = levelUpGui

	-- ãƒ†ã‚­ã‚¹ãƒˆã‚’ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
	local textTween = TweenService:Create(levelUpText, TweenInfo.new(0.5), {
		TextTransparency = 0,
		TextStrokeTransparency = 0
	})
	textTween:Play()

	-- ãƒ¬ãƒ™ãƒ«è¡¨ç¤º
	local levelText = Instance.new("TextLabel")
	levelText.Size = UDim2.new(0, 600, 0, 60)
	levelText.Position = UDim2.new(0.5, -300, 0.45, 0)
	levelText.BackgroundTransparency = 1
	levelText.TextColor3 = Color3.fromRGB(255, 255, 255)
	levelText.TextStrokeTransparency = 0
	levelText.Font = Enum.Font.GothamBold
	levelText.TextSize = 40
	levelText.Text = string.format("Level %d", level)
	levelText.TextTransparency = 1
	levelText.ZIndex = 101
	levelText.Parent = levelUpGui

	-- ãƒ¬ãƒ™ãƒ«ãƒ†ã‚­ã‚¹ãƒˆã‚’ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
	local levelTextTween = TweenService:Create(levelText, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0.2), {
		TextTransparency = 0,
		TextStrokeTransparency = 0.5
	})
	levelTextTween:Play()

	-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤ºãƒ•ãƒ¬ãƒ¼ãƒ 
	local statsFrame = Instance.new("Frame")
	statsFrame.Size = UDim2.new(0, 400, 0, 150)
	statsFrame.Position = UDim2.new(0.5, -200, 0.55, 0)
	statsFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
	statsFrame.BackgroundTransparency = 1
	statsFrame.BorderSizePixel = 0
	statsFrame.ZIndex = 101
	statsFrame.Parent = levelUpGui

	-- è§’ã‚’ä¸¸ãã™ã‚‹
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 10)
	corner.Parent = statsFrame

	-- ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
	local frameTween = TweenService:Create(statsFrame, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0.3), {
		BackgroundTransparency = 0.2
	})
	frameTween:Play()

	-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ†ã‚­ã‚¹ãƒˆ
	local statsText = Instance.new("TextLabel")
	statsText.Size = UDim2.new(1, -40, 1, -40)
	statsText.Position = UDim2.new(0, 20, 0, 20)
	statsText.BackgroundTransparency = 1
	statsText.TextColor3 = Color3.fromRGB(200, 255, 200)
	statsText.TextStrokeTransparency = 0.5
	statsText.Font = Enum.Font.Gotham
	statsText.TextSize = 20

	local hpPlus   = (deltas and deltas.hp) or 10
    local spdPlus  = (deltas and deltas.speed) or 2
    local atkPlus  = (deltas and deltas.attack) or 2
    local defPlus  = (deltas and deltas.defense) or 2

    statsText.Text = string.format(
        "HP: %d (+%d)\nç´ æ—©ã•: %d (+%d)\næ”»æ’ƒåŠ›: %d (+%d)\nå®ˆå‚™åŠ›: %d (+%d)",
        maxHP, hpPlus,
        speed, spdPlus,
        attack, atkPlus,
        defense, defPlus
    )

	statsText.TextTransparency = 1
	statsText.TextYAlignment = Enum.TextYAlignment.Top
	statsText.ZIndex = 102
	statsText.Parent = statsFrame

	-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ†ã‚­ã‚¹ãƒˆã‚’ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
	local statsTween = TweenService:Create(statsText, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0.4), {
		TextTransparency = 0,
		TextStrokeTransparency = 0.5
	})
	statsTween:Play()

	-- 2.5ç§’å¾Œã«ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
	task.delay(2.5, function()
		local fadeOutTween = TweenService:Create(background, TweenInfo.new(0.5), {
			BackgroundTransparency = 1
		})
		fadeOutTween:Play()

		TweenService:Create(levelUpText, TweenInfo.new(0.5), {
			TextTransparency = 1,
			TextStrokeTransparency = 1
		}):Play()

		TweenService:Create(levelText, TweenInfo.new(0.5), {
			TextTransparency = 1,
			TextStrokeTransparency = 1
		}):Play()

		TweenService:Create(statsFrame, TweenInfo.new(0.5), {
			BackgroundTransparency = 1
		}):Play()

		TweenService:Create(statsText, TweenInfo.new(0.5), {
			TextTransparency = 1,
			TextStrokeTransparency = 1
		}):Play()

		-- 3ç§’å¾Œã«å‰Šé™¤
		task.wait(0.5)
		if levelUpGui then
			levelUpGui:Destroy()
			levelUpGui = nil
		end
	end)
end

-- RemoteEventã‚’å¾…æ©Ÿ
local LevelUpEvent = ReplicatedStorage:WaitForChild("LevelUp", 10)
if LevelUpEvent then
	LevelUpEvent.OnClientEvent:Connect(showLevelUp)
	print("[LevelUpUI] LevelUpã‚¤ãƒ™ãƒ³ãƒˆæ¥ç¶šå®Œäº†")
else
	warn("[LevelUpUI] LevelUpã‚¤ãƒ™ãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
end

print("[LevelUpUI] åˆæœŸåŒ–å®Œäº†")
===== ./StartPlayerScripts/BattleUI.client.lua =====
-- StarterPlayer/StarterPlayerScripts/BattleUI.client.lua
-- ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ãƒãƒˆãƒ«UIåˆ¶å¾¡ï¼ˆã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ï¼‰
local Logger = require(game.ReplicatedStorage.Util.Logger)
local log = Logger.get("BattleUI") -- ãƒ•ã‚¡ã‚¤ãƒ«åãªã©ã‚’ã‚¿ã‚°ã«

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local StarterGui = game:GetService("StarterGui")
local ContextActionService = game:GetService("ContextActionService")
local LocalizationService = game:GetService("LocalizationService")
local BattleDamageEvent = ReplicatedStorage:WaitForChild("BattleDamage")

local Labels = require(ReplicatedStorage.Typing.CategoryLabels)
local TypingWords = require(ReplicatedStorage.Typing.TypingWords)
local renderCategory

local UI_READY = false
local PENDING_ENTRY = nil

local Labels = require(ReplicatedStorage.Typing.CategoryLabels)

local renderCategory

local wordFrame = nil
local wordLabel = nil

-- è¡¨ç¤ºè¨€èªï¼ˆã“ã®å¡Šã§1å›ã ã‘å®šç¾©ï¼‰
local LANG = "ja"

-- ã‚«ãƒ©ãƒ¼å®šç¾©
local CATEGORY_STYLE = {
	n = { bg = Color3.fromRGB(54, 118, 255), text = Color3.fromRGB(255, 255, 255) }, -- åè©: é’
	v = { bg = Color3.fromRGB(68, 201, 91), text = Color3.fromRGB(0, 24, 0) }, -- å‹•è©: ç·‘
	a = { bg = Color3.fromRGB(255, 149, 0), text = Color3.fromRGB(40, 16, 0) }, -- å½¢å®¹è©: æ©™
	o = { bg = Color3.fromRGB(120, 120, 120), text = Color3.fromRGB(255, 255, 255) }, -- ãã®ä»–: ç°
}
local DEFAULT_STYLE = { bg = Color3.fromRGB(240, 240, 240), text = Color3.fromRGB(20, 20, 20) }

-- è¨€èªåˆ‡æ›¿
local function setLang(lang)
	lang = tostring(lang or ""):lower()
	if Labels[lang] then
		LANG = lang
	else
		LANG = "ja"
	end
end

local function getTranslation(entry, lang)
	if not entry then
		return ""
	end
	lang = (lang or LANG)
	return entry[lang] or entry.ja or entry.es or entry.fr or entry.de or entry.tl or ""
end

-- èµ·å‹•æ™‚ã«ä¸€åº¦é©ç”¨ï¼ˆlocaleCode ã¯æ—¢å­˜ã®å¤‰æ•°ã‚’åˆ©ç”¨ï¼‰
-- setLang(Players.LocalPlayer:GetAttribute("UILang") or localeCode)
setLang(Players.LocalPlayer:GetAttribute("UILang") or "fr")

-- å±æ€§å¤‰åŒ–ã§å†æç”»
Players.LocalPlayer:GetAttributeChangedSignal("UILang"):Connect(function()
	setLang(Players.LocalPlayer:GetAttribute("UILang"))
	if wordFrame and currentWordData then
		renderCategory(wordFrame, currentWordData)
	end
	if translationLabel and currentWordData then
		translationLabel.Text = getTranslation(currentWordData, LANG)
		translationLabel.Visible = translationLabel.Text ~= ""
	end
end)

local function showWord(entry)
	log.debug(
		("[showWord] entry=%s UI_READY=%s wf=%s wl=%s"):format(
			entry and entry.word or "nil",
			tostring(UI_READY),
			tostring(wordFrame),
			tostring(wordLabel)
		)
	)
	if not entry then
		return
	end
	if not UI_READY or not (wordFrame and wordLabel) then
		PENDING_ENTRY = entry
		return
	end
	wordLabel.Text = entry.word

	-- â˜… å®‰å…¨ã‚¬ãƒ¼ãƒ‰ï¼ˆnil ãªã‚‰å‘¼ã°ãªã„ï¼‰
	local f = renderCategory
	if type(f) == "function" then
		f(wordFrame, entry)
	else
		warn("[BattleUI] renderCategory is nil (not assigned yet). Check forward declaration / duplicate locals.")
	end
end

-- ãƒãƒƒã‚¸ç”Ÿæˆï¼ˆæ§ãˆã‚ãƒ‡ã‚¶ã‚¤ãƒ³ï¼‰
local function ensureCategoryBadge(parentFrame: Frame?)
	if not parentFrame then
		return nil
	end
	local badge = parentFrame:FindFirstChild("CategoryBadge")
	if not badge then
		badge = Instance.new("TextLabel")
		badge.Name = "CategoryBadge"
		badge.AnchorPoint = Vector2.new(0, 0)
		badge.Position = UDim2.fromOffset(8, 6)
		badge.Size = UDim2.new(0, 0, 0, 0)
		badge.AutomaticSize = Enum.AutomaticSize.XY
		badge.BackgroundTransparency = 0.15
		badge.BackgroundColor3 = DEFAULT_STYLE.bg
		badge.TextColor3 = DEFAULT_STYLE.text
		badge.Font = Enum.Font.GothamSemibold
		badge.TextSize = 22
		badge.TextXAlignment = Enum.TextXAlignment.Left
		badge.TextYAlignment = Enum.TextYAlignment.Top
		badge.BorderSizePixel = 0
		badge.ZIndex = (parentFrame.ZIndex or 1) + 2

		local corner = Instance.new("UICorner")
		corner.CornerRadius = UDim.new(0, 6)
		corner.Parent = badge

		local stroke = Instance.new("UIStroke")
		stroke.Thickness = 1.25
		stroke.Transparency = 0.4
		stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
		stroke.Parent = badge

		local pad = Instance.new("UIPadding")
		pad.PaddingTop = UDim.new(0, 6)
		pad.PaddingBottom = UDim.new(0, 6)
		pad.PaddingLeft = UDim.new(0, 10)
		pad.PaddingRight = UDim.new(0, 10)
		pad.Parent = badge

		badge.Parent = parentFrame
	end
	return badge
end

-- æ–‡è¨€ç”Ÿæˆï¼ˆ[åè©] ç”Ÿãç‰©ï¼‰
local function buildCategoryText(entry, lang)
	if not entry then
		return ""
	end
	local L = Labels[lang] or Labels.ja
	local c1 = entry.category1 and (L[entry.category1] or entry.category1) or ""
	local c2 = (entry.category2 and entry.category2[lang]) or ""
	if c1 ~= "" and c2 ~= "" then
		return string.format("[%s] %s", c1, c2)
	elseif c1 ~= "" then
		return string.format("[%s]", c1)
	else
		return c2 or ""
	end
end

-- åæ˜ 
renderCategory = function(frame: Frame?, entry: table)
	if not frame or not entry then
		return
	end
	local badge = ensureCategoryBadge(frame)
	if not badge then
		return
	end

	local text = buildCategoryText(entry, LANG)
	badge.Text = text or ""
	badge.Visible = (badge.Text ~= "")

	local style = CATEGORY_STYLE[entry.category1] or DEFAULT_STYLE
	badge.BackgroundColor3 = style.bg
	badge.TextColor3 = style.text
end
-- === ã‚«ãƒ†ã‚´ãƒªè¡¨ç¤ºï¼šæº–å‚™ã“ã“ã¾ã§ ===

-- åŠ¹æœéŸ³ã®å–ã‚Šã“ã¼ã—ã‚’æˆ¦é—˜é–‹å§‹æ™‚ã«å†è§£æ±ºã™ã‚‹ä¿é™º
if not resolveSoundsIfNeeded then
	function resolveSoundsIfNeeded()
		local s = ReplicatedStorage:FindFirstChild("Sounds")
		if not s then
			return
		end
		if not TypingCorrectSound or not TypingCorrectSound.Parent then
			TypingCorrectSound = s:FindFirstChild("TypingCorrect")
		end
		if not TypingErrorSound or not TypingErrorSound.Parent then
			TypingErrorSound = s:FindFirstChild("TypingError")
		end
		if not EnemyHitSound or not EnemyHitSound.Parent then
			EnemyHitSound = s:FindFirstChild("EnemyHit")
		end
	end
end

local countdownFrame: Frame? = nil
local countdownLabel: TextLabel? = nil

local function runCountdown(seconds: number)
	if not countdownFrame or not countdownLabel then
		return
	end
	countdownFrame.Visible = true
	for n = seconds, 1, -1 do
		countdownLabel.Text = tostring(n)
		-- ç°¡å˜ãªæ¼”å‡º
		countdownLabel.TextTransparency = 0
		game:GetService("TweenService"):Create(countdownLabel, TweenInfo.new(0.25), { TextTransparency = 0 }):Play()
		task.wait(1)
	end
	countdownFrame.Visible = false
end

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")
local enemyProgContainer = nil
local enemyProgFill = nil
local enemyProgConn = nil

local pendingCyclePayload = nil -- { intervalSec=..., startedAt=... }
local progressStartedOnce = false -- ä¸€åº¦ã§ã‚‚ startEnemyProgress ã‚’å‘¼ã‚“ã ã‹

-- === æ”»æ’ƒãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ã®èµ·å‹•æŒ™å‹• ===
local PROGRESS_COUNTDOWN_ON_START = false -- trueã§3,2,1ã®ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³å¾Œã«é–‹å§‹
local COUNTDOWN_SECONDS = 3
local DEFAULT_FIRST_INTERVAL = 4 -- ã‚µãƒ¼ãƒãƒ¼ãŒæ¥ã‚‹ã¾ã§ã®ä»®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«(ç§’)

-- === å…±é€šãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆå®šæ•°ï¼ˆæ¨ªå¹…ã‚’æƒãˆã‚‹ï¼‰ ===
local STACK_WIDTH = 700 -- 3ã¤ã®æ¨ªå¹…ã‚’çµ±ä¸€ï¼ˆWordFrame ã®å¹…ã¨åŒã˜ï¼‰
local WORD_H = 150
local HP_BAR_H = 40
local PROG_H = 14
local STACK_PAD = 10 -- ç¸¦ã®éš™é–“

-- ========= äºˆçŸ¥ï¼ˆæ¬¡å˜èªã®å…ˆè¡Œæç”»ï¼‰è¨­å®š =========
local PRECOGNITION_ENABLED = false -- ãƒ‡ãƒ•ã‚©ã¯OFFï¼ˆæ‰‹å‹•ã‚¹ã‚¤ãƒƒãƒï¼‰
local function hasPrecog()
	-- æ‰‹å‹•ã‚¹ã‚¤ãƒƒãƒ or æŒ‡è¼ªè£…å‚™ã§ä»˜ä¸ã•ã‚Œã‚‹å±æ€§ï¼ˆã‚µãƒ¼ãƒå´ã‹ã‚‰SetAttributeæƒ³å®šï¼‰
	return PRECOGNITION_ENABLED or (Players.LocalPlayer:GetAttribute("HasPrecognition") == true)
end

-- äºˆçŸ¥UIï¼ãƒ‡ãƒ¼ã‚¿ï¼ˆä»–ã®é–¢æ•°ã‹ã‚‰å‚ç…§ã™ã‚‹ã®ã§å…ˆã«å®£è¨€ï¼‰
local wordLabelNext = nil
local precogNextWordData = nil -- æ¬¡ã«æ¥ã‚‹â€œäºˆç´„â€å˜èª
local function hasPrecog()
	return true -- äºˆçŸ¥ãƒ¯ãƒ¼ãƒ‰è¡¨ç¤ºãƒ•ãƒ©ã‚°
end

local enemyProgConn = nil

local function stopEnemyProgress()
	if enemyProgConn then
		enemyProgConn:Disconnect()
		enemyProgConn = nil
	end
	if enemyProgFill then
		enemyProgFill.Size = UDim2.new(0, 0, 1, 0)
	end
	if enemyProgContainer then
		enemyProgContainer.Visible = false
	end
	log.debug("[BattleUI] stopEnemyProgress: disconnected & hidden")
end

local function startEnemyProgress(durationSec: number, startedAtServer: number?)
	log.debugf(
		("[BattleUI] startEnemyProgress ENTER (dur=%.2f, startedAtServer=%s)"):format(
			tonumber(durationSec) or -1,
			tostring(startedAtServer)
		)
	)

	if not enemyProgContainer or not enemyProgFill then
		log.warn("[BattleUI] progress UI not ready; skip startEnemyProgress")
		return
	end

	enemyProgContainer.Visible = true
	enemyProgFill.Size = UDim2.new(0, 0, 1, 0)

	if enemyProgConn then
		enemyProgConn:Disconnect()
		enemyProgConn = nil
	end

	local startedAt = tonumber(startedAtServer) or tick()
	enemyProgConn = game:GetService("RunService").RenderStepped:Connect(function()
		local estT = math.clamp((tick() - startedAt) / durationSec, 0, 1)
		enemyProgFill.Size = UDim2.new(estT, 0, 1, 0)
		if estT >= 1 then
			enemyProgConn:Disconnect()
			enemyProgConn = nil
		end
	end)
end

local function applyEnemyCycle(payload)
	if not payload then
		return
	end
	local duration = tonumber(payload.intervalSec) or DEFAULT_FIRST_INTERVAL
	local startedAt = tonumber(payload.startedAt)

	log.debugf(("[BattleUI] sync interval=%.2f startedAt=%.3f"):format(duration, startedAt or -1))
	startEnemyProgress(duration, startedAt)
	-- â˜… åŒæœŸå—ä¿¡æ™‚åˆ»ã‚’ tick() åŸºæº–ã§è¨˜éŒ²ï¼ˆã‚¦ã‚©ãƒƒãƒãƒ‰ãƒƒã‚°ã¨åŒä¸€åŸºæº–ï¼‰
	lastCycleAt = tick()
end

-- å…¥åŠ›åˆ¶å¾¡ï¼ˆã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³ä¸­ã¯ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ç„¡åŠ¹ï¼‰
local TypingEnabled = true

log.debug("[BattleUI] ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆèµ·å‹•ä¸­...")

-- ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒ­ã‚±ãƒ¼ãƒ«ã‚’å–å¾—
local userLocale = string.lower(LocalizationService.RobloxLocaleId)
local localeCode = string.match(userLocale, "^(%a+)") or "en" -- "ja-jp" â†’ "ja"

-- ã€é–‹ç™ºç”¨ã€‘å¼·åˆ¶çš„ã«æ—¥æœ¬èªè¡¨ç¤ºï¼ˆæœ¬ç•ªã§ã¯å‰Šé™¤å¯èƒ½ï¼‰
local FORCE_LOCALE = "ja" -- ã“ã“ã‚’å¤‰æ›´ã™ã‚‹ã¨è¡¨ç¤ºè¨€èªãŒå¤‰ã‚ã‚‹ï¼ˆnil ã§è‡ªå‹•æ¤œå‡ºï¼‰
if FORCE_LOCALE then
	localeCode = FORCE_LOCALE
	log.debugf(("[BattleUI] è¨€èªã‚’å¼·åˆ¶è¨­å®š: %s"):format(localeCode))
end

log.debugf(("[BattleUI] ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ã‚±ãƒ¼ãƒ«: %s â†’ è¡¨ç¤ºè¨€èª: %s"):format(userLocale, localeCode))

local RunService = game:GetService("RunService")

-- ã‚µã‚¤ã‚¯ãƒ«ã®å†åŒæœŸè¦æ±‚ã‚¤ãƒ™ãƒ³ãƒˆ
local RequestEnemyCycleSyncEvent = ReplicatedStorage:WaitForChild("RequestEnemyCycleSync", 10)

-- æœ€å¾Œã«ã‚µã‚¤ã‚¯ãƒ«åŒæœŸã‚’å—ä¿¡ã—ãŸæ™‚åˆ»ï¼ˆsecï¼‰
local lastCycleAt = 0

-- ã‚µãƒ¼ãƒãƒ¼ã«å†åŒæœŸã‚’è¦æ±‚
local function requestEnemyCycleSync(reason: string?)
	if not inBattle then
		return
	end
	if not RequestEnemyCycleSyncEvent then
		return
	end
	RequestEnemyCycleSyncEvent:FireServer()
end

if not BattleStartEvent or not BattleEndEvent or not BattleDamageEvent then
	warn("[BattleUI] RemoteEventã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ")
end

-- å˜èªãƒªã‚¹ãƒˆã‚’èª­ã¿è¾¼ã¿
-- local TypingWords = require(ReplicatedStorage:WaitForChild("TypingWords"))
local TypingFolder = ReplicatedStorage:WaitForChild("Typing", 30)
local TypingWords = require(TypingFolder:WaitForChild("TypingWords", 30))

-- ãƒ‡ãƒãƒƒã‚°ï¼šå˜èªãƒªã‚¹ãƒˆã®å†…å®¹ã‚’ç¢ºèª
log.debug("[BattleUI DEBUG] TypingWords.level_1[1]:")
if TypingWords.level_1 and TypingWords.level_1[1] then
	local firstWord = TypingWords.level_1[1]
	log.debug("  Type:", type(firstWord))
	if type(firstWord) == "table" then
		log.debug("  word:", firstWord.word)
		log.debug("  ja:", firstWord.ja)
	else
		log.debug("  Value:", firstWord)
	end
end

log.debug("[BattleUI] RemoteEventså–å¾—å®Œäº†")

-- çŠ¶æ…‹
local inBattle = false
local currentWord = ""
local currentWordData = nil -- ç¿»è¨³ãƒ‡ãƒ¼ã‚¿ã‚’å«ã‚€å˜èªæƒ…å ±
local lastWord = nil -- å‰å›ã®å˜èªï¼ˆé€£ç¶šå›é¿ç”¨ï¼‰
local currentIndex = 1
local typingLevels = {}
local currentBattleTimeout = nil
local monsterHP = 0
local monsterMaxHP = 0
local playerHP = 0 -- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç¾åœ¨HP
local playerMaxHP = 0 -- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æœ€å¤§HP
local damagePerKey = 1

-- ã‚«ãƒ¡ãƒ©è¨­å®šä¿å­˜ç”¨
local originalCameraMaxZoom = nil
local originalCameraMinZoom = nil

-- UIè¦ç´ 
local battleGui = nil
local darkenFrame = nil
-- local wordFrame = nil
-- local wordLabel = nil
local translationLabel = nil -- ç¿»è¨³è¡¨ç¤ºç”¨
local hpBarBackground = nil
local hpBarFill = nil
local hpLabel = nil

-- ã‚·ã‚¹ãƒ†ãƒ ã‚­ãƒ¼ã‚’ãƒ–ãƒ­ãƒƒã‚¯ã™ã‚‹é–¢æ•°
local function blockSystemKeys()
	-- ã‚«ãƒ¡ãƒ©ã‚ºãƒ¼ãƒ ã‚’å®Œå…¨ã«å›ºå®š
	originalCameraMaxZoom = player.CameraMaxZoomDistance
	originalCameraMinZoom = player.CameraMinZoomDistance

	-- ç¾åœ¨ã®ã‚ºãƒ¼ãƒ è·é›¢ã‚’å–å¾—ã—ã¦å›ºå®š
	local camera = workspace.CurrentCamera
	local currentZoom = (camera.CFrame.Position - player.Character.HumanoidRootPart.Position).Magnitude
	player.CameraMaxZoomDistance = currentZoom
	player.CameraMinZoomDistance = currentZoom
end

-- ãƒ–ãƒ­ãƒƒã‚¯è§£é™¤
local function unblockSystemKeys()
	-- ã‚«ãƒ¡ãƒ©ã‚ºãƒ¼ãƒ ã‚’å¾©å…ƒ
	if originalCameraMaxZoom and originalCameraMinZoom then
		player.CameraMaxZoomDistance = originalCameraMaxZoom
		player.CameraMinZoomDistance = originalCameraMinZoom
	end
end

-- ã€forward declarationã€‘
local onBattleEnd
local updateDisplay
local setNextWord
local startEnemyProgress
local stopEnemyProgress
local playHitFlash

-- HPãƒãƒ¼ã®è‰²ã‚’å–å¾—ï¼ˆHPå‰²åˆã«å¿œã˜ã¦å¤‰åŒ–ï¼‰
local function getHPColor(hpPercent)
	if hpPercent > 0.6 then
		-- ç·‘
		return Color3.fromRGB(46, 204, 113)
	elseif hpPercent > 0.3 then
		-- é»„è‰²
		return Color3.fromRGB(241, 196, 15)
	else
		-- èµ¤
		return Color3.fromRGB(231, 76, 60)
	end
end

-- è¡¨ç¤ºã‚’æ›´æ–°
updateDisplay = function()
	if not wordLabel then
		return
	end

	-- å…¥åŠ›æ¸ˆã¿æ–‡å­—ã‚’ç·‘ã€æœªå…¥åŠ›ã‚’ç™½ã§è¡¨ç¤º
	local typedPart = string.sub(currentWord, 1, currentIndex - 1)
	local remainingPart = string.sub(currentWord, currentIndex)

	wordLabel.Text = string.format('<font color="#00FF00">%s</font>%s', typedPart, remainingPart)

	-- æ•µHPãƒãƒ¼æ›´æ–°
	if hpBarFill and hpLabel then
		local hpPercent = monsterHP / monsterMaxHP

		-- ãƒãƒ¼ã®é•·ã•ã‚’ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
		local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
		local tween = TweenService:Create(hpBarFill, tweenInfo, {
			Size = UDim2.new(hpPercent, 0, 1, 0),
		})
		tween:Play()

		-- è‰²ã‚’å¤‰æ›´
		hpBarFill.BackgroundColor3 = getHPColor(hpPercent)

		-- ãƒ†ã‚­ã‚¹ãƒˆæ›´æ–°
		hpLabel.Text = string.format("Enemy HP: %d / %d", monsterHP, monsterMaxHP)
	end
end

-- å˜èªã‚’é¸æŠã™ã‚‹é–¢æ•°
local function selectWord()
	if #typingLevels == 0 then
		-- ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼šlevel_1ã®ã¿
		typingLevels = { { level = "level_1", weight = 100 } }
	end

	-- é‡ã¿ä»˜ããƒ©ãƒ³ãƒ€ãƒ é¸æŠ
	local totalWeight = 0
	for _, config in ipairs(typingLevels) do
		totalWeight = totalWeight + config.weight
	end

	local randomValue = math.random(1, totalWeight)
	local cumulativeWeight = 0
	local selectedLevel = "level_1"

	for _, config in ipairs(typingLevels) do
		cumulativeWeight = cumulativeWeight + config.weight
		if randomValue <= cumulativeWeight then
			selectedLevel = config.level
			break
		end
	end

	-- é¸æŠã•ã‚ŒãŸãƒ¬ãƒ™ãƒ«ã‹ã‚‰å˜èªã‚’å–å¾—
	local wordList = TypingWords[selectedLevel]
	if wordList and #wordList > 0 then
		-- å‰å›ã¨åŒã˜å˜èªã‚’é¿ã‘ã‚‹ï¼ˆæœ€å¤§5å›ã¾ã§å†æŠ½é¸ï¼‰
		local wordData = nil
		local attempts = 0

		repeat
			wordData = wordList[math.random(1, #wordList)]
			attempts = attempts + 1

			-- æ–°å½¢å¼ï¼ˆãƒ†ãƒ¼ãƒ–ãƒ«ï¼‰ã‹æ—§å½¢å¼ï¼ˆæ–‡å­—åˆ—ï¼‰ã‹åˆ¤å®š
			local currentWordStr = type(wordData) == "table" and wordData.word or wordData

			-- å‰å›ã¨é•ã†å˜èªãŒå‡ºãŸã‚‰ã€ã¾ãŸã¯5å›è©¦ã—ãŸã‚‰ãƒ«ãƒ¼ãƒ—çµ‚äº†
			if currentWordStr ~= lastWord or attempts >= 5 or #wordList == 1 then
				break
			end
		until false

		-- æ–°å½¢å¼ï¼ˆãƒ†ãƒ¼ãƒ–ãƒ«ï¼‰ã‹æ—§å½¢å¼ï¼ˆæ–‡å­—åˆ—ï¼‰ã‹åˆ¤å®š
		if type(wordData) == "table" then
			return wordData
		else
			-- æ—§å½¢å¼ã®å ´åˆã¯äº’æ›æ€§ã®ãŸã‚ãƒ†ãƒ¼ãƒ–ãƒ«ã«å¤‰æ›
			return { word = wordData }
		end
	else
		return { word = "apple", ja = "ã‚Šã‚“ã”" } -- ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
	end
end

-- äºˆçŸ¥UIã®æ›´æ–°
local function refreshPrecogUI()
	if not wordLabelNext then
		return
	end
	if hasPrecog() and precogNextWordData and precogNextWordData.word then
		wordLabelNext.Text = "æ¬¡: " .. tostring(precogNextWordData.word)
		wordLabelNext.Visible = true
	else
		wordLabelNext.Visible = false
		wordLabelNext.Text = ""
	end
end

-- â€œcurrentWordDataâ€ã¨ã¯åˆ¥ã«ã€æ¬¡ã®äºˆç´„å˜èªã‚’ç”¨æ„ï¼ˆé€£ç¶šå›é¿ã‚‚è€ƒæ…®ï¼‰
local function rollNextPrecogWord()
	local tries = 0
	local candidate
	repeat
		candidate = selectWord()
		tries += 1
	-- ç›´å‰ã¨åŒã˜ã¯é¿ã‘ã‚‹ï¼ˆæœ€å¤§5å›ã¾ã§ï¼‰
	until (not currentWordData or candidate.word ~= currentWordData.word) or tries >= 5
	precogNextWordData = candidate
	refreshPrecogUI()
end

-- æ¬¡ã®å˜èªã‚’è¨­å®šï¼ˆäºˆçŸ¥ã«å¯¾å¿œï¼‰
-- å¼•æ•° nextData ã¯ä»»æ„ã€‚ä¸ãˆãªã‘ã‚Œã°å¾“æ¥ã©ãŠã‚Šãƒ©ãƒ³ãƒ€ãƒ é¸æŠã€‚
setNextWord = function(nextData)
	-- 1) ä»Šå›å‡ºã™å˜èªã‚’æ±ºå®šï¼ˆå¤–éƒ¨æŒ‡å®šãŒç„¡ã‘ã‚Œã°å¾“æ¥ã® selectWord()ï¼‰
	currentWordData = nextData or selectWord()
	currentWord = currentWordData.word
	currentIndex = 1
	lastWord = currentWord

	log.debug(("[setNextWord] choose=%s"):format(currentWordData.word))
	showWord(currentWordData)
	log.debug("[setNextWord] after showWord")

	-- 2) ç¿»è¨³è¡¨ç¤ºï¼ˆå¾“æ¥ã©ãŠã‚Šï¼‰
	if translationLabel then
		local translation = getTranslation(currentWordData, LANG)
		translationLabel.Text = translation
		translationLabel.Visible = translation ~= ""
	end

	-- 3) è¡¨ç¤ºæ›´æ–°ï¼ˆå¾“æ¥ã©ãŠã‚Šï¼‰
	updateDisplay()

	-- 4) äºˆçŸ¥ï¼ˆå…ˆè¡Œæç”»ï¼‰
	if hasPrecog() then
		-- ã¾ã äºˆç´„ãŒç„¡ã„/å¤ã„å ´åˆã¯æ–°ã—ãå¼•ã„ã¦ãŠã
		if not precogNextWordData then
			-- é€£ç¶šåŒä¸€å˜èªã‚’é¿ã‘ã¦1å›å¼•ãï¼ˆå¿…è¦ãªã‚‰å†æŠ½é¸ãƒ­ã‚¸ãƒƒã‚¯ã‚’è¶³ã—ã¦OKï¼‰
			local candidate = selectWord()
			if candidate and candidate.word == currentWord and #typingLevels > 0 then
				-- åŒä¸€å›é¿ã®ç°¡æ˜“ãƒªãƒˆãƒ©ã‚¤
				candidate = selectWord()
			end
			precogNextWordData = candidate
		end

		-- å…ˆè¡ŒUIã‚’å‡ºã™
		if wordLabelNext then
			local previewWord = precogNextWordData and precogNextWordData.word or ""
			wordLabelNext.Visible = previewWord ~= ""
			wordLabelNext.Text = ("Next: %s"):format(previewWord)
		end
	else
		-- OFFï¼šéè¡¨ç¤ºï¼†äºˆç´„ã‚¯ãƒªã‚¢ï¼ˆå¥½ã¿ã§æ®‹ã—ã¦ã‚‚è‰¯ã„ï¼‰
		precogNextWordData = nil
		if wordLabelNext then
			wordLabelNext.Visible = false
		end
	end
end

-- UIä½œæˆ
local function createBattleUI()
	battleGui = Instance.new("ScreenGui")
	battleGui.Name = "BattleUI"
	battleGui.ResetOnSpawn = false
	battleGui.Enabled = false
	battleGui.Parent = playerGui

	-- ä¸­å¤®ã®ç¸¦ã‚¹ã‚¿ãƒƒã‚¯ï¼ˆå¹…ã‚’çµ±ä¸€ï¼‰
	local centerStack = Instance.new("Frame")
	centerStack.Name = "CenterStack"
	centerStack.AnchorPoint = Vector2.new(0.5, 0.5)
	centerStack.Position = UDim2.new(0.5, 0, 0.5, 0)
	centerStack.Size = UDim2.new(0, STACK_WIDTH, 0, WORD_H + HP_BAR_H + PROG_H + (STACK_PAD * 2))
	centerStack.BackgroundTransparency = 1
	centerStack.BorderSizePixel = 0
	centerStack.ZIndex = 1
	centerStack.Parent = battleGui

	local stackLayout = Instance.new("UIListLayout")
	stackLayout.FillDirection = Enum.FillDirection.Vertical
	stackLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	stackLayout.VerticalAlignment = Enum.VerticalAlignment.Center
	stackLayout.Padding = UDim.new(0, STACK_PAD)
	stackLayout.SortOrder = Enum.SortOrder.LayoutOrder
	stackLayout.Parent = centerStack

	-- æš—è»¢ç”¨ãƒ•ãƒ¬ãƒ¼ãƒ 
	darkenFrame = Instance.new("Frame")
	darkenFrame.Name = "DarkenFrame"
	darkenFrame.Size = UDim2.fromScale(1, 1)
	darkenFrame.Position = UDim2.fromScale(0, 0)
	darkenFrame.BackgroundColor3 = Color3.new(0, 0, 0)
	darkenFrame.BackgroundTransparency = 1
	darkenFrame.BorderSizePixel = 0
	darkenFrame.ZIndex = 1
	darkenFrame.Parent = battleGui

	-- æ•µHPãƒãƒ¼èƒŒæ™¯
	hpBarBackground = Instance.new("Frame")
	hpBarBackground.Name = "HPBarBackground"
	hpBarBackground.Size = UDim2.new(1, 0, 0, HP_BAR_H)
	hpBarBackground.Position = UDim2.new(0.5, -250, 0.25, 0)
	hpBarBackground.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
	hpBarBackground.BorderSizePixel = 0
	hpBarBackground.ZIndex = 2
	hpBarBackground.Parent = centerStack

	-- HPãƒãƒ¼èƒŒæ™¯ã®è§’ã‚’ä¸¸ãã™ã‚‹
	local hpBarCorner = Instance.new("UICorner")
	hpBarCorner.CornerRadius = UDim.new(0, 8)
	hpBarCorner.Parent = hpBarBackground

	-- HPãƒãƒ¼ï¼ˆå¡—ã‚Šã¤ã¶ã—éƒ¨åˆ†ï¼‰
	hpBarFill = Instance.new("Frame")
	hpBarFill.Name = "HPBarFill"
	hpBarFill.Size = UDim2.new(1, 0, 1, 0)
	hpBarFill.Position = UDim2.new(0, 0, 0, 0)
	hpBarFill.BackgroundColor3 = Color3.fromRGB(46, 204, 113)
	hpBarFill.BorderSizePixel = 0
	hpBarFill.ZIndex = 3
	hpBarFill.Parent = hpBarBackground

	-- HPãƒãƒ¼ã®è§’ã‚’ä¸¸ãã™ã‚‹
	local hpFillCorner = Instance.new("UICorner")
	hpFillCorner.CornerRadius = UDim.new(0, 8)
	hpFillCorner.Parent = hpBarFill

	-- HPãƒ†ã‚­ã‚¹ãƒˆï¼ˆãƒãƒ¼ã®ä¸Šã«è¡¨ç¤ºï¼‰
	hpLabel = Instance.new("TextLabel")
	hpLabel.Name = "HPLabel"
	hpLabel.Size = UDim2.new(1, 0, 1, 0)
	hpLabel.Position = UDim2.new(0, 0, 0, 0)
	hpLabel.BackgroundTransparency = 1
	hpLabel.TextColor3 = Color3.new(1, 1, 1)
	hpLabel.TextStrokeTransparency = 0.5
	hpLabel.Font = Enum.Font.GothamBold
	hpLabel.TextSize = 20
	hpLabel.Text = "HP: 10 / 10"
	hpLabel.ZIndex = 4
	hpLabel.Parent = hpBarBackground

	-- å˜èªè¡¨ç¤ºç”¨ãƒ•ãƒ¬ãƒ¼ãƒ ï¼ˆæ ï¼‰
	wordFrame = Instance.new("Frame")
	wordFrame.Name = "WordFrame"
	wordFrame.Size = UDim2.new(1, 0, 0, WORD_H)
	wordFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
	wordFrame.BorderSizePixel = 3
	wordFrame.BorderColor3 = Color3.fromRGB(100, 200, 255)
	wordFrame.ZIndex = 2
	wordFrame.Parent = centerStack

	-- æ ã®è§’ã‚’ä¸¸ãã™ã‚‹
	local wordFrameCorner = Instance.new("UICorner")
	wordFrameCorner.CornerRadius = UDim.new(0, 12)
	wordFrameCorner.Parent = wordFrame

	-- æ ã«å…‰ã‚‹ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆUIStrokeï¼‰
	local wordFrameStroke = Instance.new("UIStroke")
	wordFrameStroke.Color = Color3.fromRGB(100, 200, 255)
	wordFrameStroke.Thickness = 3
	wordFrameStroke.Transparency = 0
	wordFrameStroke.Parent = wordFrame

	-- â˜… äºˆçŸ¥ç”¨ã®ã‚´ãƒ¼ã‚¹ãƒˆãƒ©ãƒ™ãƒ«ï¼ˆWordFrameã®å³ä¸‹ï¼å°ã•ã‚ï¼‰
	wordLabelNext = Instance.new("TextLabel")
	wordLabelNext.Name = "NextWordHint"
	wordLabelNext.BackgroundTransparency = 1
	wordLabelNext.Size = UDim2.new(1, -40, 0, 24) -- æ å†…ã„ã£ã±ã„ã€å·¦å³20pxä½™ç™½
	wordLabelNext.Position = UDim2.new(0, 20, 0, 6) -- æ ã®ä¸Šå´ã«å°ã•ãè¡¨ç¤º
	wordLabelNext.Font = Enum.Font.Gotham
	wordLabelNext.TextSize = 22
	wordLabelNext.TextColor3 = Color3.fromRGB(180, 190, 220)
	wordLabelNext.TextStrokeTransparency = 0.8
	wordLabelNext.TextXAlignment = Enum.TextXAlignment.Right
	wordLabelNext.ZIndex = (wordLabel and wordLabel.ZIndex or 3) + 1
	wordLabelNext.Text = ""
	wordLabelNext.Visible = false
	wordLabelNext.Parent = wordFrame

	-- å˜èªè¡¨ç¤ºï¼ˆRichTextå¯¾å¿œï¼‰
	wordLabel = Instance.new("TextLabel")
	wordLabel.Name = "WordLabel"
	wordLabel.Size = UDim2.new(1, -40, 0.6, 0)
	wordLabel.Position = UDim2.new(0, 20, 0, 10)
	wordLabel.BackgroundTransparency = 1
	wordLabel.TextColor3 = Color3.new(1, 1, 1)
	wordLabel.TextStrokeTransparency = 0
	wordLabel.Font = Enum.Font.GothamBold
	wordLabel.TextSize = 60
	wordLabel.Text = ""
	wordLabel.RichText = true
	wordLabel.ZIndex = 3
	wordLabel.Parent = wordFrame

	UI_READY = true
	if PENDING_ENTRY then
		showWord(PENDING_ENTRY)
		PENDING_ENTRY = nil
	end

	-- ç¿»è¨³è¡¨ç¤ºï¼ˆå˜èªã®ä¸‹ï¼‰
	translationLabel = Instance.new("TextLabel")
	translationLabel.Name = "TranslationLabel"
	translationLabel.Size = UDim2.new(1, -40, 0.35, 0)
	translationLabel.Position = UDim2.new(0, 20, 0.65, 0)
	translationLabel.BackgroundTransparency = 1
	translationLabel.TextColor3 = Color3.fromRGB(150, 200, 255)
	translationLabel.TextStrokeTransparency = 0.3
	translationLabel.Font = Enum.Font.Gotham
	translationLabel.TextSize = 28
	translationLabel.Text = ""
	translationLabel.TextYAlignment = Enum.TextYAlignment.Top
	translationLabel.Visible = true
	translationLabel.ZIndex = 3
	translationLabel.Parent = wordFrame

	log.debug("[BattleUI DEBUG] translationLabel ä½œæˆå®Œäº†")

	-- === Enemy Attack Progress ===
	enemyProgContainer = Instance.new("Frame")
	enemyProgContainer.Name = "EnemyAttackProgress"
	enemyProgContainer.AnchorPoint = Vector2.new(0.5, 1)
	enemyProgContainer.Size = UDim2.new(1, 0, 0, PROG_H)
	enemyProgContainer.Position = UDim2.new(0.5, 0, 0.98, 0)
	enemyProgContainer.BackgroundColor3 = Color3.fromRGB(40, 40, 48)
	enemyProgContainer.BorderSizePixel = 0
	enemyProgContainer.Visible = false
	enemyProgContainer.ZIndex = 5
	enemyProgContainer.Parent = centerStack

	local enemyProgCorner = Instance.new("UICorner")
	enemyProgCorner.CornerRadius = UDim.new(0, 7)
	enemyProgCorner.Parent = enemyProgContainer

	enemyProgFill = Instance.new("Frame")
	enemyProgFill.Name = "Fill"
	enemyProgFill.Size = UDim2.new(0, 0, 1, 0)
	enemyProgFill.Position = UDim2.new(0, 0, 0, 0)
	enemyProgFill.BackgroundColor3 = Color3.fromRGB(120, 200, 255)
	enemyProgFill.BorderSizePixel = 0
	enemyProgFill.ZIndex = 6
	enemyProgFill.Parent = enemyProgContainer

	local enemyProgFillCorner = Instance.new("UICorner")
	enemyProgFillCorner.CornerRadius = UDim.new(0, 7)
	enemyProgFillCorner.Parent = enemyProgFill

	-- === Countdown overlay ===
	countdownFrame = Instance.new("Frame")
	countdownFrame.Name = "Countdown"
	countdownFrame.BackgroundTransparency = 1
	countdownFrame.Size = UDim2.new(1, 0, 1, 0)
	countdownFrame.Visible = false
	countdownFrame.ZIndex = 20
	countdownFrame.Parent = battleGui

	countdownLabel = Instance.new("TextLabel")
	countdownLabel.Size = UDim2.new(1, 0, 1, 0)
	countdownLabel.BackgroundTransparency = 1
	countdownLabel.Font = Enum.Font.GothamBlack
	countdownLabel.TextScaled = true
	countdownLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
	countdownLabel.TextStrokeTransparency = 0.2
	countdownLabel.ZIndex = 21
	countdownLabel.Parent = countdownFrame

	log.debug("[BattleUI] UIä½œæˆå®Œäº†")
end

-- â–¼â–¼â–¼ ã“ã“ã‹ã‚‰ï¼šcreateBattleUI() ã®å®šç¾©â€œç›´å¾Œâ€ã«å…¥ã‚Œã‚‹ â–¼â–¼â–¼
local function connectRemoteEvent(name, handler)
	-- å…ˆã«æ¢ã™
	local ev = ReplicatedStorage:FindFirstChild(name)
	if not ev then
		warn(("[BattleUI] waiting RemoteEvent: %s"):format(name))
		-- ç”Ÿæˆã•ã‚Œã‚‹ã¾ã§å¾…æ©Ÿï¼ˆã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãªã—ï¼‰
		ev = ReplicatedStorage:WaitForChild(name)
	end
	if not ev or not ev:IsA("RemoteEvent") then
		error(
			("[BattleUI] RemoteEvent not found or wrong type: %s (got %s)"):format(name, ev and ev.ClassName or "nil")
		)
	end
	return ev.OnClientEvent:Connect(handler)
end
-- â–²â–²â–² ã“ã“ã¾ã§è¿½åŠ  â–²â–²â–²

-- === æ”»æ’ƒãƒ—ãƒ­ã‚°ãƒ¬ã‚¹é–‹å§‹ï¼ˆ0â†’æº€äº†ï¼‰===
startEnemyProgress = function(durationSec: number, startedAt: number?)
	if not enemyProgContainer or not enemyProgFill then
		return
	end

	-- æ—§ãƒ«ãƒ¼ãƒ—åœæ­¢
	if enemyProgConn then
		enemyProgConn:Disconnect()
		enemyProgConn = nil
	end

	enemyProgContainer.Visible = true
	enemyProgFill.Size = UDim2.new(0, 0, 1, 0)

	-- â˜… tick() ã«çµ±ä¸€ï¼ˆã‚µãƒ¼ãƒã® startedAt ã¨åŒåŸºæº–ï¼‰
	local s = tonumber(startedAt) or tick()

	enemyProgConn = game:GetService("RunService").RenderStepped:Connect(function()
		local t = math.clamp((tick() - s) / durationSec, 0, 1)
		enemyProgFill.Size = UDim2.new(t, 0, 1, 0)
		if t >= 1 then
			enemyProgConn:Disconnect()
			enemyProgConn = nil
		end
	end)
end

-- === æ”»æ’ƒãƒ—ãƒ­ã‚°ãƒ¬ã‚¹åœæ­¢ ===
stopEnemyProgress = function()
	if enemyProgConn then
		enemyProgConn:Disconnect()
		enemyProgConn = nil
	end
	if enemyProgContainer and enemyProgFill then
		enemyProgContainer.Visible = false
		enemyProgFill.Size = UDim2.new(0, 0, 1, 0)
	end
end

-- === è¢«å¼¾ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆã‚¿ã‚¤ãƒ—ãƒŸã‚¹ï¼æ•µã‚¿ãƒ¼ãƒ³å…±é€šï¼‰===
playHitFlash = function()
	if not wordFrame then
		return
	end

	-- æ ç·šã‚­ãƒ£ãƒƒã‚·ãƒ¥
	local frameStroke = wordFrame:FindFirstChildOfClass("UIStroke")

	-- èµ¤ãç‚¹æ»…
	wordFrame.BackgroundColor3 = Color3.fromRGB(255, 50, 50)
	wordFrame.BackgroundTransparency = 0.3
	if frameStroke then
		frameStroke.Color = Color3.fromRGB(255, 50, 50)
	end

	TweenService:Create(wordFrame, TweenInfo.new(0.3), {
		BackgroundColor3 = Color3.fromRGB(30, 30, 40),
		BackgroundTransparency = 0.2,
	}):Play()

	if frameStroke then
		TweenService:Create(frameStroke, TweenInfo.new(0.3), {
			Color = Color3.fromRGB(100, 200, 255),
		}):Play()
	end
end

if not TypingCorrectSound then
	warn("[BattleUI] TypingCorrectåŠ¹æœéŸ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ (WaitForChild ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ)")
end
if not TypingErrorSound then
	warn("[BattleUI] TypingErroråŠ¹æœéŸ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ (WaitForChild ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ)")
end

-- ãƒãƒˆãƒ«é–‹å§‹å‡¦ç†ï¼ˆçœç•¥ãªã—ãƒ»æ•´å‚™ç‰ˆï¼‰
local function onBattleStart(monsterName, hp, maxHP, damage, levels, pHP, pMaxHP)
	log.debug("[BattleUI] === onBattleStartå‘¼ã³å‡ºã— ===")

	-- nil ãƒã‚§ãƒƒã‚¯ã¨ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
	monsterName = monsterName or "Unknown"
	hp = hp or 10
	maxHP = maxHP or 10
	damage = damage or 1
	levels = levels or { { level = "level_1", weight = 100 } }
	pHP = pHP or 100
	pMaxHP = pMaxHP or 100

	log.debugf(
		("[BattleUI] ãƒãƒˆãƒ«é–‹å§‹: vs %s (æ•µHP: %d, ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼HP: %d/%d, Damage: %d)"):format(
			monsterName,
			hp,
			pHP,
			pMaxHP,
			damage
		)
	)

	-- ã™ã§ã«æˆ¦é—˜ä¸­ãªã‚‰ç„¡è¦–
	if inBattle then
		log.debug("[BattleUI DEBUG] ã™ã§ã«æˆ¦é—˜ä¸­")
		return
	end

	-- çŠ¶æ…‹ã‚»ãƒƒãƒˆ
	inBattle = true
	monsterHP = hp
	monsterMaxHP = maxHP
	playerHP = pHP
	playerMaxHP = pMaxHP
	damagePerKey = damage
	typingLevels = levels

	-- ã‚«ãƒ¡ãƒ©ãƒ»å…¥åŠ›ãƒ–ãƒ­ãƒƒã‚¯
	blockSystemKeys()
	local character = player.Character
	if character then
		local humanoid = character:FindFirstChildOfClass("Humanoid")
		if humanoid then
			humanoid.WalkSpeed = 0
			humanoid.JumpPower = 0
			humanoid.JumpHeight = 0
		end
	end

	-- Robloxã®UIã‚’ç„¡åŠ¹åŒ–
	pcall(function()
		StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Chat, false)
		StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, false)
		StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, false)
		StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.EmotesMenu, false)
	end)

	-- UIè¡¨ç¤º
	battleGui.Enabled = true

	-- ãƒãƒˆãƒ«é–‹å§‹æ™‚ç‚¹ã§äºˆçŸ¥ãƒ‘ãƒãƒ«ã‚’ãƒªã‚»ãƒƒãƒˆ
	precogNextWordData = nil
	if wordLabelNext then
		wordLabelNext.Text = ""
		wordLabelNext.Visible = hasPrecog() and false or false
		-- â†‘ true/false ã¯é–‹å§‹æ™‚ã«å‡ºã™ã‹ã©ã†ã‹ã®å¥½ã¿ï¼ˆé–‹å§‹æ™‚ã¯ false æ¨å¥¨ï¼‰
	end

	-- â˜… å˜èªãƒœãƒƒã‚¯ã‚¹ã‚’é–‹å§‹æ™‚ã«å¿…ãšå†è¡¨ç¤ºï¼†åˆæœŸçŠ¶æ…‹ã¸
	if wordFrame then
		wordFrame.Visible = true
		wordFrame.BackgroundTransparency = 0.2
		local frameStroke = wordFrame:FindFirstChildOfClass("UIStroke")
		if frameStroke then
			frameStroke.Transparency = 0
			frameStroke.Color = Color3.fromRGB(100, 200, 255)
		end
	end
	if wordLabel then
		wordLabel.Visible = true
		wordLabel.RichText = true
		wordLabel.Text = ""
		wordLabel.TextTransparency = 0
		wordLabel.TextStrokeTransparency = 0
		wordLabel.TextColor3 = Color3.new(1, 1, 1)
	end
	if translationLabel then
		translationLabel.Visible = true
		translationLabel.Text = ""
		translationLabel.TextTransparency = 0
		translationLabel.TextStrokeTransparency = 0.3
		translationLabel.TextColor3 = Color3.fromRGB(150, 200, 255)
	end

	-- â˜… HPãƒãƒ¼ã¯é–‹å§‹æ™‚ç‚¹ã§å¿…ãšè¡¨ç¤ºã«æˆ»ã™
	if hpBarBackground then
		hpBarBackground.Visible = true
	end

	-- â˜… ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹åˆæœŸåŒ–ï¼ˆç¢ºå®Ÿã«1æœ¬åŒ–ï¼‰
	if stopEnemyProgress then
		stopEnemyProgress()
	else
		-- ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼šæ¥ç¶šè§£é™¤ï¼†éè¡¨ç¤º
		if enemyProgConn then
			enemyProgConn:Disconnect()
			enemyProgConn = nil
		end
		if enemyProgContainer then
			enemyProgContainer.Visible = false
		end
	end
	if enemyProgContainer and enemyProgFill then
		enemyProgContainer.Visible = true
		enemyProgFill.Size = UDim2.new(0, 0, 1, 0)
	end

	-- åŠ¹æœéŸ³ã®å–ã‚Šã“ã¼ã—ä¿é™º
	if resolveSoundsIfNeeded then
		resolveSoundsIfNeeded()
	end

	-- ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³æœ‰ç„¡ã«å¿œã˜ã¦å…¥åŠ›åˆ¶å¾¡
	TypingEnabled = not PROGRESS_COUNTDOWN_ON_START

	-- èƒŒæ™¯ã®æš—è»¢
	if darkenFrame then
		darkenFrame.BackgroundTransparency = 0.4
	end

	-- ãƒ©ãƒ™ãƒ«ãªã©ãƒªã‚»ãƒƒãƒˆ
	if wordLabel then
		wordLabel.RichText = true
		wordLabel.TextColor3 = Color3.new(1, 1, 1)
		wordLabel.Text = ""
		wordLabel.TextTransparency = 0
		wordLabel.TextStrokeTransparency = 0
	end
	if translationLabel then
		translationLabel.TextColor3 = Color3.fromRGB(150, 200, 255)
		translationLabel.Text = ""
		translationLabel.Visible = true
		translationLabel.TextTransparency = 0
		translationLabel.TextStrokeTransparency = 0.3
	end
	if hpLabel then
		hpLabel.TextColor3 = Color3.new(1, 1, 1)
		hpLabel.Text = ""
		hpLabel.TextTransparency = 0
		hpLabel.TextStrokeTransparency = 0.5
	end
	if hpBarFill then
		hpBarFill.Size = UDim2.new(1, 0, 1, 0)
		hpBarFill.BackgroundColor3 = Color3.fromRGB(46, 204, 113)
		hpBarFill.BackgroundTransparency = 0
	end
	if hpBarBackground then
		hpBarBackground.BackgroundTransparency = 0
	end
	if playerHPBarFill then
		playerHPBarFill.Size = UDim2.new(1, 0, 1, 0)
		playerHPBarFill.BackgroundColor3 = Color3.fromRGB(46, 204, 113)
	end
	if wordFrame then
		wordFrame.BorderColor3 = Color3.fromRGB(100, 200, 255)
		wordFrame.BackgroundTransparency = 0.2
		local frameStroke = wordFrame:FindFirstChildOfClass("UIStroke")
		if frameStroke then
			frameStroke.Color = Color3.fromRGB(100, 200, 255)
			frameStroke.Transparency = 0
		end
	end

	-- æœ€åˆã®å˜èªã‚’è¨­å®šï¼ˆâ€» ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³ONã®ã¨ãã¯å¾Œã§å‡ºã™ï¼‰
	local function setFirstWordNow()
		if type(setNextWord) == "function" then
			setNextWord()
		else
			warn("[BattleUI] setNextWord ãŒæœªå®šç¾©ã§ã™")
		end
	end

	-- ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³å‹•ä½œ
	if PROGRESS_COUNTDOWN_ON_START then
		-- ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³è¡¨ç¤º
		if type(runCountdown) == "function" then
			if countdownFrame then
				countdownFrame.Visible = true
			end
			runCountdown(COUNTDOWN_SECONDS or 3)
			if countdownFrame then
				countdownFrame.Visible = false
			end
		end
		-- å…¥åŠ›è§£ç¦ï¼†å˜èªè¡¨ç¤º
		TypingEnabled = true
		setFirstWordNow()
		-- â˜… åˆå›ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ã¯ã“ã“ã§ã¯å›ã•ãªã„ï¼ˆã‚µãƒ¼ãƒã‹ã‚‰ã® EnemyAttackCycleStart ã‚’å¾…ã¤ï¼‰
	else
		-- ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³ç„¡ã—ï¼šå³åº§ã«å˜èªè¡¨ç¤º
		setFirstWordNow()
		-- â˜… åˆå›ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ã¯ã€Œä»®é€Ÿåº¦ã€ã§å›ã•ãªã„ï¼ˆã‚µãƒ¼ãƒé€šçŸ¥ã§æ­£ã—ã„é€Ÿåº¦ãƒ»é–‹å§‹æ™‚åˆ»ã«åŒæœŸï¼‰
		-- â€» ä»¥å‰ã®ä¸å…·åˆï¼ˆåˆå›ã ã‘é€”ä¸­ã§è¢«å¼¾ï¼‰ã‚’é¿ã‘ã‚‹ãŸã‚ã€ã“ã“ã¯ä½•ã‚‚ã—ãªã„
	end

	-- æˆ¦é—˜ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆï¼ˆãŠå®ˆã‚Šï¼‰
	-- if currentBattleTimeout then
	-- 	task.cancel(currentBattleTimeout)
	-- 	currentBattleTimeout = nil
	-- end
	-- currentBattleTimeout = task.delay(30, function()
	-- 	if inBattle then
	-- 		warn("[BattleUI] ãƒãƒˆãƒ«ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆï¼å¼·åˆ¶çµ‚äº†ã—ã¾ã™")
	-- 		if onBattleEnd then
	-- 			onBattleEnd(false)
	-- 		end
	-- 	end
	-- end)

	-- â˜… åˆå›ã‚µã‚¤ã‚¯ãƒ«ãƒ»ã‚¦ã‚©ãƒƒãƒãƒ‰ãƒƒã‚°ï¼š0.35ç§’å¾…ã£ã¦ã‚‚åŒæœŸãŒæ¥ãªã‘ã‚Œã°è¦æ±‚
	task.delay(0.35, function()
		-- â˜… æ¯”è¼ƒã‚‚ tick() ã«çµ±ä¸€
		if inBattle and (tick() - lastCycleAt) > 0.30 then
			requestEnemyCycleSync("first-cycle watchdog")
		end
	end)
end

-- ãƒãƒˆãƒ«çµ‚äº†å‡¦ç†
onBattleEnd = function(victory, summary)
	log.debugf("=== ãƒãƒˆãƒ«çµ‚äº†é–‹å§‹: " .. tostring(victory) .. " ===")

	-- æ—¢ã«ãƒãƒˆãƒ«ãŒçµ‚äº†ã—ã¦ã„ã‚‹å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
	if not inBattle and not battleGui.Enabled then
		log.debug("æ—¢ã«ãƒãƒˆãƒ«çµ‚äº†æ¸ˆã¿")
		return
	end

	-- ã€æœ€å„ªå…ˆã€‘ãƒãƒˆãƒ«çŠ¶æ…‹ã‚’å³åº§ã«ã‚¯ãƒªã‚¢ï¼ˆã‚­ãƒ¼å…¥åŠ›ã‚’åœæ­¢ï¼‰
	inBattle = false
	currentWord = ""
	currentWordData = nil
	currentIndex = 1
	playerHP = 0
	playerMaxHP = 0

	-- ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«
	if currentBattleTimeout then
		task.cancel(currentBattleTimeout)
		currentBattleTimeout = nil
	end

	-- æ•µæ”»æ’ƒãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ã‚’åœæ­¢ï¼†éš ã™ â† ã‚³ã‚³ãŒã€Œç›´å¾Œã€
	stopEnemyProgress()

	-- æ•µHPè¡¨ç¤ºã‚’å³åº§ã«æ¶ˆã™
	if hpBarBackground then
		hpBarBackground.Visible = false -- å­ã® hpLabel / hpBarFill ã‚‚ã¾ã¨ã‚ã¦éè¡¨ç¤º
	end
	if hpBarFill then
		hpBarFill.Size = UDim2.new(0, 0, 1, 0) -- å¿µã®ãŸã‚ãƒªã‚»ãƒƒãƒˆ
	end
	if hpLabel then
		hpLabel.Text = "" -- å¿µã®ãŸã‚ãƒªã‚»ãƒƒãƒˆ
	end

	-- å˜èªãƒœãƒƒã‚¯ã‚¹ã‚’å³åº§ã«éè¡¨ç¤º
	if wordFrame then
		wordFrame.Visible = false
	end
	if wordLabel then
		wordLabel.Text = ""
		-- å¿µã®ãŸã‚ï¼ˆæ®‹åƒå¯¾ç­–ï¼‰
		wordLabel.TextTransparency = 0
		wordLabel.TextStrokeTransparency = 0
	end
	if translationLabel then
		translationLabel.Visible = false
		translationLabel.Text = ""
	end

	-- å‹åˆ©æ™‚ã®å‡¦ç†
	if victory then
		-- ã‚·ã‚¹ãƒ†ãƒ ã‚­ãƒ¼ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’è§£é™¤
		unblockSystemKeys()

		-- Roblox UIã‚’å†æœ‰åŠ¹åŒ–
		pcall(function()
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Chat, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.EmotesMenu, true)
		end)

		-- å‹åˆ©ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
		-- â˜… å‹åˆ©ã‚µãƒãƒªãƒ¼ã‚’ä¸Šéƒ¨ã«è¡¨ç¤ºï¼ˆ2ç§’å¾Œãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆï¼‰
		do
			local exp = (summary and tonumber(summary.exp)) or 0
			local gold = (summary and tonumber(summary.gold)) or 0
			local dropsList = (summary and summary.drops) or {}
			-- è¡¨ç¤ºãƒ†ã‚­ã‚¹ãƒˆï¼ˆã€Œãªã—ã€ã‚’å«ã‚€ï¼‰
			local function formatDrops(drops)
				if type(drops) ~= "table" or #drops == 0 then
					return "ãªã—"
				end
				local t = {}
				for _, d in ipairs(drops) do
					if typeof(d) == "string" then
						table.insert(t, d)
					elseif type(d) == "table" then
						local name = d.name or d.item or "???"
						local n = d.count or d.qty or 1
						table.insert(t, string.format("%sÃ—%d", name, n))
					else
						table.insert(t, tostring(d))
					end
				end
				return table.concat(t, ", ")
			end

			local panel = Instance.new("Frame")
			panel.Name = "ResultSummary"
			panel.Size = UDim2.new(0, 520, 0, 110)
			panel.Position = UDim2.new(0.5, -260, 0.10, 0) -- â† ä¸Šéƒ¨ã«é…ç½®ï¼ˆä¸­å¤®å¯„ã›ï¼‰
			panel.BackgroundColor3 = Color3.fromRGB(25, 25, 32)
			panel.BackgroundTransparency = 0.1
			panel.BorderSizePixel = 0
			panel.ZIndex = 50
			panel.Parent = battleGui

			local corner = Instance.new("UICorner")
			corner.CornerRadius = UDim.new(0, 10)
			corner.Parent = panel

			local stroke = Instance.new("UIStroke")
			stroke.Thickness = 2
			stroke.Color = Color3.fromRGB(100, 200, 255)
			stroke.Transparency = 0.2
			stroke.Parent = panel

			local function addLine(text, order)
				local label = Instance.new("TextLabel")
				label.BackgroundTransparency = 1
				label.Size = UDim2.new(1, -24, 0, 30)
				label.Position = UDim2.new(0, 12, 0, 10 + (order - 1) * 32)
				label.Font = Enum.Font.GothamBold
				label.TextSize = 22
				label.TextXAlignment = Enum.TextXAlignment.Left
				label.TextColor3 = Color3.fromRGB(230, 240, 255)
				label.Text = text
				label.ZIndex = 51
				label.Parent = panel
				return label
			end

			addLine(("çµŒé¨“å€¤: +%d"):format(exp), 1)
			addLine(("ã‚´ãƒ¼ãƒ«ãƒ‰: +%d"):format(gold), 2)
			addLine(("ãƒ‰ãƒ­ãƒƒãƒ—: %s"):format(formatDrops(dropsList)), 3)

			-- 2ç§’ã‚­ãƒ¼ãƒ— â†’ 0.6ç§’ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ â†’ ç ´æ£„
			task.delay(2.0, function()
				if panel then
					TweenService:Create(panel, TweenInfo.new(0.6), { BackgroundTransparency = 1 }):Play()
					TweenService:Create(stroke, TweenInfo.new(0.6), { Transparency = 1 }):Play()
					for _, child in ipairs(panel:GetChildren()) do
						if child:IsA("TextLabel") then
							TweenService:Create(child, TweenInfo.new(0.6), {
								TextTransparency = 1,
								TextStrokeTransparency = 1,
							}):Play()
						end
					end
					task.wait(0.65)
					if panel then
						panel:Destroy()
					end
				end
			end)
		end

		-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å…¥åŠ›ãƒ–ãƒ­ãƒƒã‚¯ã‚’è§£é™¤
		local character = player.Character
		if character then
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			if humanoid then
				humanoid.WalkSpeed = 16
				humanoid.JumpPower = 50
				humanoid.JumpHeight = 7.2
			end
		end

		-- ç”»é¢ã‚’æ˜ã‚‹ãæˆ»ã™
		TweenService:Create(darkenFrame, TweenInfo.new(0.5), {
			BackgroundTransparency = 1,
		}):Play()

		-- UIã‚’éè¡¨ç¤ºã«ã™ã‚‹ãŸã‚ã®é…å»¶å®Ÿè¡Œï¼ˆåˆ¥ã‚¹ãƒ¬ãƒƒãƒ‰ã§ï¼‰
		task.spawn(function()
			task.wait(2.6) -- ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº†ã‚’å¾…ã¤
			if not inBattle then -- ã¾ã æ¬¡ã®ãƒãƒˆãƒ«ãŒå§‹ã¾ã£ã¦ã„ãªã„ã“ã¨ã‚’ç¢ºèª
				battleGui.Enabled = false

				-- ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼ã‚’éš ã™ï¼†é€²è¡Œãƒ«ãƒ¼ãƒ—åœæ­¢
				if enemyProgConn then
					enemyProgConn:Disconnect()
					enemyProgConn = nil
				end
				if enemyProgContainer then
					enemyProgContainer.Visible = false
				end

				-- æ•µæ”»æ’ƒãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼ã‚’éè¡¨ç¤º
				if enemyProgContainer then
					enemyProgContainer.Visible = false
				end
			end
		end)
	else
		-- æ•—åŒ—æ™‚ï¼šUIã‚’ç¶­æŒã—ãŸã¾ã¾æ­»äº¡é¸æŠUIã‚’å¾…ã¤
		log.debug("[BattleUI] æ•—åŒ— - UIã‚’ç¶­æŒã—ã¾ã™")

		-- æ•—åŒ—ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
		if wordLabel then
			wordLabel.RichText = false
			wordLabel.Text = "DEFEAT..."
			wordLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
		end

		-- ç¿»è¨³ãƒ©ãƒ™ãƒ«ã‚’éè¡¨ç¤º
		if translationLabel then
			translationLabel.Visible = false
		end

		-- æ ã®è‰²ã‚‚å¤‰æ›´
		if wordFrame then
			local frameStroke = wordFrame:FindFirstChildOfClass("UIStroke")
			if frameStroke then
				frameStroke.Color = Color3.fromRGB(255, 100, 100)
			end
		end

		-- ã‚·ã‚¹ãƒ†ãƒ ã‚­ãƒ¼ã®ãƒ–ãƒ­ãƒƒã‚¯ã¨Roblox UIã¯ç¶­æŒ
		-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç§»å‹•åˆ¶é™ã‚‚ç¶­æŒ
		-- æ­»äº¡é¸æŠUIã§é¸ã‚“ã å¾Œã«è§£é™¤ã™ã‚‹
	end

	log.debug("[BattleUI] === ãƒãƒˆãƒ«çµ‚äº†å®Œäº† ===")
end

-- HPæ›´æ–°å‡¦ç†ï¼ˆæ•µï¼‰
local function onHPUpdate(newHP)
	monsterHP = newHP
	updateDisplay()

	-- HPãŒ0ã«ãªã£ãŸã‚‰å‹åˆ©ï¼ˆã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰ã®é€šçŸ¥ã‚‚æ¥ã‚‹ãŒå¿µã®ãŸã‚ï¼‰
	if monsterHP <= 0 then
		log.debug("[BattleUI] âš ï¸ æ•µHPãŒ0ã«ãªã‚Šã¾ã—ãŸï¼ˆã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã§æ¤œå‡ºï¼‰")
	end
end

-- HPæ›´æ–°å‡¦ç†ï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼‰
local function onPlayerHPUpdate(newHP, newMaxHP)
	playerHP = newHP
	playerMaxHP = newMaxHP or playerMaxHP
	updateDisplay()
end

-- ã‚·ã‚¹ãƒ†ãƒ ã‚­ãƒ¼ã‚’ãƒ–ãƒ­ãƒƒã‚¯ã™ã‚‹å…¥åŠ›å‡¦ç†ï¼ˆæœ€å„ªå…ˆï¼‰
UserInputService.InputBegan:Connect(function(input, gameProcessed)
	-- ãƒãƒˆãƒ«ä¸­ã«ã‚·ã‚¹ãƒ†ãƒ ã‚­ãƒ¼ãŒæŠ¼ã•ã‚ŒãŸå ´åˆã€å…ˆã«å‡¦ç†ã—ã¦æ¶ˆè²»ã™ã‚‹
	if inBattle and input.UserInputType == Enum.UserInputType.Keyboard then
		local blockedKeys = {
			[Enum.KeyCode.I] = true,
			[Enum.KeyCode.O] = true,
			[Enum.KeyCode.Slash] = true,
			[Enum.KeyCode.Backquote] = true,
			[Enum.KeyCode.Tab] = true,
			[Enum.KeyCode.BackSlash] = true,
			[Enum.KeyCode.Equals] = true,
			[Enum.KeyCode.Minus] = true,
		}

		if blockedKeys[input.KeyCode] then
			-- ã“ã®ã‚­ãƒ¼ã¯ã‚¿ã‚¤ãƒ”ãƒ³ã‚°å‡¦ç†ã«å›ã™ï¼ˆã‚ºãƒ¼ãƒ ãªã©ã¯ç™ºå‹•ã•ã›ãªã„ï¼‰
			return
		end
	end
end)

playHitFlash = function()
	if not wordFrame then
		return
	end
	local frameStroke = wordFrame:FindFirstChildOfClass("UIStroke")

	-- èµ¤ãç‚¹æ»…
	wordFrame.BackgroundColor3 = Color3.fromRGB(255, 50, 50)
	wordFrame.BackgroundTransparency = 0.3
	if frameStroke then
		frameStroke.Color = Color3.fromRGB(255, 50, 50)
	end

	TweenService:Create(wordFrame, TweenInfo.new(0.3), {
		BackgroundColor3 = Color3.fromRGB(30, 30, 40),
		BackgroundTransparency = 0.2,
	}):Play()

	if frameStroke then
		TweenService:Create(frameStroke, TweenInfo.new(0.3), {
			Color = Color3.fromRGB(100, 200, 255),
		}):Play()
	end
end

-- ã‚­ãƒ¼å…¥åŠ›å‡¦ç†
local function onKeyPress(input, gameProcessed)
	if not inBattle then
		return
	end
	if not TypingEnabled then
		return
	end

	if input.UserInputType == Enum.UserInputType.Keyboard then
		local keyCode = input.KeyCode
		local keyString = UserInputService:GetStringForKeyCode(keyCode):lower()

		-- è‹±å­—ã®ã¿å—ã‘ä»˜ã‘
		if #keyString == 1 and keyString:match("%a") then
			local expectedChar = string.sub(currentWord, currentIndex, currentIndex):lower()

			if keyString == expectedChar then
				-- æ­£è§£
				currentIndex = currentIndex + 1

				-- æ­£è§£éŸ³ã‚’å†ç”Ÿ
				if TypingCorrectSound then
					TypingCorrectSound:Play()
				end

				-- ã‚µãƒ¼ãƒãƒ¼ã«ãƒ€ãƒ¡ãƒ¼ã‚¸é€šçŸ¥
				BattleDamageEvent:FireServer(damagePerKey)

				-- å˜èªå®Œæˆãƒã‚§ãƒƒã‚¯
				if currentIndex > #currentWord then
					task.wait(0.3)
					if inBattle then
						-- äºˆçŸ¥ONãªã‚‰äºˆç´„ã‚’ä½¿ã†
						local useNext = (hasPrecog and hasPrecog()) and precogNextWordData or nil

						if type(setNextWord) == "function" then
							setNextWord(useNext)
						else
							warn("[BattleUI] setNextWord is nil; fallback to direct update")
							-- ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼ˆä¸‡ä¸€ã®ãŸã‚ï¼‰
							currentWordData = useNext or selectWord()
							currentWord = currentWordData.word
							currentIndex = 1
							lastWord = currentWord
							if translationLabel then
								local translation = getTranslation(currentWordData, LANG)
								translationLabel.Text = translation
								translationLabel.Visible = translation ~= ""
							end

							updateDisplay()
						end

						-- äºˆç´„ã¯ä½¿ã„åˆ‡ã£ãŸã®ã§ã‚¯ãƒªã‚¢
						precogNextWordData = nil
					end
				else
					updateDisplay()
				end
			else
				-- ã‚¿ã‚¤ãƒ—ãƒŸã‚¹
				if TypingErrorSound then
					TypingErrorSound:Play()
				end

				if playHitFlash then
					playHitFlash()
				end

				-- ã‚¿ã‚¤ãƒ—ãƒŸã‚¹æ™‚ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ã‚µãƒ¼ãƒãƒ¼ã«é€šçŸ¥
				local TypingMistakeEvent = ReplicatedStorage:FindFirstChild("TypingMistake")
				if TypingMistakeEvent then
					TypingMistakeEvent:FireServer()
				end
			end
		end
	end
end

-- åˆæœŸåŒ–
createBattleUI()

log.debug("ã‚¤ãƒ™ãƒ³ãƒˆæ¥ç¶šä¸­...")
connectRemoteEvent("BattleStart", onBattleStart)
connectRemoteEvent("BattleEnd", onBattleEnd)

local RS = ReplicatedStorage

-- å¿…é ˆã‚¤ãƒ™ãƒ³ãƒˆï¼šã‚µãƒ¼ãƒãŒå‡ºã™ã¾ã§å¾…ã¤ï¼ˆã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆç„¡ã—ã§OKï¼‰
RS:WaitForChild("BattleStart").OnClientEvent:Connect(onBattleStart)
RS:WaitForChild("BattleEnd").OnClientEvent:Connect(onBattleEnd)
RS:WaitForChild("EnemyAttackCycleStart").OnClientEvent:Connect(function(payload)
	-- UI æœªæº–å‚™ãªã‚‰ä¸€æ—¦ä¿ç•™
	if not battleGui or not battleGui.Enabled then
		pendingEnemyCycle = payload
		return
	end
	applyEnemyCycle(payload)
end)
RS:WaitForChild("EnemyDamage").OnClientEvent:Connect(function(payload)
	if not inBattle then
		return
	end
	playHitFlash()
	if EnemyHitSound and EnemyHitSound.Play then
		EnemyHitSound:Play()
	end
end)

-- ä»»æ„ã‚¤ãƒ™ãƒ³ãƒˆï¼šç„¡ã„ç’°å¢ƒã‚‚æƒ³å®šã—ã¦â€œå¾…ã¡æ™‚é–“ã¤ãã§å–å¾—â€
do
	local ev = RS:WaitForChild("BattleHPUpdate", 10)
	if ev then
		ev.OnClientEvent:Connect(onHPUpdate)
	else
		warn("[BattleUI] BattleHPUpdate ãŒè¦‹ã¤ã‹ã‚‰ãªã„ï¼ˆã‚¹ã‚­ãƒƒãƒ—ï¼‰")
	end
end
do
	local ev = RS:WaitForChild("PlayerHPUpdate", 10)
	if ev then
		ev.OnClientEvent:Connect(onPlayerHPUpdate)
	else
		warn("[BattleUI] PlayerHPUpdate ãŒè¦‹ã¤ã‹ã‚‰ãªã„ï¼ˆã‚¹ã‚­ãƒƒãƒ—ï¼‰")
	end
end

-- ã¤ã„ã§ã«ä»–ã‚‚å®‰å…¨åŒ–
connectRemoteEvent("EnemyDamage", function(payload)
	if not inBattle then
		return
	end
	playHitFlash()
	if EnemyHitSound and EnemyHitSound.Play then
		EnemyHitSound:Play()
	end
end)

connectRemoteEvent("EnemyAttackCycleStart", function(payload)
	if not battleGui or not battleGui.Enabled then
		pendingEnemyCycle = payload
		return
	end
	applyEnemyCycle(payload)
end)

local EnemyDamageEvent = ReplicatedStorage:WaitForChild("EnemyDamage", 30)
EnemyDamageEvent.OnClientEvent:Connect(function(payload)
	-- ãƒãƒˆãƒ«ä¸­ã ã‘åå¿œ
	if not inBattle then
		return
	end

	-- æ•µã‚¿ãƒ¼ãƒ³ã®è¢«å¼¾ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
	playHitFlash()

	-- æ•µè¢«å¼¾SE
	if EnemyHitSound and EnemyHitSound.Play then
		EnemyHitSound:Play()
	end
end)

ReplicatedStorage:WaitForChild("EnemyAttackCycleStart").OnClientEvent:Connect(function(payload)
	if not battleGui or not battleGui.Enabled then
		pendingEnemyCycle = payload
		return
	end
	applyEnemyCycle(payload)
end)

-- HPæ›´æ–°ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆæ•µï¼‰
local HPUpdateEvent = ReplicatedStorage:FindFirstChild("BattleHPUpdate")
if HPUpdateEvent then
	HPUpdateEvent.OnClientEvent:Connect(onHPUpdate)
end

-- HPæ›´æ–°ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼‰
local PlayerHPUpdateEvent = ReplicatedStorage:FindFirstChild("PlayerHPUpdate")

if PlayerHPUpdateEvent then
	PlayerHPUpdateEvent.OnClientEvent:Connect(onPlayerHPUpdate)
else
	warn("[BattleUI] PlayerHPUpdate ã‚¤ãƒ™ãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
end

UserInputService.InputBegan:Connect(onKeyPress)

-- ç·Šæ€¥è„±å‡ºç”¨ï¼šEscã‚­ãƒ¼ã§å¼·åˆ¶çµ‚äº†
UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if input.KeyCode == Enum.KeyCode.Escape and battleGui.Enabled then
		warn("[BattleUI] Escã‚­ãƒ¼ã§å¼·åˆ¶çµ‚äº†")

		-- ã‚·ã‚¹ãƒ†ãƒ ã‚­ãƒ¼ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’è§£é™¤
		unblockSystemKeys()

		-- Roblox UIã‚’å†æœ‰åŠ¹åŒ–
		pcall(function()
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Chat, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.EmotesMenu, true)
		end)

		darkenFrame.BackgroundTransparency = 1
		battleGui.Enabled = false
		inBattle = false
		currentWord = ""
		currentWordData = nil
		currentIndex = 1
		playerHP = 0
		playerMaxHP = 0

		local character = player.Character
		if character then
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			if humanoid then
				humanoid.WalkSpeed = 16
				humanoid.JumpPower = 50
				humanoid.JumpHeight = 7.2
			end
		end
	end
end)

-- â˜… ãƒ•ã‚©ãƒ¼ã‚«ã‚¹å¾©å¸°ã§å†åŒæœŸ
UserInputService.WindowFocused:Connect(function()
	if inBattle then
		requestEnemyCycleSync("window focused")
	end
end)

===== ./StartPlayerScripts/RewardPopup.client.lua =====
-- StarterPlayer/StarterPlayerScripts/RewardPopup.client.lua
-- å ±é…¬å–å¾—æ™‚ã®ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—è¡¨ç¤º

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

print("[RewardPopup] åˆæœŸåŒ–é–‹å§‹")

-- RemoteEventå–å¾—
local InteractionResponseEvent = ReplicatedStorage:WaitForChild("InteractionResponse", 10)
if not InteractionResponseEvent then
	warn("[RewardPopup] InteractionResponseãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
	return
end

-- ScreenGuiä½œæˆ
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "RewardPopupUI"
screenGui.ResetOnSpawn = false
screenGui.IgnoreGuiInset = true
screenGui.DisplayOrder = 200
screenGui.Parent = playerGui

-- ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã‚’è¡¨ç¤º
local function showRewardPopup(rewards, duration)
	duration = duration or 3
	print(("[RewardPopup] å ±é…¬ã‚’è¡¨ç¤º: %då€‹, è¡¨ç¤ºæ™‚é–“: %dç§’"):format(#rewards, duration))

	-- ãƒ¡ã‚¤ãƒ³ãƒ•ãƒ¬ãƒ¼ãƒ 
	local frame = Instance.new("Frame")
	frame.Name = "RewardFrame"
	frame.Size = UDim2.new(0, 400, 0, 0) -- é«˜ã•ã¯å‹•çš„ã«èª¿æ•´
	frame.Position = UDim2.new(0.5, -200, 0.3, 0)
	frame.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
	frame.BackgroundTransparency = 0.2
	frame.BorderSizePixel = 0
	frame.Parent = screenGui

	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 12)
	corner.Parent = frame

	-- ã‚¿ã‚¤ãƒˆãƒ«
	local title = Instance.new("TextLabel")
	title.Size = UDim2.new(1, -20, 0, 40)
	title.Position = UDim2.new(0, 10, 0, 10)
	title.BackgroundTransparency = 1
	title.Text = "âœ¨ ã‚¢ã‚¤ãƒ†ãƒ ã‚’æ‰‹ã«å…¥ã‚ŒãŸï¼"
	title.TextColor3 = Color3.fromRGB(255, 220, 100)
	title.TextSize = 24
	title.Font = Enum.Font.GothamBold
	title.TextXAlignment = Enum.TextXAlignment.Left
	title.Parent = frame

	-- å ±é…¬ãƒªã‚¹ãƒˆã‚³ãƒ³ãƒ†ãƒŠ
	local listContainer = Instance.new("Frame")
	listContainer.Size = UDim2.new(1, -20, 1, -60)
	listContainer.Position = UDim2.new(0, 10, 0, 50)
	listContainer.BackgroundTransparency = 1
	listContainer.Parent = frame

	local listLayout = Instance.new("UIListLayout")
	listLayout.SortOrder = Enum.SortOrder.LayoutOrder
	listLayout.Padding = UDim.new(0, 8)
	listLayout.Parent = listContainer

	-- å„å ±é…¬ã‚’è¡¨ç¤º
	for i, reward in ipairs(rewards) do
		local rewardFrame = Instance.new("Frame")
		rewardFrame.Size = UDim2.new(1, 0, 0, 35)
		rewardFrame.BackgroundColor3 = Color3.fromRGB(60, 60, 70)
		rewardFrame.BackgroundTransparency = 0.5
		rewardFrame.BorderSizePixel = 0
		rewardFrame.LayoutOrder = i
		rewardFrame.Parent = listContainer

		local rewardCorner = Instance.new("UICorner")
		rewardCorner.CornerRadius = UDim.new(0, 8)
		rewardCorner.Parent = rewardFrame

		-- ã‚¢ã‚¤ãƒ†ãƒ å
		local itemLabel = Instance.new("TextLabel")
		itemLabel.Size = UDim2.new(0.7, 0, 1, 0)
		itemLabel.Position = UDim2.new(0, 15, 0, 0)
		itemLabel.BackgroundTransparency = 1
		itemLabel.Text = reward.item
		itemLabel.TextColor3 = Color3.new(1, 1, 1)
		itemLabel.TextSize = 20
		itemLabel.Font = Enum.Font.SourceSansBold
		itemLabel.TextXAlignment = Enum.TextXAlignment.Left
		itemLabel.Parent = rewardFrame

		-- å€‹æ•°
		local countLabel = Instance.new("TextLabel")
		countLabel.Size = UDim2.new(0.3, -15, 1, 0)
		countLabel.Position = UDim2.new(0.7, 0, 0, 0)
		countLabel.BackgroundTransparency = 1
		countLabel.Text = "x" .. tostring(reward.count)
		countLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
		countLabel.TextSize = 20
		countLabel.Font = Enum.Font.SourceSansBold
		countLabel.TextXAlignment = Enum.TextXAlignment.Right
		countLabel.Parent = rewardFrame
	end

	-- ãƒ•ãƒ¬ãƒ¼ãƒ ã®é«˜ã•ã‚’èª¿æ•´
	local contentHeight = 60 + (#rewards * 35) + ((#rewards - 1) * 8)
	frame.Size = UDim2.new(0, 400, 0, contentHeight)

	-- ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
	frame.BackgroundTransparency = 1
	title.TextTransparency = 1

	for _, child in ipairs(listContainer:GetChildren()) do
		if child:IsA("Frame") then
			child.BackgroundTransparency = 1
			for _, label in ipairs(child:GetChildren()) do
				if label:IsA("TextLabel") then
					label.TextTransparency = 1
				end
			end
		end
	end

	-- ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼šãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
	TweenService:Create(frame, TweenInfo.new(0.5), {
		BackgroundTransparency = 0.2
	}):Play()

	TweenService:Create(title, TweenInfo.new(0.5), {
		TextTransparency = 0
	}):Play()

	for _, child in ipairs(listContainer:GetChildren()) do
		if child:IsA("Frame") then
			TweenService:Create(child, TweenInfo.new(0.5), {
				BackgroundTransparency = 0.5
			}):Play()

			for _, label in ipairs(child:GetChildren()) do
				if label:IsA("TextLabel") then
					TweenService:Create(label, TweenInfo.new(0.5), {
						TextTransparency = 0
					}):Play()
				end
			end
		end
	end

	-- 5ç§’å¾Œã«ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
	task.wait(5)

	-- ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼šãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
	local fadeOut = TweenService:Create(frame, TweenInfo.new(1), {
		BackgroundTransparency = 1
	})

	TweenService:Create(title, TweenInfo.new(1), {
		TextTransparency = 1
	}):Play()

	for _, child in ipairs(listContainer:GetChildren()) do
		if child:IsA("Frame") then
			TweenService:Create(child, TweenInfo.new(1), {
				BackgroundTransparency = 1
			}):Play()

			for _, label in ipairs(child:GetChildren()) do
				if label:IsA("TextLabel") then
					TweenService:Create(label, TweenInfo.new(1), {
						TextTransparency = 1
					}):Play()
				end
			end
		end
	end

	fadeOut:Play()
	fadeOut.Completed:Connect(function()
		frame:Destroy()
		print("[RewardPopup] ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã‚’å‰Šé™¤ã—ã¾ã—ãŸ")
	end)
end

-- ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰ã®å ±é…¬æƒ…å ±ã‚’å—ä¿¡
InteractionResponseEvent.OnClientEvent:Connect(function(data)
	if data.success and data.type == "chest" and data.rewards then
		local duration = data.displayDuration or 3
		showRewardPopup(data.rewards, duration)
	end
end)

print("[RewardPopup] åˆæœŸåŒ–å®Œäº†")
===== ./StartPlayerScripts/FastTravelUI.client.lua =====
-- StarterPlayer/StarterPlayerScripts/FastTravelUI.client.lua
-- ãƒ•ã‚¡ã‚¹ãƒˆãƒˆãƒ©ãƒ™ãƒ«UIã‚·ã‚¹ãƒ†ãƒ 

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

print("[FastTravelUI] åˆæœŸåŒ–é–‹å§‹")

-- RemoteEventå–å¾—
local FastTravelEvent = ReplicatedStorage:WaitForChild("FastTravelEvent", 10)
local GetContinentsEvent = ReplicatedStorage:WaitForChild("GetContinentsEvent", 10)

if not FastTravelEvent or not GetContinentsEvent then
	warn("[FastTravelUI] RemoteEventãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
	return
end

-- UIã‚³ãƒ³ãƒ†ãƒŠ
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "FastTravelUI"
screenGui.ResetOnSpawn = false
screenGui.IgnoreGuiInset = true
-- screenGui.ZIndex = 100
screenGui.Parent = playerGui

-- ãƒ¯ãƒ¼ãƒ—ãƒœã‚¿ãƒ³ï¼ˆãƒŸãƒ‹ãƒãƒƒãƒ—ã®ä¸Šï¼‰
local warpButton = Instance.new("TextButton")
warpButton.Name = "WarpButton"
warpButton.Size = UDim2.new(0, 200, 0, 35) -- ãƒŸãƒ‹ãƒãƒƒãƒ—ã¨åŒã˜æ¨ªå¹…200ã€é«˜ã•35
warpButton.Position = UDim2.new(0, 20, 1, -300) -- ãƒŸãƒ‹ãƒãƒƒãƒ—ã®ä¸Šã«é…ç½®
warpButton.BackgroundColor3 = Color3.fromRGB(50, 120, 200)
warpButton.BackgroundTransparency = 0.2
warpButton.BorderSizePixel = 2
warpButton.BorderColor3 = Color3.fromRGB(255, 255, 255)
warpButton.Text = "ãƒ¯ãƒ¼ãƒ—"
warpButton.TextColor3 = Color3.new(1, 1, 1)
warpButton.TextSize = 18
warpButton.Font = Enum.Font.SourceSansBold
warpButton.Parent = screenGui

local warpButtonCorner = Instance.new("UICorner")
warpButtonCorner.CornerRadius = UDim.new(0, 6)
warpButtonCorner.Parent = warpButton

-- ãƒ¢ãƒ¼ãƒ€ãƒ«èƒŒæ™¯
local modalBackground = Instance.new("Frame")
modalBackground.Name = "ModalBackground"
modalBackground.Size = UDim2.fromScale(1, 1)
modalBackground.Position = UDim2.fromScale(0, 0)
modalBackground.BackgroundColor3 = Color3.new(0, 0, 0)
modalBackground.BackgroundTransparency = 1
modalBackground.Visible = false
modalBackground.ZIndex = 101
modalBackground.Parent = screenGui

-- ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦
local modalWindow = Instance.new("Frame")
modalWindow.Name = "ModalWindow"
modalWindow.Size = UDim2.new(0, 400, 0, 500)
modalWindow.Position = UDim2.new(0.5, -200, 0.5, -250)
modalWindow.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
modalWindow.BackgroundTransparency = 0.1
modalWindow.BorderSizePixel = 3
modalWindow.BorderColor3 = Color3.fromRGB(100, 150, 255)
modalWindow.ZIndex = 102
modalWindow.Parent = modalBackground

local modalCorner = Instance.new("UICorner")
modalCorner.CornerRadius = UDim.new(0, 12)
modalCorner.Parent = modalWindow

-- ã‚¿ã‚¤ãƒˆãƒ«
local titleLabel = Instance.new("TextLabel")
titleLabel.Name = "Title"
titleLabel.Size = UDim2.new(1, 0, 0, 50)
titleLabel.Position = UDim2.new(0, 0, 0, 0)
titleLabel.BackgroundTransparency = 1
titleLabel.Text = "ãƒ¯ãƒ¼ãƒ—å…ˆã‚’é¸æŠ"
titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
titleLabel.TextSize = 24
titleLabel.Font = Enum.Font.GothamBold
titleLabel.ZIndex = 103
titleLabel.Parent = modalWindow

-- é–‰ã˜ã‚‹ãƒœã‚¿ãƒ³
local closeButton = Instance.new("TextButton")
closeButton.Name = "CloseButton"
closeButton.Size = UDim2.new(0, 40, 0, 40)
closeButton.Position = UDim2.new(1, -50, 0, 5)
closeButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
closeButton.BackgroundTransparency = 0.3
closeButton.BorderSizePixel = 0
closeButton.Text = "âœ•"
closeButton.TextColor3 = Color3.new(1, 1, 1)
closeButton.TextSize = 24
closeButton.Font = Enum.Font.SourceSansBold
closeButton.ZIndex = 103
closeButton.Parent = modalWindow

local closeButtonCorner = Instance.new("UICorner")
closeButtonCorner.CornerRadius = UDim.new(0, 8)
closeButtonCorner.Parent = closeButton

-- ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒ•ãƒ¬ãƒ¼ãƒ ï¼ˆå¤§é™¸ä¸€è¦§ï¼‰
local scrollFrame = Instance.new("ScrollingFrame")
scrollFrame.Name = "ContinentsList"
scrollFrame.Size = UDim2.new(1, -40, 1, -100)
scrollFrame.Position = UDim2.new(0, 20, 0, 70)
scrollFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 30)
scrollFrame.BackgroundTransparency = 0.5
scrollFrame.BorderSizePixel = 0
scrollFrame.ScrollBarThickness = 8
scrollFrame.ZIndex = 102
scrollFrame.Parent = modalWindow

local scrollCorner = Instance.new("UICorner")
scrollCorner.CornerRadius = UDim.new(0, 8)
scrollCorner.Parent = scrollFrame

local listLayout = Instance.new("UIListLayout")
listLayout.SortOrder = Enum.SortOrder.LayoutOrder
listLayout.Padding = UDim.new(0, 10)
listLayout.Parent = scrollFrame

local listPadding = Instance.new("UIPadding")
listPadding.PaddingTop = UDim.new(0, 10)
listPadding.PaddingBottom = UDim.new(0, 10)
listPadding.PaddingLeft = UDim.new(0, 10)
listPadding.PaddingRight = UDim.new(0, 10)
listPadding.Parent = scrollFrame

-- ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ã
local function openModal()
	print("[FastTravelUI] ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ã")

	-- å¤§é™¸ä¸€è¦§ã‚’å–å¾—
	local success, continents = pcall(function()
		return GetContinentsEvent:InvokeServer()
	end)

	if not success or not continents then
		warn("[FastTravelUI] å¤§é™¸ä¸€è¦§ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ")
		return
	end

	-- æ—¢å­˜ã®ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªã‚¢
	for _, child in ipairs(scrollFrame:GetChildren()) do
		if child:IsA("TextButton") then
			child:Destroy()
		end
	end

	-- å¤§é™¸ãƒœã‚¿ãƒ³ã‚’ä½œæˆ
	for i, continent in ipairs(continents) do
		local button = Instance.new("TextButton")
		button.Name = continent.name
		button.Size = UDim2.new(1, -20, 0, 60)
		button.BackgroundColor3 = Color3.fromRGB(60, 100, 180)
		button.BackgroundTransparency = 0.2
		button.BorderSizePixel = 0
		button.Text = continent.displayName
		button.TextColor3 = Color3.new(1, 1, 1)
		button.TextSize = 20
		button.Font = Enum.Font.SourceSansBold
		button.LayoutOrder = i
		button.ZIndex = 103
		button.Parent = scrollFrame

		local buttonCorner = Instance.new("UICorner")
		buttonCorner.CornerRadius = UDim.new(0, 8)
		buttonCorner.Parent = button

		-- ãƒ›ãƒãƒ¼ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
		button.MouseEnter:Connect(function()
			TweenService:Create(button, TweenInfo.new(0.2), {
				BackgroundTransparency = 0,
			}):Play()
		end)

		button.MouseLeave:Connect(function()
			TweenService:Create(button, TweenInfo.new(0.2), {
				BackgroundTransparency = 0.2,
			}):Play()
		end)

		-- ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆ
		button.MouseButton1Click:Connect(function()
			print(("[FastTravelUI] %s ã¸ãƒ¯ãƒ¼ãƒ—è¦æ±‚"):format(continent.name))
			FastTravelEvent:FireServer(continent.name)
			closeModal()
		end)
	end

	-- ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒ•ãƒ¬ãƒ¼ãƒ ã®ã‚µã‚¤ã‚ºèª¿æ•´
	scrollFrame.CanvasSize = UDim2.new(0, 0, 0, listLayout.AbsoluteContentSize.Y + 20)

	-- ãƒ¢ãƒ¼ãƒ€ãƒ«è¡¨ç¤º
	modalBackground.Visible = true
	modalBackground.BackgroundTransparency = 0.5

	-- ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
	TweenService:Create(modalBackground, TweenInfo.new(0.3), {
		BackgroundTransparency = 0.3,
	}):Play()
end

-- ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
function closeModal()
	print("[FastTravelUI] ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹")

	TweenService:Create(modalBackground, TweenInfo.new(0.3), {
		BackgroundTransparency = 1,
	}):Play()

	task.wait(0.3)
	modalBackground.Visible = false
end

-- ã‚¤ãƒ™ãƒ³ãƒˆæ¥ç¶š
warpButton.MouseButton1Click:Connect(openModal)
closeButton.MouseButton1Click:Connect(closeModal)

-- èƒŒæ™¯ã‚¯ãƒªãƒƒã‚¯ã§é–‰ã˜ã‚‹
modalBackground.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		-- ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦å¤–ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸå ´åˆ
		local mousePos = input.Position
		local windowPos = modalWindow.AbsolutePosition
		local windowSize = modalWindow.AbsoluteSize

		if
			mousePos.X < windowPos.X
			or mousePos.X > windowPos.X + windowSize.X
			or mousePos.Y < windowPos.Y
			or mousePos.Y > windowPos.Y + windowSize.Y
		then
			closeModal()
		end
	end
end)

print("[FastTravelUI] åˆæœŸåŒ–å®Œäº†")

===== ./StartPlayerScripts/LoadingScreen.client.lua =====
-- StarterPlayer/StarterPlayerScripts/LoadingScreen.client.lua
-- åˆå›ãƒ­ãƒ¼ãƒ‰æ™‚ã®ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ç”»é¢ï¼ˆãƒ¯ãƒ¼ãƒ—ç”¨ã¨çµ±ä¸€ï¼‰

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

print("[LoadingScreen] åˆæœŸåŒ–ä¸­...")

-- ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ç”»åƒã® Asset ID ãƒªã‚¹ãƒˆ
local LoadingImages = {
	-- "rbxassetid://74049529220513",
	-- "rbxassetid://139010932520933",
	-- å®Ÿéš›ã® Asset ID ã«ç½®ãæ›ãˆã¦ãã ã•ã„
}

-- LoadingHints ã‚’èª­ã¿è¾¼ã¿
local LoadingHints = require(ReplicatedStorage:WaitForChild("LoadingHints"))

-- ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ç”»é¢ã®UIï¼ˆãƒ¯ãƒ¼ãƒ—ç”¨ã¨åŒã˜æ§‹æˆï¼‰
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "InitialLoadingUI"
screenGui.ResetOnSpawn = false
screenGui.IgnoreGuiInset = true
screenGui.DisplayOrder = 1000 -- æœ€å‰é¢ã«è¡¨ç¤º
screenGui.Parent = playerGui

-- èƒŒæ™¯ï¼ˆå…¨ç”»é¢é»’ï¼‰
local background = Instance.new("Frame")
background.Name = "Background"
background.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
background.BackgroundTransparency = 0
background.Size = UDim2.fromScale(1, 1)
background.Position = UDim2.fromScale(0, 0)
background.ZIndex = 1
background.Parent = screenGui

-- ç”»åƒè¡¨ç¤ºã‚¨ãƒªã‚¢ï¼ˆä¸­å¤®ã«å¤§ããï¼‰
local imageLabel = Instance.new("ImageLabel")
imageLabel.Name = "LoadingImage"
imageLabel.BackgroundTransparency = 1
imageLabel.Size = UDim2.fromOffset(600, 450)
imageLabel.Position = UDim2.fromScale(0.5, 0.35)
imageLabel.AnchorPoint = Vector2.new(0.5, 0.5)
imageLabel.ScaleType = Enum.ScaleType.Fit
imageLabel.ZIndex = 2
imageLabel.Parent = background

-- "Now Loading..." ãƒ†ã‚­ã‚¹ãƒˆ
local loadingText = Instance.new("TextLabel")
loadingText.Name = "LoadingText"
loadingText.Text = "Now Loading..."
loadingText.Font = Enum.Font.GothamBold
loadingText.TextSize = 56
loadingText.TextColor3 = Color3.fromRGB(255, 255, 255)
loadingText.BackgroundTransparency = 1
loadingText.Size = UDim2.fromOffset(500, 70)
loadingText.Position = UDim2.fromScale(0.5, 0.75)
loadingText.AnchorPoint = Vector2.new(0.5, 0.5)
loadingText.ZIndex = 2
loadingText.Parent = background

-- ãƒ’ãƒ³ãƒˆãƒ†ã‚­ã‚¹ãƒˆï¼ˆã‚·ãƒ³ãƒ—ãƒ«ç‰ˆï¼šèƒŒæ™¯ãªã—ï¼‰
local hintText = Instance.new("TextLabel")
hintText.Name = "HintText"
hintText.Text = ""
hintText.Font = Enum.Font.Gotham
hintText.TextSize = 24
hintText.TextColor3 = Color3.fromRGB(255, 255, 100) -- é»„è‰²ã§ãƒã‚¤ãƒ©ã‚¤ãƒˆ
hintText.BackgroundTransparency = 1
hintText.TextWrapped = true
hintText.TextScaled = true
hintText.Size = UDim2.fromOffset(800, 100)
hintText.Position = UDim2.fromScale(0.5, 0.88)
hintText.AnchorPoint = Vector2.new(0.5, 0.5)
hintText.ZIndex = 2
hintText.Parent = background

-- ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ï¼ˆç¸å–ã‚Šï¼‰ã‚’è¿½åŠ 
hintText.TextStrokeTransparency = 0.5
hintText.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)

print("[LoadingScreen] ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ç”»é¢ã‚’ä½œæˆã—ã¾ã—ãŸ")

-- åˆæœŸè¡¨ç¤ºï¼šãƒ©ãƒ³ãƒ€ãƒ ç”»åƒã¨ãƒ’ãƒ³ãƒˆ
local function showInitialLoading()
	-- ãƒ©ãƒ³ãƒ€ãƒ ã«ç”»åƒã‚’é¸æŠã—ã¦ã‚»ãƒƒãƒˆ
	if #LoadingImages > 0 then
		local randomImage = LoadingImages[math.random(#LoadingImages)]
		imageLabel.Image = randomImage
		print("[LoadingScreen] ç”»åƒã‚’ã‚»ãƒƒãƒˆ: " .. randomImage)
	else
		print("[LoadingScreen] è­¦å‘Š: LoadingImages ãŒç©ºã§ã™")
	end

	-- ãƒ’ãƒ³ãƒˆå–å¾—ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ¬ãƒ™ãƒ« 1ï¼‰
	local hint = LoadingHints.getHintByLevel(1)
	hintText.Text = "ğŸ’¡ " .. hint
	print("[LoadingScreen] ãƒ’ãƒ³ãƒˆè¡¨ç¤º: " .. hint)
end

-- ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰ã®æº–å‚™å®Œäº†ä¿¡å·ã‚’å¾…ã¤
local spawnReadyEvent = ReplicatedStorage:WaitForChild("SpawnReady", 10)

if spawnReadyEvent then
	-- åˆæœŸãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°è¡¨ç¤º
	showInitialLoading()

	spawnReadyEvent.OnClientEvent:Connect(function()
		print("[LoadingScreen] ã‚¹ãƒãƒ¼ãƒ³æº–å‚™å®Œäº†ã€ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆé–‹å§‹")

		-- ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
		local fadeOut = TweenService:Create(background, TweenInfo.new(1, Enum.EasingStyle.Quad), {
			BackgroundTransparency = 1,
		})

		local labelFadeOut = TweenService:Create(loadingText, TweenInfo.new(1, Enum.EasingStyle.Quad), {
			TextTransparency = 1,
		})

		local imageFadeOut = TweenService:Create(imageLabel, TweenInfo.new(1, Enum.EasingStyle.Quad), {
			ImageTransparency = 1,
		})

		local hintFadeOut = TweenService:Create(hintText, TweenInfo.new(1, Enum.EasingStyle.Quad), {
			TextTransparency = 1,
		})

		fadeOut:Play()
		labelFadeOut:Play()
		imageFadeOut:Play()
		hintFadeOut:Play()

		fadeOut.Completed:Connect(function()
			screenGui:Destroy()
			print("[LoadingScreen] ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ç”»é¢ã‚’å‰Šé™¤")
		end)
	end)
else
	warn("[LoadingScreen] SpawnReadyã‚¤ãƒ™ãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
	-- ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼š3ç§’å¾Œã«è‡ªå‹•ã§æ¶ˆã™
	task.wait(3)
	screenGui:Destroy()
end

print("[LoadingScreen] åˆæœŸåŒ–å®Œäº†")

===== ./StartPlayerScripts/StatusUI.client.lua =====
-- StarterPlayer/StarterPlayerScripts/StatusUI.client.lua
-- ç”»é¢å·¦ä¸‹ã«å¸¸æ™‚è¡¨ç¤ºã™ã‚‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

print("[StatusUI] åˆæœŸåŒ–ä¸­...")

-- ç¾åœ¨ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
local currentHP = 100
local currentMaxHP = 100
local currentLevel = 1
local currentExp = 0
local currentExpToNext = 100
local currentGold = 0

-- UIè¦ç´ 
local statusGui = nil
local hpBarBackground = nil
local hpBarFill = nil
local hpLabel = nil
local levelLabel = nil
local expLabel = nil
local goldLabel = nil

-- HPã®è‰²ã‚’å–å¾—
local function getHPColor(hpPercent)
	if hpPercent > 0.6 then
		return Color3.fromRGB(46, 204, 113)  -- ç·‘
	elseif hpPercent > 0.3 then
		return Color3.fromRGB(241, 196, 15)  -- é»„è‰²
	else
		return Color3.fromRGB(231, 76, 60)  -- èµ¤
	end
end

-- è¡¨ç¤ºã‚’æ›´æ–°
local function updateDisplay()
	if hpBarFill and hpLabel then
		local hpPercent = currentHP / currentMaxHP

		-- ãƒãƒ¼ã®é•·ã•ã‚’ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
		local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
		local tween = TweenService:Create(hpBarFill, tweenInfo, {
			Size = UDim2.new(hpPercent, 0, 1, 0)
		})
		tween:Play()

		-- è‰²ã‚’å¤‰æ›´
		hpBarFill.BackgroundColor3 = getHPColor(hpPercent)

		-- ãƒ†ã‚­ã‚¹ãƒˆæ›´æ–°
		hpLabel.Text = string.format("%d / %d", currentHP, currentMaxHP)
	end

	if levelLabel then
		levelLabel.Text = string.format("Lv.%d", currentLevel)
	end

	if expLabel then
		expLabel.Text = string.format("EXP: %d / %d", currentExp, currentExpToNext)
	end

	if goldLabel then
		goldLabel.Text = string.format("ğŸ’° %d G", currentGold)
	end
end

-- UIä½œæˆ
local function createStatusUI()
	statusGui = Instance.new("ScreenGui")
	statusGui.Name = "StatusUI"
	statusGui.ResetOnSpawn = false
	statusGui.Parent = playerGui

	-- èƒŒæ™¯ãƒ•ãƒ¬ãƒ¼ãƒ 
	local backgroundFrame = Instance.new("Frame")
	backgroundFrame.Name = "StatusBackground"
	backgroundFrame.Size = UDim2.new(0, 250, 0, 120)
	backgroundFrame.Position = UDim2.new(1, -270, 1, -140)
	backgroundFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
	backgroundFrame.BackgroundTransparency = 0.3
	backgroundFrame.BorderSizePixel = 0
	backgroundFrame.Parent = statusGui

	-- è§’ã‚’ä¸¸ãã™ã‚‹
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 10)
	corner.Parent = backgroundFrame

	-- ãƒ¬ãƒ™ãƒ«è¡¨ç¤º
	levelLabel = Instance.new("TextLabel")
	levelLabel.Name = "LevelLabel"
	levelLabel.Size = UDim2.new(0, 80, 0, 25)
	levelLabel.Position = UDim2.new(0, 10, 0, 10)
	levelLabel.BackgroundTransparency = 1
	levelLabel.TextColor3 = Color3.fromRGB(255, 215, 0)
	levelLabel.TextStrokeTransparency = 0.5
	levelLabel.Font = Enum.Font.GothamBold
	levelLabel.TextSize = 20
	levelLabel.Text = "Lv.1"
	levelLabel.TextXAlignment = Enum.TextXAlignment.Left
	levelLabel.Parent = backgroundFrame

	-- HPãƒãƒ¼èƒŒæ™¯
	hpBarBackground = Instance.new("Frame")
	hpBarBackground.Name = "HPBarBackground"
	hpBarBackground.Size = UDim2.new(1, -20, 0, 20)
	hpBarBackground.Position = UDim2.new(0, 10, 0, 40)
	hpBarBackground.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
	hpBarBackground.BorderSizePixel = 0
	hpBarBackground.Parent = backgroundFrame

	-- HPãƒãƒ¼èƒŒæ™¯ã®è§’ã‚’ä¸¸ãã™ã‚‹
	local hpBarCorner = Instance.new("UICorner")
	hpBarCorner.CornerRadius = UDim.new(0, 5)
	hpBarCorner.Parent = hpBarBackground

	-- HPãƒãƒ¼ï¼ˆå¡—ã‚Šã¤ã¶ã—ï¼‰
	hpBarFill = Instance.new("Frame")
	hpBarFill.Name = "HPBarFill"
	hpBarFill.Size = UDim2.new(1, 0, 1, 0)
	hpBarFill.Position = UDim2.new(0, 0, 0, 0)
	hpBarFill.BackgroundColor3 = Color3.fromRGB(46, 204, 113)
	hpBarFill.BorderSizePixel = 0
	hpBarFill.Parent = hpBarBackground

	-- HPãƒãƒ¼ã®è§’ã‚’ä¸¸ãã™ã‚‹
	local hpFillCorner = Instance.new("UICorner")
	hpFillCorner.CornerRadius = UDim.new(0, 5)
	hpFillCorner.Parent = hpBarFill

	-- HPãƒ†ã‚­ã‚¹ãƒˆ
	hpLabel = Instance.new("TextLabel")
	hpLabel.Name = "HPLabel"
	hpLabel.Size = UDim2.new(1, 0, 1, 0)
	hpLabel.Position = UDim2.new(0, 0, 0, 0)
	hpLabel.BackgroundTransparency = 1
	hpLabel.TextColor3 = Color3.new(1, 1, 1)
	hpLabel.TextStrokeTransparency = 0.5
	hpLabel.Font = Enum.Font.GothamBold
	hpLabel.TextSize = 14
	hpLabel.Text = "100 / 100"
	hpLabel.Parent = hpBarBackground

	-- çµŒé¨“å€¤è¡¨ç¤º
	expLabel = Instance.new("TextLabel")
	expLabel.Name = "ExpLabel"
	expLabel.Size = UDim2.new(1, -20, 0, 18)
	expLabel.Position = UDim2.new(0, 10, 0, 65)
	expLabel.BackgroundTransparency = 1
	expLabel.TextColor3 = Color3.fromRGB(150, 200, 255)
	expLabel.TextStrokeTransparency = 0.7
	expLabel.Font = Enum.Font.Gotham
	expLabel.TextSize = 14
	expLabel.Text = "EXP: 0 / 100"
	expLabel.TextXAlignment = Enum.TextXAlignment.Left
	expLabel.Parent = backgroundFrame

	-- ã‚´ãƒ¼ãƒ«ãƒ‰è¡¨ç¤º
	goldLabel = Instance.new("TextLabel")
	goldLabel.Name = "GoldLabel"
	goldLabel.Size = UDim2.new(1, -20, 0, 18)
	goldLabel.Position = UDim2.new(0, 10, 0, 88)
	goldLabel.BackgroundTransparency = 1
	goldLabel.TextColor3 = Color3.fromRGB(255, 215, 0)
	goldLabel.TextStrokeTransparency = 0.7
	goldLabel.Font = Enum.Font.GothamBold
	goldLabel.TextSize = 14
	goldLabel.Text = "ğŸ’° 0 G"
	goldLabel.TextXAlignment = Enum.TextXAlignment.Left
	goldLabel.Parent = backgroundFrame

	print("[StatusUI] UIä½œæˆå®Œäº†")
end

-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°ã‚¤ãƒ™ãƒ³ãƒˆ
local function onStatusUpdate(hp, maxHP, level, exp, expToNext, gold)
	print(("[StatusUI] ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°å—ä¿¡: HP=%d/%d, Lv=%d, EXP=%d/%d, Gold=%d"):format(
		hp or 0, maxHP or 0, level or 0, exp or 0, expToNext or 0, gold or 0
		))

	currentHP = hp or currentHP
	currentMaxHP = maxHP or currentMaxHP
	currentLevel = level or currentLevel
	currentExp = exp or currentExp
	currentExpToNext = expToNext or currentExpToNext
	currentGold = gold or currentGold

	updateDisplay()
end

-- åˆæœŸåŒ–
createStatusUI()

print("[StatusUI] RemoteEventã‚’å¾…æ©Ÿä¸­...")

-- RemoteEventã‚’å¾…æ©Ÿï¼ˆæœ€å¤§30ç§’ï¼‰
task.spawn(function()
	local StatusUpdateEvent = ReplicatedStorage:WaitForChild("StatusUpdate", 10)
	if StatusUpdateEvent then
		StatusUpdateEvent.OnClientEvent:Connect(onStatusUpdate)
		print("[StatusUI] StatusUpdateã‚¤ãƒ™ãƒ³ãƒˆæ¥ç¶šå®Œäº†")

		-- åˆå›ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¦æ±‚
		task.wait(1)  -- 1ç§’å¾…ã£ã¦ã‹ã‚‰è¦æ±‚
		local RequestStatusEvent = ReplicatedStorage:FindFirstChild("RequestStatus")
		if RequestStatusEvent then
			print("[StatusUI] åˆå›ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’è¦æ±‚")
			RequestStatusEvent:FireServer()
		else
			warn("[StatusUI] RequestStatusã‚¤ãƒ™ãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
		end
	else
		warn("[StatusUI] StatusUpdateã‚¤ãƒ™ãƒ³ãƒˆã®å¾…æ©ŸãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸ")
	end
end)

print("[StatusUI] åˆæœŸåŒ–å®Œäº†")
===== ./StartPlayerScripts/WarpUI.client.lua =====
-- ===== ./StartPlayerScripts/WarpUI.client.lua =====
-- StarterPlayer/StarterPlayerScripts/WarpUI.client.lua
-- ãƒ¯ãƒ¼ãƒ—æ™‚ã®ãƒ­ãƒ¼ãƒ‰ç”»é¢

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- RemoteEventã‚’å–å¾— - ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’çŸ­ãè¨­å®š
local warpEvent = ReplicatedStorage:WaitForChild("WarpEvent", 5) -- â˜…ä¿®æ­£: ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’5ç§’ã«è¨­å®š

if not warpEvent then
    warn("[WarpUI] WarpEventãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚ãƒ¯ãƒ¼ãƒ—UIã¯æ©Ÿèƒ½ã—ã¾ã›ã‚“ã€‚")
    return
end

print("[WarpUI] åˆæœŸåŒ–å®Œäº†")

-- ãƒ­ãƒ¼ãƒ‰ç”»é¢ã®UI
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "WarpLoadingUI"
screenGui.ResetOnSpawn = false
screenGui.IgnoreGuiInset = true
screenGui.Parent = playerGui

local frame = Instance.new("Frame")
frame.Name = "LoadingFrame"
frame.Size = UDim2.new(1, 0, 1, 0)
frame.BackgroundColor3 = Color3.new(0, 0, 0)
frame.BackgroundTransparency = 1
frame.Visible = false
frame.Parent = screenGui

local label = Instance.new("TextLabel")
label.Size = UDim2.new(0.6, 0, 0.2, 0)
label.Position = UDim2.new(0.2, 0, 0.4, 0)
label.BackgroundTransparency = 1
label.Text = "Loading..."
label.TextColor3 = Color3.new(1, 1, 1)
label.TextScaled = true
label.Font = Enum.Font.SourceSansBold
label.Parent = frame

-- RemoteEventã‚’å—ä¿¡
warpEvent.OnClientEvent:Connect(function(action, zoneName)
	if action == "StartLoading" then
		print("[WarpUI] ãƒ­ãƒ¼ãƒ‰ç”»é¢è¡¨ç¤º:", zoneName)
		label.Text = "Warping to " .. (zoneName or "???") .. "..."
		frame.BackgroundTransparency = 0.3
		frame.Visible = true

		-- ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
		for i = 0.3, 0.7, 0.1 do
			frame.BackgroundTransparency = 1 - i
			task.wait(0.05)
		end

	elseif action == "EndLoading" then
		print("[WarpUI] ãƒ­ãƒ¼ãƒ‰ç”»é¢éè¡¨ç¤º")

		-- ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
		for i = 0.7, 0, -0.1 do
			frame.BackgroundTransparency = 1 - i
			task.wait(0.05)
		end

		frame.Visible = false
	end
end)
===== ./StartPlayerScripts/LoadingUI.client.lua =====
-- StartPlayerScripts/LoadingUI.client.lua
-- ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ç”»é¢ã®è¡¨ç¤ºãƒ»éè¡¨ç¤ºåˆ¶å¾¡ï¼ˆãƒ‡ãƒãƒƒã‚°ç‰ˆï¼‰

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

print("[LoadingUI] åˆæœŸåŒ–é–‹å§‹")

-- ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ç”»åƒã® Asset ID ãƒªã‚¹ãƒˆ
local LoadingImages = {
	"rbxassetid://74049529220513",
	"rbxassetid://139010932520933",
	"rbxassetid://140175964173817",
	"rbxassetid://117367461463003",
	"rbxassetid://109768764700057",
}

-- LoadingHints ã‚’èª­ã¿è¾¼ã¿
local LoadingHints = require(ReplicatedStorage:WaitForChild("LoadingHints"))

-- ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚° UI ã‚’ä½œæˆ
local function createLoadingScreen()
	local screenGui = Instance.new("ScreenGui")
	screenGui.Name = "LoadingScreen"
	screenGui.ResetOnSpawn = false
	screenGui.IgnoreGuiInset = true
	screenGui.Parent = playerGui

	-- èƒŒæ™¯ï¼ˆå…¨ç”»é¢é»’ï¼‰
	local background = Instance.new("Frame")
	background.Name = "Background"
	background.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	background.BackgroundTransparency = 0
	background.Size = UDim2.fromScale(1, 1)
	background.Position = UDim2.fromScale(0, 0)
	background.ZIndex = 1
	background.Parent = screenGui

	-- ç”»åƒè¡¨ç¤ºã‚¨ãƒªã‚¢
	local imageLabel = Instance.new("ImageLabel")
	imageLabel.Name = "LoadingImage"
	imageLabel.BackgroundTransparency = 1
	imageLabel.Size = UDim2.fromOffset(600, 450)
	imageLabel.Position = UDim2.fromScale(0.5, 0.35)
	imageLabel.AnchorPoint = Vector2.new(0.5, 0.5)
	imageLabel.ScaleType = Enum.ScaleType.Fit
	imageLabel.ZIndex = 2
	imageLabel.Parent = background

	-- "Now Loading..." ãƒ†ã‚­ã‚¹ãƒˆ
	local loadingText = Instance.new("TextLabel")
	loadingText.Name = "LoadingText"
	loadingText.Text = "Now Loading..."
	loadingText.Font = Enum.Font.GothamBold
	loadingText.TextSize = 56
	loadingText.TextColor3 = Color3.fromRGB(255, 255, 255)
	loadingText.BackgroundTransparency = 1
	loadingText.Size = UDim2.fromOffset(500, 70)
	loadingText.Position = UDim2.fromScale(0.5, 0.75)
	loadingText.AnchorPoint = Vector2.new(0.5, 0.5)
	loadingText.ZIndex = 2
	loadingText.Parent = background

	-- ãƒ’ãƒ³ãƒˆãƒ†ã‚­ã‚¹ãƒˆï¼ˆã‚·ãƒ³ãƒ—ãƒ«ç‰ˆï¼šèƒŒæ™¯ãªã—ï¼‰
	local hintText = Instance.new("TextLabel")
	hintText.Name = "HintText"
	hintText.Text = ""
	hintText.Font = Enum.Font.Gotham
	hintText.TextSize = 24
	hintText.TextColor3 = Color3.fromRGB(255, 255, 100) -- é»„è‰²ã§ãƒã‚¤ãƒ©ã‚¤ãƒˆ
	hintText.BackgroundTransparency = 1
	hintText.TextWrapped = true
	hintText.TextScaled = true
	hintText.Size = UDim2.fromOffset(800, 100)
	hintText.Position = UDim2.fromScale(0.5, 0.88)
	hintText.AnchorPoint = Vector2.new(0.5, 0.5)
	hintText.ZIndex = 2
	hintText.Parent = background

	-- ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ï¼ˆç¸å–ã‚Šï¼‰ã‚’è¿½åŠ 
	hintText.TextStrokeTransparency = 0.5
	hintText.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)

	-- åˆæœŸçŠ¶æ…‹ã¯éè¡¨ç¤º
	screenGui.Enabled = false

	print("[LoadingUI] ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ç”»é¢ã‚’ä½œæˆã—ã¾ã—ãŸ")

	local loadingScreenObj = {}
	loadingScreenObj.screenGui = screenGui
	loadingScreenObj.imageLabel = imageLabel
	loadingScreenObj.hintText = hintText

	function loadingScreenObj:show(playerLevel)
		print("[LoadingUI] show() å‘¼ã³å‡ºã—é–‹å§‹")

		playerLevel = playerLevel or 1
		print("[LoadingUI] playerLevel: " .. tostring(playerLevel))

		-- ãƒ©ãƒ³ãƒ€ãƒ ã«ç”»åƒã‚’é¸æŠã—ã¦ã‚»ãƒƒãƒˆ
		if #LoadingImages > 0 then
			local randomImage = LoadingImages[math.random(#LoadingImages)]
			self.imageLabel.Image = randomImage
			print("[LoadingUI] ç”»åƒã‚’ã‚»ãƒƒãƒˆ: " .. randomImage)
		else
			print("[LoadingUI] è­¦å‘Š: LoadingImages ãŒç©ºã§ã™")
		end

		-- ãƒ’ãƒ³ãƒˆå–å¾—
		print("[LoadingUI] ãƒ’ãƒ³ãƒˆå–å¾—ä¸­...")
		local hint = LoadingHints.getHintByLevel(playerLevel)
		print("[LoadingUI] ãƒ’ãƒ³ãƒˆå–å¾—å®Œäº†: " .. tostring(hint))

		-- ãƒ’ãƒ³ãƒˆãƒ†ã‚­ã‚¹ãƒˆã‚’ã‚»ãƒƒãƒˆ
		self.hintText.Text = "ğŸ’¡ " .. hint
		print("[LoadingUI] hintText ã‚’ã‚»ãƒƒãƒˆå®Œäº†: " .. self.hintText.Text)

		-- è¡¨ç¤º
		self.screenGui.Enabled = true
		print("[LoadingUI] screenGui ã‚’è¡¨ç¤º")
	end

	function loadingScreenObj:hide()
		self.screenGui.Enabled = false
		self.imageLabel.Image = ""
		self.hintText.Text = ""
		print("[LoadingUI] ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ç”»é¢ã‚’éè¡¨ç¤º")
	end

	return loadingScreenObj
end

local loadingScreen = createLoadingScreen()

-- ãƒ¯ãƒ¼ãƒ—ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆWarpPortal çµŒç”±ï¼‰
local warpEvent = ReplicatedStorage:WaitForChild("WarpEvent")
warpEvent.OnClientEvent:Connect(function(action, zoneName, playerLevel)
	print(
		"[LoadingUI] warpEvent å—ä¿¡: action="
			.. tostring(action)
			.. ", zoneName="
			.. tostring(zoneName)
			.. ", playerLevel="
			.. tostring(playerLevel)
	)

	if action == "StartLoading" then
		print(("[LoadingUI] ãƒ¯ãƒ¼ãƒ—é–‹å§‹: %s (ãƒ¬ãƒ™ãƒ«: %d)"):format(zoneName or "Unknown", playerLevel or 1))
		loadingScreen:show(playerLevel or 1)
	elseif action == "EndLoading" then
		print(("[LoadingUI] ãƒ¯ãƒ¼ãƒ—å®Œäº†: %s"):format(zoneName or "Unknown"))
		task.wait(0.5)
		loadingScreen:hide()
	end
end)

-- ãƒ•ã‚¡ã‚¹ãƒˆãƒˆãƒ©ãƒ™ãƒ«ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆFastTravelSystem çµŒç”±ï¼‰
local fastTravelEvent = ReplicatedStorage:WaitForChild("FastTravelEvent")
fastTravelEvent.OnClientEvent:Connect(function(action, zoneName, playerLevel)
	print(
		"[LoadingUI] fastTravelEvent å—ä¿¡: action="
			.. tostring(action)
			.. ", zoneName="
			.. tostring(zoneName)
			.. ", playerLevel="
			.. tostring(playerLevel)
	)

	if action == "StartLoading" then
		print(
			("[LoadingUI] ãƒ•ã‚¡ã‚¹ãƒˆãƒˆãƒ©ãƒ™ãƒ«é–‹å§‹: %s (ãƒ¬ãƒ™ãƒ«: %d)"):format(
				zoneName or "Unknown",
				playerLevel or 1
			)
		)
		loadingScreen:show(playerLevel or 1)
	elseif action == "EndLoading" then
		print(("[LoadingUI] ãƒ•ã‚¡ã‚¹ãƒˆãƒˆãƒ©ãƒ™ãƒ«å®Œäº†: %s"):format(zoneName or "Unknown"))
		task.wait(0.5)
		loadingScreen:hide()
	end
end)

print("[LoadingUI] åˆæœŸåŒ–å®Œäº†")

-- ãƒ‡ãƒãƒƒã‚°ãƒ†ã‚¹ãƒˆ
print("[LoadingUI] loadingScreen ã®å‹: " .. type(loadingScreen))
print("[LoadingUI] loadingScreen.show ã®å‹: " .. type(loadingScreen.show))
if loadingScreen.show then
	print("[LoadingUI] show ãƒ¡ã‚½ãƒƒãƒ‰ã¯å­˜åœ¨ã—ã¾ã™")
else
	print("[LoadingUI] ERROR: show ãƒ¡ã‚½ãƒƒãƒ‰ãŒå­˜åœ¨ã—ã¾ã›ã‚“ï¼ï¼ï¼")
end

-- ç›´æ¥å‘¼ã³å‡ºã—
pcall(function()
	loadingScreen:show(5)
end)

===== ./StartPlayerScripts/DeathUI.client.lua =====
-- StarterPlayer/StarterPlayerScripts/DeathUI.client.lua
-- æ­»äº¡æ™‚ã®é¸æŠUIï¼ˆè¡—ã«æˆ»ã‚‹ / ã‚´ãƒ¼ãƒ«ãƒ‰ãƒ­ã‚¹ãƒˆã§å¾©æ´»ï¼‰

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

print("[DeathUI] åˆæœŸåŒ–ä¸­...")

-- UIè¦ç´ 
local deathGui = nil

-- æ­»äº¡UIã‚’è¡¨ç¤º
local function showDeathUI(currentGold, reviveCost)
	print(("[DeathUI] ========================================"):format())
	print(("[DeathUI] æ­»äº¡UIè¡¨ç¤º"):format())
	print(("[DeathUI] æ‰€æŒé‡‘: %d G, å¾©æ´»ã‚³ã‚¹ãƒˆ: %d G"):format(currentGold, reviveCost))
	print(("[DeathUI] ========================================"):format())

	-- æ—¢å­˜ã®GUIã‚’å‰Šé™¤
	if deathGui then
		deathGui:Destroy()
	end

	-- æ–°ã—ã„GUIã‚’ä½œæˆ
	deathGui = Instance.new("ScreenGui")
	deathGui.Name = "DeathUI"
	deathGui.ResetOnSpawn = false
	deathGui.Parent = playerGui

	-- èƒŒæ™¯ï¼ˆæš—ã„ï¼‰
	local background = Instance.new("Frame")
	background.Size = UDim2.fromScale(1, 1)
	background.Position = UDim2.fromScale(0, 0)
	background.BackgroundColor3 = Color3.new(0, 0, 0)
	background.BackgroundTransparency = 0.3
	background.BorderSizePixel = 0
	background.ZIndex = 200
	background.Parent = deathGui

	-- ã‚¿ã‚¤ãƒˆãƒ«
	local titleText = Instance.new("TextLabel")
	titleText.Size = UDim2.new(0, 600, 0, 80)
	titleText.Position = UDim2.new(0.5, -300, 0.3, 0)
	titleText.BackgroundTransparency = 1
	titleText.TextColor3 = Color3.fromRGB(255, 100, 100)
	titleText.TextStrokeTransparency = 0
	titleText.Font = Enum.Font.GothamBold
	titleText.TextSize = 50
	titleText.Text = "YOU DIED"
	titleText.ZIndex = 201
	titleText.Parent = deathGui

	-- é¸æŠãƒ•ãƒ¬ãƒ¼ãƒ 
	local choiceFrame = Instance.new("Frame")
	choiceFrame.Size = UDim2.new(0, 600, 0, 200)
	choiceFrame.Position = UDim2.new(0.5, -300, 0.45, 0)
	choiceFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
	choiceFrame.BackgroundTransparency = 0.2
	choiceFrame.BorderSizePixel = 0
	choiceFrame.ZIndex = 201
	choiceFrame.Parent = deathGui

	-- è§’ã‚’ä¸¸ãã™ã‚‹
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 10)
	corner.Parent = choiceFrame

	-- èª¬æ˜ãƒ†ã‚­ã‚¹ãƒˆ
	local descText = Instance.new("TextLabel")
	descText.Size = UDim2.new(1, -40, 0, 60)
	descText.Position = UDim2.new(0, 20, 0, 20)
	descText.BackgroundTransparency = 1
	descText.TextColor3 = Color3.fromRGB(255, 255, 255)
	descText.TextStrokeTransparency = 0.5
	descText.Font = Enum.Font.Gotham
	descText.TextSize = 18
	descText.Text = "æ•—åŒ—ã—ã¾ã—ãŸã€‚ã©ã†ã—ã¾ã™ã‹ï¼Ÿ"
	descText.TextWrapped = true
	descText.ZIndex = 202
	descText.Parent = choiceFrame

	-- ã€Œè¡—ã«æˆ»ã‚‹ã€ãƒœã‚¿ãƒ³
	local returnButton = Instance.new("TextButton")
	returnButton.Size = UDim2.new(0, 250, 0, 50)
	returnButton.Position = UDim2.new(0.5, -260, 0, 100)
	returnButton.BackgroundColor3 = Color3.fromRGB(52, 152, 219)
	returnButton.BorderSizePixel = 0
	returnButton.Font = Enum.Font.GothamBold
	returnButton.TextSize = 20
	returnButton.Text = "ğŸ  è¡—ã«æˆ»ã‚‹"
	returnButton.TextColor3 = Color3.new(1, 1, 1)
	returnButton.ZIndex = 202
	returnButton.Parent = choiceFrame

	-- ãƒœã‚¿ãƒ³ã®è§’ã‚’ä¸¸ãã™ã‚‹
	local returnCorner = Instance.new("UICorner")
	returnCorner.CornerRadius = UDim.new(0, 8)
	returnCorner.Parent = returnButton

	-- ã€Œã‚´ãƒ¼ãƒ«ãƒ‰ã§å¾©æ´»ã€ãƒœã‚¿ãƒ³
	local reviveButton = Instance.new("TextButton")
	reviveButton.Size = UDim2.new(0, 250, 0, 50)
	reviveButton.Position = UDim2.new(0.5, 10, 0, 100)
	reviveButton.BorderSizePixel = 0
	reviveButton.Font = Enum.Font.GothamBold
	reviveButton.TextSize = 20
	reviveButton.TextColor3 = Color3.new(1, 1, 1)
	reviveButton.ZIndex = 202
	reviveButton.Parent = choiceFrame

	-- ãƒœã‚¿ãƒ³ã®è§’ã‚’ä¸¸ãã™ã‚‹
	local reviveCorner = Instance.new("UICorner")
	reviveCorner.CornerRadius = UDim.new(0, 8)
	reviveCorner.Parent = reviveButton

	-- ã‚´ãƒ¼ãƒ«ãƒ‰ãŒè¶³ã‚Šã‚‹ã‹ãƒã‚§ãƒƒã‚¯
	if currentGold >= reviveCost then
		reviveButton.BackgroundColor3 = Color3.fromRGB(46, 204, 113)
		reviveButton.Text = string.format("ğŸ’° å¾©æ´» (%d G)", reviveCost)
	else
		reviveButton.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
		reviveButton.Text = string.format("ğŸ’° å¾©æ´» (%d G) - ä¸è¶³", reviveCost)
		reviveButton.Active = false
	end

	-- ãƒœã‚¿ãƒ³ã®ãƒ›ãƒãƒ¼ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
	returnButton.MouseEnter:Connect(function()
		returnButton.BackgroundColor3 = Color3.fromRGB(62, 172, 239)
	end)
	returnButton.MouseLeave:Connect(function()
		returnButton.BackgroundColor3 = Color3.fromRGB(52, 152, 219)
	end)

	if currentGold >= reviveCost then
		reviveButton.MouseEnter:Connect(function()
			reviveButton.BackgroundColor3 = Color3.fromRGB(56, 224, 133)
		end)
		reviveButton.MouseLeave:Connect(function()
			reviveButton.BackgroundColor3 = Color3.fromRGB(46, 204, 113)
		end)
	end

	-- ã€Œè¡—ã«æˆ»ã‚‹ã€ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯
	returnButton.MouseButton1Click:Connect(function()
		print("[DeathUI] è¡—ã«æˆ»ã‚‹ã‚’é¸æŠ")

		-- ã‚µãƒ¼ãƒãƒ¼ã«é€šçŸ¥
		local DeathChoiceEvent = ReplicatedStorage:FindFirstChild("DeathChoice")
		if DeathChoiceEvent then
			DeathChoiceEvent:FireServer("return")
		end

		-- ãƒãƒˆãƒ«UIã‚’é–‰ã˜ã‚‹
		local battleUI = playerGui:FindFirstChild("BattleUI")
		if battleUI then
			battleUI.Enabled = false
		end

		-- ã‚·ã‚¹ãƒ†ãƒ ã‚­ãƒ¼ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’è§£é™¤
		local ContextActionService = game:GetService("ContextActionService")
		ContextActionService:UnbindAction("BlockSystemKeys")

		-- Roblox UIã‚’å†æœ‰åŠ¹åŒ–
		local StarterGui = game:GetService("StarterGui")
		pcall(function()
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Chat, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.EmotesMenu, true)
		end)

		-- UIã‚’é–‰ã˜ã‚‹
		if deathGui then
			deathGui:Destroy()
			deathGui = nil
		end
	end)

	-- ã€Œã‚´ãƒ¼ãƒ«ãƒ‰ã§å¾©æ´»ã€ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯
	reviveButton.MouseButton1Click:Connect(function()
		if currentGold < reviveCost then
			print("[DeathUI] ã‚´ãƒ¼ãƒ«ãƒ‰ä¸è¶³")
			return
		end

		print("[DeathUI] ã‚´ãƒ¼ãƒ«ãƒ‰ã§å¾©æ´»ã‚’é¸æŠ")

		-- ã‚µãƒ¼ãƒãƒ¼ã«é€šçŸ¥
		local DeathChoiceEvent = ReplicatedStorage:FindFirstChild("DeathChoice")
		if DeathChoiceEvent then
			DeathChoiceEvent:FireServer("revive")
		end

		-- ãƒãƒˆãƒ«UIã‚’é–‰ã˜ã‚‹
		local battleUI = playerGui:FindFirstChild("BattleUI")
		if battleUI then
			battleUI.Enabled = false
		end

		-- ã‚·ã‚¹ãƒ†ãƒ ã‚­ãƒ¼ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’è§£é™¤
		local ContextActionService = game:GetService("ContextActionService")
		ContextActionService:UnbindAction("BlockSystemKeys")

		-- Roblox UIã‚’å†æœ‰åŠ¹åŒ–
		local StarterGui = game:GetService("StarterGui")
		pcall(function()
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Chat, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.EmotesMenu, true)
		end)

		-- UIã‚’é–‰ã˜ã‚‹
		if deathGui then
			deathGui:Destroy()
			deathGui = nil
		end
	end)
end

-- RemoteEventã‚’å¾…æ©Ÿ
local ShowDeathUIEvent = ReplicatedStorage:WaitForChild("ShowDeathUI", 10)
if ShowDeathUIEvent then
	ShowDeathUIEvent.OnClientEvent:Connect(showDeathUI)
	print("[DeathUI] ShowDeathUIã‚¤ãƒ™ãƒ³ãƒˆæ¥ç¶šå®Œäº†")
else
	warn("[DeathUI] ShowDeathUIã‚¤ãƒ™ãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
end

print("[DeathUI] åˆæœŸåŒ–å®Œäº†")
===== ./StartPlayerScripts/BGMManager.client.lua =====
-- StarterPlayer/StarterPlayerScripts/BGMManager.client.lua
-- å¤§é™¸BGMç®¡ç†ã‚·ã‚¹ãƒ†ãƒ  (ãƒãƒˆãƒ«ä¸­ã®éŸ³é‡èª¿æ•´å¯¾å¿œç‰ˆ)

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local SoundService = game:GetService("SoundService")
local TweenService = game:GetService("TweenService") -- TweenServiceã‚’è¿½åŠ 

local player = Players.LocalPlayer

-- å¤§é™¸æƒ…å ±ã‚’èª­ã¿è¾¼ã¿
local ContinentsRegistry = require(ReplicatedStorage.Continents.Registry)
local Continents = {}
for _, continent in ipairs(ContinentsRegistry) do
	Continents[continent.name] = continent
end

-- BGMçŠ¶æ…‹
local currentBGM = nil
local currentZone = nil
local isBattleActive = false
local bgmSound = nil
local originalVolume = 0.3 -- ã€è¿½åŠ ãƒ»ä¿®æ­£1ã€‘å…ƒã®éŸ³é‡ã‚’ä¿æŒã™ã‚‹å¤‰æ•°ã‚’è¿½åŠ ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ 0.3ï¼‰

-- === User Settings bridge ===
local function getAttrNum(name, default)
	local v = Players.LocalPlayer:GetAttribute(name)
	return (type(v) == "number") and v or default
end

-- SE/BGMã®åæ˜ ï¼ˆSEã¯SoundServiceå…¨ä½“ã€BGMã¯bgmSoundã«é©ç”¨ï¼‰
local function applyVolumes()
	local se = getAttrNum("SEVolume", 1.0)
	local bgm = getAttrNum("BGMVolume", 1.0)

	SoundService.Volume = se

	-- BGMã¯ isBattleActive ä¸­ã¯ãƒ‡ã‚£ãƒŸãƒ³ã‚°ä¿‚æ•°(0.3)ãŒä¹—ã‚‹
	if bgmSound then
		local base = originalVolume -- originalVolume ã¯ createBGMSound ã§æ›´æ–°
		local dim = isBattleActive and 0.3 or 1.0
		bgmSound.Volume = base * dim
	end
end

-- BGMã‚µã‚¦ãƒ³ãƒ‰ã‚’ä½œæˆ
local function createBGMSound(assetId, volume)
	if bgmSound then
		bgmSound:Stop()
		bgmSound:Destroy()
	end

	bgmSound = Instance.new("Sound")
	bgmSound.Name = "BGM"
	bgmSound.SoundId = assetId

	-- ã€ä¿®æ­£2ã€‘éŸ³é‡ã‚’è¨­å®šã—ã€originalVolumeã‚’æ›´æ–°
	local userBGM = tonumber(Players.LocalPlayer:GetAttribute("BGMVolume")) or 1.0
	local finalVolume = (volume or 0.3) * userBGM
	bgmSound.Volume = finalVolume
	originalVolume = finalVolume

	bgmSound.Looped = true
	bgmSound.Parent = SoundService

	return bgmSound
end

-- BGMã‚’å†ç”Ÿ
local function playBGM(assetId, volume)
	if currentBGM == assetId and bgmSound and bgmSound.IsPlaying and not isBattleActive then
		-- æ—¢ã«åŒã˜BGMãŒå†ç”Ÿä¸­ã§ã€æˆ¦é—˜ä¸­ã§ãªã‘ã‚Œã°ä½•ã‚‚ã—ãªã„
		return
	end

	print(("[BGMManager] BGMå†ç”Ÿ: %s, Volume: %.2f"):format(assetId, volume or 0.3))

	currentBGM = assetId
	local sound = createBGMSound(assetId, volume)
	sound:Play()

	-- æ–°ã—ãå†ç”Ÿã™ã‚‹BGMãŒæˆ¦é—˜ä¸­ã«åˆ‡ã‚Šæ›¿ã‚ã£ãŸå ´åˆã€éŸ³é‡ã‚’ä¸‹ã’ã‚‹
	if isBattleActive and bgmSound then
		bgmSound.Volume = originalVolume * 0.3
	end
end

-- BGMã‚’åœæ­¢
local function stopBGM()
	if bgmSound then
		print("[BGMManager] BGMåœæ­¢")

		-- ã€ä¿®æ­£3ã€‘Tweenã‚’ä½¿ã£ã¦ã‚¹ãƒ ãƒ¼ã‚ºã«åœæ­¢
		TweenService:Create(bgmSound, TweenInfo.new(0.5), {
			Volume = 0,
		}):Play()

		task.delay(0.5, function()
			-- 0.5ç§’å¾Œã€éŸ³é‡ãŒ0ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¦åœæ­¢ãƒ»å‰Šé™¤
			if bgmSound and bgmSound.Volume == 0 then
				bgmSound:Stop()
				bgmSound:Destroy()
				bgmSound = nil -- å‚ç…§ã‚’ã‚¯ãƒªã‚¢
			end
		end)
	end
	currentBGM = nil
end

-- ã‚¾ãƒ¼ãƒ³å¤‰æ›´æ™‚ã®BGMå‡¦ç†
local function onZoneChange(zoneName, isActive)
	if isActive then
		-- ã‚¾ãƒ¼ãƒ³ã«å…¥ã£ãŸ
		currentZone = zoneName

		-- å¤§é™¸ã®BGMè¨­å®šã‚’å–å¾—
		local continent = Continents[zoneName]
		if continent and continent.BGM then
			-- BGMVolumeã‚’playBGMã«æ¸¡ã—ã¦ã€originalVolumeã«ä¿å­˜ã•ã›ã‚‹
			playBGM(continent.BGM, continent.BGMVolume or 0.3)
		else
			-- BGMè¨­å®šãŒãªã„å ´åˆã¯åœæ­¢
			stopBGM()
		end
	else
		-- ã‚¾ãƒ¼ãƒ³ã‹ã‚‰å‡ºãŸå ´åˆã‚‚BGMã‚’åœæ­¢
		if currentZone == zoneName then
			stopBGM()
			currentZone = nil
		end
	end
end

-- ãƒãƒˆãƒ«é–‹å§‹ã‚¤ãƒ™ãƒ³ãƒˆ
local BattleStartEvent = ReplicatedStorage:WaitForChild("BattleStart", 10)
if BattleStartEvent then
	BattleStartEvent.OnClientEvent:Connect(function()
		print("[BGMManager] ãƒãƒˆãƒ«é–‹å§‹ã‚’æ¤œçŸ¥")
		isBattleActive = true

		-- ã€ä¿®æ­£4ã€‘BGMã‚’åœæ­¢ã›ãšã€éŸ³é‡ã‚’50%ã«ä¸‹ã’ã‚‹
		if bgmSound and bgmSound.IsPlaying then
			local targetVolume = originalVolume * 0.3 -- å…ƒã®éŸ³é‡ã®50%
			print(("[BGMManager] BGMéŸ³é‡ã‚’ %.2f ã‹ã‚‰ %.2f ã«èª¿æ•´"):format(bgmSound.Volume, targetVolume))
			TweenService:Create(bgmSound, TweenInfo.new(0.5), {
				Volume = targetVolume,
			}):Play()
		end
	end)
end

-- ãƒãƒˆãƒ«çµ‚äº†ã‚¤ãƒ™ãƒ³ãƒˆ
local BattleEndEvent = ReplicatedStorage:WaitForChild("BattleEnd", 10)
if BattleEndEvent then
	BattleEndEvent.OnClientEvent:Connect(function()
		print("[BGMManager] ãƒãƒˆãƒ«çµ‚äº†ã‚’æ¤œçŸ¥")
		isBattleActive = false

		-- ã€ä¿®æ­£5ã€‘BGMã‚’å…ƒã®éŸ³é‡ã«æˆ»ã™
		if bgmSound and bgmSound.IsPlaying then
			print(("[BGMManager] BGMéŸ³é‡ã‚’ %.2f ã«æˆ»ã™"):format(originalVolume))
			TweenService:Create(bgmSound, TweenInfo.new(0.5), {
				Volume = originalVolume,
			}):Play()
		end
	end)
end

-- ã‚¾ãƒ¼ãƒ³å¤‰æ›´ã‚’ç›£è¦–
task.spawn(function()
	local ZoneChangeEvent = ReplicatedStorage:FindFirstChild("ZoneChange")
	if not ZoneChangeEvent then
		warn("[BGMManager] ZoneChangeã‚¤ãƒ™ãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
		return
	end

	ZoneChangeEvent.OnClientEvent:Connect(function(zoneName, isActive)
		print(("[BGMManager] ã‚¾ãƒ¼ãƒ³å¤‰æ›´: %s - %s"):format(zoneName, isActive and "å…¥ã£ãŸ" or "å‡ºãŸ"))
		onZoneChange(zoneName, isActive)
	end)

	-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å±æ€§ã®å¤‰åŒ–ã‚’ç›£è¦–ã—ã¦éšæ™‚åæ˜ 
	Players.LocalPlayer:GetAttributeChangedSignal("SEVolume"):Connect(applyVolumes)
	Players.LocalPlayer:GetAttributeChangedSignal("BGMVolume"):Connect(function()
		-- originalVolume ã¯ createBGMSound æ™‚ã«æ›´æ–°æ¸ˆã¿ãªã®ã§ã€
		-- ã“ã“ã§ã¯ç¾åœ¨ã® originalVolume ã‚’ä½¿ã£ã¦éŸ³é‡ã ã‘å†é©ç”¨
		applyVolumes()
	end)

	print("[BGMManager] ZoneChangeã‚¤ãƒ™ãƒ³ãƒˆæ¥ç¶šå®Œäº†")
end)

applyVolumes()
print("[BGMManager] åˆæœŸåŒ–å®Œäº†")

===== ./StartPlayerScripts/InteractionUI.client.lua =====
-- StarterPlayer/StarterPlayerScripts/InteractionUI.client.lua
-- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³æ¤œå‡ºã¨UIãƒœã‚¿ãƒ³è¡¨ç¤º

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

print("[InteractionUI] åˆæœŸåŒ–é–‹å§‹")

-- RemoteEventå–å¾—
local InteractEvent = ReplicatedStorage:WaitForChild("InteractEvent", 10)
if not InteractEvent then
	warn("[InteractionUI] InteractEventãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
	return
end

-- RemoteFunctionã§å–å¾—æ¸ˆã¿ãƒªã‚¹ãƒˆã‚’å–å¾—
local GetCollectedItemsFunc = ReplicatedStorage:FindFirstChild("GetCollectedItems")
if not GetCollectedItemsFunc then
	GetCollectedItemsFunc = Instance.new("RemoteFunction")
	GetCollectedItemsFunc.Name = "GetCollectedItems"
	GetCollectedItemsFunc.Parent = ReplicatedStorage
end

-- ç¾åœ¨ã®ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³å¯¾è±¡
local currentTarget = nil
local currentButton = nil

-- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³æ¸ˆã¿ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¨˜éŒ²
local interactedObjects = {}

-- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³UIä½œæˆ
local function createInteractionButton(targetObject, actionText, key)
	-- æ—¢å­˜ã®ãƒœã‚¿ãƒ³ã‚’å‰Šé™¤
	if currentButton then
		currentButton:Destroy()
		currentButton = nil
	end

	-- ScreenGuiã«é…ç½®ï¼ˆç”»é¢ä¸­å¤®ä¸‹éƒ¨ï¼‰
	local screenGui = playerGui:FindFirstChild("InteractionButtonGui")
	if not screenGui then
		screenGui = Instance.new("ScreenGui")
		screenGui.Name = "InteractionButtonGui"
		screenGui.ResetOnSpawn = false
		screenGui.DisplayOrder = 150
		screenGui.Parent = playerGui
	end

	-- èƒŒæ™¯ãƒ•ãƒ¬ãƒ¼ãƒ 
	local frame = Instance.new("Frame")
	frame.Name = "InteractionFrame"
	frame.Size = UDim2.new(0, 250, 0, 60)
	frame.Position = UDim2.new(0.5, -125, 0.85, 0) -- ç”»é¢ä¸‹éƒ¨ä¸­å¤®
	frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	frame.BackgroundTransparency = 0.3
	frame.BorderSizePixel = 0
	frame.Parent = screenGui

	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 12)
	corner.Parent = frame

	-- ãƒœã‚¿ãƒ³
	local button = Instance.new("TextButton")
	button.Size = UDim2.new(0.9, 0, 0.7, 0)
	button.Position = UDim2.new(0.05, 0, 0.15, 0)
	button.BackgroundColor3 = Color3.fromRGB(255, 200, 100)
	button.BackgroundTransparency = 0.2
	button.BorderSizePixel = 2
	button.BorderColor3 = Color3.new(1, 1, 1)
	button.Text = string.format("%s [%s]", actionText, key)
	button.TextColor3 = Color3.new(0, 0, 0)
	button.TextSize = 20
	button.Font = Enum.Font.SourceSansBold
	button.AutoButtonColor = true
	button.Parent = frame

	local buttonCorner = Instance.new("UICorner")
	buttonCorner.CornerRadius = UDim.new(0, 8)
	buttonCorner.Parent = button

	-- ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯
	button.MouseButton1Click:Connect(function()
		print("[InteractionUI DEBUG] ===== ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆç™ºç« =====")
		print(("[InteractionUI] ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯: %s"):format(targetObject.Name))

		-- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³æ¸ˆã¿ã«è¨˜éŒ²
		interactedObjects[targetObject] = true

		-- ã‚µãƒ¼ãƒãƒ¼ã«é€ä¿¡
		InteractEvent:FireServer(targetObject)

		-- å³åº§ã«ãƒœã‚¿ãƒ³ã‚’å‰Šé™¤
		if currentButton then
			currentButton:Destroy()
			currentButton = nil
		end
		currentTarget = nil
	end)

	-- ãƒ‡ãƒãƒƒã‚°ï¼šãƒ›ãƒãƒ¼æ¤œå‡º
	button.MouseEnter:Connect(function()
		print("[InteractionUI DEBUG] ãƒã‚¦ã‚¹ãŒãƒœã‚¿ãƒ³ã«å…¥ã£ãŸ")
		button.BackgroundTransparency = 0 -- ãƒã‚¤ãƒ©ã‚¤ãƒˆ
	end)

	button.MouseLeave:Connect(function()
		print("[InteractionUI DEBUG] ãƒã‚¦ã‚¹ãŒãƒœã‚¿ãƒ³ã‹ã‚‰å‡ºãŸ")
		button.BackgroundTransparency = 0.2
	end)

	currentButton = frame
	return frame
end

-- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³å¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ¤œå‡º
local function findNearestInteractable()
	local character = player.Character
	if not character then return nil end

	local hrp = character:FindFirstChild("HumanoidRootPart")
	if not hrp then return nil end

	local nearestObject = nil
	local nearestDistance = math.huge

	-- workspaceå†…ã®å…¨ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ãƒã‚§ãƒƒã‚¯
	for _, obj in ipairs(workspace:GetDescendants()) do
		if obj:IsA("BasePart") and obj:GetAttribute("HasInteraction") then
			-- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³æ¸ˆã¿ãªã‚‰ã‚¹ã‚­ãƒƒãƒ—
			if interactedObjects[obj] then
				continue
			end

			local distance = (hrp.Position - obj.Position).Magnitude
			local range = obj:GetAttribute("InteractionRange") or 8

			if distance <= range and distance < nearestDistance then
				nearestObject = obj
				nearestDistance = distance
			end
		end
	end

	return nearestObject
end

-- ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ—
RunService.Heartbeat:Connect(function()
	local nearest = findNearestInteractable()

	-- å¯¾è±¡ãŒå¤‰ã‚ã£ãŸå ´åˆ
	if nearest ~= currentTarget then
		-- å¤ã„ãƒœã‚¿ãƒ³ã‚’å‰Šé™¤
		if currentButton then
			currentButton:Destroy()
			currentButton = nil
		end

		currentTarget = nearest

		-- æ–°ã—ã„ãƒœã‚¿ãƒ³ã‚’ä½œæˆ
		if nearest then
			local action = nearest:GetAttribute("InteractionAction") or "èª¿ã¹ã‚‹"
			local key = nearest:GetAttribute("InteractionKey") or "E"
			createInteractionButton(nearest, action, key)

			print(("[InteractionUI] ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³å¯èƒ½: %s"):format(action))
		end
	end
end)

-- ã‚­ãƒ¼å…¥åŠ›
UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then return end

	if currentTarget and input.KeyCode == Enum.KeyCode.E then
		local action = currentTarget:GetAttribute("InteractionAction") or "èª¿ã¹ã‚‹"
		print(("[InteractionUI] Eã‚­ãƒ¼æŠ¼ä¸‹: %s"):format(action))

		-- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³æ¸ˆã¿ã«è¨˜éŒ²
		interactedObjects[currentTarget] = true

		-- ã‚µãƒ¼ãƒãƒ¼ã«é€ä¿¡
		InteractEvent:FireServer(currentTarget)

		-- å³åº§ã«ãƒœã‚¿ãƒ³ã‚’å‰Šé™¤
		if currentButton then
			currentButton:Destroy()
			currentButton = nil
		end
		currentTarget = nil
	end
end)


===== ./ServerScriptService/ZoneManager.lua =====
-- ServerScriptService/ZoneManager.lua
-- æ”¹å–„ç‰ˆï¼šå¤ã„å¤§é™¸ã‚’å‰Šé™¤ + Townå¸¸é§ + ãƒ¯ãƒ¼ãƒ—ãƒ­ã‚¸ãƒƒã‚¯çµ±ä¸€

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local FieldGen = require(ReplicatedStorage:WaitForChild("FieldGen"))

local ZoneManager = {}

ZoneManager.ActiveZones = {}
ZoneManager.PlayerZones = {}

local IslandsRegistry = require(ReplicatedStorage.Islands.Registry)
local ContinentsRegistry = require(ReplicatedStorage.Continents.Registry)

-- å³¶ã®è¨­å®šã‚’ãƒãƒƒãƒ—åŒ–
local Islands = {}
for _, island in ipairs(IslandsRegistry) do
	Islands[island.name] = island
end

-- å¤§é™¸ã®è¨­å®šã‚’ãƒãƒƒãƒ—åŒ–
local Continents = {}
for _, continent in ipairs(ContinentsRegistry) do
	if continent and continent.name then
		Continents[continent.name] = continent
	else
		warn("[ZoneManager] åå‰ãŒè¨­å®šã•ã‚Œã¦ã„ãªã„å¤§é™¸å®šç¾©ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã—ãŸ")
	end
end

print("[ZoneManager] åˆæœŸåŒ–å®Œäº†ã€‚å³¶æ•°:", #IslandsRegistry, "å¤§é™¸æ•°:", #ContinentsRegistry)

-- DisplayConfigï¼ˆä»»æ„ï¼‰
local DisplayConfig
do
	local ok, cfg = pcall(function()
		local cfgFolder = ReplicatedStorage:FindFirstChild("Config")
		if not cfgFolder then
			return nil
		end
		local m = cfgFolder:FindFirstChild("DisplayConfig")
		if not m then
			return nil
		end
		return require(m)
	end)
	if ok then
		DisplayConfig = cfg
	else
		DisplayConfig = nil
	end
end

-- ZoneChangeã‚¤ãƒ™ãƒ³ãƒˆï¼ˆã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆé€šçŸ¥ç”¨ï¼‰
local ZoneChangeEvent = ReplicatedStorage:FindFirstChild("ZoneChange")
if not ZoneChangeEvent then
	ZoneChangeEvent = Instance.new("RemoteEvent")
	ZoneChangeEvent.Name = "ZoneChange"
	ZoneChangeEvent.Parent = ReplicatedStorage
	print("[ZoneManager] ZoneChangeã‚¤ãƒ™ãƒ³ãƒˆã‚’ä½œæˆã—ã¾ã—ãŸ")
end

-- å®šæ•°
local TOWN_ZONE_NAME = "ContinentTown"
local PERMANENT_ZONES = { TOWN_ZONE_NAME }

-- ã‚¾ãƒ¼ãƒ³ãŒå¤§é™¸ã‹ãƒã‚§ãƒƒã‚¯
local function isContinent(zoneName)
	return Continents[zoneName] ~= nil
end

-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¾ãƒ¼ãƒ³ã‚’æ›´æ–°
local function updatePlayerZone(player, newZone)
	local oldZone = ZoneManager.PlayerZones[player]

	if oldZone == newZone then
		return
	end

	if oldZone then
		print(("[ZoneManager] %s ãŒ %s ã‹ã‚‰å‡ºã¾ã—ãŸ"):format(player.Name, oldZone))
		ZoneChangeEvent:FireClient(player, oldZone, false)
	end

	if newZone then
		print(("[ZoneManager] %s ãŒ %s ã«å…¥ã‚Šã¾ã—ãŸ"):format(player.Name, newZone))
		ZoneManager.PlayerZones[player] = newZone
		ZoneChangeEvent:FireClient(player, newZone, true)
	else
		ZoneManager.PlayerZones[player] = nil
	end
end

-- å³¶ãƒ©ãƒ™ãƒ«ï¼ˆBillboardGuiï¼‰ç”Ÿæˆ
local function createIslandLabel(cfg)
	if not (cfg and cfg.showIslandLabel) then
		return
	end

	local worldFolder = workspace:FindFirstChild("World")
	if not worldFolder then
		worldFolder = Instance.new("Folder")
		worldFolder.Name = "World"
		worldFolder.Parent = workspace
	end

	local anchorName = (cfg.name or "Island") .. "_LabelAnchor"
	local old = worldFolder:FindFirstChild(anchorName)
	if old then
		old:Destroy()
	end

	local anchor = Instance.new("Part")
	anchor.Name = anchorName
	anchor.Size = Vector3.new(0.2, 0.2, 0.2)
	anchor.Anchored = true
	anchor.CanCollide = false
	anchor.CanQuery = false
	anchor.CastShadow = false
	anchor.Transparency = 1

	local baseY = cfg.baseY or 0
	local thickness = cfg.thickness or 0
	local labelOffset = cfg.labelOffsetY or 6
	anchor.Position = Vector3.new(cfg.centerX, baseY + thickness + labelOffset, cfg.centerZ)
	anchor.Parent = worldFolder

	local bb = Instance.new("BillboardGui")
	bb.Name = "Nameplate"
	bb.AlwaysOnTop = true
	bb.MaxDistance = cfg.labelMaxDistance or 5000
	bb.Size = UDim2.fromOffset(260, 72)
	bb.Parent = anchor

	local bg = Instance.new("Frame")
	bg.BackgroundColor3 = Color3.fromRGB(10, 10, 10)
	bg.BackgroundTransparency = (cfg._labelBgTrans ~= nil) and cfg._labelBgTrans or 0.35
	bg.BorderSizePixel = 0
	bg.Size = UDim2.fromScale(1, 1)
	bg.Parent = bb

	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 8)
	corner.Parent = bg

	local label = Instance.new("TextLabel")
	label.BackgroundTransparency = 1
	label.Size = UDim2.fromScale(1, 1)
	label.TextWrapped = true
	label.RichText = false
	label.Font = cfg._labelFont or Enum.Font.GothamBold
	label.TextScaled = false
	label.TextSize = cfg._labelTextSize or 16
	label.TextColor3 = Color3.fromRGB(255, 255, 255)
	label.TextStrokeTransparency = 0.5
	label.Text = string.format("%s\n(%.1f, %.1f)", tostring(cfg.name or "Island"), cfg.centerX, cfg.centerZ)
	label.Parent = bg

	local pad = Instance.new("UIPadding")
	pad.PaddingTop, pad.PaddingBottom = UDim.new(0, 6), UDim.new(0, 6)
	pad.PaddingLeft, pad.PaddingRight = UDim.new(0, 10), UDim.new(0, 10)
	pad.Parent = bg
end

-- å¤§é™¸ã‚’ãƒ­ãƒ¼ãƒ‰
local function loadContinent(continentName)
	local continent = Continents[continentName]
	if not continent then
		warn(("[ZoneManager] å¤§é™¸ '%s' ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"):format(continentName))
		return false
	end

	print(("[ZoneManager] å¤§é™¸ç”Ÿæˆé–‹å§‹: %s"):format(continentName))

	local showForThisContinent = false
	local labelParams = nil
	if DisplayConfig and DisplayConfig.isEnabledFor and DisplayConfig.getParamsFor then
		showForThisContinent = DisplayConfig.isEnabledFor(continent.name)
		labelParams = DisplayConfig.getParamsFor(continent.name)
	end

	-- å«ã¾ã‚Œã‚‹å…¨ã¦ã®å³¶ã‚’ç”Ÿæˆ
	for _, islandName in ipairs(continent.islands) do
		local islandConfig = Islands[islandName]
		if islandConfig then
			if showForThisContinent and labelParams then
				islandConfig.showIslandLabel = (labelParams.showIslandLabel ~= false)
				islandConfig.labelOffsetY = labelParams.labelOffsetY
				islandConfig.labelMaxDistance = labelParams.labelMaxDistance
				islandConfig._labelFont = labelParams.font
				islandConfig._labelTextSize = labelParams.textSize
				islandConfig._labelBgTrans = labelParams.backgroundTransparency
			end

			print(("[ZoneManager]   - å³¶ã‚’ç”Ÿæˆ: %s"):format(islandName))
			FieldGen.generateIsland(islandConfig)
		else
			warn(("[ZoneManager]   - å³¶ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: %s"):format(islandName))
		end
	end

	-- æ©‹ã‚’ç”Ÿæˆ
	if continent.bridges then
		for _, bridgeConfig in ipairs(continent.bridges) do
			local fromIsland = Islands[bridgeConfig.fromIsland]
			local toIsland = Islands[bridgeConfig.toIsland]

			if fromIsland and toIsland then
				print(("[ZoneManager]   - æ©‹ã‚’ç”Ÿæˆ: %s"):format(bridgeConfig.name))
				FieldGen.generateBridge(fromIsland, toIsland, bridgeConfig)
			else
				warn(("[ZoneManager]   - æ©‹ã®ç”Ÿæˆå¤±æ•—: %s"):format(bridgeConfig.name))
			end
		end
	end

	ZoneManager.ActiveZones[continentName] = {
		config = continent,
		loadedAt = os.time(),
	}

	-- è¿½åŠ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	if continent.fieldObjects and #continent.fieldObjects > 0 then
		print(("[ZoneManager] è¿½åŠ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’é…ç½®: %d å€‹"):format(#continent.fieldObjects))
		FieldGen.placeFieldObjects(continent.name, continent.fieldObjects)
	end

	-- é“
	if continent.paths then
		local arr = continent.paths
		if #arr == 0 and arr.points then
			arr = { continent.paths }
		end
		if #arr > 0 then
			print("[ZoneManager] é“ã‚’å¼•ãã¾ã™")
			FieldGen.buildPaths(continent.name, arr)
		end
	end

	print(("[ZoneManager] å¤§é™¸ç”Ÿæˆå®Œäº†: %s"):format(continentName))
	return true
end

-- ã‚¾ãƒ¼ãƒ³ã‚’ãƒ­ãƒ¼ãƒ‰
function ZoneManager.LoadZone(zoneName)
	if ZoneManager.ActiveZones[zoneName] then
		print(("[ZoneManager] %s ã¯æ—¢ã«ç”Ÿæˆæ¸ˆã¿ã§ã™"):format(zoneName))
		return true
	end

	if isContinent(zoneName) then
		return loadContinent(zoneName)
	else
		warn(("[ZoneManager] ã‚¾ãƒ¼ãƒ³ '%s' ã¯å¤§é™¸ã§ã¯ã‚ã‚Šã¾ã›ã‚“"):format(zoneName))
		return false
	end
end

-- ã‚¾ãƒ¼ãƒ³ã‚’ã‚¢ãƒ³ãƒ­ãƒ¼ãƒ‰ï¼ˆå®Œå…¨å‰Šé™¤ï¼‰
function ZoneManager.UnloadZone(zoneName)
	if not ZoneManager.ActiveZones[zoneName] then
		return
	end

	print(("[ZoneManager] ã‚¾ãƒ¼ãƒ³å‰Šé™¤é–‹å§‹: %s"):format(zoneName))

	if not isContinent(zoneName) then
		warn(("[ZoneManager] ã‚¾ãƒ¼ãƒ³ '%s' ã¯å¤§é™¸ã§ã¯ã‚ã‚Šã¾ã›ã‚“"):format(zoneName))
		return
	end

	local continent = Continents[zoneName]
	local terrain = workspace.Terrain

	-- ã‚¹ãƒ†ãƒƒãƒ—1: Terrainï¼ˆåœ°å½¢ï¼‰ã‚’å‰Šé™¤
	local configsToUnload = {}
	for _, islandName in ipairs(continent.islands) do
		table.insert(configsToUnload, Islands[islandName])
	end

	for _, config in ipairs(configsToUnload) do
		if config then
			local halfSize = config.sizeXZ / 2 + 50
			-- å±±ã®é ‚ä¸Šã¾ã§å‰Šé™¤ã™ã‚‹ãŸã‚ã€hillAmplitude ã‚’è€ƒæ…®
			local maxHeight = config.baseY + (config.hillAmplitude or 20) + 50
			local region = Region3.new(
				Vector3.new(config.centerX - halfSize, config.baseY - 50, config.centerZ - halfSize),
				Vector3.new(config.centerX + halfSize, maxHeight, config.centerZ + halfSize)
			)
			region = region:ExpandToGrid(4)
			terrain:FillRegion(region, 4, Enum.Material.Air)
		end
	end

	-- ã‚¹ãƒ†ãƒƒãƒ—2: ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼å‰Šé™¤
	for _, model in ipairs(workspace:GetChildren()) do
		if model:IsA("Model") and model:GetAttribute("IsEnemy") then
			local spawnZone = model:GetAttribute("SpawnZone")
			if spawnZone == zoneName then
				model:Destroy()
			end
		end
	end

	-- ã‚¹ãƒ†ãƒƒãƒ—3: ãƒãƒ¼ã‚¿ãƒ«å‰Šé™¤
	if _G.DestroyPortalsForZone then
		_G.DestroyPortalsForZone(zoneName)
	end

	-- ã‚¹ãƒ†ãƒƒãƒ—4: ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‰Šé™¤
	local fieldObjectsFolder = workspace:FindFirstChild("FieldObjects")
	if fieldObjectsFolder then
		local zoneFolder = fieldObjectsFolder:FindFirstChild(zoneName)
		if zoneFolder then
			zoneFolder:Destroy()
		end
	end

	ZoneManager.ActiveZones[zoneName] = nil
	print(("[ZoneManager] ã‚¾ãƒ¼ãƒ³å‰Šé™¤å®Œäº†: %s"):format(zoneName))
end

-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ãƒ¯ãƒ¼ãƒ—ï¼ˆæ”¹å–„ç‰ˆï¼‰
function ZoneManager.WarpPlayerToZone(player, zoneName)
	print(("[ZoneManager] %s ã‚’ %s ã«ãƒ¯ãƒ¼ãƒ—ä¸­..."):format(player.Name, zoneName))

	if not isContinent(zoneName) then
		warn(("[ZoneManager] ã‚¾ãƒ¼ãƒ³ '%s' ã¯å¤§é™¸ã§ã¯ã‚ã‚Šã¾ã›ã‚“"):format(player.Name))
		return false
	end

	local character = player.Character
	if not character then
		warn(("[ZoneManager] %s ã®ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"):format(player.Name))
		return false
	end

	local hrp = character:FindFirstChild("HumanoidRootPart")
	if not hrp then
		return false
	end

	-- ========== æ”¹å–„: ãƒ¯ãƒ¼ãƒ—ãƒ•ãƒ­ãƒ¼ ==========

	-- ãƒ•ã‚§ãƒ¼ã‚º1: ç¾åœ¨ã®ã‚¾ãƒ¼ãƒ³ã‚’å–å¾—
	local currentZone = ZoneManager.GetPlayerZone(player)
	print(("[ZoneManager] ç¾åœ¨ã®ã‚¾ãƒ¼ãƒ³: %s"):format(currentZone or "nil"))

	-- ãƒ•ã‚§ãƒ¼ã‚º2: å¤ã„å¤§é™¸ã‚’ã‚¢ãƒ³ãƒ­ãƒ¼ãƒ‰ï¼ˆTown ã¯é™¤å¤–ï¼‰
	if currentZone and currentZone ~= zoneName and not table.find(PERMANENT_ZONES, currentZone) then
		print(("[ZoneManager] å¤ã„å¤§é™¸ã‚’ã‚¢ãƒ³ãƒ­ãƒ¼ãƒ‰: %s"):format(currentZone))
		ZoneManager.UnloadZone(currentZone)
	end

	-- ãƒ•ã‚§ãƒ¼ã‚º3: Town ã‚’å¸¸é§ã•ã›ã‚‹
	if zoneName ~= TOWN_ZONE_NAME and not ZoneManager.ActiveZones[TOWN_ZONE_NAME] then
		print(("[ZoneManager] Town ã‚’ãƒ­ãƒ¼ãƒ‰ï¼ˆå¸¸é§ï¼‰"):format())
		ZoneManager.LoadZone(TOWN_ZONE_NAME)
	end

	-- ãƒ•ã‚§ãƒ¼ã‚º4: ç›®çš„åœ°ã‚¾ãƒ¼ãƒ³ã‚’ãƒ­ãƒ¼ãƒ‰
	if not ZoneManager.ActiveZones[zoneName] then
		print(("[ZoneManager] ç›®çš„åœ°ã‚¾ãƒ¼ãƒ³ã‚’ãƒ­ãƒ¼ãƒ‰: %s"):format(zoneName))
		ZoneManager.LoadZone(zoneName)
	end

	-- ãƒ•ã‚§ãƒ¼ã‚º5: ãƒ¯ãƒ¼ãƒ—å…ˆåº§æ¨™ã‚’æ±ºå®š
	local continent = Continents[zoneName]
	local firstIslandName = continent.islands[1]
	local firstIsland = Islands[firstIslandName]

	if not firstIsland then
		warn(
			("[ZoneManager] å¤§é™¸ '%s' ã®æœ€åˆã®å³¶ '%s' ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"):format(
				zoneName,
				firstIslandName
			)
		)
		return false
	end

	local targetX = firstIsland.centerX
	local targetZ = firstIsland.centerZ
	local baseY = firstIsland.baseY
	local hillAmplitude = firstIsland.hillAmplitude or 20

	-- ãƒ•ã‚§ãƒ¼ã‚º6: åœ°é¢æ¤œå‡º
	local rayStartY = baseY + hillAmplitude + 100
	local groundY = FieldGen.raycastGroundY(targetX, targetZ, rayStartY)

	local spawnY
	if groundY then
		spawnY = groundY + 5
		print(("[ZoneManager] åœ°é¢æ¤œå‡ºæˆåŠŸ: Y=%.1f"):format(groundY))
	else
		spawnY = baseY + (hillAmplitude * 0.6) + 10
		warn(("[ZoneManager] åœ°é¢æ¤œå‡ºå¤±æ•—ã€äºˆæƒ³é«˜åº¦ä½¿ç”¨: Y=%.1f"):format(spawnY))
	end

	-- ãƒ•ã‚§ãƒ¼ã‚º7: ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ãƒ¯ãƒ¼ãƒ—
	hrp.CFrame = CFrame.new(targetX, spawnY, targetZ)
	updatePlayerZone(player, zoneName)

	print(
		("[ZoneManager] %s ã‚’ %s ã«ãƒ¯ãƒ¼ãƒ—å®Œäº† (%.1f, %.1f, %.1f)"):format(
			player.Name,
			zoneName,
			targetX,
			spawnY,
			targetZ
		)
	)

	return true
end

function ZoneManager.GetPlayerZone(player)
	return ZoneManager.PlayerZones[player]
end

-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼é€€å‡ºæ™‚ã®å‡¦ç†
Players.PlayerRemoving:Connect(function(player)
	local oldZone = ZoneManager.PlayerZones[player]
	if oldZone then
		print(("[ZoneManager] %s ãŒé€€å‡ºã—ã¾ã—ãŸã€‚ã‚¾ãƒ¼ãƒ³: %s"):format(player.Name, oldZone))
		ZoneManager.PlayerZones[player] = nil
	end
end)

return ZoneManager

===== ./ServerScriptService/FastTravelSystem.server.lua =====
-- ServerScriptService/FastTravelSystem.server.lua
-- æ”¹å–„ç‰ˆï¼šãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ç”»é¢ã«ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ¬ãƒ™ãƒ«ã‚’é€ä¿¡

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")

print("[FastTravel] åˆæœŸåŒ–é–‹å§‹")

local ContinentsRegistry = require(ReplicatedStorage:WaitForChild("Continents"):WaitForChild("Registry"))
local IslandsRegistry = require(ReplicatedStorage:WaitForChild("Islands"):WaitForChild("Registry"))
local ZoneManager = require(game:GetService("ServerScriptService"):WaitForChild("ZoneManager", 10))
local PlayerStatsModule = require(ServerScriptService:WaitForChild("PlayerStats"))

-- IslandsRegistry ã‚’è¾æ›¸å½¢å¼ã«å¤‰æ›
local Islands = {}
for _, island in ipairs(IslandsRegistry) do
	if island and island.name then
		Islands[island.name] = island
	end
end

-- RemoteEvent ä½œæˆ
local FastTravelEvent = ReplicatedStorage:FindFirstChild("FastTravelEvent")
if not FastTravelEvent then
	FastTravelEvent = Instance.new("RemoteEvent")
	FastTravelEvent.Name = "FastTravelEvent"
	FastTravelEvent.Parent = ReplicatedStorage
	print("[FastTravel] FastTravelEvent ã‚’ä½œæˆã—ã¾ã—ãŸ")
end

local GetContinentsEvent = ReplicatedStorage:FindFirstChild("GetContinentsEvent")
if not GetContinentsEvent then
	GetContinentsEvent = Instance.new("RemoteFunction")
	GetContinentsEvent.Name = "GetContinentsEvent"
	GetContinentsEvent.Parent = ReplicatedStorage
	print("[FastTravel] GetContinentsEvent ã‚’ä½œæˆã—ã¾ã—ãŸ")
end

-- å¤§é™¸ä¸€è¦§ã‚’å–å¾—
local function getContinentsList()
	local continents = {}

	for _, continent in ipairs(ContinentsRegistry) do
		table.insert(continents, {
			name = continent.name,
			displayName = continent.displayName or continent.name,
		})
	end

	return continents
end

-- ãƒ¯ãƒ¼ãƒ—å‡¦ç†ï¼ˆæ”¹å–„ç‰ˆï¼šãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ¬ãƒ™ãƒ«ã‚’ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ç”»é¢ã«é€ä¿¡ï¼‰
local function handleFastTravel(player, continentName)
	print(("[FastTravel] %s ãŒ %s ã¸ã®ãƒ¯ãƒ¼ãƒ—ã‚’è¦æ±‚"):format(player.Name, continentName))

	-- ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
	local continent = nil
	for _, cont in ipairs(ContinentsRegistry) do
		if cont.name == continentName then
			continent = cont
			break
		end
	end

	if not continent then
		warn(("[FastTravel] å¤§é™¸ '%s' ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"):format(continentName))
		return false
	end

	-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ¬ãƒ™ãƒ«ã‚’å–å¾—
	local stats = PlayerStatsModule.getStats(player)
	local playerLevel = stats and stats.Level or 1
	print(("[FastTravel] ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ %s ã®ãƒ¬ãƒ™ãƒ«: %d"):format(player.Name, playerLevel))

	-- ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°é–‹å§‹ã‚’é€šçŸ¥ï¼ˆãƒ¬ãƒ™ãƒ«ä»˜ãï¼‰
	FastTravelEvent:FireClient(player, "StartLoading", continentName, playerLevel)
	task.wait(0.2)

	-- ZoneManager.WarpPlayerToZone() ã‚’å‘¼ã³å‡ºã—
	local success = ZoneManager.WarpPlayerToZone(player, continentName)

	if success then
		print(("[FastTravel] %s ã‚’ %s ã«ãƒ¯ãƒ¼ãƒ—ã—ã¾ã—ãŸ"):format(player.Name, continentName))

		-- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã¨ãƒãƒ¼ã‚¿ãƒ«ã‚’ç”Ÿæˆï¼ˆéåŒæœŸï¼‰
		task.spawn(function()
			task.wait(1)

			-- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ç”Ÿæˆ
			if _G.SpawnMonstersForZone then
				_G.SpawnMonstersForZone(continentName)
				print(("[FastTravel] %s ã®ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’ç”Ÿæˆã—ã¾ã—ãŸ"):format(continentName))
			else
				warn("[FastTravel] SpawnMonstersForZone ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
			end

			-- ãƒãƒ¼ã‚¿ãƒ«ç”Ÿæˆ
			if _G.CreatePortalsForZone then
				_G.CreatePortalsForZone(continentName)
				print(("[FastTravel] %s ã®ãƒãƒ¼ã‚¿ãƒ«ã‚’ç”Ÿæˆã—ã¾ã—ãŸ"):format(continentName))
			else
				warn("[FastTravel] CreatePortalsForZone ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
			end

			-- ç”Ÿæˆå®Œäº†å¾Œã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°çµ‚äº†ã‚’é€šçŸ¥
			FastTravelEvent:FireClient(player, "EndLoading", continentName, playerLevel)
		end)
	else
		warn(("[FastTravel] %s ã®ãƒ¯ãƒ¼ãƒ—ã«å¤±æ•—ã—ã¾ã—ãŸ"):format(player.Name))
		FastTravelEvent:FireClient(player, "EndLoading", continentName, playerLevel)
	end

	return success
end

-- ã‚¤ãƒ™ãƒ³ãƒˆæ¥ç¶š
GetContinentsEvent.OnServerInvoke = function(player)
	return getContinentsList()
end

FastTravelEvent.OnServerEvent:Connect(function(player, continentName)
	handleFastTravel(player, continentName)
end)

print("[FastTravel] åˆæœŸåŒ–å®Œäº†")

===== ./ServerScriptService/PlayerStats.lua =====
-- ServerScriptService/PlayerStats.lua
-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’ç®¡ç†ã™ã‚‹ModuleScript
-- ã‚¹ãƒ†ãƒƒãƒ—2: SharedState/GameEventsçµ±åˆç‰ˆ

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- ã€ã‚¹ãƒ†ãƒƒãƒ—2ã€‘SharedStateã¨GameEventsã‚’ãƒ­ãƒ¼ãƒ‰
local SharedState = require(ReplicatedStorage:WaitForChild("SharedState"))
local GameEvents = require(ReplicatedStorage:WaitForChild("GameEvents"))

local DataStoreManager = require(script.Parent:WaitForChild("DataStoreManager"))

local PlayerStats = {}
local LoadedDataCache = {}

-- RemoteEventã‚’å–å¾—ã™ã‚‹é–¢æ•°
local function getRemoteEvent(name)
	return ReplicatedStorage:WaitForChild(name, 10)
end

-- ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
local DEFAULT_STATS = {
	Level = 1,
	Experience = 0,
	Gold = 100,  -- åˆæœŸã‚´ãƒ¼ãƒ«ãƒ‰100G

	MaxHP = 100,
	CurrentHP = 100,

	Speed = 10,      -- ç´ æ—©ã•
	Attack = 10,     -- æ”»æ’ƒåŠ›
	Defense = 10,    -- å®ˆå‚™åŠ›
	MonstersDefeated = 0,


	MonsterCounts = {}, 	-- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚«ã‚¦ãƒ³ãƒˆè¿½åŠ 
	CollectedItems = {},	-- å–å¾—æ¸ˆã¿ã‚¢ã‚¤ãƒ†ãƒ 
}

-- ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ã«å¿…è¦ãªçµŒé¨“å€¤ï¼ˆç·©ã‚„ã‹é€“å¢—: 50 * level^1.7ï¼‰
local function getRequiredExp(level)
	return math.floor(50 * (level ^ 1.7) + 0.5)
end


-- å„ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’ä¿å­˜
local PlayerData = {}

-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’åˆæœŸåŒ–
function PlayerStats.initPlayer(player: Player)
	if PlayerData[player] then
		warn(("[PlayerStats] %s ã¯æ—¢ã«åˆæœŸåŒ–æ¸ˆã¿ã§ã™"):format(player.Name))
        -- æ—¢ã«åˆæœŸåŒ–æ¸ˆã¿ã®å ´åˆã¯Locationã‚’è¿”å´
        return PlayerData[player].Location or {
            ZoneName = "ContinentTown", X = DEFAULT_STATS.MaxHP, Y = DEFAULT_STATS.MaxHP, Z = DEFAULT_STATS.MaxHP
        }
	end

	-- ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã§ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’ä½œæˆ
	local stats = {}
	for key, value in pairs(DEFAULT_STATS) do
		stats[key] = value
	end

	-- â˜…DataStoreã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ­ãƒ¼ãƒ‰ï¼ˆãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ï¼‰
	local loadedData = DataStoreManager.LoadData(player)
	LoadedDataCache[player] = loadedData

	local loadedLocation = nil

	if loadedData and loadedData.PlayerState then
		local playerState = loadedData.PlayerState

		-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’é©ç”¨
		for key, value in pairs(playerState.Stats) do
			if stats[key] ~= nil then
				stats[key] = value
			end
		end

		-- Locationã‚’é©ç”¨
		if playerState.Location then
			loadedLocation = playerState.Location
			print(("[PlayerStats] %s ã®ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ã‚’é©ç”¨ã—ã¾ã—ãŸ: %s (%.0f, %.0f, %.0f)"):format(
				player.Name,
				loadedLocation.ZoneName,
				loadedLocation.X,
				loadedLocation.Y,
				loadedLocation.Z
			))
		end

		 stats.CollectedItems = loadedData.CollectedItems or {}

		print(("[PlayerStats] %s ã®å–å¾—æ¸ˆã¿ã‚¢ã‚¤ãƒ†ãƒ æ•°: %d"):format(
			player.Name,
			next(stats.CollectedItems) and #stats.CollectedItems or 0
		))
	else
		print(("[PlayerStats] %s ã®æ–°è¦ãƒ‡ãƒ¼ã‚¿ã€ã¾ãŸã¯ãƒ­ãƒ¼ãƒ‰å¤±æ•—ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ä½¿ç”¨ï¼‰"):format(player.Name))
	end

	PlayerData[player] = stats
	print(("[PlayerStats] %s ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’åˆæœŸåŒ–ã—ã¾ã—ãŸï¼ˆDataStoreé©ç”¨å¾Œï¼‰"):format(player.Name))

	-- ã€ã‚¹ãƒ†ãƒƒãƒ—2ã€‘SharedStateã«ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¾ãƒ¼ãƒ³ã‚’åˆæœŸåŒ–
	SharedState.PlayerZones[player] = nil
	-- â˜…ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸLocationæƒ…å ±ã‚’è¿”ã™
	return loadedLocation
end

function PlayerStats.getLastLoadedData(player: Player)
    return LoadedDataCache[player]
end

-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’å–å¾—
function PlayerStats.getStats(player: Player)
	return PlayerData[player]
end

-- ç‰¹å®šã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’å–å¾—
function PlayerStats.getStat(player: Player, statName: string)
	local stats = PlayerData[player]
	if not stats then
		warn(("[PlayerStats] %s ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"):format(player.Name))
		return nil
	end
	return stats[statName]
end

-- ç‰¹å®šã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’è¨­å®š
function PlayerStats.setStat(player: Player, statName: string, value)
	local stats = PlayerData[player]
	if not stats then
		warn(("[PlayerStats] %s ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"):format(player.Name))
		return
	end

	stats[statName] = value
	print(("[PlayerStats] %s ã® %s ã‚’ %s ã«è¨­å®š"):format(player.Name, statName, tostring(value)))
end

-- HPã‚’å›å¾©
function PlayerStats.healHP(player: Player, amount: number)
	local stats = PlayerData[player]
	if not stats then return end

	stats.CurrentHP = math.min(stats.CurrentHP + amount, stats.MaxHP)
	print(("[PlayerStats] %s ã®HPã‚’ %d å›å¾©ï¼ˆç¾åœ¨: %d/%d)"):format(
		player.Name, amount, stats.CurrentHP, stats.MaxHP
		))
end

-- HPã‚’å…¨å›å¾©
function PlayerStats.fullHeal(player: Player)
	local stats = PlayerData[player]
	if not stats then return end

	stats.CurrentHP = stats.MaxHP
	print(("[PlayerStats] %s ã®HPã‚’å…¨å›å¾©"):format(player.Name))
end

-- ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ã‚‹
function PlayerStats.takeDamage(player: Player, damage: number): boolean
	local stats = PlayerData[player]
	if not stats then return false end

	stats.CurrentHP = math.max(0, stats.CurrentHP - damage)
	print(("[PlayerStats] %s ãŒ %d ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ãŸï¼ˆæ®‹ã‚ŠHP: %d/%d)"):format(
		player.Name, damage, stats.CurrentHP, stats.MaxHP
		))

	-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°ã‚’é€ä¿¡
	local StatusUpdateEvent = getRemoteEvent("StatusUpdate")
	if StatusUpdateEvent then
		local expToNext = getRequiredExp(stats.Level)
		StatusUpdateEvent:FireClient(
			player,
			stats.CurrentHP,
			stats.MaxHP,
			stats.Level,
			stats.Experience,
			expToNext,
			stats.Gold
		)
	end

	-- æ­»äº¡åˆ¤å®š
	if stats.CurrentHP <= 0 then
		print(("[PlayerStats] %s ã¯å€’ã‚ŒãŸï¼"):format(player.Name))
		return true  -- æ­»äº¡
	end

	return false  -- ç”Ÿå­˜
end

-- çµŒé¨“å€¤ã‚’è¿½åŠ 
function PlayerStats.addExperience(player, amount)
	local stats = PlayerStats.getStats(player)
	if not stats then return end

	stats.Experience = (stats.Experience or 0) + (amount or 0)

	-- è¤‡æ•°ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ã«å¯¾å¿œ
	local leveledUp = false
	local lastDeltas = nil

	while true do
		local need = PlayerStats.getExpToNext(stats.Level)
		if (stats.Experience or 0) < need then
			break
		end

		stats.Experience = stats.Experience - need
		stats.Level = stats.Level + 1
		leveledUp = true

		-- ä¸Šæ˜‡é‡è¨ˆç®—
		local deltas = PlayerStats.calcLevelUpDeltas(stats.Level)
		lastDeltas = deltas

		-- åæ˜ 
		stats.MaxHP = (stats.MaxHP or 100) + deltas.hp
		stats.Speed  = (stats.Speed  or 10)  + deltas.speed
		stats.Attack = (stats.Attack or 10)  + deltas.attack
		stats.Defense= (stats.Defense or 10) + deltas.defense

		-- HPã¯å…¨å›å¾©ï¼ˆãŠå¥½ã¿ã§ï¼‰
		stats.CurrentHP = stats.MaxHP

		-- ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—æ¼”å‡ºï¼ˆã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¸ï¼‰
		-- æ—¢å­˜ï¼šLevelUpEvent:FireClient(player, level, maxHP, speed, attack, defense)
		-- å¾Œæ–¹äº’æ›ï¼‹æ‹¡å¼µï¼šç¬¬7å¼•æ•°ã« deltas ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’è¿½åŠ 
		local LevelUpEvent = game.ReplicatedStorage:FindFirstChild("LevelUp")
		if LevelUpEvent then
			LevelUpEvent:FireClient(
				player,
				stats.Level,
				stats.MaxHP,
				stats.Speed,
				stats.Attack,
				stats.Defense,
				deltas -- è¿½åŠ ï¼ˆnilã§ã‚‚OKã«ã—ã¦ãŠãï¼‰
			)
		end
	end

	-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ä¿å­˜ã‚„é€šçŸ¥ãŒã‚ã‚Œã°ã“ã“ã§
end


-- ã‚´ãƒ¼ãƒ«ãƒ‰ã‚’è¿½åŠ 
function PlayerStats.addGold(player: Player, gold: number)
	local stats = PlayerData[player]
	if not stats then return end

	stats.Gold = stats.Gold + gold
	print(("[PlayerStats] %s ãŒã‚´ãƒ¼ãƒ«ãƒ‰ %d ã‚’ç²å¾—ï¼ˆåˆè¨ˆ: %d)"):format(
		player.Name, gold, stats.Gold
		))

	-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°ã‚’é€ä¿¡
	local StatusUpdateEvent = getRemoteEvent("StatusUpdate")
	if StatusUpdateEvent then
		local expToNext = getRequiredExp(stats.Level)
		StatusUpdateEvent:FireClient(
			player,
			stats.CurrentHP,
			stats.MaxHP,
			stats.Level,
			stats.Experience,
			expToNext,
			stats.Gold
		)
	end
end

-- ã‚´ãƒ¼ãƒ«ãƒ‰ã‚’æ¸›ã‚‰ã™
function PlayerStats.removeGold(player: Player, gold: number): boolean
	local stats = PlayerData[player]
	if not stats then return false end

	if stats.Gold < gold then
		print(("[PlayerStats] %s ã®ã‚´ãƒ¼ãƒ«ãƒ‰ãŒä¸è¶³ã—ã¦ã„ã¾ã™"):format(player.Name))
		return false
	end

	stats.Gold = stats.Gold - gold
	print(("[PlayerStats] %s ãŒã‚´ãƒ¼ãƒ«ãƒ‰ %d ã‚’å¤±ã£ãŸï¼ˆæ®‹ã‚Š: %d)"):format(
		player.Name, gold, stats.Gold
		))
	return true
end

-- å€’ã—ãŸãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æ•°ã‚’è¿½åŠ 
function PlayerStats.addMonstersDefeated(player: Player, count: number)
	print(("[PlayerStats] ========================================"):format())
	print(("[PlayerStats] addMonstersDefeated å‘¼ã³å‡ºã—"):format())
	print(("  ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼: %s"):format(player.Name))
	print(("  è¿½åŠ æ•°: %d"):format(count or 1))

	local stats = PlayerData[player]
	if not stats then
		warn(("[PlayerStats] âŒ %s ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ï¼ˆãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚«ã‚¦ãƒ³ãƒˆå¤±æ•—)"):format(player.Name))
		print(("[PlayerStats] ========================================"):format())
		return
	end

	local oldCount = stats.MonstersDefeated
	count = count or 1
	stats.MonstersDefeated = stats.MonstersDefeated + count

	print(("  å¤‰æ›´å‰: %d"):format(oldCount))
	print(("  å¤‰æ›´å¾Œ: %d"):format(stats.MonstersDefeated))
	print(("[PlayerStats] âœ… ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æ’ƒç ´æ•°æ›´æ–°æˆåŠŸ"):format())
	print(("[PlayerStats] ========================================"):format())
end

-- ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—
function PlayerStats.levelUp(player: Player)
	local stats = PlayerData[player]
	if not stats then return end

	local oldLevel = stats.Level
	stats.Level = stats.Level + 1

	-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚¢ãƒƒãƒ—
	stats.MaxHP = stats.MaxHP + 10
	stats.CurrentHP = stats.MaxHP  -- å…¨å›å¾©
	stats.Speed = stats.Speed + 2
	stats.Attack = stats.Attack + 2
	stats.Defense = stats.Defense + 2

	print(("[PlayerStats] ğŸ‰ %s ãŒãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ï¼ %d â†’ %d"):format(
		player.Name, oldLevel, stats.Level
		))
	print(("  HP: %d, ç´ æ—©ã•: %d, æ”»æ’ƒ: %d, å®ˆå‚™: %d"):format(
		stats.MaxHP, stats.Speed, stats.Attack, stats.Defense
		))

	-- ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—æ¼”å‡ºã‚’é€šçŸ¥
	local LevelUpEvent = getRemoteEvent("LevelUp")
	if LevelUpEvent then
		LevelUpEvent:FireClient(player, stats.Level, stats.MaxHP, stats.Speed, stats.Attack, stats.Defense)
	end

	-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°ã‚’é€ä¿¡
	local StatusUpdateEvent = getRemoteEvent("StatusUpdate")
	if StatusUpdateEvent then
		local expToNext = stats.Level * 100
		StatusUpdateEvent:FireClient(
			player,
			stats.CurrentHP,
			stats.MaxHP,
			stats.Level,
			stats.Experience,
			expToNext,
			stats.Gold
		)
	end
end

-- ã€ã‚¹ãƒ†ãƒƒãƒ—2ã€‘ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚«ã‚¦ãƒ³ãƒˆã‚’æ›´æ–°
function PlayerStats.updateMonsterCounts(player: Player, zoneName: string)
	local stats = PlayerData[player]
	if not stats then return end

	-- SharedStateã‹ã‚‰æœ€æ–°ã®ã‚«ã‚¦ãƒ³ãƒˆã‚’å–å¾—
	if SharedState.MonsterCounts[zoneName] then
		stats.MonsterCounts[zoneName] = SharedState.MonsterCounts[zoneName]
		print(("[PlayerStats] %s ã®ã‚¾ãƒ¼ãƒ³ %s ã®ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚«ã‚¦ãƒ³ãƒˆã‚’æ›´æ–°"):format(
			player.Name, zoneName
		))
	end
end

-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒé€€å‡ºã—ãŸã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¯ãƒªã‚¢
function PlayerStats.removePlayer(player: Player)
    PlayerData[player] = nil
    LoadedDataCache[player] = nil -- ã€è¿½åŠ ã€‘
    SharedState.PlayerZones[player] = nil
    print(("[PlayerStats] %s ã®ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã—ã¾ã—ãŸ"):format(player.Name))
end

-- åˆæœŸåŒ–
function PlayerStats.init()
	-- æ—¢å­˜ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’åˆæœŸåŒ–
	for _, player in ipairs(Players:GetPlayers()) do
		PlayerStats.initPlayer(player)
	end

	-- æ–°è¦å‚åŠ ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’åˆæœŸåŒ–
	Players.PlayerAdded:Connect(function(player)
		PlayerStats.initPlayer(player)
	end)

	-- é€€å‡ºæ™‚ã«ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¯ãƒªã‚¢
	Players.PlayerRemoving:Connect(function(player)
		PlayerStats.removePlayer(player)
	end)

	-- è©³ç´°ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒªã‚¯ã‚¨ã‚¹ãƒˆç”¨RemoteEvent
	local RequestStatsDetailEvent = ReplicatedStorage:FindFirstChild("RequestStatsDetail")
	if not RequestStatsDetailEvent then
		RequestStatsDetailEvent = Instance.new("RemoteEvent")
		RequestStatsDetailEvent.Name = "RequestStatsDetail"
		RequestStatsDetailEvent.Parent = ReplicatedStorage
	end

	RequestStatsDetailEvent.OnServerEvent:Connect(function(player)
		local stats = PlayerStats.getStats(player)
		if stats then
			-- StatsDetailEventã‚’å–å¾—ã¾ãŸã¯ä½œæˆ
			local StatsDetailEvent = ReplicatedStorage:FindFirstChild("StatsDetail")
			if not StatsDetailEvent then
				StatsDetailEvent = Instance.new("RemoteEvent")
				StatsDetailEvent.Name = "StatsDetail"
				StatsDetailEvent.Parent = ReplicatedStorage
				print("[PlayerStats] StatsDetailã‚¤ãƒ™ãƒ³ãƒˆã‚’ä½œæˆã—ã¾ã—ãŸ")
			end

			print(("[PlayerStats] è©³ç´°ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’é€ä¿¡: MonstersDefeated=%d"):format(stats.MonstersDefeated or 0))
			StatsDetailEvent:FireClient(player, stats)
		end
	end)

	print("[PlayerStats] åˆæœŸåŒ–å®Œäº†ï¼ˆã‚¹ãƒ†ãƒƒãƒ—2: SharedStateçµ±åˆç‰ˆï¼‰")
end

-- ä¾‹ï¼‰PlayerStats.lua ã®ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ï¼ˆreturn ã®å‰ã€ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ã®è¾ºã‚Šï¼‰ã«è¿½è¨˜
local function pow(base, exp)
	return base ^ exp
end

function PlayerStats.getExpToNext(level: number): number
	-- 50 * level^1.7 ã‚’å››æ¨äº”å…¥
	return math.floor(50 * pow(level, 1.7) + 0.5)
end

-- ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—æ™‚ã®å¢—åˆ†ã‚’è¨ˆç®—
-- ä»•æ§˜ï¼š
--  - é€šå¸¸ï¼šHP +10ã€ä»– +2
--  - ãƒ¬ãƒ™ãƒ«ãŒ5ã®å€æ•°ï¼š1.5å€ï¼ˆHP+15ã€ä»–+3ï¼‰
--  - ã•ã‚‰ã«HPã¯ãƒ¬ãƒ™ãƒ«å¸¯ã§ä¸Šæ˜‡å¹…ã‚’å¢—ã‚„ã™ï¼ˆä¾‹ï¼šLv10~19:+15ã€Lv20~29:+20ã€â€¦ï¼‰
function PlayerStats.calcLevelUpDeltas(newLevel: number)
	-- åŸºæœ¬å€¤
	local hpInc = 10
	local otherInc = 2

	-- ãƒ¬ãƒ™ãƒ«å¸¯ã§HPå¢—åŠ å¹…ã‚’åŠ ç®—ï¼ˆä¾‹ç¤ºï¼‰
	if newLevel >= 20 then
		hpInc = 20
	elseif newLevel >= 10 then
		hpInc = 15
	end
	-- å¿…è¦ãªã‚‰ã•ã‚‰ã«å¸¯ã‚’å¢—ã‚„ã›ã¾ã™
	-- if newLevel >= 30 then hpInc = 25 end ... ç­‰

	-- 5ã®å€æ•°ã¯1.5å€
	if newLevel % 5 == 0 then
		hpInc = math.floor(hpInc * 1.5 + 0.5)     -- 10â†’15, 15â†’22, 20â†’30 ãªã©
		otherInc = math.floor(otherInc * 1.5 + 0.5) -- 2â†’3
	end

	return {
		hp = hpInc,
		speed = otherInc,
		attack = otherInc,
		defense = otherInc,
	}
end


return PlayerStats
===== ./ServerScriptService/MemoryMonitor.server.lua =====
-- ServerScriptService/MemoryMonitor.server.lua
print("[MemoryMonitor] èµ·å‹•")

local ZoneManager = require(game:GetService("ServerScriptService"):WaitForChild("ZoneManager"))

task.spawn(function()
	while true do
		task.wait(10) -- 10ç§’ã”ã¨

		print("\n========== ãƒ¡ãƒ¢ãƒªç›£è¦– ==========")

		-- ActiveZones ã‚’è¡¨ç¤º
		local activeZones = {}
		for zoneName, _ in pairs(ZoneManager.ActiveZones) do
			table.insert(activeZones, zoneName)
		end
		print("ãƒ­ãƒ¼ãƒ‰æ¸ˆã¿å¤§é™¸:", table.concat(activeZones, ", ") or "ãªã—")
		print("å¤§é™¸æ•°:", #activeZones)

		-- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æ•°
		local monsterCount = 0
		for _, model in ipairs(workspace:GetChildren()) do
			if model:IsA("Model") and model:GetAttribute("IsEnemy") then
				monsterCount = monsterCount + 1
			end
		end
		print("ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æ•°:", monsterCount)

		local monstersByZone = {}
		for _, model in ipairs(workspace:GetChildren()) do
			if model:IsA("Model") and model:GetAttribute("IsEnemy") then
				local spawnZone = model:GetAttribute("SpawnZone")
				monstersByZone[spawnZone] = (monstersByZone[spawnZone] or 0) + 1
			end
		end
		print("ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼è©³ç´°:", monstersByZone)

		-- workspace ã®å­è¦ç´ æ•°
		print("Workspace å­è¦ç´ æ•°:", #workspace:GetChildren())

		-- ãƒãƒ¼ã‚¿ãƒ«æ•°
		local portalCount = 0
		local worldFolder = workspace:FindFirstChild("World")
		if worldFolder then
			for _, child in ipairs(worldFolder:GetChildren()) do
				if child:IsA("Part") and child:GetAttribute("FromZone") then
					portalCount = portalCount + 1
				end
			end
		end
		print("ãƒãƒ¼ã‚¿ãƒ«æ•°:", portalCount)

		print("================================\n")
	end
end)

print("[MemoryMonitor] ãƒ¢ãƒ‹ã‚¿ãƒ¼é–‹å§‹ï¼ˆ10ç§’ã”ã¨ï¼‰")

===== ./ServerScriptService/Bootstrap.server.lua =====
-- ServerScriptService/Bootstrap.server.lua
-- ã‚²ãƒ¼ãƒ åˆæœŸåŒ–ã‚¹ã‚¯ãƒªãƒ—ãƒˆï¼ˆæœ€çµ‚å®‰å®šç‰ˆ - DataStoreãƒ­ãƒ¼ãƒ‰å®‰å®šåŒ–ï¼‰

local ServerScriptService = game:GetService("ServerScriptService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

print("[Bootstrap] === ã‚²ãƒ¼ãƒ åˆæœŸåŒ–é–‹å§‹ (æœ€çµ‚å®‰å®šç‰ˆ) ===")
-- â˜… åŠ¹æœéŸ³ã®åˆæœŸåŒ–ï¼ˆæ—©æœŸï¼‰: å ´æ‰€ã‚ºãƒ¬/ç¨®é¡ãƒŸã‚¹ã§ã‚‚è½ã¡ãªã„ãƒ­ãƒ¼ãƒ€ãƒ¼
do
	local function findSoundRegistry()
		-- 1) ServerScriptService ç›´ä¸‹
		local m = ServerScriptService:FindFirstChild("SoundRegistry")
		-- 2) Modules ãƒ•ã‚©ãƒ«ãƒ€é…ä¸‹
		if not m then
			local modules = ServerScriptService:FindFirstChild("Modules")
			if modules then
				m = modules:FindFirstChild("SoundRegistry")
			end
		end
		-- 3) ReplicatedStorage å´ã«ç½®ã„ãŸå ´åˆ
		if not m then
			m = ReplicatedStorage:FindFirstChild("SoundRegistry")
		end
		return m
	end

	local m = findSoundRegistry()
	print("[Bootstrap] (early) SoundRegistry =", m and m:GetFullName() or "nil", m and m.ClassName)

	if m and m:IsA("ModuleScript") then
		local okReq, modOrErr = pcall(require, m)
		if okReq and type(modOrErr) == "table" and type(modOrErr.init) == "function" then
			local okInit, errInit = pcall(modOrErr.init)
			if okInit then
				print("[Bootstrap] SoundsåˆæœŸåŒ–å®Œäº†ï¼ˆSoundRegistryãƒ»æ—©æœŸï¼‰")
			else
				warn("[Bootstrap] SoundRegistry.init ã‚¨ãƒ©ãƒ¼ï¼ˆæ—©æœŸï¼‰: ", errInit)
			end
		else
			warn("[Bootstrap] SoundRegistry ã®æˆ»ã‚Šå€¤ãŒä¸æ­£ or require å¤±æ•—ï¼ˆæ—©æœŸï¼‰: ", modOrErr)
		end
	else
		-- ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ã¨ã‚Šã‚ãˆãš Sounds ãƒ•ã‚©ãƒ«ãƒ€ã¨æœ€ä½é™ã®éŸ³ã‚’ç”¨æ„ï¼ˆã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã® WaitForChild å¯¾ç­–ï¼‰
		local folder = ReplicatedStorage:FindFirstChild("Sounds")
		if not folder then
			folder = Instance.new("Folder")
			folder.Name = "Sounds"
			folder.Parent = ReplicatedStorage
		end

		local function ensure(name, id, vol)
			local s = folder:FindFirstChild(name)
			if not s then
				s = Instance.new("Sound")
				s.Name = name
				s.SoundId = id
				s.Volume = vol
				s.Parent = folder
			end
		end
		ensure("TypingCorrect", "rbxassetid://159534615", 0.4)
		ensure("TypingError", "rbxassetid://113721818600044", 0.5)
		ensure("EnemyHit", "rbxassetid://155288625", 0.6)

		warn(
			"[Bootstrap] SoundRegistry ãŒè¦‹ã¤ã‹ã‚‰ãªã„/ModuleScriptã§ãªã„ãŸã‚ã€æš«å®šã§ Sounds ã‚’ç”¨æ„ï¼ˆæ—©æœŸï¼‰"
		)
	end
end

-- ZoneManagerã‚’èª­ã¿è¾¼ã¿ï¼ˆServerScriptServiceã®å…„å¼Ÿãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ï¼‰
local ZoneManager = require(script.Parent:WaitForChild("ZoneManager"))

-- PlayerStatsã®ModuleScriptã®å®Ÿè¡Œçµæœã‚’ãƒ­ãƒ¼ãƒ‰ï¼ˆServerScriptServiceã®å…„å¼Ÿãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ï¼‰
local PlayerStatsModule = require(script.Parent:WaitForChild("PlayerStats"))
local DataCollectors = require(script.Parent:WaitForChild("DataCollectors"))

local START_ZONE_NAME = "ContinentTown"
local LOAD_TIMEOUT = 10 -- DataStoreãƒ­ãƒ¼ãƒ‰ã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ(ç§’)

-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã”ã¨ã®ãƒ­ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ç®¡ç†
local LastLoadedLocation = {}
local LastLoadedData = {}

-- PlayerStatsã®åˆæœŸåŒ–ï¼ˆDataStoreãƒ­ãƒ¼ãƒ‰å‡¦ç†ã‚’å«ã‚€ï¼‰
PlayerStatsModule.init()

print("[Bootstrap] ã‚»ãƒ¼ãƒ–æ©Ÿèƒ½ã‚’åˆæœŸåŒ–ä¸­...")

local SaveGameEvent = ReplicatedStorage:FindFirstChild("SaveGame")
if not SaveGameEvent then
	SaveGameEvent = Instance.new("RemoteEvent")
	SaveGameEvent.Name = "SaveGame"
	SaveGameEvent.Parent = ReplicatedStorage
	print("[Bootstrap] âœ“ SaveGameã‚¤ãƒ™ãƒ³ãƒˆä½œæˆ")
end

local SaveSuccessEvent = ReplicatedStorage:FindFirstChild("SaveSuccess")
if not SaveSuccessEvent then
	SaveSuccessEvent = Instance.new("RemoteEvent")
	SaveSuccessEvent.Name = "SaveSuccess"
	SaveSuccessEvent.Parent = ReplicatedStorage
	print("[Bootstrap] âœ“ SaveSuccessã‚¤ãƒ™ãƒ³ãƒˆä½œæˆ")
end

-- DataStoreManagerã¨DataCollectorsã‚’ãƒ­ãƒ¼ãƒ‰
local DataStoreManager = require(ServerScriptService:WaitForChild("DataStoreManager"))
local DataCollectors = require(ServerScriptService:WaitForChild("DataCollectors"))

-- ã‚»ãƒ¼ãƒ–ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ã‚’ç™»éŒ²
SaveGameEvent.OnServerEvent:Connect(function(player)
	print(("[Bootstrap] ğŸ’¾ %s ã‹ã‚‰ã‚»ãƒ¼ãƒ–ãƒªã‚¯ã‚¨ã‚¹ãƒˆå—ä¿¡"):format(player.Name))

	-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’å–å¾—
	local stats = PlayerStatsModule.getStats(player)
	if not stats then
		warn(("[Bootstrap] âŒ %s ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"):format(player.Name))
		SaveSuccessEvent:FireClient(player, false)
		return
	end

	-- ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆ
	local saveData = DataCollectors.createSaveData(player, stats)

	print(("[Bootstrap] ğŸ“¦ ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ä½œæˆå®Œäº†"):format())

	-- DataStoreã«ä¿å­˜
	local success = DataStoreManager.SaveData(player, saveData)

	if success then
		print(("[Bootstrap] âœ… %s ã®ã‚»ãƒ¼ãƒ–æˆåŠŸ"):format(player.Name))
	else
		warn(("[Bootstrap] âŒ %s ã®ã‚»ãƒ¼ãƒ–å¤±æ•—"):format(player.Name))
	end
end)

print("[Bootstrap] âœ“ ã‚»ãƒ¼ãƒ–æ©Ÿèƒ½ã®åˆæœŸåŒ–å®Œäº†")

print("[Bootstrap] è¡—ã‚’ç”Ÿæˆä¸­ï¼ˆéåŒæœŸï¼‰...")
task.spawn(function()
	ZoneManager.LoadZone(START_ZONE_NAME)
	print("[Bootstrap] åœ°å½¢ç”Ÿæˆå®Œäº†")
end)

-- è¡—ã®è¨­å®šã‚’å–å¾—
local IslandsRegistry = require(ReplicatedStorage.Islands.Registry)
local townConfig = nil
for _, island in ipairs(IslandsRegistry) do
	if island.name == "StartTown" then
		townConfig = island
		break
	end
end

if not townConfig then
	warn("[Bootstrap] StartTown ã®è¨­å®šãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ï¼")
	return
end

-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¹ãƒãƒ¼ãƒ³ä½ç½®ã‚’è¡—ã«è¨­å®š
local function setupPlayerSpawn(player)
	-- DataStoreã‹ã‚‰ã®ãƒ­ãƒ¼ãƒ‰å‡¦ç†ï¼ˆåŒæœŸçš„ã«å¾…ã¤ï¼‰
	local function loadDataAndPrepareSpawn()
		local startTime = os.clock()
		print(("[Bootstrap] %s ã®DataStoreãƒ­ãƒ¼ãƒ‰é–‹å§‹"):format(player.Name))

		local loadedLocation = PlayerStatsModule.initPlayer(player)
		local fullLoadedData = PlayerStatsModule.getLastLoadedData(player)

		print(("[Bootstrap] â±ï¸ DataStoreãƒ­ãƒ¼ãƒ‰å®Œäº†: %.2fç§’"):format(os.clock() - startTime))

		if not loadedLocation then
			warn(("[Bootstrap] %s ã®ãƒ­ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ãŒnilã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆä½¿ç”¨"):format(player.Name))
			loadedLocation = {
				ZoneName = "ContinentTown",
				X = townConfig.centerX,
				Y = townConfig.baseY + 25,
				Z = townConfig.centerZ,
			}
		end

		LastLoadedData[player] = {
			Location = loadedLocation,
			FieldState = fullLoadedData and fullLoadedData.FieldState or nil,
			CurrentZone = fullLoadedData and fullLoadedData.CurrentZone or nil,
		}

		print(
			("[Bootstrap] %s ã®ãƒ­ãƒ¼ãƒ‰å®Œäº†: %s (%.0f, %.0f, %.0f)"):format(
				player.Name,
				loadedLocation.ZoneName,
				loadedLocation.X,
				loadedLocation.Y,
				loadedLocation.Z
			)
		)

		player:SetAttribute("ContinentName", loadedLocation.ZoneName)
		return LastLoadedData[player]
	end

	-- ãƒ¡ã‚¤ãƒ³å‡¦ç†
	task.spawn(function()
		local totalStartTime = os.clock()

		-- DataStoreãƒ­ãƒ¼ãƒ‰ã‚’å¾…ã¤
		local loadedData = loadDataAndPrepareSpawn()
		local loadedLocation = loadedData.Location
		local targetZone = loadedLocation.ZoneName

		-- ã€é‡è¦ã€‘ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ç”Ÿæˆå‰ã«ã‚¾ãƒ¼ãƒ³ã‚’ãƒ­ãƒ¼ãƒ‰
		if targetZone ~= START_ZONE_NAME then
			local zoneLoadStart = os.clock()
			print(("[Bootstrap] ã‚­ãƒ£ãƒ©ç”Ÿæˆå‰: %s ã®ã‚¾ãƒ¼ãƒ³ã‚’ãƒ­ãƒ¼ãƒ‰"):format(targetZone))
			ZoneManager.LoadZone(targetZone)
			task.wait(2) -- åœ°å½¢ç”Ÿæˆå®Œäº†ã‚’å¾…ã¤
			print(("[Bootstrap] â±ï¸ ã‚¾ãƒ¼ãƒ³ãƒ­ãƒ¼ãƒ‰å®Œäº†: %.2fç§’"):format(os.clock() - zoneLoadStart))
		end

		-- ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ç”Ÿæˆ
		local charGenStart = os.clock()
		print(("[Bootstrap] %s ã®ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ç”Ÿæˆã‚’é–‹å§‹"):format(player.Name))

		-- ã€è¿½åŠ ã€‘SpawnReadyEventã‚’å–å¾—/ä½œæˆ
		local SpawnReadyEvent = ReplicatedStorage:FindFirstChild("SpawnReady")
		if not SpawnReadyEvent then
			SpawnReadyEvent = Instance.new("RemoteEvent")
			SpawnReadyEvent.Name = "SpawnReady"
			SpawnReadyEvent.Parent = ReplicatedStorage
		end

		-- CharacterAddedã‚’å…ˆã«æ¥ç¶šï¼ˆç”Ÿæˆã¨åŒæ™‚ã«ãƒ¯ãƒ¼ãƒ—ã™ã‚‹ãŸã‚ï¼‰
		local connection
		connection = player.CharacterAdded:Connect(function(character)
			connection:Disconnect() -- ä¸€åº¦ã ã‘å®Ÿè¡Œ

			print(("[Bootstrap] â±ï¸ ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ç”Ÿæˆå®Œäº†: %.2fç§’"):format(os.clock() - charGenStart))

			-- å³åº§ã«ãƒ¯ãƒ¼ãƒ—ï¼ˆæç”»ã•ã‚Œã‚‹å‰ã«ï¼‰
			task.spawn(function()
				local hrpStart = os.clock()
				local hrp = character:WaitForChild("HumanoidRootPart", 5)
				print(("[Bootstrap] â±ï¸ HRPå–å¾—å®Œäº†: %.2fç§’"):format(os.clock() - hrpStart))

				if not hrp then
					warn(("[Bootstrap] %s ã®HRPãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"):format(player.Name))
					return
				end

				local targetX = loadedLocation.X
				local targetY = loadedLocation.Y
				local targetZ = loadedLocation.Z

				print(
					("[Bootstrap] å³åº§ã«ãƒ¯ãƒ¼ãƒ—: %s â†’ (%.0f, %.0f, %.0f)"):format(
						player.Name,
						targetX,
						targetY,
						targetZ
					)
				)

				-- å³åº§ã«é…ç½®
				hrp.CFrame = CFrame.new(targetX, targetY, targetZ)
				ZoneManager.PlayerZones[player] = targetZone

				print(("[Bootstrap] %s ã‚’é…ç½®å®Œäº†"):format(player.Name))
				print(("[Bootstrap] â±ï¸ åˆè¨ˆæ™‚é–“: %.2fç§’"):format(os.clock() - totalStartTime))

				-- ã€è¿½åŠ ã€‘ãƒ¯ãƒ¼ãƒ—å®Œäº†å¾Œã€å³åº§ã«ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°è§£é™¤é€šçŸ¥
				SpawnReadyEvent:FireClient(player)
				print(("[Bootstrap] %s ã«ã‚¹ãƒãƒ¼ãƒ³æº–å‚™å®Œäº†ã‚’é€šçŸ¥ï¼ˆå³åº§ï¼‰"):format(player.Name))

				-- ã€ä¿®æ­£ã€‘ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã¨ãƒãƒ¼ã‚¿ãƒ«ã®å¾©å…ƒã‚’ä¸¦è¡Œå‡¦ç†ã«å¤‰æ›´
				task.spawn(function()
					task.wait(1) -- å°‘ã—å¾…ã£ã¦ã‹ã‚‰å¾©å…ƒ

					if loadedData.FieldState and loadedData.CurrentZone then
						local zoneName = loadedData.CurrentZone
						print(("[Bootstrap] %s ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰çŠ¶æ…‹ã‚’å¾©å…ƒ: %s"):format(player.Name, zoneName))

						DataCollectors.restoreFieldState(zoneName, loadedData.FieldState)

						if _G.CreatePortalsForZone then
							_G.CreatePortalsForZone(zoneName)
						end
					else
						print(("[Bootstrap] %s ã¯åˆå›ãƒ—ãƒ¬ã‚¤"):format(player.Name))

						if targetZone ~= START_ZONE_NAME then
							if _G.SpawnMonstersForZone then
								_G.SpawnMonstersForZone(targetZone)
							end
							if _G.CreatePortalsForZone then
								_G.CreatePortalsForZone(targetZone)
							end
						else
							if _G.CreatePortalsForZone then
								_G.CreatePortalsForZone(START_ZONE_NAME)
							end
						end
					end

					-- ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
					LastLoadedData[player] = nil
				end)

				-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°ï¼ˆä¸¦è¡Œå‡¦ç†ï¼‰
				task.spawn(function()
					local stats = PlayerStatsModule.getStats(player)
					if stats then
						local expToNext = stats.Level * 100
						local StatusUpdateEvent = ReplicatedStorage:FindFirstChild("StatusUpdate")
						if StatusUpdateEvent then
							StatusUpdateEvent:FireClient(
								player,
								stats.CurrentHP,
								stats.MaxHP,
								stats.Level,
								stats.Experience,
								expToNext,
								stats.Gold
							)
						end
					end
				end)

				print(("[Bootstrap] %s ã®ã‚¹ãƒãƒ¼ãƒ³å‡¦ç†å®Œäº†"):format(player.Name))
			end)
		end)

		-- ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ç”Ÿæˆ
		player:LoadCharacter()
	end)
end

-- æ—¢å­˜ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«é©ç”¨
for _, player in ipairs(Players:GetPlayers()) do
	setupPlayerSpawn(player)
end

-- æ–°è¦ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«é©ç”¨
Players.PlayerAdded:Connect(setupPlayerSpawn)

-- é€€å‡ºæ™‚ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
Players.PlayerRemoving:Connect(function(player)
	LastLoadedLocation[player] = nil
end)

-- åŠ¹æœéŸ³ã®åˆæœŸåŒ–ï¼ˆå ´æ‰€ã‚ºãƒ¬/ç¨®é¡ãƒŸã‚¹ã«ã‚‚å¼·ã„ãƒ­ãƒ¼ãƒ€ãƒ¼ï¼‰
do
	local function findSoundRegistry()
		-- 1) ã¾ãšã¯ç›´ä¸‹
		local m = ServerScriptService:FindFirstChild("SoundRegistry")
		-- 2) ã‚ˆãã‚ã‚‹ Modules ãƒ•ã‚©ãƒ«ãƒ€é…ä¸‹
		if not m then
			local modules = ServerScriptService:FindFirstChild("Modules")
			if modules then
				m = modules:FindFirstChild("SoundRegistry")
			end
		end
		-- 3) ã‚‚ã— ReplicatedStorage ã«ç½®ã„ãŸå ´åˆ
		if not m then
			m = ReplicatedStorage:FindFirstChild("SoundRegistry")
		end
		return m
	end

	local m = findSoundRegistry()
	print("[Bootstrap] SoundRegistry child =", m, m and m.ClassName, m and m:GetFullName())

	if not m then
		warn(
			"[Bootstrap] SoundRegistry ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚ServerScriptService ç›´ä¸‹ï¼ˆã¾ãŸã¯ Modules é…ä¸‹ï¼‰ã« ModuleScript ã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚"
		)
	elseif not m:IsA("ModuleScript") then
		warn(
			("[Bootstrap] SoundRegistry ã¯ %s ã§ã™ã€‚ModuleScript ã«ä½œã‚Šç›´ã—ã¦ãã ã•ã„ã€‚"):format(
				m.ClassName
			)
		)
	else
		local ok, SoundRegistryOrErr = pcall(require, m)
		if not ok then
			warn("[Bootstrap] require ã«å¤±æ•—: ", SoundRegistryOrErr)
		else
			local SoundRegistry = SoundRegistryOrErr
			if type(SoundRegistry) == "table" and type(SoundRegistry.init) == "function" then
				local okInit, errInit = pcall(SoundRegistry.init)
				if okInit then
					print("[Bootstrap] SoundsåˆæœŸåŒ–å®Œäº†ï¼ˆSoundRegistryï¼‰")
				else
					warn("[Bootstrap] SoundRegistry.init ã§ã‚¨ãƒ©ãƒ¼: ", errInit)
				end
			else
				warn(
					"[Bootstrap] SoundRegistry ã¯ãƒ†ãƒ¼ãƒ–ãƒ«+inité–¢æ•°ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ModuleScriptã®æˆ»ã‚Šå€¤ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚"
				)
			end
		end
	end
end

-- ã€è¿½åŠ ã€‘ã‚»ãƒ¼ãƒ–ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ã®ç™»éŒ²
local SaveGameEvent = ReplicatedStorage:FindFirstChild("SaveGame")
if not SaveGameEvent then
	SaveGameEvent = Instance.new("RemoteEvent")
	SaveGameEvent.Name = "SaveGame"
	SaveGameEvent.Parent = ReplicatedStorage
	print("[Bootstrap] SaveGameã‚¤ãƒ™ãƒ³ãƒˆã‚’ä½œæˆã—ã¾ã—ãŸ")
end

local DataStoreManager = require(ServerScriptService:WaitForChild("DataStoreManager"))
local DataCollectors = require(ServerScriptService:WaitForChild("DataCollectors"))

SaveGameEvent.OnServerEvent:Connect(function(player)
	print(("[Bootstrap] %s ã‹ã‚‰ã‚»ãƒ¼ãƒ–ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’å—ä¿¡"):format(player.Name))

	-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’å–å¾—
	local stats = PlayerStatsModule.getStats(player)
	if not stats then
		warn(("[Bootstrap] %s ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"):format(player.Name))
		local SaveSuccessEvent = ReplicatedStorage:FindFirstChild("SaveSuccess")
		if SaveSuccessEvent then
			SaveSuccessEvent:FireClient(player, false)
		end
		return
	end

	-- ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆ
	local saveData = DataCollectors.createSaveData(player, stats)

	-- DataStoreã«ä¿å­˜
	local success = DataStoreManager.SaveData(player, saveData)

	if success then
		print(("[Bootstrap] %s ã®ã‚»ãƒ¼ãƒ–æˆåŠŸ"):format(player.Name))
	else
		warn(("[Bootstrap] %s ã®ã‚»ãƒ¼ãƒ–å¤±æ•—"):format(player.Name))
	end
end)

print("[Bootstrap] ã‚»ãƒ¼ãƒ–ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ã‚’ç™»éŒ²ã—ã¾ã—ãŸ")

print("[Bootstrap] === ã‚²ãƒ¼ãƒ åˆæœŸåŒ–å®Œäº† ===")
print(("[Bootstrap] ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯è¡—ï¼ˆ%sï¼‰ã‹ã‚‰ã‚¹ã‚¿ãƒ¼ãƒˆã—ã¾ã™"):format(START_ZONE_NAME))

===== ./ServerScriptService/LoadTest.server.lua =====
-- ServerScriptService/LoadTest (Script)
local startTime = os.clock()
local startMemory = gcinfo()

-- ã‚²ãƒ¼ãƒ é–‹å§‹ã‚’å¾…ã¤
-- task.wait(5)

-- local endTime = os.clock()
-- local endMemory = gcinfo()

-- print("=== è² è·ãƒ†ã‚¹ãƒˆçµæœ ===")
-- print(("åœ°å½¢ç”Ÿæˆæ™‚é–“: %.2fç§’"):format(endTime - startTime))
-- print(("ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡: %.2f MB"):format((endMemory - startMemory) / 1024))
-- print(("ç·ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæ•°: %d"):format(#workspace:GetDescendants()))

-- ç¶™ç¶šãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°
task.spawn(function()
	while true do
		task.wait(5)
		local fps = 1 / game:GetService("RunService").Heartbeat:Wait()
		print(("FPS: %.1f | ãƒ¡ãƒ¢ãƒª: %.1f MB"):format(fps, gcinfo() / 1024))
	end
end)
===== ./ServerScriptService/SoundRegistry.server.lua =====
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local SoundRegistry = {}

local SOUND_DEFS = {
    { name = "TypingCorrect", id = "rbxassetid://159534615",        volume = 0.4 },
    { name = "TypingError",   id = "rbxassetid://113721818600044",   volume = 0.5 },
    { name = "EnemyHit",      id = "rbxassetid://155288625",         volume = 0.6 }, -- æ•µã‚¿ãƒ¼ãƒ³SE
}

function SoundRegistry.init()
    local folder = ReplicatedStorage:FindFirstChild("Sounds")
    if not folder then
        folder = Instance.new("Folder")
        folder.Name = "Sounds"
        folder.Parent = ReplicatedStorage
    end

    for _, def in ipairs(SOUND_DEFS) do
        local s = folder:FindFirstChild(def.name)
        if not s then
            s = Instance.new("Sound")
            s.Name = def.name
            s.SoundId = def.id
            s.Volume = def.volume or 0.5
            s.RollOffMode = Enum.RollOffMode.InverseTapered
            s.Parent = folder
        end
    end
end

return SoundRegistry

===== ./ServerScriptService/OceanSafety.server.lua =====
-- ServerScriptService/OceanSafety.server.lua
-- æ”¹å–„ç‰ˆï¼šå„ã‚¾ãƒ¼ãƒ³ã®ãƒªã‚¹ãƒãƒ¼ãƒ³ä½ç½®ã‚’å‹•çš„ã«å–å¾—

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

print("[OceanSafety] åˆæœŸåŒ–é–‹å§‹")

-- è¨­å®š
local WATER_LEVEL = -25 -- ã“ã®é«˜ã•ã‚ˆã‚Šä¸‹ã«è½ã¡ãŸã‚‰å‡¦ç†
local CHECK_INTERVAL = 0.5 -- ãƒã‚§ãƒƒã‚¯é–“éš”ï¼ˆç§’ï¼‰

local ZoneManager = require(game:GetService("ServerScriptService").ZoneManager)
local Islands = require(ReplicatedStorage.Islands.Registry)
local Continents = require(ReplicatedStorage.Continents.Registry)

-- å³¶ã‚’ãƒãƒƒãƒ—åŒ–
local IslandsMap = {}
for _, island in ipairs(Islands) do
	IslandsMap[island.name] = island
end

-- å¤§é™¸ã‚’ãƒãƒƒãƒ—åŒ–
local ContinentsMap = {}
for _, continent in ipairs(Continents) do
	if continent and continent.name then
		ContinentsMap[continent.name] = continent
	end
end

-- æŒ‡å®šã‚¾ãƒ¼ãƒ³ã®ãƒªã‚¹ãƒãƒ¼ãƒ³ä½ç½®ã‚’å–å¾—
local function getZoneSpawnPosition(zoneName)
	local continent = ContinentsMap[zoneName]

	if not continent or not continent.islands or #continent.islands == 0 then
		warn(("[OceanSafety] ã‚¾ãƒ¼ãƒ³ '%s' ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"):format(zoneName))
		-- ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: Town ã®æœ€åˆã®å³¶ã‚’ä½¿ç”¨
		local townContinent = ContinentsMap["ContinentTown"]
		if townContinent and townContinent.islands and #townContinent.islands > 0 then
			continent = townContinent
		else
			return Vector3.new(0, 20, 0) -- æœ€å¾Œã®æ‰‹æ®µ
		end
	end

	-- æœ€åˆã®å³¶ã‚’å–å¾—
	local firstIslandName = continent.islands[1]
	local firstIsland = IslandsMap[firstIslandName]

	if not firstIsland then
		warn(
			("[OceanSafety] å¤§é™¸ '%s' ã®æœ€åˆã®å³¶ '%s' ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"):format(
				zoneName,
				firstIslandName
			)
		)
		return Vector3.new(0, 20, 0)
	end

	local spawnX = firstIsland.centerX
	local spawnZ = firstIsland.centerZ
	local spawnY = firstIsland.baseY + 25

	return Vector3.new(spawnX, spawnY, spawnZ)
end

print("[OceanSafety] åˆæœŸåŒ–å®Œäº†")

-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç›£è¦–
local function monitorPlayer(player)
	player.CharacterAdded:Connect(function(character)
		local hrp = character:WaitForChild("HumanoidRootPart")
		local humanoid = character:WaitForChild("Humanoid")

		local lastCheck = 0

		RunService.Heartbeat:Connect(function()
			if not character.Parent or not hrp.Parent then
				return
			end

			local now = os.clock()
			if now - lastCheck < CHECK_INTERVAL then
				return
			end
			lastCheck = now

			-- æ°´é¢ã‚ˆã‚Šä¸‹ã«è½ã¡ãŸã‹ãƒã‚§ãƒƒã‚¯
			if hrp.Position.Y < WATER_LEVEL then
				print(("[OceanSafety] %s ãŒæµ·ã«è½ã¡ã¾ã—ãŸã€‚ãƒªã‚¹ãƒãƒ¼ãƒ³ä¸­..."):format(player.Name))

				-- ç¾åœ¨ã®ã‚¾ãƒ¼ãƒ³ã‚’å–å¾—
				local currentZone = ZoneManager.GetPlayerZone(player)
				local spawnPos = getZoneSpawnPosition(currentZone or "ContinentTown")

				-- é€Ÿåº¦ã‚’ã‚¼ãƒ­ã«
				hrp.AssemblyLinearVelocity = Vector3.zero
				hrp.AssemblyAngularVelocity = Vector3.zero

				-- ã‚¾ãƒ¼ãƒ³ã®ä¸­å¿ƒã«æˆ»ã™
				hrp.CFrame = CFrame.new(spawnPos)

				-- ä½“åŠ›ã‚’å°‘ã—æ¸›ã‚‰ã™ï¼ˆãƒšãƒŠãƒ«ãƒ†ã‚£ï¼‰
				if humanoid.Health > 10 then
					humanoid.Health = humanoid.Health - 10
				end

				print(
					("[OceanSafety] %s ã‚’ãƒªã‚¹ãƒãƒ¼ãƒ³å®Œäº†: (%.1f, %.1f, %.1f)"):format(
						player.Name,
						spawnPos.X,
						spawnPos.Y,
						spawnPos.Z
					)
				)
			end
		end)
	end)
end

-- æ—¢å­˜ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨æ–°è¦ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«é©ç”¨
for _, player in ipairs(Players:GetPlayers()) do
	monitorPlayer(player)
end
Players.PlayerAdded:Connect(monitorPlayer)

-- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã®ç›£è¦–
RunService.Heartbeat:Connect(function()
	for _, model in ipairs(workspace:GetChildren()) do
		if model:IsA("Model") and model:GetAttribute("IsEnemy") then
			local hrp = model:FindFirstChild("HumanoidRootPart")

			if hrp and hrp.Position.Y < WATER_LEVEL then
				model:Destroy()
			end
		end
	end
end)

===== ./ServerScriptService/ResetSave.server.lua =====
-- ServerScriptService/ResetSave.server.lua
-- ã€ŒåˆæœŸåŒ–ã™ã‚‹ã€ãƒœã‚¿ãƒ³ã‹ã‚‰ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’å‡¦ç†ã—ã¦ã€ã‚»ãƒ¼ãƒ–ã‚’æ¶ˆå»ï¼†Lv1åˆæœŸåŒ–

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")

-- RemoteEventsï¼ˆç„¡ã‘ã‚Œã°ä½œã‚‹ï¼‰
local function getOrCreateEvent(name)
	local ev = ReplicatedStorage:FindFirstChild(name)
	if not ev then
		ev = Instance.new("RemoteEvent")
		ev.Name = name
		ev.Parent = ReplicatedStorage
	end
	return ev
end

local ResetSaveRequest = getOrCreateEvent("ResetSaveRequest")
local ResetSaveResult  = getOrCreateEvent("ResetSaveResult")

-- ä¾å­˜ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
local okPS, PlayerStats = pcall(function()
	return require(ServerScriptService:WaitForChild("PlayerStats"))
end)
local okDM, DataStoreManager = pcall(function()
	return require(ServerScriptService:WaitForChild("DataStoreManager"))
end)
local okDC, DataCollectors = pcall(function()
	return require(ServerScriptService:WaitForChild("DataCollectors"))
end)

-- åˆæœŸå€¤ã‚’ä¸Šæ›¸ãã‚»ãƒ¼ãƒ–ã™ã‚‹ãƒ˜ãƒ«ãƒ‘
local function saveDefaults(player)
	if not okPS then return false, "PlayerStats not found" end

	local defaults = {
		Level = 1,
		Experience = 0,
		MaxHP = 100,
		CurrentHP = 100,
		Attack = 10,
		Defense = 10,
		Speed = 10,
		Gold = 0,
		MonstersDefeated = 0,
	}

	-- æ‰‹å…ƒã® PlayerStats ã« setter ãŒç„¡ã‘ã‚Œã° stats ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’ç›´æ›¸ãï¼ˆå­˜åœ¨ã™ã‚‹ãªã‚‰ãã¡ã‚‰ã‚’å„ªå…ˆï¼‰
	local stats = PlayerStats.getStats and PlayerStats.getStats(player)
	if stats then
		for k,v in pairs(defaults) do
			stats[k] = v
		end
	else
		-- ä½•ã‚‚ç„¡ã‘ã‚Œã°è«¦ã‚ã‚‹
		return false, "Player stats not available"
	end

	-- DataCollectors + DataStoreManager ã§ã‚»ãƒ¼ãƒ–ï¼ˆå­˜åœ¨ã™ã‚Œã°ï¼‰
	if okDM and okDC and DataCollectors.createSaveData and DataStoreManager.SaveData then
		local saveData = DataCollectors.createSaveData(player, stats)
		local ok = DataStoreManager.SaveData(player, saveData)
		if not ok then
			return false, "Save failed"
		end
	end

	return true
end

-- ã‚»ãƒ¼ãƒ–ã®æ¶ˆå»ï¼ˆãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒæŒã£ã¦ã„ã‚Œã°ä½¿ã†ï¼ç„¡ã‘ã‚Œã°ä¸Šæ›¸ãä¿å­˜ã§å®Ÿè³ªåˆæœŸåŒ–ï¼‰
local function wipeSave(player)
	-- DataStoreManager ã« Delete/Wipe ç³»ãŒã‚ã‚Œã°ä½¿ã†
	for _, fn in ipairs({"DeleteData", "WipeData", "RemoveData", "ResetData"}) do
		if okDM and type(DataStoreManager[fn]) == "function" then
			local ok, err = pcall(function()
				return DataStoreManager[fn](player)
			end)
			if ok then return true end
			warn("[ResetSave] DataStoreManager."..fn.." failed:", err)
		end
	end
	-- ç„¡ã‘ã‚Œã°ã€ŒåˆæœŸå€¤ã§ä¸Šæ›¸ãä¿å­˜ã€ã‚’ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã¨ã—ã¦æ¡ç”¨
	local ok, msg = saveDefaults(player)
	return ok, msg
end

ResetSaveRequest.OnServerEvent:Connect(function(player)
	-- 1) ã‚»ãƒ¼ãƒ–æ¶ˆå»
	local ok, msg = wipeSave(player)
	if not ok then
		ResetSaveResult:FireClient(player, false, msg or "wipe failed")
		return
	end

	-- 2) ãã®ã¾ã¾åˆæœŸå€¤ã‚’åæ˜ ï¼ˆãƒ¡ãƒ¢ãƒªä¸Šã®å€¤ã‚‚Lv1ã«ï¼‰
	local ok2, msg2 = saveDefaults(player)
	if not ok2 then
		ResetSaveResult:FireClient(player, false, msg2 or "apply defaults failed")
		return
	end

	-- 3) å¿µã®ãŸã‚HPå…¨å›å¾©ï¼†ã‚¹ãƒ†æ›´æ–°ã‚’é£›ã°ã™ï¼ˆå­˜åœ¨ã™ã‚Œã°ï¼‰
	if okPS then
		if type(PlayerStats.fullHeal) == "function" then
			PlayerStats.fullHeal(player)
		end
		if type(PlayerStats.sendStatusUpdate) == "function" then
			PlayerStats.sendStatusUpdate(player)
		end
	end

	-- å®Œäº†
	ResetSaveResult:FireClient(player, true)
end)

===== ./ServerScriptService/WarpPortal.server.lua =====
-- ServerScriptService/WarpPortal.server.lua
-- æ”¹å–„ç‰ˆï¼šãƒãƒ¼ã‚¿ãƒ«ãƒ¯ãƒ¼ãƒ—ã«ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ¬ãƒ™ãƒ«ã‚’é€ä¿¡

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

print("[WarpPortal] åˆæœŸåŒ–é–‹å§‹")

local warpEvent = ReplicatedStorage:FindFirstChild("WarpEvent")
if not warpEvent then
	warpEvent = Instance.new("RemoteEvent")
	warpEvent.Name = "WarpEvent"
	warpEvent.Parent = ReplicatedStorage
end

local ZoneManager = require(script.Parent.ZoneManager)
local BattleSystem = require(script.Parent.BattleSystem)
local PlayerStatsModule = require(script.Parent.PlayerStats)

local warpingPlayers = {}
local activePortals = {}

local IslandsRegistry = require(ReplicatedStorage.Islands.Registry)
local ContinentsRegistry = require(ReplicatedStorage.Continents.Registry)

local Islands = {}
for _, island in ipairs(IslandsRegistry) do
	Islands[island.name] = island
end

local Continents = {}
for _, continent in ipairs(ContinentsRegistry) do
	if continent and continent.name then
		Continents[continent.name] = continent
	else
		warn("[WarpPortal] åå‰ãŒè¨­å®šã•ã‚Œã¦ã„ãªã„å¤§é™¸å®šç¾©ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã—ãŸ")
	end
end

local function ensureHRP(model)
	local hrp = model:FindFirstChild("HumanoidRootPart")
	if hrp and hrp:IsA("BasePart") then
		if not model.PrimaryPart then
			model.PrimaryPart = hrp
		end
		return hrp
	end
	return nil
end

local function attachLabel(model, maxDist)
	local hrp = model.PrimaryPart or model:FindFirstChild("HumanoidRootPart")
	if not hrp then
		return
	end

	local _, bboxSize = model:GetBoundingBox()
	local labelOffset = math.min(bboxSize.Y * 0.5 + 2, 15)

	local gui = Instance.new("BillboardGui")
	gui.Name = "DebugInfo"
	gui.Adornee = hrp
	gui.AlwaysOnTop = true
	gui.Size = UDim2.new(0, 150, 0, 50)
	gui.StudsOffset = Vector3.new(0, labelOffset, 0)
	gui.MaxDistance = maxDist
	gui.Parent = hrp

	local lb = Instance.new("TextLabel")
	lb.Name = "InfoText"
	lb.BackgroundTransparency = 1
	lb.TextScaled = true
	lb.Font = Enum.Font.GothamBold
	lb.TextColor3 = Color3.new(1, 1, 1)
	lb.TextStrokeTransparency = 0.5
	lb.Size = UDim2.fromScale(1, 1)
	lb.Text = "Ready"
	lb.Parent = gui
end

local function createPortal(config, fromZone)
	local islandName = config.islandName or fromZone
	local zoneConfig = Islands[islandName]

	if not zoneConfig then
		warn(("[WarpPortal] ã‚¾ãƒ¼ãƒ³ '%s' ã®å³¶è¨­å®šãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"):format(islandName))
		return nil
	end

	local portalSize = config.size or Vector3.new(8, 12, 8)
	local portalHeight = portalSize.Y

	local portalX = zoneConfig.centerX + (config.offsetX or 0)
	local portalZ = zoneConfig.centerZ + (config.offsetZ or 0)

	local FieldGen = require(ReplicatedStorage:WaitForChild("FieldGen"))
	local groundY = nil
	local maxRetries = 2

	for attempt = 1, maxRetries do
		local rayStartY = zoneConfig.baseY + (zoneConfig.hillAmplitude or 20) + 100
		groundY = FieldGen.raycastGroundY(portalX, portalZ, rayStartY)
		if groundY then
			break
		end
		task.wait(0.05)
	end

	local portalY
	if groundY then
		portalY = groundY + portalHeight / 2
		print(
			("[WarpPortal DEBUG] %s: åœ°é¢æ¤œå‡ºæˆåŠŸ (Y=%.1f), ãƒãƒ¼ã‚¿ãƒ«Y=%.1f"):format(
				config.name,
				groundY,
				portalY
			)
		)
	else
		local estimatedHeight = zoneConfig.baseY + ((zoneConfig.hillAmplitude or 20) * 0.5)
		portalY = estimatedHeight + portalHeight / 2
		warn(("[WarpPortal DEBUG] %s: åœ°é¢æ¤œå‡ºå¤±æ•—ã€æ¨å®šé«˜åº¦ä½¿ç”¨ (Y=%.1f)"):format(config.name, portalY))
	end

	local portalPosition = Vector3.new(portalX, portalY, portalZ)

	local portal = Instance.new("Part")
	portal.Name = config.name
	portal.Size = portalSize
	portal.Position = portalPosition
	portal.Anchored = true
	portal.CanCollide = false
	portal.Transparency = 0.3
	portal.Color = config.color or Color3.fromRGB(255, 255, 255)
	portal.Material = Enum.Material.Neon

	portal:SetAttribute("FromZone", fromZone)
	portal:SetAttribute("ToZone", config.toZone)

	local bodyAngularVelocity = Instance.new("BodyAngularVelocity")
	bodyAngularVelocity.AngularVelocity = Vector3.new(0, 2, 0)
	bodyAngularVelocity.MaxTorque = Vector3.new(0, math.huge, 0)
	bodyAngularVelocity.P = 1000
	bodyAngularVelocity.Parent = portal

	local billboard = Instance.new("BillboardGui")
	billboard.Name = "PortalLabel"
	billboard.Size = UDim2.new(0, 200, 0, 50)
	billboard.StudsOffset = Vector3.new(0, 7, 0)
	billboard.AlwaysOnTop = true
	billboard.Parent = portal

	local label = Instance.new("TextLabel")
	label.Size = UDim2.new(1, 0, 1, 0)
	label.BackgroundTransparency = 1
	label.Text = config.label or ("â†’ " .. config.toZone)
	label.TextColor3 = Color3.new(1, 1, 1)
	label.TextScaled = true
	label.Font = Enum.Font.SourceSansBold
	label.TextStrokeTransparency = 0.5
	label.Parent = billboard

	local worldFolder = workspace:FindFirstChild("World")
	if not worldFolder then
		worldFolder = Instance.new("Folder")
		worldFolder.Name = "World"
		worldFolder.Parent = workspace
	end

	portal.Parent = worldFolder

	-- ãƒãƒ¼ã‚¿ãƒ«ã‚¿ãƒƒãƒå‡¦ç†
	portal.Touched:Connect(function(hit)
		local character = hit.Parent
		if not character then
			return
		end

		local player = Players:GetPlayerFromCharacter(character)
		if not player then
			return
		end

		-- ãƒ¯ãƒ¼ãƒ—ä¸­ãƒã‚§ãƒƒã‚¯
		if warpingPlayers[player.UserId] then
			return
		end

		-- ãƒãƒˆãƒ«ä¸­ãƒã‚§ãƒƒã‚¯
		if BattleSystem and BattleSystem.isInBattle and BattleSystem.isInBattle(player) then
			return
		end

		local actualFromZone = portal:GetAttribute("FromZone")
		local currentZone = ZoneManager.GetPlayerZone(player)

		if currentZone ~= actualFromZone then
			if not currentZone then
				ZoneManager.PlayerZones[player] = actualFromZone
			else
				return
			end
		end

		print(("[WarpPortal] %s ãŒ %s ã«å…¥ã‚Šã¾ã—ãŸ"):format(player.Name, config.name))

		-- ãƒ¯ãƒ¼ãƒ—ä¸­ãƒ•ãƒ©ã‚°ã‚’è¨­å®š
		warpingPlayers[player.UserId] = true
		character:SetAttribute("IsWarping", true)

		-- ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚’é€æ˜åŒ–
		local originalTransparencies = {}
		for _, part in ipairs(character:GetDescendants()) do
			if part:IsA("BasePart") then
				originalTransparencies[part] = part.Transparency
				part.Transparency = 1
			elseif part:IsA("Decal") or part:IsA("Texture") then
				originalTransparencies[part] = part.Transparency
				part.Transparency = 1
			end
		end

		-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ¬ãƒ™ãƒ«ã‚’å–å¾—
		local stats = PlayerStatsModule.getStats(player)
		local playerLevel = stats and stats.Level or 1
		print(("[WarpPortal] ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ %s ã®ãƒ¬ãƒ™ãƒ«: %d"):format(player.Name, playerLevel))

		-- ãƒ¬ãƒ™ãƒ«ä»˜ãã§ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°é–‹å§‹ã‚’é€šçŸ¥
		warpEvent:FireClient(player, "StartLoading", config.toZone, playerLevel)
		task.wait(0.5)

		-- ãƒãƒˆãƒ«ã‚·ã‚¹ãƒ†ãƒ ãƒªã‚»ãƒƒãƒˆ
		if BattleSystem and BattleSystem.resetAllBattles then
			BattleSystem.resetAllBattles()
		end

		-- ãƒ¯ãƒ¼ãƒ—å®Ÿè¡Œ
		local success = ZoneManager.WarpPlayerToZone(player, config.toZone)

		if success then
			-- é€æ˜åº¦ã‚’æˆ»ã™
			for part, transparency in pairs(originalTransparencies) do
				if part and part.Parent then
					part.Transparency = transparency
				end
			end

			-- æ–°ã—ã„ã‚¾ãƒ¼ãƒ³ã®ãƒãƒ¼ã‚¿ãƒ«ã‚’ç”Ÿæˆ
			createPortalsForZone(config.toZone)

			-- æ–°ã—ã„ã‚¾ãƒ¼ãƒ³ã®ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’ç”Ÿæˆ
			local TO_IS_TOWN = config.toZone == "ContinentTown"
			if not TO_IS_TOWN and _G.SpawnMonstersForZone then
				_G.SpawnMonstersForZone(config.toZone)
			end

			task.wait(0.5)
			warpEvent:FireClient(player, "EndLoading", config.toZone, playerLevel)
		else
			warn(("[WarpPortal] %s ã®ãƒ¯ãƒ¼ãƒ—ã«å¤±æ•—"):format(player.Name))
			warpEvent:FireClient(player, "EndLoading", config.toZone, playerLevel)
		end

		-- ãƒ¯ãƒ¼ãƒ—ä¸­ãƒ•ãƒ©ã‚°ã‚’è§£é™¤
		task.wait(1)
		warpingPlayers[player.UserId] = nil
		if character and character.Parent then
			character:SetAttribute("IsWarping", false)
		end
	end)

	return portal
end

function createPortalsForZone(zoneName)
	if activePortals[zoneName] then
		print(("[WarpPortal] %s ã®ãƒãƒ¼ã‚¿ãƒ«ã¯æ—¢ã«å­˜åœ¨ã—ã¾ã™"):format(zoneName))
		return
	end

	activePortals[zoneName] = {}

	local continent = Continents[zoneName]
	if continent and continent.portals then
		print(("[WarpPortal] %s ã®ãƒãƒ¼ã‚¿ãƒ«ã‚’ä¸¦åˆ—ç”Ÿæˆä¸­..."):format(zoneName))

		for _, portalConfig in ipairs(continent.portals) do
			task.spawn(function()
				local islandName = portalConfig.islandName
				if not Islands[islandName] then
					warn(("[WarpPortal] å³¶ '%s' ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"):format(islandName))
				else
					local portal = createPortal(portalConfig, zoneName)
					if portal then
						portal:SetAttribute("FromZone", zoneName)
						table.insert(activePortals[zoneName], portal)
						print(
							("[WarpPortal] ãƒãƒ¼ã‚¿ãƒ«ä½œæˆ: %s (é…ç½®: %s)"):format(portalConfig.name, islandName)
						)
					end
				end
			end)
		end
	else
		print(("[WarpPortal] %s ã®ãƒãƒ¼ã‚¿ãƒ«è¨­å®šãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"):format(zoneName))
	end
end

function destroyPortalsForZone(zoneName)
	local actualZoneName = zoneName
	if actualZoneName == "StartTown" then
		actualZoneName = "ContinentTown"
	end

	if not activePortals[actualZoneName] then
		print(
			("[WarpPortal] %s ã®ãƒãƒ¼ã‚¿ãƒ«ã¯ã‚ã‚Šã¾ã›ã‚“ï¼ˆæ—¢ã«å‰Šé™¤æ¸ˆã¿ã‹æœªä½œæˆï¼‰"):format(
				actualZoneName
			)
		)
		return
	end

	print(("[WarpPortal] %s ã®ãƒãƒ¼ã‚¿ãƒ«ã‚’å‰Šé™¤ä¸­..."):format(actualZoneName))

	for _, portal in ipairs(activePortals[actualZoneName] or {}) do
		if portal and portal.Parent then
			portal:Destroy()
		end
	end

	activePortals[actualZoneName] = nil
	print(("[WarpPortal] %s ã®ãƒãƒ¼ã‚¿ãƒ«ã‚’å‰Šé™¤å®Œäº†"):format(actualZoneName))
end

task.spawn(function()
	local maxWait = 10
	local waited = 0

	while not _G.SpawnMonstersForZone and waited < maxWait do
		task.wait(0.5)
		waited = waited + 0.5
	end

	if _G.SpawnMonstersForZone then
		print("[WarpPortal] MonsterSpawneré–¢æ•°æ¤œå‡ºæˆåŠŸ")
	else
		warn("[WarpPortal] MonsterSpawneré–¢æ•°ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
	end
end)

task.wait(0.3)
createPortalsForZone("ContinentTown")

Players.PlayerRemoving:Connect(function(player)
	warpingPlayers[player.UserId] = nil
	ZoneManager.PlayerZones[player] = nil
end)

_G.CreatePortalsForZone = createPortalsForZone
_G.DestroyPortalsForZone = destroyPortalsForZone

print("[WarpPortal] åˆæœŸåŒ–å®Œäº†")

===== ./ServerScriptService/InteractionSystem.server.lua =====
-- ServerScriptService/InteractionSystem.server.lua
-- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ã‚·ã‚¹ãƒ†ãƒ ï¼ˆå®ç®±ã€NPCç­‰ï¼‰

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")
local HttpService = game:GetService("HttpService")

print("[InteractionSystem] åˆæœŸåŒ–é–‹å§‹")

-- ä¾å­˜ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
local PlayerStatsModule = require(ServerScriptService:WaitForChild("PlayerStats"))

-- RemoteEventä½œæˆ
local InteractEvent = ReplicatedStorage:FindFirstChild("InteractEvent")
if not InteractEvent then
	InteractEvent = Instance.new("RemoteEvent")
	InteractEvent.Name = "InteractEvent"
	InteractEvent.Parent = ReplicatedStorage
end

local InteractionResponseEvent = ReplicatedStorage:FindFirstChild("InteractionResponse")
if not InteractionResponseEvent then
	InteractionResponseEvent = Instance.new("RemoteEvent")
	InteractionResponseEvent.Name = "InteractionResponse"
	InteractionResponseEvent.Parent = ReplicatedStorage
end

-- å®ç®±ã‚’é–‹ã‘ã‚‹å‡¦ç†
local function handleChestInteraction(player, chestObject)
	print("[InteractionSystem DEBUG] ã‚¹ãƒ†ãƒƒãƒ—1: é–‹å§‹")

	local chestId = chestObject:GetAttribute("ChestId")
	if not chestId then
		warn("[InteractionSystem] ChestIdãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“")
		return false
	end

	print("[InteractionSystem DEBUG] ã‚¹ãƒ†ãƒƒãƒ—2: ChestIdå–å¾— =", chestId)

	-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’å–å¾—
	local stats = PlayerStatsModule.getStats(player)
	if not stats then
		warn(("[InteractionSystem] %s ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"):format(player.Name))
		return false
	end

	print("[InteractionSystem DEBUG] ã‚¹ãƒ†ãƒƒãƒ—3: ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å–å¾—å®Œäº†")

	-- æ—¢ã«å–å¾—æ¸ˆã¿ã‹ãƒã‚§ãƒƒã‚¯
	if stats.CollectedItems[chestId] then
		print(("[InteractionSystem] %s ã¯æ—¢ã« %s ã‚’å–å¾—æ¸ˆã¿"):format(player.Name, chestId))
		return false
	end

	print("[InteractionSystem DEBUG] ã‚¹ãƒ†ãƒƒãƒ—4: æœªå–å¾—ç¢ºèªå®Œäº†")

	-- è·é›¢ãƒã‚§ãƒƒã‚¯ï¼ˆä¸æ­£é˜²æ­¢ï¼‰
	local character = player.Character
	if not character then
		warn("[InteractionSystem DEBUG] ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãªã—")
		return false
	end

	local hrp = character:FindFirstChild("HumanoidRootPart")
	if not hrp then
		warn("[InteractionSystem DEBUG] HRPãªã—")
		return false
	end

	print("[InteractionSystem DEBUG] ã‚¹ãƒ†ãƒƒãƒ—5: ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ç¢ºèªå®Œäº†")

	local distance = (hrp.Position - chestObject.Position).Magnitude
	local range = chestObject:GetAttribute("InteractionRange") or 8

	if distance > range + 5 then
		warn(("[InteractionSystem] %s ãŒé ã™ãã¾ã™: %.1f > %d"):format(player.Name, distance, range))
		return false
	end

	print("[InteractionSystem DEBUG] ã‚¹ãƒ†ãƒƒãƒ—6: è·é›¢ãƒã‚§ãƒƒã‚¯å®Œäº†")
	print(("[InteractionSystem] %s ãŒ %s ã‚’é–‹ã‘ã¾ã™"):format(player.Name, chestId))

	-- å ±é…¬ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
	local rewardsJson = chestObject:GetAttribute("RewardsData")
	print("[InteractionSystem DEBUG] ã‚¹ãƒ†ãƒƒãƒ—7: RewardsData =", rewardsJson)

	local rewards = {}
	if rewardsJson then
		local success, decoded = pcall(function()
			return HttpService:JSONDecode(rewardsJson)
		end)
		if success then
			rewards = decoded
			print("[InteractionSystem DEBUG] ã‚¹ãƒ†ãƒƒãƒ—8: å ±é…¬ãƒ‡ã‚³ãƒ¼ãƒ‰æˆåŠŸ")
		else
			warn("[InteractionSystem DEBUG] ã‚¹ãƒ†ãƒƒãƒ—8: å ±é…¬ãƒ‡ã‚³ãƒ¼ãƒ‰å¤±æ•—")
		end
	end

	-- å ±é…¬ã‚’ä»˜ä¸
	for _, reward in ipairs(rewards) do
		if reward.item == "ã‚´ãƒ¼ãƒ«ãƒ‰" then
			stats.Gold = stats.Gold + reward.count
			print(("[InteractionSystem] %s ã«ã‚´ãƒ¼ãƒ«ãƒ‰ %d ã‚’ä»˜ä¸"):format(player.Name, reward.count))
		else
			-- å°†æ¥çš„ã«ã‚¢ã‚¤ãƒ†ãƒ ã‚·ã‚¹ãƒ†ãƒ ã¨é€£æº
			print(("[InteractionSystem] %s ã« %s x%d ã‚’ä»˜ä¸ï¼ˆæœªå®Ÿè£…ï¼‰"):format(
				player.Name, reward.item, reward.count
			))
		end
	end

	print("[InteractionSystem DEBUG] ã‚¹ãƒ†ãƒƒãƒ—9: å ±é…¬ä»˜ä¸å®Œäº†")

	-- å–å¾—æ¸ˆã¿ã«è¨­å®š
	stats.CollectedItems[chestId] = true

	-- ã‚»ãƒ¼ãƒ–ï¼ˆå³åº§ã«ä¿å­˜ï¼‰
	if _G.AutoSavePlayer then
		_G.AutoSavePlayer(player, "å®ç®±å–å¾—")
	end

	print("[InteractionSystem DEBUG] ã‚¹ãƒ†ãƒƒãƒ—10: ã‚»ãƒ¼ãƒ–å®Œäº†")

	-- ãƒ¢ãƒ‡ãƒ«ã‚’é–‹ã„ãŸçŠ¶æ…‹ã«åˆ‡ã‚Šæ›¿ãˆ
	local openedModelName = chestObject:GetAttribute("OpenedModel")
	if openedModelName then
		print("[InteractionSystem DEBUG] ã‚¹ãƒ†ãƒƒãƒ—11: ãƒ¢ãƒ‡ãƒ«åˆ‡ã‚Šæ›¿ãˆé–‹å§‹")
		task.spawn(function()
			local ServerStorage = game:GetService("ServerStorage")
			local fieldObjectsFolder = ServerStorage:FindFirstChild("FieldObjects")
			if fieldObjectsFolder then
				local openedTemplate = fieldObjectsFolder:FindFirstChild(openedModelName)
				if openedTemplate then
					-- é–‰ã˜ãŸå®ç®±ã‚’éè¡¨ç¤º
					chestObject.Transparency = 1
					for _, child in ipairs(chestObject:GetDescendants()) do
						if child:IsA("BasePart") then
							child.Transparency = 1
						end
					end

					-- é–‹ã„ãŸå®ç®±ã‚’é…ç½®
					local openedChest = openedTemplate:Clone()
					openedChest.CFrame = chestObject.CFrame
					openedChest.Anchored = true
					openedChest.CanCollide = false
					openedChest.Parent = chestObject.Parent

					print("[InteractionSystem DEBUG] é–‹ã„ãŸå®ç®±ã‚’é…ç½®")

					-- è¡¨ç¤ºæ™‚é–“å¾Œã«å‰Šé™¤
					local duration = chestObject:GetAttribute("DisplayDuration") or 3
					task.wait(duration)

					openedChest:Destroy()
					chestObject:Destroy()

					print(("[InteractionSystem] %s ã‚’å‰Šé™¤ã—ã¾ã—ãŸ"):format(chestId))
				else
					warn("[InteractionSystem DEBUG] é–‹ã„ãŸãƒ¢ãƒ‡ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“:", openedModelName)
				end
			else
				warn("[InteractionSystem DEBUG] FieldObjectsãƒ•ã‚©ãƒ«ãƒ€ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
			end
		end)
	end

	print("[InteractionSystem DEBUG] ã‚¹ãƒ†ãƒƒãƒ—12: ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆé€ä¿¡æº–å‚™")

	-- ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«å ±é…¬æƒ…å ±ã‚’é€ä¿¡
	local responseData = {
		success = true,
		type = "chest",
		rewards = rewards,
		displayDuration = chestObject:GetAttribute("DisplayDuration") or 3,
	}

	print(("[InteractionSystem DEBUG] é€ä¿¡ãƒ‡ãƒ¼ã‚¿: %s"):format(HttpService:JSONEncode(responseData)))

	InteractionResponseEvent:FireClient(player, responseData)

	print("[InteractionSystem DEBUG] ã‚¹ãƒ†ãƒƒãƒ—13: é€ä¿¡å®Œäº†")

	return true
end

-- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³å‡¦ç†ã®ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°
local function handleInteraction(player, object)
	print("[InteractionSystem DEBUG] handleInteractionå‘¼ã³å‡ºã—")

	if not object or not object:IsA("BasePart") then
		warn("[InteractionSystem DEBUG] ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒç„¡åŠ¹")
		return
	end

	print("[InteractionSystem DEBUG] ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ:", object.Name)

	local interactionType = object:GetAttribute("InteractionType")
	print("[InteractionSystem DEBUG] InteractionType:", interactionType)

	if interactionType == "chest" then
		handleChestInteraction(player, object)
	elseif interactionType == "npc" then
		-- å°†æ¥çš„ã«NPCå‡¦ç†
		print("[InteractionSystem] NPCå‡¦ç†ã¯æœªå®Ÿè£…")
	else
		warn(("[InteractionSystem] æœªçŸ¥ã®ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—: %s"):format(tostring(interactionType)))
	end
end

-- ã‚¤ãƒ™ãƒ³ãƒˆæ¥ç¶š
InteractEvent.OnServerEvent:Connect(function(player, object)
	print("[InteractionSystem DEBUG] InteractEventå—ä¿¡")
	handleInteraction(player, object)
end)

-- å–å¾—æ¸ˆã¿ã‚¢ã‚¤ãƒ†ãƒ ãƒªã‚¹ãƒˆã‚’è¿”ã™RemoteFunction
local GetCollectedItemsFunc = ReplicatedStorage:FindFirstChild("GetCollectedItems")
if not GetCollectedItemsFunc then
	GetCollectedItemsFunc = Instance.new("RemoteFunction")
	GetCollectedItemsFunc.Name = "GetCollectedItems"
	GetCollectedItemsFunc.Parent = ReplicatedStorage
end

GetCollectedItemsFunc.OnServerInvoke = function(player)
	local stats = PlayerStatsModule.getStats(player)
	if stats and stats.CollectedItems then
		print(("[InteractionSystem] %s ã®å–å¾—æ¸ˆã¿ãƒªã‚¹ãƒˆã‚’é€ä¿¡: %då€‹"):format(
			player.Name,
			next(stats.CollectedItems) and #stats.CollectedItems or 0
		))
		return stats.CollectedItems
	end
	return {}
end

print("[InteractionSystem] åˆæœŸåŒ–å®Œäº†")
===== ./ServerScriptService/DataStoreManager.lua =====
-- ServerScriptService/DataStoreManager.lua
-- DataStoreã®åŸºæœ¬æ“ä½œã‚’ç®¡ç†ã™ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«

local DataStoreService = game:GetService("DataStoreService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local DataStoreManager = {}

-- DataStoreã®å®šç¾© (ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç®¡ç†ã®ãŸã‚V1)
local PLAYER_DATA_STORE = DataStoreService:GetDataStore("TypingQuestPlayerSaveData_V1")

-- â˜…ä¿®æ­£: WaitForChildã‚’å»ƒæ­¢ã—ã€éãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ã®FindFirstChildã‚’ä½¿ç”¨
local SAVE_SUCCESS_EVENT = ReplicatedStorage:FindFirstChild("SaveSuccess")
local LOAD_GAME_EVENT = ReplicatedStorage:FindFirstChild("LoadGame")

-- DataStoreã‚µãƒ¼ãƒ“ã‚¹å–å¾—
local success, DataStoreService = pcall(function()
	return game:GetService("DataStoreService")
end)

if not success then
	warn("[DataStoreManager] DataStoreãŒç„¡åŠ¹ã§ã™ã€‚Studioè¨­å®šã§æœ‰åŠ¹åŒ–ã—ã¦ãã ã•ã„ã€‚")
	-- ãƒ€ãƒŸãƒ¼ã®DataStoreã‚’è¿”ã™
	return {
		SavePlayerData = function() warn("[DataStore] ä¿å­˜ã‚¹ã‚­ãƒƒãƒ—ï¼ˆç„¡åŠ¹ï¼‰") end,
		LoadPlayerData = function() warn("[DataStore] èª­è¾¼ã‚¹ã‚­ãƒƒãƒ—ï¼ˆç„¡åŠ¹ï¼‰") return nil end,
	}
else
	print("[DataStoreManager] âœ… DataStoreè¨­å®š: æœ‰åŠ¹")
end

local PlayerDataStore = DataStoreService:GetDataStore("PlayerData_v1")

-- ãƒ‡ãƒ¼ã‚¿ã®ä¿å­˜ (éåŒæœŸ)
function DataStoreManager.SaveData(player: Player, data: table)
    local success, err = pcall(function()
        -- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®UserIdã‚’ã‚­ãƒ¼ã¨ã—ã¦ä½¿ç”¨
        PLAYER_DATA_STORE:SetAsync(player.UserId, data)
    end)

    -- ã€ä¿®æ­£ã€‘æ¯å›SaveSuccessEventã‚’å–å¾—
    local SaveSuccessEvent = ReplicatedStorage:FindFirstChild("SaveSuccess")

    if success then
        print(("[DataStoreManager] %s ã®ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜ã—ã¾ã—ãŸã€‚ã‚­ãƒ¼: %d"):format(player.Name, player.UserId))

        -- ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«ä¿å­˜æˆåŠŸã‚’é€šçŸ¥
        if SaveSuccessEvent then
            SaveSuccessEvent:FireClient(player, true)
        end
    else
        warn(("[DataStoreManager] %s ã®ãƒ‡ãƒ¼ã‚¿ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ: %s"):format(player.Name, err))

        -- ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«ä¿å­˜å¤±æ•—ã‚’é€šçŸ¥
        if SaveSuccessEvent then
            SaveSuccessEvent:FireClient(player, false)
        end
    end
    return success
end

-- ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ (éåŒæœŸ)
function DataStoreManager.LoadData(player: Player)
    local data = nil
    local success, err = pcall(function()
        -- ãƒ‡ãƒ¼ã‚¿ã®å–å¾— (ç¢ºå®Ÿã«UserIdã‚’ä½¿ç”¨)
        data = PLAYER_DATA_STORE:GetAsync(player.UserId)
    end)

    if success then
        print(("[DataStoreManager] %s ã®ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸã€‚ã‚­ãƒ¼: %d"):format(player.Name, player.UserId))

        -- ãƒ‡ãƒ¼ã‚¿ãŒnilã®å ´åˆã€æ–°è¦ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã—ã¦ç©ºã®ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’è¿”ã™
        return data or {}
    else
        warn(("[DataStoreManager] %s ã®ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: %s"):format(player.Name, err))
        return {} -- å¤±æ•—ã—ãŸå ´åˆã¯ç©ºã®ãƒ‡ãƒ¼ã‚¿ã‚’è¿”ã—ã€ã‚²ãƒ¼ãƒ ã‚’ç¶™ç¶šã•ã›ã‚‹
    end
end

-- æ‰‹å‹•ãƒ­ãƒ¼ãƒ‰è¦æ±‚ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ (ãƒ­ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³æŠ¼ä¸‹æ™‚)
if LOAD_GAME_EVENT then
    LOAD_GAME_EVENT.OnServerEvent:Connect(function(player)
        -- ç¾çŠ¶ã€ç‰¹åˆ¥ãªå‡¦ç†ã¯ä¸è¦ï¼ˆæ¬¡ã®æ¥ç¶šæ™‚ã«è‡ªå‹•ãƒ­ãƒ¼ãƒ‰ã•ã‚Œã‚‹ãŸã‚ï¼‰
        print(("[DataStoreManager] %s ã‹ã‚‰ãƒ­ãƒ¼ãƒ‰è¦æ±‚ã‚’å—ä¿¡ã—ã¾ã—ãŸã€‚"):format(player.Name))
    end)
else
    warn("[DataStoreManager] LOAD_GAME_EVENT ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚ãƒ­ãƒ¼ãƒ‰è¦æ±‚ãƒªã‚¹ãƒŠãƒ¼ã¯æ©Ÿèƒ½ã—ã¾ã›ã‚“ã€‚")
end

return DataStoreManager
===== ./ServerScriptService/BattleSystem.lua =====
-- ServerScriptService/BattleSystem.lua
-- ãƒãƒˆãƒ«ã‚·ã‚¹ãƒ†ãƒ ã®ç®¡ç†ï¼ˆæ•µã®å®šæœŸæ”»æ’ƒå¯¾å¿œç‰ˆï¼‰
-- ã‚¹ãƒ†ãƒƒãƒ—4: SharedStateçµ±åˆç‰ˆ

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")

-- ã€ã‚¹ãƒ†ãƒƒãƒ—4ã€‘SharedStateã¨GameEventsã‚’ãƒ­ãƒ¼ãƒ‰
local SharedState = require(ReplicatedStorage:WaitForChild("SharedState"))
local GameEvents = require(ReplicatedStorage:WaitForChild("GameEvents"))

local BattleSystem = {}

-- PlayerStatsãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ãƒ­ãƒ¼ãƒ‰
local PlayerStats = require(ServerScriptService:WaitForChild("PlayerStats"))

-- ã€ã‚¹ãƒ†ãƒƒãƒ—4ã€‘ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã‚’SharedStateã«ç§»è¡Œ
-- SharedState.ActiveBattles = {}  -- æ—¢ã«SharedStateã§å®šç¾©æ¸ˆã¿
-- SharedState.GlobalBattleActive = false  -- è¿½åŠ ãŒå¿…è¦
-- SharedState.EndingBattles = {}  -- è¿½åŠ ãŒå¿…è¦
-- SharedState.DefeatedByMonster = {}  -- è¿½åŠ ãŒå¿…è¦

-- åˆæœŸåŒ–ï¼ˆSharedStateã«è¿½åŠ ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’è¨­å®šï¼‰
if not SharedState.GlobalBattleActive then
	SharedState.GlobalBattleActive = false
end
if not SharedState.EndingBattles then
	SharedState.EndingBattles = {}
end
if not SharedState.DefeatedByMonster then
	SharedState.DefeatedByMonster = {}
end

-- ãƒãƒˆãƒ«çµ‚äº†ç›´å¾Œã®ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³
local LastBattleEndTime = 0
local BATTLE_COOLDOWN = 0.5

-- â˜… æ”»æ’ƒé–“éš”ã®åŸºæº–ï¼ˆæ‹®æŠ—=4sã€+100â†’8sã€-100â†’1sï¼‰
local function computeBaseEnemyInterval(playerSpeed: number, enemySpeed: number): number
	local diff = (playerSpeed or 0) - (enemySpeed or 0)
	if diff <= 0 then
		-- diff: -100â†’0 ã‚’ 1sâ†’4s ã«ç·šå½¢ãƒãƒƒãƒ—
		return 1 + 0.03 * math.clamp(diff + 100, 0, 100) -- 1ï½4
	else
		-- diff: 0â†’+100 ã‚’ 4sâ†’8s ã«ç·šå½¢ãƒãƒƒãƒ—
		return 4 + 0.04 * math.clamp(diff, 0, 100) -- 4ï½8
	end
end

-- â˜… å°†æ¥ã®ãƒãƒ•/ãƒ‡ãƒãƒ•å€ç‡ã‚’æ›ã‘ã‚‹ï¼ˆé€¸è„±è¨±å®¹ã®ãŸã‚ç·©ã„æœ€çµ‚ã‚¯ãƒ©ãƒ³ãƒ—ï¼‰
local MIN_INTERVAL, MAX_INTERVAL = 0.5, 12
local function applyIntervalModifiers(baseInterval: number, multiplier: number?): number
	return math.clamp(baseInterval * (multiplier or 1), MIN_INTERVAL, MAX_INTERVAL)
end

-- â˜…ï¼ˆä»»æ„æ‹¡å¼µï¼‰çŠ¶æ…‹ã‹ã‚‰å€ç‡ã‚’é›†è¨ˆã™ã‚‹å…¥å£ã€‚ç¾çŠ¶ã¯1å›ºå®šã€‚
local function getIntervalMultiplierFor(player: Player, monsterDef): number
	-- ä¾‹ï¼šSharedStateã‚„ä¸€æ™‚çš„ãªStatusã‹ã‚‰ã‚¹ãƒ­ã‚¦/ãƒ˜ã‚¤ã‚¹ãƒˆã‚’èª­ã‚€
	-- return (SharedState.IntervalMult[player] or 1)
	return 1
end

-- RemoteEvent ã®ä½œæˆ/å–å¾—
local function getOrCreateRemoteEvent(name)
	local event = ReplicatedStorage:FindFirstChild(name)
	if not event then
		event = Instance.new("RemoteEvent")
		event.Name = name
		event.Parent = ReplicatedStorage
		-- print(("[BattleSystem] RemoteEventä½œæˆ: %s"):format(name))
	end
	return event
end

-- RemoteEventsã‚’ä½œæˆ
local BattleStartEvent = getOrCreateRemoteEvent("BattleStart")
local BattleEndEvent = getOrCreateRemoteEvent("BattleEnd")
local BattleVictoryEvent = getOrCreateRemoteEvent("BattleVictory")
local BattleDamageEvent = getOrCreateRemoteEvent("BattleDamage")
local BattleHPUpdateEvent = getOrCreateRemoteEvent("BattleHPUpdate")
local PlayerHPUpdateEvent = getOrCreateRemoteEvent("PlayerHPUpdate")
local StatusUpdateEvent = getOrCreateRemoteEvent("StatusUpdate")
local RequestStatusEvent = getOrCreateRemoteEvent("RequestStatus")
local LevelUpEvent = getOrCreateRemoteEvent("LevelUp")
local ShowDeathUIEvent = getOrCreateRemoteEvent("ShowDeathUI")
local DeathChoiceEvent = getOrCreateRemoteEvent("DeathChoice")
local TypingMistakeEvent = getOrCreateRemoteEvent("TypingMistake")
local EnemyAttackCycleStartEvent = getOrCreateRemoteEvent("EnemyAttackCycleStart")
local EnemyDamageEvent = getOrCreateRemoteEvent("EnemyDamage")
local RequestEnemyCycleSyncEvent = getOrCreateRemoteEvent("RequestEnemyCycleSync")


print("[BattleSystem] RemoteEventsæº–å‚™å®Œäº†")

-- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼å®šç¾©ã‚’å–å¾—
local MonstersRegistry = require(ReplicatedStorage:WaitForChild("Monsters"):WaitForChild("Registry"))

-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«é€ä¿¡
local function sendStatusUpdate(player: Player)
	local stats = PlayerStats.getStats(player)
	if not stats then return end

	-- PlayerStats.getExpToNext ã‚’ä½¿ã†
	local expToNext = 0
	if PlayerStats.getExpToNext then
		expToNext = PlayerStats.getExpToNext(stats.Level)
	else
		expToNext = math.floor(50 * (stats.Level ^ 1.7) + 0.5) -- å¿µã®ãŸã‚ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
	end

	StatusUpdateEvent:FireClient(
		player,
		stats.CurrentHP,
		stats.MaxHP,
		stats.Level,
		stats.Experience,
		expToNext,
		stats.Gold
	)
end

-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒæˆ¦é—˜ä¸­ã‹ãƒã‚§ãƒƒã‚¯
function BattleSystem.isInBattle(player: Player): boolean
	return SharedState.ActiveBattles[player] ~= nil
end

-- ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªãƒãƒˆãƒ«çŠ¶æ…‹ã‚’å–å¾—
function BattleSystem.isAnyBattleActive(): boolean
	return SharedState.GlobalBattleActive
end

-- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼å®šç¾©ã‚’åå‰ã‹ã‚‰å–å¾—
local function getMonsterDef(monsterName)
	for _, def in ipairs(MonstersRegistry) do
		if def.Name == monsterName then
			return def
		end
	end
	return nil
end

-- ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’è¨ˆç®—ï¼ˆæ•µâ†’ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼‰
local function calculateDamage(attackerAttack: number, defenderDefense: number): number
	-- åŸºæœ¬ãƒ€ãƒ¡ãƒ¼ã‚¸ = æ”»æ’ƒåŠ› * 0.5 - å®ˆå‚™åŠ› * 0.25
	local baseDamage = attackerAttack * 0.5 - defenderDefense * 0.25
	baseDamage = math.max(1, baseDamage)  -- æœ€ä½1ãƒ€ãƒ¡ãƒ¼ã‚¸

	-- Â±10%ã®ãƒ©ãƒ³ãƒ€ãƒ å¹…
	local randomMultiplier = 0.9 + math.random() * 0.2  -- 0.9 ~ 1.1
	local finalDamage = baseDamage * randomMultiplier

	return math.floor(finalDamage)  -- æ•´æ•°ã«ä¸¸ã‚ã‚‹
end

-- æ”»æ’ƒé–“éš”ã‚’è¨ˆç®—
local function calculateAttackInterval(playerSpeed: number, enemySpeed: number, player: Player, monsterDef): number
	local base = computeBaseEnemyInterval(playerSpeed, enemySpeed)
	local mult = getIntervalMultiplierFor(player, monsterDef) -- å°†æ¥æ‹¡å¼µ
	return applyIntervalModifiers(base, mult)
end

-- æ•µã®æ”»æ’ƒå‡¦ç†
-- æ•µã®æ”»æ’ƒå‡¦ç†
local function enemyAttack(player: Player, battleData)
	-- å®‰å…¨ã‚¬ãƒ¼ãƒ‰
	if not battleData or not battleData.monster or not battleData.monsterDef then
		warn(("[BattleSystem] invalid battleData; aborting enemyAttack for %s"):format(player.Name))
		return
	end

	local monsterDef = battleData.monsterDef
	local playerStats = PlayerStats.getStats(player)
	if not playerStats then
		warn(("[BattleSystem] %s ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"):format(player.Name))
		return
	end

	-- ãƒ€ãƒ¡ãƒ¼ã‚¸è¨ˆç®—
	local damage = calculateDamage(monsterDef.Attack, playerStats.Defense)
	print(("[BattleSystem] %s ãŒ %s ã‹ã‚‰ %d ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ãŸ"):format(player.Name, battleData.monster.Name, damage))

	-- ãƒ€ãƒ¡ãƒ¼ã‚¸åæ˜ 
	local isDead = PlayerStats.takeDamage(player, damage)

	-- ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«ã€Œæ•µã‚¿ãƒ¼ãƒ³ã®è¢«å¼¾ã€ã‚’é€šçŸ¥ï¼ˆèµ¤ç‚¹æ»…ï¼‹SEç”¨ï¼‰
	EnemyDamageEvent:FireClient(player, { amount = damage })

	-- HPæ›´æ–°ã‚’é€šçŸ¥
	PlayerHPUpdateEvent:FireClient(player, playerStats.CurrentHP, playerStats.MaxHP)

	if isDead then
		print(("[BattleSystem] %s ã¯å€’ã‚ŒãŸï¼"):format(player.Name))
		BattleSystem.endBattle(player, false)
		return
	end

	-- æ¬¡ã‚µã‚¤ã‚¯ãƒ«ã‚’ç¢ºå®š
	local attackInterval = calculateAttackInterval(playerStats.Speed, monsterDef.Speed, player, monsterDef)
	local nowTick = tick()
	battleData.nextAttackTime = nowTick + attackInterval

	-- ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«æ¬¡ã‚µã‚¤ã‚¯ãƒ«é–‹å§‹ã‚’é€šçŸ¥ï¼ˆãƒ—ãƒ­ã‚°ãƒ¬ã‚¹åŒæœŸï¼‰
	EnemyAttackCycleStartEvent:FireClient(player, { intervalSec = attackInterval, startedAt = nowTick })

	print(("[BattleSystem] æ¬¡ã®æ”»æ’ƒã¾ã§ %.1f ç§’"):format(attackInterval))
end


-- ãƒãƒˆãƒ«é–‹å§‹
function BattleSystem.startBattle(player: Player, monster: Model)
	print(("[BattleSystem] startBattleå‘¼ã³å‡ºã—: %s vs %s"):format(player.Name, monster.Name))

	-- ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ãƒã‚§ãƒƒã‚¯
	local timeSinceLastBattle = tick() - LastBattleEndTime
	if timeSinceLastBattle < BATTLE_COOLDOWN then
		return false
	end

	-- äºŒé‡ãƒã‚§ãƒƒã‚¯
	if SharedState.GlobalBattleActive then
		return false
	end

	if BattleSystem.isInBattle(player) then
		return false
	end

	-- çµ‚äº†å‡¦ç†ä¸­ãƒã‚§ãƒƒã‚¯
	if SharedState.EndingBattles[player] then
		print(("[BattleSystem] %s ã¯çµ‚äº†å‡¦ç†ä¸­ã§ã™"):format(player.Name))
		return false
	end

	local character = player.Character
	if not character then
		return false
	end

	local humanoid = character:FindFirstChildOfClass("Humanoid")
	local hrp = character:FindFirstChild("HumanoidRootPart")
	local monsterHumanoid = monster:FindFirstChildOfClass("Humanoid")
	local monsterHrp = monster.PrimaryPart

	if not humanoid or not hrp or not monsterHumanoid or not monsterHrp then
		return false
	end

	-- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã®ç¨®é¡ã‚’å–å¾—
	local monsterKind = monster:GetAttribute("MonsterKind") or "Unknown"
	local monsterDef = getMonsterDef(monsterKind)

	if not monsterDef then
		warn(("[BattleSystem] ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼å®šç¾©ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: %s"):format(monsterKind))
		return false
	end

	-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’å–å¾—
	local playerStats = PlayerStats.getStats(player)
	if not playerStats then
		warn(("[BattleSystem] %s ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"):format(player.Name))
		return false
	end

	print(("[BattleSystem] ãƒãƒˆãƒ«é–‹å§‹: %s vs %s"):format(player.Name, monster.Name))
	print(("  ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼: HP %d/%d, ç´ æ—©ã• %d, æ”»æ’ƒ %d, å®ˆå‚™ %d"):format(
		playerStats.CurrentHP, playerStats.MaxHP,
		playerStats.Speed, playerStats.Attack, playerStats.Defense
		))
	print(("  ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼: HP %d, ç´ æ—©ã• %d, æ”»æ’ƒ %d, å®ˆå‚™ %d"):format(
		monsterDef.HP, monsterDef.Speed, monsterDef.Attack, monsterDef.Defense
		))

	-- ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒãƒˆãƒ«ãƒ•ãƒ©ã‚°ã‚’ON
	SharedState.GlobalBattleActive = true

	-- å…ƒã®é€Ÿåº¦ã‚’ä¿å­˜
	local originalPlayerSpeed = humanoid.WalkSpeed
	local originalJumpPower = humanoid.JumpPower
	local originalMonsterSpeed = monsterHumanoid.WalkSpeed

	-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å®Œå…¨åœæ­¢
	humanoid.WalkSpeed = 0
	humanoid.JumpPower = 0
	humanoid.JumpHeight = 0

	-- ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Œå…¨åœæ­¢
	for _, track in pairs(humanoid:GetPlayingAnimationTracks()) do
		track:Stop(0)
	end

	humanoid:ChangeState(Enum.HumanoidStateType.Physics)
	task.wait(0.05)
	humanoid:ChangeState(Enum.HumanoidStateType.Running)
	hrp.Anchored = true
	hrp.AssemblyLinearVelocity = Vector3.zero
	hrp.AssemblyAngularVelocity = Vector3.zero

	-- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’å®Œå…¨åœæ­¢
	monsterHumanoid.WalkSpeed = 0
	monsterHumanoid.JumpPower = 0
	monsterHumanoid:MoveTo(monsterHrp.Position)

	-- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã®å…¨ãƒ‘ãƒ¼ãƒ„ã‚’Anchor
	for _, part in ipairs(monster:GetDescendants()) do
		if part:IsA("BasePart") then
			part.Anchored = true
		end
	end

	-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®1æ–‡å­—ã‚ãŸã‚Šã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’è¨ˆç®—
	local damagePerKey = math.floor(playerStats.Attack * 0.8)
	damagePerKey = math.max(1, damagePerKey)  -- æœ€ä½1ãƒ€ãƒ¡ãƒ¼ã‚¸

	-- æ•µã®æœ€åˆã®æ”»æ’ƒã‚¿ã‚¤ãƒŸãƒ³ã‚°ã‚’è¨ˆç®—
	local attackInterval = calculateAttackInterval(playerStats.Speed, monsterDef.Speed, player, monsterDef)
	local nowTick = tick()
	local nextAttackTime = nowTick + attackInterval

	-- â˜… æˆ¦é—˜ãƒ‡ãƒ¼ã‚¿ã‚’å…ˆã«è¨˜éŒ²ï¼ˆã“ã“ãŒæœ€å„ªå…ˆï¼ï¼‰
	SharedState.ActiveBattles[player] = {
		monster = monster,
		monsterDef = monsterDef,
		monsterHP = monsterDef.HP,
		monsterMaxHP = monsterDef.HP,
		damagePerKey = damagePerKey,
		nextAttackTime = nextAttackTime,
		startTime = tick(),
		originalPlayerSpeed = originalPlayerSpeed,
		originalJumpPower = originalJumpPower,
		originalMonsterSpeed = originalMonsterSpeed
	}

	-- â˜… ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«ãƒãƒˆãƒ«é–‹å§‹ã‚’é€šçŸ¥ï¼ˆã“ã®æ™‚ç‚¹ã§ inBattle = true ã«ãªã‚‹ï¼‰
	BattleStartEvent:FireClient(
		player,
		monster.Name,
		monsterDef.HP,
		monsterDef.HP,
		damagePerKey,
		monsterDef.TypingLevels or {{level = "level_1", weight = 100}},
		playerStats.CurrentHP,
		playerStats.MaxHP
	)

	-- â˜… åˆå›ã‚µã‚¤ã‚¯ãƒ«ã‚’ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¸é€šçŸ¥ï¼ˆé †åºã¯ BattleStart ã®â€œå¾Œâ€ï¼‰
	EnemyAttackCycleStartEvent:FireClient(player, { intervalSec = attackInterval, startedAt = nowTick })

	-- â˜… æ•µã®æ”»æ’ƒãƒ«ãƒ¼ãƒ—ã‚’é–‹å§‹ï¼ˆæœ€å¾Œã«ï¼‰
	task.spawn(function()
		while SharedState.ActiveBattles[player] and not SharedState.EndingBattles[player] do
			local bd = SharedState.ActiveBattles[player]
			if not bd then break end

			if tick() >= bd.nextAttackTime then
				enemyAttack(player, bd)
			end

			task.wait(0.1)
		end
	end)
	-- ã“ã“ã‹ã‚‰è¿½è¨˜ï¼ˆé–¢æ•°ã‚’é–‰ã˜ã‚‹ï¼‰
	return true
end


-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‹ã‚‰ã®ãƒ€ãƒ¡ãƒ¼ã‚¸å‡¦ç†
local function onDamageReceived(player, damageAmount)
	-- ãƒãƒˆãƒ«çµ‚äº†å‡¦ç†ä¸­ã¯ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ç„¡è¦–
	if SharedState.EndingBattles[player] then
		print(("[BattleSystem] %s ã¯çµ‚äº†å‡¦ç†ä¸­ã®ãŸã‚ã€ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ç„¡è¦–"):format(player.Name))
		return
	end

	local battleData = SharedState.ActiveBattles[player]
	if not battleData then
		warn(("[BattleSystem] %s ã¯ãƒãƒˆãƒ«ä¸­ã§ã¯ã‚ã‚Šã¾ã›ã‚“ï¼ˆãƒ€ãƒ¡ãƒ¼ã‚¸ç„¡è¦–ï¼‰"):format(player.Name))
		return
	end

	-- HPã‚’æ¸›ã‚‰ã™
	local oldHP = battleData.monsterHP
	battleData.monsterHP = math.max(0, battleData.monsterHP - damageAmount)

	print(("[BattleSystem] ========================================"):format())
	print(("[BattleSystem] ãƒ€ãƒ¡ãƒ¼ã‚¸å‡¦ç†"):format())
	print(("  ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼: %s"):format(player.Name))
	print(("  ãƒ€ãƒ¡ãƒ¼ã‚¸é‡: %d"):format(damageAmount))
	print(("  HPå¤‰åŒ–: %d â†’ %d"):format(oldHP, battleData.monsterHP))
	print(("  æœ€å¤§HP: %d"):format(battleData.monsterMaxHP))
	print(("[BattleSystem] ========================================"):format())

	-- ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«HPæ›´æ–°ã‚’é€šçŸ¥
	BattleHPUpdateEvent:FireClient(player, battleData.monsterHP)

	-- HPãŒ0ã«ãªã£ãŸã‚‰å‹åˆ©
	if battleData.monsterHP <= 0 then
		print(("[BattleSystem] ========================================"):format())
		print(("[BattleSystem] ğŸ‰ å‹åˆ©æ¡ä»¶é”æˆï¼"):format())
		print(("  %s ãŒ %s ã‚’å€’ã—ã¾ã—ãŸï¼"):format(player.Name, battleData.monster.Name))
		print(("  ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼HP: %d"):format(battleData.monsterHP))
		print(("[BattleSystem] endBattle(true) ã‚’å‘¼ã³å‡ºã—ã¾ã™"):format())
		print(("[BattleSystem] ========================================"):format())

		BattleSystem.endBattle(player, true)

		print(("[BattleSystem] endBattle(true) å‘¼ã³å‡ºã—å®Œäº†"):format())
	end
end

-- ãƒãƒˆãƒ«çµ‚äº†
function BattleSystem.endBattle(player: Player, victory: boolean)
	print(("[BattleSystem] ãƒãƒˆãƒ«çµ‚äº†: %s - %s"):format(
		player.Name, victory and "å‹åˆ©" or "æ•—åŒ—"
		))

	-- äºŒé‡çµ‚äº†ãƒã‚§ãƒƒã‚¯
	if SharedState.EndingBattles[player] then
		warn(("[BattleSystem] %s ã¯æ—¢ã«çµ‚äº†å‡¦ç†ä¸­ã§ã™"):format(player.Name))
		return
	end

	-- çµ‚äº†å‡¦ç†ä¸­ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹
	SharedState.EndingBattles[player] = true

	-- ã€é‡è¦ã€‘å‹åˆ©æ™‚ã®ã¿ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒãƒˆãƒ«ãƒ•ãƒ©ã‚°ã‚’OFF
	-- æ•—åŒ—æ™‚ã¯æ­»äº¡é¸æŠãŒå®Œäº†ã™ã‚‹ã¾ã§ç¶­æŒ
	if victory then
		SharedState.GlobalBattleActive = false
	end

	-- ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³é–‹å§‹
	LastBattleEndTime = tick()

	local battleData = SharedState.ActiveBattles[player]
	if not battleData then
		warn("[BattleSystem] battleDataãŒå­˜åœ¨ã—ã¾ã›ã‚“ï¼")

		-- æœ€ä½é™ã®å¾©å…ƒ
		local character = player.Character
		if character then
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			local hrp = character:FindFirstChild("HumanoidRootPart")
			if humanoid then
				humanoid.WalkSpeed = 16
				humanoid.JumpPower = 50
				humanoid.JumpHeight = 7.2
			end
			if hrp then
				hrp.Anchored = false
			end
		end

		-- ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«é€šçŸ¥
		BattleEndEvent:FireClient(player, victory, nil)

		SharedState.ActiveBattles[player] = nil

		-- çµ‚äº†å‡¦ç†å®Œäº†å¾Œã«ãƒ•ãƒ©ã‚°ã‚’è§£é™¤
		task.delay(1, function()
			SharedState.EndingBattles[player] = nil
		end)

		return
	end

	local character = player.Character
	local monster = battleData.monster
	local monsterDef = battleData.monsterDef

	-- å‹åˆ©æ™‚ã®å‡¦ç†
	if victory then
		-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç§»å‹•ã‚’å¾©å…ƒ
		if character then
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			local hrp = character:FindFirstChild("HumanoidRootPart")
			if humanoid then
				humanoid.WalkSpeed = battleData.originalPlayerSpeed or 16
				humanoid.JumpPower = battleData.originalJumpPower or 50
				humanoid.JumpHeight = 7.2
			end
			if hrp then
				hrp.Anchored = false
			end
		end

		-- çµŒé¨“å€¤ã¨ã‚´ãƒ¼ãƒ«ãƒ‰ã‚’ä»˜ä¸
		if monsterDef.Experience then
			print(("[BattleSystem] çµŒé¨“å€¤ %d ã‚’ä»˜ä¸"):format(monsterDef.Experience))
			PlayerStats.addExperience(player, monsterDef.Experience)
		end
		if monsterDef.Gold then
			print(("[BattleSystem] ã‚´ãƒ¼ãƒ«ãƒ‰ %d ã‚’ä»˜ä¸"):format(monsterDef.Gold))
			PlayerStats.addGold(player, monsterDef.Gold)
		end

		print(("[BattleSystem] ========================================"):format())
		print(("[BattleSystem] ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æ’ƒç ´ã‚«ã‚¦ãƒ³ãƒˆå‡¦ç†é–‹å§‹"):format())
		print(("[BattleSystem] ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼: %s"):format(player.Name))
		print(("[BattleSystem] ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼: %s"):format(battleData.monster.Name))


		PlayerStats.addMonstersDefeated(player, 1)

		print(("[BattleSystem] ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æ’ƒç ´ã‚«ã‚¦ãƒ³ãƒˆå‡¦ç†å®Œäº†"):format())
		print(("[BattleSystem] ========================================"):format())


		-- å°‘ã—å¾…ã£ã¦ã‹ã‚‰ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°ã‚’é€ä¿¡ï¼ˆå¿µã®ãŸã‚ï¼‰
		task.wait(0.1)
		sendStatusUpdate(player)

		-- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’éè¡¨ç¤º
		monster:SetAttribute("Defeated", true)

		for _, part in ipairs(monster:GetDescendants()) do
			if part:IsA("BasePart") then
				part.Transparency = 1
			end
		end

		local hrp = monster:FindFirstChild("HumanoidRootPart")
		if hrp then
			local gui = hrp:FindFirstChild("DebugInfo")
			if gui then
				gui.Enabled = false
			end
		end

		-- 1ç§’å¾Œã«å‰Šé™¤
		task.delay(1, function()
			if monster and monster.Parent then
				monster:Destroy()
			end
		end)
	else
		-- æ•—åŒ—æ™‚ï¼šãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯ç§»å‹•åˆ¶é™ã‚’ç¶­æŒï¼ˆæ­»äº¡é¸æŠUIã§é¸ã‚“ã å¾Œã«å¾©å…ƒï¼‰
		-- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’å¾©å…ƒ
		monster:SetAttribute("InBattle", false)

		local monsterHumanoid = monster:FindFirstChildOfClass("Humanoid")
		if monsterHumanoid then
			monsterHumanoid.WalkSpeed = battleData.originalMonsterSpeed or 14
		end

		-- Anchorè§£é™¤
		local partsToUnanchor = {}
		for _, part in ipairs(monster:GetDescendants()) do
			if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
				table.insert(partsToUnanchor, part)
			end
		end

		for _, part in ipairs(partsToUnanchor) do
			part.Anchored = false
		end

		if monster.PrimaryPart then
			task.wait(0.1)
			monster.PrimaryPart.Anchored = false
		end

		-- æ­»äº¡æ™‚ã®é¸æŠUIã‚’è¡¨ç¤º
		local playerStats = PlayerStats.getStats(player)
		if playerStats then
			local reviveCost = math.floor(playerStats.Level * 50)  -- ãƒ¬ãƒ™ãƒ« * 50ã‚´ãƒ¼ãƒ«ãƒ‰
			print(("[BattleSystem] ========================================"):format())
			print(("[BattleSystem] æ­»äº¡UIè¡¨ç¤ºã‚’é€ä¿¡"):format())
			print(("[BattleSystem] æ‰€æŒé‡‘: %d G, å¾©æ´»ã‚³ã‚¹ãƒˆ: %d G"):format(playerStats.Gold, reviveCost))
			print(("[BattleSystem] ========================================"):format())

			-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«æ­»äº¡ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹ï¼ˆãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ãŒæ¥è§¦ã—ãªã„ã‚ˆã†ã«ï¼‰
			if character then
				character:SetAttribute("IsDead", true)
				print(("[BattleSystem] %s ã«æ­»äº¡ãƒ•ãƒ©ã‚°ã‚’è¨­å®š"):format(player.Name))
			end

			-- ã€é‡è¦ã€‘å€’ã—ãŸãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’è¨˜éŒ²ï¼ˆé¸æŠå¾Œã«æ¶ˆå»ã™ã‚‹ãŸã‚ï¼‰
			SharedState.DefeatedByMonster[player] = monster
			print(("[BattleSystem] å€’ã—ãŸãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ %s ã‚’è¨˜éŒ²"):format(monster.Name))

			ShowDeathUIEvent:FireClient(player, playerStats.Gold, reviveCost)
		else
			warn("[BattleSystem] ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ï¼")
		end
	end

	-- ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«é€šçŸ¥
	local summary = nil
	if victory then
		local exp = (monsterDef and monsterDef.Experience) or 0
		local gold = (monsterDef and monsterDef.Gold) or 0
		-- ãƒ‰ãƒ­ãƒƒãƒ—å®šç¾©ãŒã‚ã‚Œã°ä½¿ã†ã€‚ãªã‘ã‚Œã°ç©ºé…åˆ—ã§OK
		local drops = (monsterDef and monsterDef.Drops) or {}
		summary = { exp = exp, gold = gold, drops = drops }
	end

	BattleEndEvent:FireClient(player, victory, summary)

	-- å‹åˆ©æ™‚ã¯æˆ¦é—˜ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¯ãƒªã‚¢ã—ã¦çµ‚äº†å‡¦ç†ãƒ•ãƒ©ã‚°ã‚‚è§£é™¤
	if victory then
		SharedState.ActiveBattles[player] = nil

		-- çµ‚äº†å‡¦ç†å®Œäº†å¾Œã«ãƒ•ãƒ©ã‚°ã‚’è§£é™¤ï¼ˆ1ç§’å¾Œï¼‰
		task.delay(1, function()
			SharedState.EndingBattles[player] = nil
			print(("[BattleSystem] %s ã®çµ‚äº†å‡¦ç†ãƒ•ãƒ©ã‚°ã‚’è§£é™¤"):format(player.Name))
		end)
	else
		-- æ•—åŒ—æ™‚ã¯æˆ¦é—˜ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¯ãƒªã‚¢ã™ã‚‹ãŒã€çµ‚äº†å‡¦ç†ãƒ•ãƒ©ã‚°ã¯ç¶­æŒ
		-- ï¼ˆæ­»äº¡é¸æŠUIã§é¸ã‚“ã å¾Œã«è§£é™¤ã™ã‚‹ï¼‰
		SharedState.ActiveBattles[player] = nil
		print(("[BattleSystem] æ•—åŒ— - çµ‚äº†å‡¦ç†ãƒ•ãƒ©ã‚°ã‚’ç¶­æŒã—ã¾ã™ï¼ˆé¸æŠã¾ã§ï¼‰"))
	end
end

-- åˆæœŸåŒ–
function BattleSystem.init()
	-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚¤ãƒ™ãƒ³ãƒˆ
	RequestStatusEvent.OnServerEvent:Connect(function(player)
		print(("[BattleSystem] %s ãŒã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’è¦æ±‚ã—ã¾ã—ãŸ"):format(player.Name))
		sendStatusUpdate(player)
	end)

	-- ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚¤ãƒ™ãƒ³ãƒˆ
	BattleDamageEvent.OnServerEvent:Connect(function(player, damageAmount)
		print(("[BattleSystem] ãƒ€ãƒ¡ãƒ¼ã‚¸é€šçŸ¥å—ä¿¡: %s -> %d"):format(player.Name, damageAmount))
		onDamageReceived(player, damageAmount)
	end)

	-- ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‹ã‚‰ã®ã‚µã‚¤ã‚¯ãƒ«å†åŒæœŸãƒªã‚¯ã‚¨ã‚¹ãƒˆ
	RequestEnemyCycleSyncEvent.OnServerEvent:Connect(function(player)
		-- ãƒãƒˆãƒ«ä¸­ï¼†çµ‚äº†å‡¦ç†ä¸­ã§ãªã„ã“ã¨ã‚’ç¢ºèª
		local bd = SharedState.ActiveBattles[player]
		if not bd or SharedState.EndingBattles[player] then
			return
		end

		-- å¿…è¦æƒ…å ±ã‚’å–å¾—
		local stats = PlayerStats.getStats(player)
		if not stats or not bd.monsterDef then
			return
		end

		-- ç¾åœ¨ã®ï¼ˆè¨­è¨ˆä¸Šã®ï¼‰ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«ã‚’è¨ˆç®—
		local intervalSec = calculateAttackInterval(stats.Speed, bd.monsterDef.Speed, player, bd.monsterDef)

		-- çµŒéã¨æ®‹ã‚Šæ™‚é–“ã‹ã‚‰ startedAt ã‚’é€†ç®—ï¼ˆã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã®ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ã‚’æ»‘ã‚‰ã‹ã«ï¼‰
		local now = tick()
		local remaining = math.max(0.05, bd.nextAttackTime - now)              -- ã‚‚ã†ã™ãç™ºå‹•ã®å ´åˆã‚‚æœ€ä½0.05ç§’
		local elapsed = math.clamp(intervalSec - remaining, 0, intervalSec)    -- çµŒéæ™‚é–“ã‚’ã‚¯ãƒ©ãƒ³ãƒ—
		local startedAt = now - elapsed

		-- ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«ã€Œä»Šã“ã®ãƒšãƒ¼ã‚¹ã§å›ã£ã¦ã‚‹ã‚ˆã€ã‚’å³é€šçŸ¥
		EnemyAttackCycleStartEvent:FireClient(player, {
			intervalSec = intervalSec,
			startedAt   = startedAt
		})
	end)


	-- å‹åˆ©ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆå¿µã®ãŸã‚æ®‹ã—ã¦ãŠãï¼‰
	BattleVictoryEvent.OnServerEvent:Connect(function(player)
		print(("[BattleSystem] å‹åˆ©é€šçŸ¥å—ä¿¡: %s"):format(player.Name))

		if BattleSystem.isInBattle(player) then
			BattleSystem.endBattle(player, true)
		end
	end)

	-- æ­»äº¡æ™‚ã®é¸æŠã‚¤ãƒ™ãƒ³ãƒˆ
	DeathChoiceEvent.OnServerEvent:Connect(function(player, choice)
		print(("[BattleSystem] %s ãŒé¸æŠ: %s"):format(player.Name, choice))

		-- ã€é‡è¦ã€‘ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒãƒˆãƒ«ãƒ•ãƒ©ã‚°ã‚’è§£é™¤ï¼ˆæ•—åŒ—æ™‚ã«ç¶­æŒã—ã¦ã„ãŸï¼‰
		SharedState.GlobalBattleActive = false
		print("[BattleSystem] ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒãƒˆãƒ«ãƒ•ãƒ©ã‚°ã‚’è§£é™¤")

		-- ã€é‡è¦ã€‘çµ‚äº†å‡¦ç†ãƒ•ãƒ©ã‚°ã‚’è§£é™¤ï¼ˆãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ãŒæ¥è§¦ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ï¼‰
		SharedState.EndingBattles[player] = nil
		print(("[BattleSystem] %s ã®çµ‚äº†å‡¦ç†ãƒ•ãƒ©ã‚°ã‚’è§£é™¤"):format(player.Name))

		local playerStats = PlayerStats.getStats(player)
		if not playerStats then return end

		-- æ­»äº¡ãƒ•ãƒ©ã‚°ã‚’è§£é™¤
		local character = player.Character
		if character then
			character:SetAttribute("IsDead", false)
			print(("[BattleSystem] %s ã®æ­»äº¡ãƒ•ãƒ©ã‚°ã‚’è§£é™¤"):format(player.Name))
		end

		-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç§»å‹•åˆ¶é™ã‚’è§£é™¤
		if character then
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			local hrp = character:FindFirstChild("HumanoidRootPart")
			if humanoid then
				humanoid.WalkSpeed = 16
				humanoid.JumpPower = 50
				humanoid.JumpHeight = 7.2
			end
			if hrp then
				hrp.Anchored = false
			end
		end

		-- ã€é‡è¦ã€‘å€’ã—ãŸãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’æ¶ˆå»ï¼ˆä¸¡æ–¹ã®é¸æŠè‚¢ã§æ¶ˆå»ï¼‰
		local defeatedMonster = SharedState.DefeatedByMonster[player]
		if defeatedMonster and defeatedMonster.Parent then
			print(("[BattleSystem] å€’ã—ãŸãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ %s ã‚’æ¶ˆå»"):format(defeatedMonster.Name))

			-- éè¡¨ç¤ºåŒ–
			defeatedMonster:SetAttribute("Defeated", true)
			for _, part in ipairs(defeatedMonster:GetDescendants()) do
				if part:IsA("BasePart") then
					part.Transparency = 1
				end
			end

			-- ãƒ©ãƒ™ãƒ«éè¡¨ç¤º
			local hrp = defeatedMonster:FindFirstChild("HumanoidRootPart")
			if hrp then
				local gui = hrp:FindFirstChild("DebugInfo")
				if gui then
					gui.Enabled = false
				end
			end

			-- å‰Šé™¤
			task.delay(0.5, function()
				if defeatedMonster and defeatedMonster.Parent then
					defeatedMonster:Destroy()
				end
			end)
		end

		-- è¨˜éŒ²ã‚’ã‚¯ãƒªã‚¢
		SharedState.DefeatedByMonster[player] = nil

		if choice == "return" then
			-- è¡—ã«æˆ»ã‚‹
			print(("[BattleSystem] %s ã‚’è¡—ã«æˆ»ã—ã¾ã™"):format(player.Name))

			-- HPã‚’å…¨å›å¾©
			PlayerStats.fullHeal(player)

			-- StartTownã®åº§æ¨™ã‚’å–å¾—
			print("[BattleSystem] StartTownã®åº§æ¨™ã‚’å–å¾—ä¸­...")
			local IslandsRegistry = require(ReplicatedStorage:WaitForChild("Islands"):WaitForChild("Registry"))
			print(("[BattleSystem] IslandsRegistryå–å¾—å®Œäº†ã€‚å³¶ã®æ•°: %d"):format(#IslandsRegistry))

			local townConfig = nil
			for i, island in ipairs(IslandsRegistry) do
				print(("[BattleSystem] å³¶ %d: name=%s"):format(i, tostring(island.name)))
				if island.name == "StartTown" then
					townConfig = island
					print("[BattleSystem] StartTownã‚’ç™ºè¦‹ï¼")
					break
				end
			end

			-- è¡—ã«ãƒ†ãƒ¬ãƒãƒ¼ãƒˆ
			if character and townConfig then
				local hrp = character:FindFirstChild("HumanoidRootPart")
				if hrp then
					local spawnX = townConfig.centerX
					local spawnZ = townConfig.centerZ
					local spawnY = townConfig.baseY + 50  -- é«˜ã‚ã«è¨­å®š
					print(("[BattleSystem] ãƒ†ãƒ¬ãƒãƒ¼ãƒˆåº§æ¨™: X=%.0f, Y=%.0f, Z=%.0f"):format(
						spawnX, spawnY, spawnZ
						))

					-- ãƒ†ãƒ¬ãƒãƒ¼ãƒˆå®Ÿè¡Œ
					hrp.CFrame = CFrame.new(spawnX, spawnY, spawnZ)

					-- å°‘ã—å¾…ã£ã¦ã‹ã‚‰å†åº¦è¨­å®šï¼ˆä»–ã®ã‚·ã‚¹ãƒ†ãƒ ã®å¹²æ¸‰ã‚’é˜²ãï¼‰
					task.wait(0.1)
					hrp.CFrame = CFrame.new(spawnX, spawnY, spawnZ)

					print(("[BattleSystem] %s ã‚’è¡—ã«ãƒ†ãƒ¬ãƒãƒ¼ãƒˆå®Œäº†"):format(player.Name))

					-- ZoneManagerã«ã‚‚é€šçŸ¥
					local ZoneManager = require(ServerScriptService:WaitForChild("ZoneManager"))
					ZoneManager.PlayerZones[player] = "StartTown"
					print("[BattleSystem] ZoneManagerã«StartTownã‚’è¨˜éŒ²")

					-- ã€é‡è¦ã€‘StartTownã®ãƒãƒ¼ã‚¿ãƒ«ã‚’å†ç”Ÿæˆ
					if _G.CreatePortalsForZone then
						print("[BattleSystem] StartTownã®ãƒãƒ¼ã‚¿ãƒ«ã‚’å†ç”Ÿæˆ")
						_G.CreatePortalsForZone("StartTown")
					else
						warn("[BattleSystem] CreatePortalsForZoneé–¢æ•°ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
					end
				end
			elseif character then
				-- ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼štownConfigãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆ
				warn("[BattleSystem] StartTownãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ï¼")
				print("[BattleSystem] ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼šåŸç‚¹ã«ãƒ†ãƒ¬ãƒãƒ¼ãƒˆ")
				local hrp = character:FindFirstChild("HumanoidRootPart")
				if hrp then
					hrp.CFrame = CFrame.new(0, 50, 0)
				end
			end

			-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°
			sendStatusUpdate(player)

		elseif choice == "revive" then
			-- ã‚´ãƒ¼ãƒ«ãƒ‰ã§å¾©æ´»
			local reviveCost = math.floor(playerStats.Level * 50)

			if PlayerStats.removeGold(player, reviveCost) then
				print(("[BattleSystem] %s ãŒã‚´ãƒ¼ãƒ«ãƒ‰ %d ã§å¾©æ´»"):format(player.Name, reviveCost))

				-- HPã‚’å…¨å›å¾©
				PlayerStats.fullHeal(player)

				-- ã€é‡è¦ã€‘å¾©æ´»å¾Œã®ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ã‚’è¨­å®šï¼ˆ3ç§’é–“ãƒãƒˆãƒ«ä¸å¯ï¼‰
				LastBattleEndTime = tick()
				print("[BattleSystem] å¾©æ´»å¾Œã®ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³é–‹å§‹")

				-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°
				sendStatusUpdate(player)
			else
				warn(("[BattleSystem] %s ã®ã‚´ãƒ¼ãƒ«ãƒ‰ãŒä¸è¶³ã—ã¦ã„ã¾ã™"):format(player.Name))
			end
		end
	end)

	-- ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚¤ãƒ™ãƒ³ãƒˆ
	BattleDamageEvent.OnServerEvent:Connect(function(player, damageAmount)
		print(("[BattleSystem] ãƒ€ãƒ¡ãƒ¼ã‚¸é€šçŸ¥å—ä¿¡: %s -> %d"):format(player.Name, damageAmount))
		onDamageReceived(player, damageAmount)
	end)

	-- ã‚¿ã‚¤ãƒ—ãƒŸã‚¹ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆæ–°è¦è¿½åŠ ï¼‰
	TypingMistakeEvent.OnServerEvent:Connect(function(player)
		print(("[BattleSystem] ã‚¿ã‚¤ãƒ—ãƒŸã‚¹å—ä¿¡: %s"):format(player.Name))

		local battleData = SharedState.ActiveBattles[player]
		if not battleData then
			warn(("[BattleSystem] %s ã¯ãƒãƒˆãƒ«ä¸­ã§ã¯ã‚ã‚Šã¾ã›ã‚“ï¼ˆã‚¿ã‚¤ãƒ—ãƒŸã‚¹ç„¡è¦–ï¼‰"):format(player.Name))
			return
		end

		local monsterDef = battleData.monsterDef
		local playerStats = PlayerStats.getStats(player)

		if not playerStats then
			warn(("[BattleSystem] %s ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"):format(player.Name))
			return
		end

		-- ã‚¿ã‚¤ãƒ—ãƒŸã‚¹ãƒ€ãƒ¡ãƒ¼ã‚¸ = æ•µã®é€šå¸¸æ”»æ’ƒã®åŠåˆ†
		local normalDamage = calculateDamage(monsterDef.Attack, playerStats.Defense)
		local mistakeDamage = math.floor(normalDamage * 0.5)
		mistakeDamage = math.max(1, mistakeDamage)  -- æœ€ä½1ãƒ€ãƒ¡ãƒ¼ã‚¸

		print(("[BattleSystem] %s ãŒã‚¿ã‚¤ãƒ—ãƒŸã‚¹ã§ %d ãƒ€ãƒ¡ãƒ¼ã‚¸"):format(player.Name, mistakeDamage))

		-- ãƒ€ãƒ¡ãƒ¼ã‚¸å‡¦ç†
		local isDead = PlayerStats.takeDamage(player, mistakeDamage)

		-- HPã‚’ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«é€šçŸ¥
		PlayerHPUpdateEvent:FireClient(player, playerStats.CurrentHP, playerStats.MaxHP)

		-- æ­»äº¡åˆ¤å®š
		if isDead then
			print(("[BattleSystem] %s ã¯ã‚¿ã‚¤ãƒ—ãƒŸã‚¹ã§å€’ã‚ŒãŸï¼"):format(player.Name))
			BattleSystem.endBattle(player, false)  -- æ•—åŒ—
		end
	end)

	-- å‹åˆ©ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆå¿µã®ãŸã‚æ®‹ã—ã¦ãŠãï¼‰

	-- ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯æ¤œå‡º
	task.spawn(function()
		while true do
			task.wait(5)

			for player, battleData in pairs(SharedState.ActiveBattles) do
				local duration = tick() - battleData.startTime

				if duration > 60 then
					warn(("[BattleSystem] ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯æ¤œå‡ºï¼ %s ã®ãƒãƒˆãƒ«ã‚’å¼·åˆ¶çµ‚äº†"):format(player.Name))
					BattleSystem.endBattle(player, false)
				end
			end
		end
	end)

	print("[BattleSystem] åˆæœŸåŒ–å®Œäº†ï¼ˆæ•µæ”»æ’ƒã‚·ã‚¹ãƒ†ãƒ å¯¾å¿œï¼‰")
end

-- ãƒãƒˆãƒ«çŠ¶æ…‹ã‚’å¼·åˆ¶ãƒªã‚»ãƒƒãƒˆ
function BattleSystem.resetAllBattles()
	print("[BattleSystem] å…¨ãƒãƒˆãƒ«çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ")

	SharedState.GlobalBattleActive = false

	for player, _ in pairs(SharedState.ActiveBattles) do
		SharedState.ActiveBattles[player] = nil
		SharedState.EndingBattles[player] = nil

		if player.Character then
			player.Character:SetAttribute("InBattle", false)

			local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
			local hrp = player.Character:FindFirstChild("HumanoidRootPart")
			if humanoid then
				humanoid.WalkSpeed = 16
				humanoid.JumpPower = 50
				humanoid.JumpHeight = 7.2
			end
			if hrp then
				hrp.Anchored = false
			end
		end
	end

	local monstersFolder = workspace:FindFirstChild("Monsters")
	if monstersFolder then
		for _, model in ipairs(monstersFolder:GetChildren()) do
			if model:IsA("Model") then
				model:SetAttribute("InBattle", false)
				model:SetAttribute("Defeated", false)
			end
		end
	end

	for _, model in ipairs(workspace:GetChildren()) do
		if model:IsA("Model") and model:GetAttribute("IsEnemy") then
			model:SetAttribute("InBattle", false)
			model:SetAttribute("Defeated", false)
		end
	end

	print("[BattleSystem] ãƒªã‚»ãƒƒãƒˆå®Œäº†")
end

return BattleSystem
===== ./ServerScriptService/MonsterSpawner.server.lua =====
-- ServerScriptService/MonsterSpawner.server.lua
-- ã‚¾ãƒ¼ãƒ³å¯¾å¿œç‰ˆãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼é…ç½®ã‚·ã‚¹ãƒ†ãƒ ï¼ˆãƒãƒˆãƒ«é«˜é€ŸåŒ–ç‰ˆã€å¾˜å¾ŠAIä¿®æ­£ç‰ˆï¼‰

local ServerStorage = game:GetService("ServerStorage")
local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local FieldGen = require(ReplicatedStorage:WaitForChild("FieldGen"))
local ZoneManager = require(script.Parent.ZoneManager)

local SharedState = require(ReplicatedStorage:WaitForChild("SharedState"))
local GameEvents = require(ReplicatedStorage:WaitForChild("GameEvents"))
local ContinentsRegistry = require(ReplicatedStorage.Continents.Registry)

-- BattleSystemèª­è¾¼ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒŠãƒ«ï¼‰
local BattleSystem = nil
local battleSystemScript = script.Parent:FindFirstChild("BattleSystem")
if battleSystemScript then
	local success, result = pcall(function()
		return require(battleSystemScript)
	end)
	if success then
		BattleSystem = result
		print("[MonsterSpawner] BattleSystemèª­ã¿è¾¼ã¿æˆåŠŸ")
	else
		warn("[MonsterSpawner] BattleSystemèª­ã¿è¾¼ã¿å¤±æ•—:", result)
	end
else
	warn("[MonsterSpawner] BattleSystemãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ - ãƒãƒˆãƒ«æ©Ÿèƒ½ã¯ç„¡åŠ¹ã§ã™")
end

-- Registryèª­è¾¼
local MonstersFolder = ReplicatedStorage:WaitForChild("Monsters")
local Registry = require(MonstersFolder:WaitForChild("Registry"))

-- å³¶ã®è¨­å®šã‚’èª­ã¿è¾¼ã¿
local IslandsRegistry = require(ReplicatedStorage.Islands.Registry)
local Islands = {}
for _, island in ipairs(IslandsRegistry) do
	Islands[island.name] = island
end

-- ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
local ActiveMonsters = {}
local UpdateInterval = 0.05
local MonsterCounts = {}
local TemplateCache = {}
local RespawnQueue = {}

-- å®‰å…¨åœ°å¸¯ãƒã‚§ãƒƒã‚¯
local function isSafeZone(zoneName)
	local island = Islands[zoneName]
	if island and island.safeZone then
		return true
	end
	return false
end

-- ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°
local function resolveTemplate(pathArray: { string }): Model?
	local node: Instance = game
	for _, seg in ipairs(pathArray) do
		node = node:FindFirstChild(seg)
		if not node then
			return nil
		end
	end
	return (node and node:IsA("Model")) and node or nil
end

local function ensureHRP(model: Model): BasePart?
	local hrp = model:FindFirstChild("HumanoidRootPart")
	if hrp and hrp:IsA("BasePart") then
		if not model.PrimaryPart then
			model.PrimaryPart = hrp
		end
		return hrp
	end
	return nil
end

-- å³¶ã‹ã‚‰å¤§é™¸åã‚’é€†å¼•ãã™ã‚‹ãƒãƒƒãƒ—ã‚’ä½œæˆ
local IslandToContinentMap = {}
do
	for _, continent in ipairs(ContinentsRegistry) do
		if continent and continent.islands then
			for _, islandName in ipairs(continent.islands) do
				IslandToContinentMap[islandName] = continent.name
				print(("[MonsterSpawner] ãƒãƒƒãƒ—: %s -> %s"):format(islandName, continent.name))
			end
		end
	end
	local mapCount = 0
	for _ in pairs(IslandToContinentMap) do
		mapCount = mapCount + 1
	end

	print("[MonsterSpawner] IslandToContinentMap åˆæœŸåŒ–å®Œäº† (" .. mapCount .. " å€‹)")
end

-- å³¶åã‹ã‚‰å¤§é™¸åã‚’å–å¾—
local function getContinentNameFromIsland(islandName)
	local result = IslandToContinentMap[islandName]
	if not result then
		warn(
			("[MonsterSpawner] è­¦å‘Š: å³¶ '%s' ãŒ IslandToContinentMap ã«è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚å³¶åã‚’ãã®ã¾ã¾ä½¿ç”¨ã—ã¾ã™"):format(
				islandName
			)
		)
		return islandName
	end
	return result
end
-- å³¶åã‹ã‚‰å¤§é™¸åã‚’å–å¾—
local function getContinentNameFromIsland(islandName)
	return IslandToContinentMap[islandName] or islandName
end

local function attachLabel(model: Model, maxDist: number)
	local hrp = model.PrimaryPart or model:FindFirstChild("HumanoidRootPart")
	if not hrp then
		return
	end

	local _, bboxSize = model:GetBoundingBox()
	local labelOffset = math.min(bboxSize.Y * 0.5 + 2, 15)

	local gui = Instance.new("BillboardGui")
	gui.Name = "DebugInfo"
	gui.Adornee = hrp
	gui.AlwaysOnTop = true
	gui.Size = UDim2.new(0, 150, 0, 50)
	gui.StudsOffset = Vector3.new(0, labelOffset, 0)
	gui.MaxDistance = maxDist
	gui.Parent = hrp

	local lb = Instance.new("TextLabel")
	lb.Name = "InfoText"
	lb.BackgroundTransparency = 1
	lb.TextScaled = true
	lb.Font = Enum.Font.GothamBold
	lb.TextColor3 = Color3.new(1, 1, 1)
	lb.TextStrokeTransparency = 0.5
	lb.Size = UDim2.fromScale(1, 1)
	lb.Text = "Ready"
	lb.Parent = gui
end

local function placeOnGround(model: Model, x: number, z: number)
	local hrp = model.PrimaryPart or model:FindFirstChild("HumanoidRootPart")
	if not hrp then
		warn("[MonsterSpawner] HumanoidRootPart ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: " .. model.Name)
		return
	end

	local groundY = FieldGen.raycastGroundY(x, z, 100)
		or FieldGen.raycastGroundY(x, z, 200)
		or FieldGen.raycastGroundY(x, z, 50)
		or 10

	local _, yaw = hrp.CFrame:ToOrientation()
	model:PivotTo(CFrame.new(x, groundY + 20, z) * CFrame.Angles(0, yaw, 0))

	local bboxCFrame, bboxSize = model:GetBoundingBox()
	local bottomY = bboxCFrame.Position.Y - (bboxSize.Y * 0.5)
	local offset = hrp.Position.Y - bottomY

	model:PivotTo(CFrame.new(x, groundY + offset, z) * CFrame.Angles(0, yaw, 0))
end

local function nearestPlayer(position: Vector3)
	local best, bestDist = nil, math.huge
	for _, pl in ipairs(Players:GetPlayers()) do
		local ch = pl.Character
		local hrp = ch and ch:FindFirstChild("HumanoidRootPart")
		if hrp then
			local d = (position - hrp.Position).Magnitude
			if d < bestDist then
				best, bestDist = pl, d
			end
		end
	end
	return best, bestDist
end

-- AIçŠ¶æ…‹ç®¡ç†ï¼ˆé«˜é€ŸåŒ–ç‰ˆï¼‰
local AIState = {}
AIState.__index = AIState

function AIState.new(monster, def)
	local self = setmetatable({}, AIState)
	self.monster = monster
	self.def = def
	self.humanoid = monster:FindFirstChildOfClass("Humanoid")
	self.root = monster.PrimaryPart
	self.courage = math.random()
	self.brave = (self.courage > 0.5)
	self.wanderGoal = nil
	self.nextWanderAt = 0
	self.lastUpdateTime = 0
	self.lastDistanceLog = 0
	self.updateRate = def.AiTickRate or 0.3
	self.nearUpdateRate = 0.05 -- 0.05ç§’ã«é«˜é€ŸåŒ–ï¼ˆãƒãƒˆãƒ«åˆ¤å®šãŒé€Ÿããªã‚‹ï¼‰
	self.farUpdateRate = 0.5 -- 0.5ç§’ã«é«˜é€ŸåŒ–

	self.originalSpeed = self.humanoid.WalkSpeed
	self.wasInBattle = false

	-- ã€ä¿®æ­£ç‚¹1ã€‘å¾˜å¾Šã‚¹ãƒ†ãƒ¼ãƒˆç®¡ç†ã‚’æ•´ç†
	self.isMoving = false -- ç§»å‹•çŠ¶æ…‹ã‹
	self.isWaiting = false -- å¾…æ©ŸçŠ¶æ…‹ã‹ (åœæ­¢çŠ¶æ…‹)
	self.waitEndTime = 0 -- å¾…æ©Ÿçµ‚äº†æ™‚åˆ»
	-- ã€ä¿®æ­£ç‚¹1 çµ‚ã‚ã‚Šã€‘

	return self
end

function AIState:shouldUpdate(currentTime)
	local _, dist = nearestPlayer(self.root.Position)
	-- è¿‘è·é›¢åˆ¤å®šã‚’150ã‚¹ã‚¿ãƒƒãƒ‰ã«æ‹¡å¤§ï¼ˆãƒãƒˆãƒ«åˆ¤å®šã‚’ã‚ˆã‚Šé »ç¹ã«ï¼‰
	local rate = dist < 150 and self.nearUpdateRate or self.farUpdateRate
	return (currentTime - self.lastUpdateTime) >= rate
end

function AIState:update()
	if not self.monster.Parent or not self.humanoid or not self.root then
		return false
	end

	if self.monster:GetAttribute("Defeated") then
		if not self.loggedDefeated then
			-- print(("[AI DEBUG] %s - DefeatedçŠ¶æ…‹ã®ãŸã‚ã‚¹ã‚­ãƒƒãƒ—"):format(self.monster.Name))
			self.loggedDefeated = true
		end
		return false
	end

	-- ãƒãƒˆãƒ«çŠ¶æ…‹ã‚’ç¢ºèª
	local isGlobalBattle = BattleSystem and BattleSystem.isAnyBattleActive and BattleSystem.isAnyBattleActive()
	local isThisMonsterInBattle = self.monster:GetAttribute("InBattle")
	local isAnyBattle = isGlobalBattle or isThisMonsterInBattle

	-- ã„ãšã‚Œã‹ã®ãƒãƒˆãƒ«ãŒé€²è¡Œä¸­ãªã‚‰åœæ­¢
	if isAnyBattle then
		self.humanoid.WalkSpeed = 0
		self.humanoid:MoveTo(self.root.Position)
		self.wasInBattle = true
		return true
	end

	-- ãƒãƒˆãƒ«ãŒçµ‚äº†ã—ãŸã‚‰é€Ÿåº¦ã‚’å¾©å…ƒ
	if self.wasInBattle and not isAnyBattle then
		-- print(("[AI DEBUG] %s - ãƒãƒˆãƒ«çµ‚äº†ã€é€Ÿåº¦å¾©å…ƒ: %.1f"):format(self.monster.Name, self.originalSpeed))
		self.humanoid.WalkSpeed = self.originalSpeed
		self.wasInBattle = false
		self.loggedDefeated = false
	end

	local p, dist = nearestPlayer(self.root.Position)
	local chaseRange = self.def.ChaseDistance or 60
	local now = os.clock()

	-- ãƒãƒˆãƒ«åˆ¤å®šï¼ˆé«˜é€ŸåŒ–ãƒ»è·é›¢æ‹¡å¤§ï¼‰
	if BattleSystem and p and dist <= 7 then -- 7ã‚¹ã‚¿ãƒƒãƒ‰ã«æ‹¡å¤§
		-- print(("[AI DEBUG] %s - æ¥è§¦æ¤œå‡ºï¼è·é›¢=%.1f"):format(self.monster.Name, dist))

		if BattleSystem.isInBattle(p) then
			self.humanoid:MoveTo(self.root.Position)
			return true
		end

		if BattleSystem.isAnyBattleActive and BattleSystem.isAnyBattleActive() then
			self.humanoid:MoveTo(self.root.Position)
			return true
		end

		if self.monster:GetAttribute("InBattle") then
			return true
		end

		local character = p.Character
		if character then
			-- ã€é‡è¦ã€‘å³åº§ã«ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’åœæ­¢ï¼ˆãƒãƒˆãƒ«é–‹å§‹å‰ï¼‰
			local playerHumanoid = character:FindFirstChildOfClass("Humanoid")
			local playerHrp = character:FindFirstChild("HumanoidRootPart")

			if playerHumanoid and playerHrp then
				-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å³åº§ã«åœæ­¢
				playerHumanoid.WalkSpeed = 0
				playerHumanoid.JumpPower = 0
				playerHrp.Anchored = true
			end

			self.monster:SetAttribute("InBattle", true)
			self.humanoid.WalkSpeed = 0
			self.humanoid:MoveTo(self.root.Position)

			local battleStarted = BattleSystem.startBattle(p, self.monster)
			-- print(("[AI DEBUG] ãƒãƒˆãƒ«é–‹å§‹çµæœ: %s"):format(tostring(battleStarted)))

			if not battleStarted then
				-- ãƒãƒˆãƒ«é–‹å§‹å¤±æ•—æ™‚ã¯ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚‚è§£æ”¾
				self.monster:SetAttribute("InBattle", false)
				self.humanoid.WalkSpeed = self.originalSpeed

				if playerHumanoid and playerHrp then
					playerHumanoid.WalkSpeed = 16
					playerHumanoid.JumpPower = 50
					playerHrp.Anchored = false
				end
			end

			return true
		else
			self.monster:SetAttribute("InBattle", false)
		end
	end

	-- æµ·ãƒã‚§ãƒƒã‚¯
	local isInWater = self.root.Position.Y < 0 or self.humanoid:GetState() == Enum.HumanoidStateType.Swimming

	-- ãƒ©ãƒ™ãƒ«æ›´æ–°
	local label = self.root:FindFirstChild("DebugInfo") and self.root.DebugInfo:FindFirstChild("InfoText")
	if label then
		local behavior = self.brave and "CHASE" or "FLEE"
		label.Text = string.format("%s\n%s | %.1fm", self.monster.Name, behavior, dist or 999)
	end

	local gui = self.root:FindFirstChild("DebugInfo")
	if gui then
		gui.Enabled = not isInWater
	end

	-- ã€ä¿®æ­£ç‚¹2ã€‘å¾˜å¾Šãƒ­ã‚¸ãƒƒã‚¯ã‚’å†æ§‹ç¯‰
	local function wanderLogic()
		local w = self.def.Wander or {}
		local minWait = w.MinWait or 2
		local maxWait = w.MaxWait or 5
		local minRadius = w.MinRadius or 20
		local maxRadius = w.MaxRadius or 60
		local stopDistance = 5 -- ç›®æ¨™åˆ°é”ã¨è¦‹ãªã™è·é›¢

		local isGoalReached = self.wanderGoal and (self.root.Position - self.wanderGoal).Magnitude < stopDistance
		local isWaitFinished = self.isWaiting and now >= self.waitEndTime

		if self.isWaiting then
			-- ã‚¹ãƒ†ãƒ¼ãƒˆ: å¾…æ©Ÿä¸­ï¼ˆåœæ­¢ï¼‰
			self.humanoid:MoveTo(self.root.Position) -- åœæ­¢ã‚’ç¶­æŒ
			self.isMoving = false

			if isWaitFinished then
				-- å¾…æ©Ÿçµ‚äº†ã€‚æ¬¡ã®ç›®æ¨™è¨­å®šã¸
				self.isWaiting = false
				self.wanderGoal = nil
			end
		elseif isGoalReached or not self.wanderGoal then
			-- ã‚¹ãƒ†ãƒ¼ãƒˆ: ç›®æ¨™åˆ°é” or ç›®æ¨™ãªã— -> æ–°ç›®æ¨™è¨­å®š & ç§»å‹•é–‹å§‹

			-- ç›®æ¨™ã«åˆ°é”ã—ãŸã‚‰å¾…æ©Ÿãƒ¢ãƒ¼ãƒ‰ã«ç§»è¡Œ
			if isGoalReached then
				self.isWaiting = true
				self.waitEndTime = now + math.random(minWait * 10, maxWait * 10) / 10
				self.humanoid:MoveTo(self.root.Position) -- åœæ­¢
				return
			end

			-- æ–°ã—ã„ç›®æ¨™ã‚’è¨­å®š
			local ang = math.random() * math.pi * 2
			local rad = math.random(minRadius, maxRadius)
			local gx = self.root.Position.X + math.cos(ang) * rad
			local gz = self.root.Position.Z + math.sin(ang) * rad

			local gy = FieldGen.raycastGroundY(gx, gz, 100) or self.root.Position.Y + 5 -- è¦‹ã¤ã‹ã‚‰ãªã‘ã‚Œã°ç¾åœ¨ã®Y+5

			self.wanderGoal = Vector3.new(gx, gy, gz)
			self.isMoving = true

			self.humanoid:MoveTo(self.wanderGoal)
		else
			-- ã‚¹ãƒ†ãƒ¼ãƒˆ: ç§»å‹•ä¸­ï¼ˆç¶™ç¶šï¼‰
			self.isMoving = true
			self.humanoid:MoveTo(self.wanderGoal)
		end
	end
	-- ã€ä¿®æ­£ç‚¹2 çµ‚ã‚ã‚Šã€‘

	-- è¡Œå‹•æ±ºå®š
	if not p then
		-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒã„ãªã„ï¼šå¾˜å¾Šã®ã¿
		wanderLogic()
	elseif dist < chaseRange then
		-- è¿½è·¡ or é€ƒèµ°
		self.wanderGoal = nil
		self.isMoving = false
		self.isWaiting = false -- è¿½è·¡ä¸­ã¯å¾˜å¾Šã‚¹ãƒ†ãƒ¼ãƒˆã‚’å¼·åˆ¶è§£é™¤
		if self.brave then
			self.humanoid:MoveTo(p.Character.HumanoidRootPart.Position)
		else
			local away = (self.root.Position - p.Character.HumanoidRootPart.Position).Unit
			self.humanoid:MoveTo(self.root.Position + away * 80)
		end
	else
		-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒé ã„ï¼šå¾˜å¾Š
		wanderLogic()
	end

	self.lastUpdateTime = now
	return true
end

-- ã‚¹ãƒãƒ¼ãƒ³å‡¦ç†ï¼ˆå³¶æŒ‡å®šç‰ˆï¼‰
local function spawnMonster(template: Model, index: number, def, islandName)
	local m = template:Clone()
	m.Name = (def.Name or template.Name) .. "_" .. index

	local hum = m:FindFirstChildOfClass("Humanoid")
	local hrp = ensureHRP(m)

	if not hum or not hrp then
		warn("[MonsterSpawner] Humanoid ã¾ãŸã¯ HRP ãŒã‚ã‚Šã¾ã›ã‚“: " .. m.Name)
		m:Destroy()
		return
	end

	m:SetAttribute("IsEnemy", true)
	m:SetAttribute("MonsterKind", def.Name or "Monster")
	m:SetAttribute("ChaseDistance", def.ChaseDistance or 60)

	-- â˜…ä¿®æ­£ç‚¹â˜…: SpawnZone ã«å¤§é™¸åã‚’è¨­å®š
	local continentName = getContinentNameFromIsland(islandName)
	m:SetAttribute("SpawnZone", continentName)
	m:SetAttribute("SpawnIsland", islandName)

	local speedMin = def.SpeedMin or 0.7
	local speedMax = def.SpeedMax or 1.3
	local speedMult = speedMin + math.random() * (speedMax - speedMin)
	hum.WalkSpeed = (def.WalkSpeed or 14) * speedMult
	hum.HipHeight = 0

	hrp.Anchored = true
	hrp.CanCollide = false
	hrp.Transparency = 1

	for _, descendant in ipairs(m:GetDescendants()) do
		if descendant:IsA("BasePart") and descendant ~= hrp then
			descendant.CanCollide = true
			descendant.Anchored = false

			for _, child in ipairs(descendant:GetChildren()) do
				if child:IsA("WeldConstraint") or child:IsA("Weld") then
					child:Destroy()
				end
			end

			local weld = Instance.new("WeldConstraint")
			weld.Part0 = hrp
			weld.Part1 = descendant
			weld.Parent = descendant
		end
	end

	m.Parent = Workspace

	local island = Islands[islandName]
	if not island then
		warn(("[MonsterSpawner] å³¶ '%s' ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"):format(islandName))
		m:Destroy()
		return
	end

	local spawnRadius
	if def.radiusPercent then
		spawnRadius = (island.sizeXZ / 2) * (def.radiusPercent / 100)
	else
		spawnRadius = def.spawnRadius or 50
	end

	local rx = island.centerX + math.random(-spawnRadius, spawnRadius)
	local rz = island.centerZ + math.random(-spawnRadius, spawnRadius)

	placeOnGround(m, rx, rz)

	task.wait(0.05)
	hrp.Anchored = false

	local aiState = AIState.new(m, def)
	table.insert(ActiveMonsters, aiState)

	local monsterName = def.Name or "Monster"
	if not MonsterCounts[islandName] then
		MonsterCounts[islandName] = {}
	end
	MonsterCounts[islandName][monsterName] = (MonsterCounts[islandName][monsterName] or 0) + 1

	print(
		("[MonsterSpawner] %s ã‚’ %s (%s) ã«ã‚¹ãƒãƒ¼ãƒ³ (å¤§é™¸: %s)"):format(
			m.Name,
			islandName,
			def.Name,
			continentName
		)
	)
end

-- ã‚¾ãƒ¼ãƒ³å†…ã®ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚«ã‚¦ãƒ³ãƒˆã‚’å–å¾—
local function getZoneMonsterCounts(zoneName)
	local counts = {}

	-- å¤§é™¸åã‹ã‚‰å³¶ã®ãƒªã‚¹ãƒˆã‚’å–å¾—
	local islandNames = {}

	-- ContinentsRegistryã‚’ãƒ­ãƒ¼ãƒ‰ï¼ˆã¾ã ãƒ­ãƒ¼ãƒ‰ã•ã‚Œã¦ã„ãªã„å ´åˆï¼‰
	if not ContinentsRegistry then
		local ContinentsFolder = ReplicatedStorage:FindFirstChild("Continents")
		if ContinentsFolder then
			local RegistryModule = ContinentsFolder:FindFirstChild("Registry")
			if RegistryModule then
				ContinentsRegistry = require(RegistryModule)
				print("[MonsterSpawner] ContinentsRegistryã‚’ãƒ­ãƒ¼ãƒ‰ã—ã¾ã—ãŸ")
			end
		end
	end

	-- å¤§é™¸ã®å ´åˆã¯ã€å«ã¾ã‚Œã‚‹å³¶ã‚’ã™ã¹ã¦å–å¾—
	local continent = nil
	if ContinentsRegistry then
		for _, cont in ipairs(ContinentsRegistry) do
			if cont.name == zoneName then
				continent = cont
				break
			end
		end
	end

	if continent and continent.islands then
		-- å¤§é™¸å†…ã®å…¨å³¶ã‚’å¯¾è±¡ã«ã™ã‚‹
		for _, islandName in ipairs(continent.islands) do
			table.insert(islandNames, islandName)
		end
		print(("[MonsterSpawner] å¤§é™¸ %s ã®å³¶ãƒªã‚¹ãƒˆ: %s"):format(zoneName, table.concat(islandNames, ", ")))
	else
		-- å¤§é™¸ã§ãªã„å ´åˆã¯ã€ã‚¾ãƒ¼ãƒ³åè‡ªä½“ã‚’å³¶åã¨ã™ã‚‹
		table.insert(islandNames, zoneName)
		print(("[MonsterSpawner] %s ã¯å³¶ã¨ã—ã¦æ‰±ã„ã¾ã™"):format(zoneName))
	end

	-- å„å³¶ã®ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚«ã‚¦ãƒ³ãƒˆã‚’é›†è¨ˆ
	for _, islandName in ipairs(islandNames) do
		if MonsterCounts[islandName] then
			for monsterName, count in pairs(MonsterCounts[islandName]) do
				counts[monsterName] = (counts[monsterName] or 0) + count
			end
		end
	end

	print(
		("[MonsterSpawner] ã‚¾ãƒ¼ãƒ³ %s ã®ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚«ã‚¦ãƒ³ãƒˆ: %s"):format(
			zoneName,
			game:GetService("HttpService"):JSONEncode(counts)
		)
	)

	return counts
end

-- å…¨ã‚¾ãƒ¼ãƒ³ã®ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æ•°ã‚’SharedStateã«ä¿å­˜
local function updateAllMonsterCounts()
	print("[MonsterSpawner] å…¨ã‚¾ãƒ¼ãƒ³ã®ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚«ã‚¦ãƒ³ãƒˆã‚’æ›´æ–°ä¸­...")

	-- ä¸€æ—¦ã‚¯ãƒªã‚¢
	SharedState.MonsterCounts = {}

	-- ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚¾ãƒ¼ãƒ³ã”ã¨ã«ã‚«ã‚¦ãƒ³ãƒˆ
	local ZoneManager = require(script.Parent.ZoneManager)
	for zoneName, _ in pairs(ZoneManager.ActiveZones) do
		SharedState.MonsterCounts[zoneName] = getZoneMonsterCounts(zoneName)
	end

	print("[MonsterSpawner] ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚«ã‚¦ãƒ³ãƒˆæ›´æ–°å®Œäº†")
end

-- ã‚«ã‚¹ã‚¿ãƒ ã‚«ã‚¦ãƒ³ãƒˆã§ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’ã‚¹ãƒãƒ¼ãƒ³ï¼ˆãƒ­ãƒ¼ãƒ‰æ™‚ç”¨ï¼‰
local function spawnMonstersWithCounts(zoneName, customCounts)
	if isSafeZone(zoneName) then
		print(
			("[MonsterSpawner] %s ã¯å®‰å…¨åœ°å¸¯ã§ã™ã€‚ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’ã‚¹ãƒãƒ¼ãƒ³ã—ã¾ã›ã‚“"):format(zoneName)
		)
		return
	end

	if not customCounts or type(customCounts) ~= "table" then
		print(
			("[MonsterSpawner] ã‚«ã‚¹ã‚¿ãƒ ã‚«ã‚¦ãƒ³ãƒˆãŒç„¡åŠ¹ã§ã™ã€‚é€šå¸¸ã‚¹ãƒãƒ¼ãƒ³ã‚’å®Ÿè¡Œ: %s"):format(
				zoneName
			)
		)
		spawnMonstersForZone(zoneName)
		return
	end

	print(("[MonsterSpawner] ã‚«ã‚¹ã‚¿ãƒ ã‚«ã‚¦ãƒ³ãƒˆã§ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’ã‚¹ãƒãƒ¼ãƒ³: %s"):format(zoneName))
	print(("[MonsterSpawner] ã‚«ã‚¦ãƒ³ãƒˆ: %s"):format(game:GetService("HttpService"):JSONEncode(customCounts)))

	-- ã‚«ã‚¹ã‚¿ãƒ ã‚«ã‚¦ãƒ³ãƒˆã«åŸºã¥ã„ã¦ã‚¹ãƒãƒ¼ãƒ³
	for monsterName, count in pairs(customCounts) do
		local template = TemplateCache[monsterName]
		local def = nil

		-- å®šç¾©ã‚’å–å¾—
		for _, regDef in ipairs(Registry) do
			if regDef.Name == monsterName then
				def = regDef
				break
			end
		end

		if template and def and count > 0 then
			print(("[MonsterSpawner] %s ã‚’ %d ä½“ã‚¹ãƒãƒ¼ãƒ³"):format(monsterName, count))

			-- å„ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã®é…ç½®å…ˆã‚’æ±ºå®š
			if def.SpawnLocations then
				-- å„ãƒ­ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã«å‡ç­‰é…åˆ†
				local locationsInZone = {}
				for _, location in ipairs(def.SpawnLocations) do
					-- ã“ã®ã‚¾ãƒ¼ãƒ³ã«å«ã¾ã‚Œã‚‹å³¶ã‹ãƒã‚§ãƒƒã‚¯
					local isInZone = false

					-- å¤§é™¸ã®å ´åˆ
					local Continents = {}
					for _, continent in ipairs(ContinentsRegistry) do
						Continents[continent.name] = continent
					end

					if Continents[zoneName] then
						for _, islandName in ipairs(Continents[zoneName].islands) do
							if islandName == location.islandName then
								isInZone = true
								break
							end
						end
					elseif zoneName == location.islandName then
						isInZone = true
					end

					if isInZone then
						table.insert(locationsInZone, location.islandName)
					end
				end

				-- å„ãƒ­ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã«é…åˆ†
				if #locationsInZone > 0 then
					local countPerLocation = math.ceil(count / #locationsInZone)

					for _, islandName in ipairs(locationsInZone) do
						for i = 1, math.min(countPerLocation, count) do
							local spawnDef = {}
							for k, v in pairs(def) do
								spawnDef[k] = v
							end

							spawnMonster(template, i, spawnDef, islandName)
							count = count - 1

							if count <= 0 then
								break
							end
							if i % 5 == 0 then
								task.wait()
							end
						end

						if count <= 0 then
							break
						end
					end
				end
			end
		else
			if not template then
				warn(("[MonsterSpawner] ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆæœªç™ºè¦‹: %s"):format(monsterName))
			end
			if not def then
				warn(("[MonsterSpawner] å®šç¾©æœªç™ºè¦‹: %s"):format(monsterName))
			end
		end
	end
end

-- ã‚¾ãƒ¼ãƒ³ã«ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’ã‚¹ãƒãƒ¼ãƒ³ã™ã‚‹ï¼ˆå¤§é™¸å¯¾å¿œç‰ˆï¼‰
function spawnMonstersForZone(zoneName)
	if isSafeZone(zoneName) then
		print(
			("[MonsterSpawner] %s ã¯å®‰å…¨åœ°å¸¯ã§ã™ã€‚ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’ã‚¹ãƒãƒ¼ãƒ³ã—ã¾ã›ã‚“"):format(zoneName)
		)
		return
	end

	print(("[MonsterSpawner] %s ã«ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’é…ç½®ä¸­..."):format(zoneName))

	local islandsInZone = {}

	local ContinentsRegistry = require(ReplicatedStorage.Continents.Registry)
	local Continents = {}
	for _, continent in ipairs(ContinentsRegistry) do
		Continents[continent.name] = continent
	end

	if Continents[zoneName] then
		local continent = Continents[zoneName]
		for _, islandName in ipairs(continent.islands) do
			islandsInZone[islandName] = true
		end
		print(("[MonsterSpawner] å¤§é™¸ %s ã®å³¶: %s"):format(zoneName, table.concat(continent.islands, ", ")))
	else
		islandsInZone[zoneName] = true
	end

	for _, def in ipairs(Registry) do
		local monsterName = def.Name or "Monster"
		local template = TemplateCache[monsterName]

		if template then
			if def.SpawnLocations then
				for _, location in ipairs(def.SpawnLocations) do
					local islandName = location.islandName

					if islandsInZone[islandName] then
						local radiusText = location.radiusPercent or 100
						print(
							("[MonsterSpawner] %s ã‚’ %s ã«é…ç½®ä¸­ (æ•°: %d, ç¯„å›²: %d%%)"):format(
								monsterName,
								islandName,
								location.count,
								radiusText
							)
						)

						if not MonsterCounts[islandName] then
							MonsterCounts[islandName] = {}
						end
						MonsterCounts[islandName][monsterName] = 0

						for i = 1, (location.count or 0) do
							local spawnDef = {}
							for k, v in pairs(def) do
								spawnDef[k] = v
							end
							spawnDef.radiusPercent = location.radiusPercent
							spawnDef.spawnRadius = location.spawnRadius

							spawnMonster(template, i, spawnDef, islandName)
							if i % 5 == 0 then
								task.wait()
							end
						end
					end
				end
			else
				warn(
					("[MonsterSpawner] %s ã¯æ—§å½¢å¼ã§ã™ã€‚SpawnLocationså½¢å¼ã«ç§»è¡Œã—ã¦ãã ã•ã„"):format(
						monsterName
					)
				)
			end
		end
	end
end

-- ãƒªã‚¹ãƒãƒ¼ãƒ³å‡¦ç†ï¼ˆå³¶å¯¾å¿œç‰ˆï¼‰
local function scheduleRespawn(monsterName, def, islandName)
	local respawnTime = def.RespawnTime or 10
	if respawnTime <= 0 then
		return
	end

	local respawnData = {
		monsterName = monsterName,
		def = def,
		islandName = islandName,
		respawnAt = os.clock() + respawnTime,
	}
	table.insert(RespawnQueue, respawnData)
end

local function processRespawnQueue()
	task.spawn(function()
		while true do
			local now = os.clock()

			for i = #RespawnQueue, 1, -1 do
				local data = RespawnQueue[i]
				if now >= data.respawnAt then
					local isActive = false
					for zoneName, _ in pairs(ZoneManager.ActiveZones) do
						isActive = true
						break
					end

					if isActive then
						local template = TemplateCache[data.monsterName]
						if template and MonsterCounts[data.islandName] then
							local nextIndex = (MonsterCounts[data.islandName][data.monsterName] or 0) + 1
							spawnMonster(template, nextIndex, data.def, data.islandName)
							-- print(("[MonsterSpawner] %s ãŒ %s ã«ãƒªã‚¹ãƒãƒ¼ãƒ³"):format(data.monsterName, data.islandName))
						end
					end
					table.remove(RespawnQueue, i)
				end
			end

			task.wait(1)
		end
	end)
end

-- AIæ›´æ–°ãƒ«ãƒ¼ãƒ—ï¼ˆé«˜é€ŸåŒ–ï¼‰
local function startGlobalAILoop()
	print("[MonsterSpawner] AIæ›´æ–°ãƒ«ãƒ¼ãƒ—é–‹å§‹ï¼ˆé«˜é€ŸåŒ–ç‰ˆï¼‰")

	task.spawn(function()
		while true do
			if #ActiveMonsters > 0 then
				local currentTime = os.clock()

				for i = #ActiveMonsters, 1, -1 do
					local state = ActiveMonsters[i]

					if state:shouldUpdate(currentTime) then
						local success, result = pcall(function()
							return state:update()
						end)

						if not success then
							warn(
								("[MonsterSpawner ERROR] AIæ›´æ–°ã‚¨ãƒ©ãƒ¼: %s - %s"):format(
									state.monster.Name,
									tostring(result)
								)
							)
						elseif not result then
							local monsterDef = state.def
							local monsterName = monsterDef.Name or "Unknown"
							local zoneName = state.monster:GetAttribute("SpawnZone") or "Unknown"

							if MonsterCounts[zoneName] and MonsterCounts[zoneName][monsterName] then
								MonsterCounts[zoneName][monsterName] = MonsterCounts[zoneName][monsterName] - 1
							end

							table.remove(ActiveMonsters, i)
							scheduleRespawn(monsterName, monsterDef, zoneName)
						end
					end
				end
			end

			task.wait(UpdateInterval)
		end
	end)
end

-- ã‚¾ãƒ¼ãƒ³ã®ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’å‰Šé™¤ã™ã‚‹
function despawnMonstersForZone(zoneName)
	print(("[MonsterSpawner] %s ã®ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’å‰Šé™¤ä¸­..."):format(zoneName))

	local removedCount = 0

	-- â˜…ä¿®æ­£ç‚¹â˜…: SpawnZone ã¯å¤§é™¸åã§æ¯”è¼ƒ
	for i = #ActiveMonsters, 1, -1 do
		local state = ActiveMonsters[i]
		local monsterZone = state.monster:GetAttribute("SpawnZone")

		if monsterZone == zoneName then
			state.monster:Destroy()
			table.remove(ActiveMonsters, i)
			removedCount = removedCount + 1
		end
	end

	-- RespawnQueue ã‹ã‚‰ã‚‚å‰Šé™¤
	for i = #RespawnQueue, 1, -1 do
		if RespawnQueue[i].zoneName == zoneName then
			table.remove(RespawnQueue, i)
		end
	end

	print(("[MonsterSpawner] %s ã®ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’ %dä½“ å‰Šé™¤ã—ã¾ã—ãŸ"):format(zoneName, removedCount))
end

-- ===== MemoryMonitor ç”¨ã®ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼è©³ç´°è¡¨ç¤ºï¼ˆæ›´æ–°ç‰ˆï¼‰=====
local function getZoneMonsterDetails(zoneName)
	local details = {}

	for _, state in ipairs(ActiveMonsters) do
		local spawnZone = state.monster:GetAttribute("SpawnZone")
		local spawnIsland = state.monster:GetAttribute("SpawnIsland")

		-- å¤§é™¸ã§æ¯”è¼ƒ
		if spawnZone == zoneName then
			if not details[spawnIsland] then
				details[spawnIsland] = 0
			end
			details[spawnIsland] = details[spawnIsland] + 1
		end
	end

	return details
end

-- åˆæœŸåŒ–
print("[MonsterSpawner] === ã‚¹ã‚¯ãƒªãƒ—ãƒˆé–‹å§‹ï¼ˆãƒãƒˆãƒ«é«˜é€ŸåŒ–ç‰ˆï¼‰===")

if BattleSystem then
	BattleSystem.init()
	print("[MonsterSpawner] BattleSystemåˆæœŸåŒ–å®Œäº†")
else
	print("[MonsterSpawner] BattleSystemãªã—ã§èµ·å‹•")
end

-- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚«ã‚¦ãƒ³ãƒˆãƒªã‚¯ã‚¨ã‚¹ãƒˆã«å¿œç­”
GameEvents.MonsterCountRequest.Event:Connect(function(zoneName)
	print(("[MonsterSpawner] ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚«ã‚¦ãƒ³ãƒˆãƒªã‚¯ã‚¨ã‚¹ãƒˆå—ä¿¡: %s"):format(zoneName or "å…¨ã‚¾ãƒ¼ãƒ³"))

	if zoneName then
		-- ç‰¹å®šã‚¾ãƒ¼ãƒ³ã®ã¿
		SharedState.MonsterCounts[zoneName] = getZoneMonsterCounts(zoneName)
	else
		-- å…¨ã‚¾ãƒ¼ãƒ³
		updateAllMonsterCounts()
	end

	-- å®Œäº†é€šçŸ¥
	GameEvents.MonsterCountResponse:Fire()
end)

print("[MonsterSpawner] GameEventsã¸ã®å¿œç­”ç™»éŒ²å®Œäº†")

Workspace:WaitForChild("World", 10)
print("[MonsterSpawner] World ãƒ•ã‚©ãƒ«ãƒ€æ¤œå‡º")

task.wait(1)

print("[MonsterSpawner] ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥ä¸­...")
for _, def in ipairs(Registry) do
	local template = resolveTemplate(def.TemplatePath)
	if template then
		local monsterName = def.Name or "Monster"
		TemplateCache[monsterName] = template
		print(("[MonsterSpawner] ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚­ãƒ£ãƒƒã‚·ãƒ¥: %s"):format(monsterName))
	else
		warn(("[MonsterSpawner] ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆæœªç™ºè¦‹: %s"):format(def.Name or "?"))
	end
end

startGlobalAILoop()
processRespawnQueue()

print("[MonsterSpawner] === åˆæœŸåŒ–å®Œäº†ï¼ˆãƒãƒˆãƒ«å³åº§é–‹å§‹å¯¾å¿œï¼‰===")

_G.SpawnMonstersForZone = spawnMonstersForZone
_G.DespawnMonstersForZone = despawnMonstersForZone
_G.SpawnMonstersWithCounts = spawnMonstersWithCounts
_G.GetZoneMonsterCounts = getZoneMonsterCounts
_G.UpdateAllMonsterCounts = updateAllMonsterCounts

print("[MonsterSpawner] ã‚°ãƒ­ãƒ¼ãƒãƒ«é–¢æ•°ç™»éŒ²å®Œäº†ï¼ˆã‚«ã‚¦ãƒ³ãƒˆæ©Ÿèƒ½ä»˜ãï¼‰")

===== ./ServerScriptService/DataCollectors.lua =====
-- ServerScriptService/DataCollectors.lua
-- ã‚»ãƒ¼ãƒ–/ãƒ­ãƒ¼ãƒ‰ã«å¿…è¦ãªãƒ‡ãƒ¼ã‚¿ã‚’åé›†ãƒ»é©ç”¨ã™ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")
local HttpService = game:GetService("HttpService")

local DataCollectors = {}

-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®çŠ¶æ…‹ã‚’åé›†
function DataCollectors.collectPlayerState(player: Player, playerStats)
    local character = player.Character or player.CharacterAdded:Wait()
    local hrp = character:WaitForChild("HumanoidRootPart", 5)

    local zoneManager = require(script.Parent.ZoneManager)
    local currentZone = zoneManager.GetPlayerZone(player)

    local playerState = {
        -- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ (PlayerStatsã‹ã‚‰å–å¾—)
        Stats = {
            Level = playerStats.Level,
            Experience = playerStats.Experience,
            Gold = playerStats.Gold,
            CurrentHP = playerStats.CurrentHP,
            MonstersDefeated = playerStats.MonstersDefeated,
        },
        -- ä½ç½®æƒ…å ±
        Location = {
            ZoneName = currentZone or "ContinentTown", -- ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ã‚¿ã‚¦ãƒ³
            X = hrp and hrp.Position.X or 0,
            Y = hrp and hrp.Position.Y or 50, -- Yã¯åœ°å½¢ã‹ã‚‰å°‘ã—ä¸Šã®ä½ç½®
            Z = hrp and hrp.Position.Z or 0,
        },
    }

    return playerState
end

-- ã€ä¿®æ­£ã€‘ãƒ¯ãƒ¼ãƒ«ãƒ‰ã®çŠ¶æ…‹ï¼ˆãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚«ã‚¦ãƒ³ãƒˆã®ã¿ï¼‰ã‚’åé›†
function DataCollectors.collectFieldState(zoneName)
    local fieldState = {
        MonsterCounts = {}
    }

    -- MonsterSpawnerã®ã‚°ãƒ­ãƒ¼ãƒãƒ«é–¢æ•°ã‚’ä½¿ã£ã¦ã‚«ã‚¦ãƒ³ãƒˆå–å¾—
    if _G.GetZoneMonsterCounts then
        local counts = _G.GetZoneMonsterCounts(zoneName)
        if counts then
            fieldState.MonsterCounts = counts
            print(("[DataCollectors] %s ã®ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚«ã‚¦ãƒ³ãƒˆåé›†: %s"):format(
                zoneName,
                HttpService:JSONEncode(counts)
            ))
        else
            print(("[DataCollectors] %s ã«ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚«ã‚¦ãƒ³ãƒˆãŒã‚ã‚Šã¾ã›ã‚“"):format(zoneName))
        end
    else
        warn("[DataCollectors] _G.GetZoneMonsterCounts ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“")
    end

    return fieldState
end

-- ã€ä¿®æ­£ã€‘ãƒ¯ãƒ¼ãƒ«ãƒ‰ã®çŠ¶æ…‹ã‚’å¾©å…ƒ (ãƒ­ãƒ¼ãƒ‰æ™‚ã«ä½¿ç”¨)
function DataCollectors.restoreFieldState(zoneName, fieldState)
    if not fieldState then
        warn("[DataCollectors] å¾©å…ƒã™ã‚‹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰çŠ¶æ…‹ãŒã‚ã‚Šã¾ã›ã‚“")
        return false
    end

    if not fieldState.MonsterCounts or next(fieldState.MonsterCounts) == nil then
        print(("[DataCollectors] %s ã«å¾©å…ƒã™ã‚‹ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ãŒã‚ã‚Šã¾ã›ã‚“"):format(zoneName))
        return false
    end

    print(("[DataCollectors] %s ã®ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’å¾©å…ƒä¸­: %s"):format(
        zoneName,
        HttpService:JSONEncode(fieldState.MonsterCounts)
    ))

    -- MonsterSpawnerã®ã‚°ãƒ­ãƒ¼ãƒãƒ«é–¢æ•°ã‚’ä½¿ã£ã¦ã‚¹ãƒãƒ¼ãƒ³
    if _G.SpawnMonstersWithCounts then
        _G.SpawnMonstersWithCounts(zoneName, fieldState.MonsterCounts)
        print(("[DataCollectors] %s ã®ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼å¾©å…ƒå®Œäº†"):format(zoneName))
        return true
    else
        warn("[DataCollectors] _G.SpawnMonstersWithCounts ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“")
        return false
    end
end

-- ç·åˆã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆ
function DataCollectors.createSaveData(player: Player, playerStats)
    local currentZone = (require(script.Parent.ZoneManager)).GetPlayerZone(player)

    local saveData = {
        PlayerState = DataCollectors.collectPlayerState(player, playerStats),
        CurrentZone = currentZone,
        FieldState = (currentZone ~= "ContinentTown") and DataCollectors.collectFieldState(currentZone) or nil,
        CollectedItems = playerStats.CollectedItems or {},
        SaveTime = os.time(),
    }

    return saveData
end

return DataCollectors
===== ./ServerScriptService/SettingsService.server.lua =====
-- ServerScriptService/SettingsService.server.luaï¼ˆæ–°è¦ï¼‰
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local DataStoreManager = require(game.ServerScriptService.DataStoreManager)

Players.PlayerAdded:Connect(function(player)
	local data = DataStoreManager.LoadData(player) or {}
	local s = data.Settings or {}

	player:SetAttribute("UILang", s.UILang or "ja")
	player:SetAttribute("VolBGM", tonumber(s.VolBGM) or 1.0)
	player:SetAttribute("VolSE", tonumber(s.VolSE) or 1.0)
end)

Players.PlayerRemoving:Connect(function(player)
	-- é€€å®¤æ™‚ã‚‚ä¿å­˜ï¼ˆä¿é™ºï¼‰
	local data = DataStoreManager.LoadData(player) or {}
	data.Settings = {
		UILang = player:GetAttribute("UILang") or "ja",
		VolBGM = tonumber(player:GetAttribute("VolBGM")) or 1.0,
		VolSE = tonumber(player:GetAttribute("VolSE")) or 1.0,
	}
	DataStoreManager.SaveData(player, data)
end)

===== ./ServerScriptService/TowerPlacement.server.lua =====
-- ServerScriptService/TowerPlacement.server.lua
-- StartTownã«ã‚¿ãƒ¯ãƒ¼ã‚’é…ç½®

local ServerStorage = game:GetService("ServerStorage")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
print("[TowerPlacement] ã‚¿ãƒ¯ãƒ¼é…ç½®ã‚’ã‚¹ã‚­ãƒƒãƒ—")
-- print("[TowerPlacement] ã‚¿ãƒ¯ãƒ¼é…ç½®é–‹å§‹")

-- -- StartTownã®è¨­å®šã‚’å–å¾—
-- local IslandsRegistry = require(ReplicatedStorage.Islands.Registry)
-- local townConfig = nil
-- for _, island in ipairs(IslandsRegistry) do
-- 	if island.name == "StartTown" then
-- 		townConfig = island
-- 		break
-- 	end
-- end

-- if not townConfig then
-- 	warn("[TowerPlacement] StartTownã®è¨­å®šãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
-- 	return
-- end

-- -- é…ç½®ä½ç½®ï¼ˆStartTownã®ä¸­å¿ƒã‹ã‚‰æ±ã«50ã‚¹ã‚¿ãƒƒãƒ‰ï¼‰
-- local TOWER_OFFSET_X = 400  -- â˜…ä¿®æ­£: 400ã«å¤‰æ›´ (-100 + 400 = 300)
-- local TOWER_OFFSET_Z = -100 -- â˜…ä¿®æ­£: -100ã«å¤‰æ›´ (100 + (-100) = 0)

-- -- åœ°å½¢ç”Ÿæˆã‚’å¾…ã¤
-- task.wait(1)

-- -- ServerStorage/Buildingsã‹ã‚‰ã‚¿ãƒ¯ãƒ¼ã®ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’å–å¾—
-- local buildingsFolder = ServerStorage:FindFirstChild("Buildings")
-- if not buildingsFolder then
-- 	warn("[TowerPlacement] ServerStorage ã« 'Buildings' ãƒ•ã‚©ãƒ«ãƒ€ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
-- 	return
-- end

-- local towerTemplate = buildingsFolder:FindFirstChild("Tower")
-- if not towerTemplate then
-- 	warn("[TowerPlacement] ServerStorage/Buildings ã« 'Tower' ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
-- 	warn("[TowerPlacement] Toolboxã‹ã‚‰ Asset ID 12127172596 ã‚’ ServerStorage/Buildings ã«é…ç½®ã—ã¦ãã ã•ã„")
-- 	return
-- end

-- -- ã‚¿ãƒ¯ãƒ¼ã‚’è¤‡è£½
-- local tower = towerTemplate:Clone()
-- tower.Parent = workspace

-- print("[TowerPlacement] ã‚¿ãƒ¯ãƒ¼ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ:", tower.Name)

-- -- é…ç½®ä½ç½®ã‚’è¨ˆç®—
-- local towerX = townConfig.centerX + TOWER_OFFSET_X
-- local towerZ = townConfig.centerZ + TOWER_OFFSET_Z

-- -- åœ°é¢ã®é«˜ã•ã‚’å–å¾—
-- local FieldGen = require(ReplicatedStorage:WaitForChild("FieldGen"))
-- local groundY = FieldGen.raycastGroundY(towerX, towerZ, townConfig.baseY + 100)

-- if not groundY then
-- 	-- ãƒ¬ã‚¤ã‚­ãƒ£ã‚¹ãƒˆãŒå¤±æ•—ã—ãŸå ´åˆã¯æ¨å®šé«˜åº¦ã‚’ä½¿ç”¨
-- 	groundY = townConfig.baseY + 5
-- 	warn("[TowerPlacement] åœ°é¢æ¤œå‡ºå¤±æ•—ã€æ¨å®šé«˜åº¦ã‚’ä½¿ç”¨:", groundY)
-- end

-- -- ã‚¿ãƒ¯ãƒ¼ã®åº•é¢ã‚’åœ°é¢ã«åˆã‚ã›ã‚‹
-- if tower:IsA("Model") then
-- 	-- Modelã®å ´åˆï¼šæœ€ä¸‹ç‚¹ã‚’åœ°é¢ã«åˆã‚ã›ã‚‹
-- 	local primaryPart = tower.PrimaryPart
-- 	if not primaryPart then
-- 		for _, part in ipairs(tower:GetDescendants()) do
-- 			if part:IsA("BasePart") then
-- 				tower.PrimaryPart = part
-- 				primaryPart = part
-- 				print("[TowerPlacement] PrimaryPartã‚’è‡ªå‹•è¨­å®š:", part.Name)
-- 				break
-- 			end
-- 		end
-- 	end

-- 	if primaryPart then
-- 		-- ã¾ãšç›®æ¨™ä½ç½®ã«é…ç½®
-- 		tower:SetPrimaryPartCFrame(CFrame.new(towerX, groundY, towerZ))

-- 		-- æœ€ä¸‹ç‚¹ã‚’æ¢ã™
-- 		local lowestY = math.huge
-- 		local lowestPartName = ""
-- 		for _, part in ipairs(tower:GetDescendants()) do
-- 			if part:IsA("BasePart") then
-- 				local partBottom = part.Position.Y - (part.Size.Y / 2)
-- 				if partBottom < lowestY then
-- 					lowestY = partBottom
-- 					lowestPartName = part.Name
-- 				end
-- 			end
-- 		end

-- 		print(("[TowerPlacement] ãƒ‡ãƒãƒƒã‚°æƒ…å ±:"):format())
-- 		print(("  åœ°é¢ã®é«˜ã• (groundY): %.1f"):format(groundY))
-- 		print(("  æœ€ä¸‹ç‚¹ãƒ‘ãƒ¼ãƒ„: %s"):format(lowestPartName))
-- 		print(("  æœ€ä¸‹ç‚¹ã®é«˜ã• (é…ç½®å‰): %.1f"):format(lowestY))

-- 		-- æœ€ä¸‹ç‚¹ãŒåœ°é¢ã«ãªã‚‹ã‚ˆã†èª¿æ•´
-- 		local adjustment = groundY - lowestY
-- 		local currentCFrame = tower:GetPrimaryPartCFrame()
-- 		tower:SetPrimaryPartCFrame(currentCFrame + Vector3.new(0, adjustment, 0))

-- 		-- èª¿æ•´å¾Œã®æœ€ä¸‹ç‚¹ã‚’ç¢ºèª
-- 		local newLowestY = math.huge
-- 		for _, part in ipairs(tower:GetDescendants()) do
-- 			if part:IsA("BasePart") then
-- 				local partBottom = part.Position.Y - (part.Size.Y / 2)
-- 				if partBottom < newLowestY then
-- 					newLowestY = partBottom
-- 				end
-- 			end
-- 		end

-- 		local _, size = tower:GetBoundingBox()
-- 		print("[TowerPlacement] ã‚¿ãƒ¯ãƒ¼ã‚’é…ç½®ã—ã¾ã—ãŸ (Model):")
-- 		print(("  ä½ç½®: X=%.1f, Y=%.1f, Z=%.1f"):format(towerX, groundY, towerZ))
-- 		print(("  ã‚µã‚¤ã‚º: %.1f x %.1f x %.1f"):format(size.X, size.Y, size.Z))
-- 		print(("  èª¿æ•´: %.1f ã‚¹ã‚¿ãƒƒãƒ‰ä¸Šã«ç§»å‹•"):format(adjustment))
-- 		print(("  èª¿æ•´å¾Œã®æœ€ä¸‹ç‚¹: %.1f (ç›®æ¨™: %.1f)"):format(newLowestY, groundY))
-- 	else
-- 		local cf, size = tower:GetBoundingBox()
-- 		local lowestY = cf.Position.Y - (size.Y / 2)
-- 		local adjustment = groundY - lowestY
-- 		tower:PivotTo(CFrame.new(towerX, groundY + adjustment, towerZ))
-- 		print("[TowerPlacement] PivotToã§é…ç½®ã—ã¾ã—ãŸ:")
-- 		print(("  ä½ç½®: X=%.1f, Y=%.1f, Z=%.1f"):format(towerX, groundY, towerZ))
-- 	end
-- elseif tower:IsA("BasePart") then
-- 	-- MeshPartãªã©å˜ä¸€ãƒ‘ãƒ¼ãƒ„ã®å ´åˆ
-- 	local size = tower.Size
-- 	local offsetY = size.Y / 2
-- 	tower.CFrame = CFrame.new(towerX, groundY + offsetY, towerZ)
-- 	print("[TowerPlacement] ã‚¿ãƒ¯ãƒ¼ã‚’é…ç½®ã—ã¾ã—ãŸ (BasePart):")
-- 	print(("  ä½ç½®: X=%.1f, Y=%.1f, Z=%.1f"):format(towerX, groundY + offsetY, towerZ))
-- 	print(("  ã‚µã‚¤ã‚º: %.1f x %.1f x %.1f"):format(size.X, size.Y, size.Z))
-- else
-- 	warn("[TowerPlacement] æœªå¯¾å¿œã®å‹:", tower.ClassName)
-- 	return
-- end

-- -- ã‚¿ãƒ¯ãƒ¼ã‚’å›ºå®š
-- for _, part in ipairs(tower:GetDescendants()) do
-- 	if part:IsA("BasePart") then
-- 		part.Anchored = true
-- 	end
-- end

-- print("[TowerPlacement] é…ç½®å®Œäº†")
===== ./ReplicatedStorage/LoadingHints.lua =====
-- ReplicatedStorage/LoadingHints.lua
-- ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ç”»é¢ã«è¡¨ç¤ºã™ã‚‹ãƒ’ãƒ³ãƒˆãƒ†ã‚­ã‚¹ãƒˆé›†

local hints = {
	general = {
		"æ•µã«æ¥è§¦ã™ã‚‹ã¨è‡ªå‹•çš„ã«ãƒãƒˆãƒ«ãŒå§‹ã¾ã‚Šã¾ã™",
		"ãƒãƒ¼ã‚·ãƒ§ãƒ³åŠ¹æœã¯ä¸€æ™‚çš„ã§ã™ã€‚å¤§äº‹ã«ä½¿ãŠã†",
		"é«˜ã„ãƒ¬ãƒ™ãƒ«ã®æ•µã«ã¯çµŒé¨“å€¤ãŒå¤šãã‚‚ã‚‰ãˆã‚‹",
		"ã‚´ãƒ¼ãƒ«ãƒ‰ã‚’é›†ã‚ã¦è£…å‚™ã‚’å¼·åŒ–ã—ã‚ˆã†",
		"ãƒãƒ¼ã‚¿ãƒ«ã§åˆ¥ã®å¤§é™¸ã¸ãƒ¯ãƒ¼ãƒ—ã§ãã¾ã™",
		"E ã‚­ãƒ¼ã‚’æŠ¼ã™ã“ã¨ã§ã‚¢ã‚¤ãƒ†ãƒ ã¨ç›¸äº’ä½œç”¨ã§ãã¾ã™",
		"æ•µã‚’å€’ã™ã¨çµŒé¨“å€¤ã¨ã‚´ãƒ¼ãƒ«ãƒ‰ãŒæ‰‹ã«å…¥ã‚Šã¾ã™",
		"ãƒ¬ãƒ™ãƒ«ãŒä¸ŠãŒã‚‹ã¨ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒä¸Šæ˜‡ã—ã¾ã™",
	},

	level_1_10 = {
		"åˆå¿ƒè€…å‘ã‘ã‚¨ãƒªã‚¢ã§åŸºç¤ã‚’å­¦ã³ã¾ã—ã‚‡ã†",
		"å¼±ã„æ•µã‹ã‚‰å§‹ã‚ã¦å¾ã€…ã«å¼·ã„æ•µã«æŒ‘æˆ¦ã—ã‚ˆã†",
		"ãƒãƒˆãƒ«ã«è² ã‘ã¦ã‚‚ãƒšãƒŠãƒ«ãƒ†ã‚£ã¯ã‚ã‚Šã¾ã›ã‚“",
		"ç¹°ã‚Šè¿”ã—æ•µã‚’å€’ã—ã¦çµŒé¨“ã‚’ç©ã¿ã¾ã—ã‚‡ã†",
		"HPãŒæ¸›ã£ãŸã‚‰ãƒãƒ¼ã‚·ãƒ§ãƒ³ã§å›å¾©ã—ã‚ˆã†",
	},

	level_11_30 = {
		"è¤‡æ•°ã®æ•µãŒå‡ºç¾ã™ã‚‹ã‚¨ãƒªã‚¢ã«æŒ‘æˆ¦ã—ã‚ˆã†",
		"æ•µã®å¼·ã•ã«å¿œã˜ã¦æˆ¦ç•¥ã‚’å¤‰ãˆã¾ã—ã‚‡ã†",
		"ãƒ¬ã‚¢ãªãƒ‰ãƒ­ãƒƒãƒ—ã‚’ç‹™ã£ã¦ãƒœã‚¹ã«æŒ‘æˆ¦ã—ã¦ã¿ã¦ã¯",
		"ä»–ã®å¤§é™¸ã¸ã®å†’é™ºã‚‚è¦–é‡ã«å…¥ã‚Œã‚ˆã†",
	},

	level_31_plus = {
		"å¼·åŠ›ãªæ•µã»ã©å¤šãã®çµŒé¨“å€¤ã‚’ãã‚Œã¾ã™",
		"æœ€é›£é–¢ã‚¨ãƒªã‚¢ã¯ã‚„ã‚ŠãŒã„ãŒã‚ã‚Šã¾ã™",
		"å…¨åˆ¶è¦‡ã‚’ç›®æŒ‡ã—ã¦ã‚³ãƒ³ãƒ—ãƒªãƒ¼ãƒˆã‚’ç‹™ãŠã†",
		"è‡ªåˆ†ã®é™ç•Œã«æŒ‘æˆ¦ã—ã¦ã¿ã¾ã—ã‚‡ã†",
	},
}

local function getHintByLevel(level)
	if level <= 10 then
		return hints.level_1_10[math.random(#hints.level_1_10)]
	elseif level <= 30 then
		return hints.level_11_30[math.random(#hints.level_11_30)]
	else
		return hints.level_31_plus[math.random(#hints.level_31_plus)]
	end
end

local function getGeneralHint()
	return hints.general[math.random(#hints.general)]
end

return {
	getHintByLevel = getHintByLevel,
	getGeneralHint = getGeneralHint,
	hints = hints,
}

===== ./ReplicatedStorage/CombatMath_remove.lua =====
-- ReplicatedStorage/CombatMath.lua
local CombatMath = {}

-- å°ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
local function clamp(x, a, b)
	if x < a then return a end
	if x > b then return b end
	return x
end

local function num(v, fallback)
	if typeof(v) == "number" and v == v then
		return v
	end
	return fallback
end

-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼Speedã®ã¿ï¼ˆå¾Œæ–¹äº’æ›ï¼‰
-- baseInterval: ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã®åŸºæº–ç§’ï¼ˆnilâ†’8ï¼‰
-- playerSpeed:  ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®Speedï¼ˆnilâ†’10ï¼‰
function CombatMath.enemyAttackInterval(baseInterval, playerSpeed)
	local base = num(baseInterval, 8)
	local p    = num(playerSpeed, 10)
	-- â€œpãŒé«˜ã„ã»ã©æ•µãŒé…ããªã‚‹â€èª¿æ•´ï¼ˆ0.35 ã¯ä½“æ„Ÿä¿‚æ•°ï¼‰
	local interval = base - (p - 10) * 0.35
	return clamp(interval, 5, 11)
end

-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼/ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ä¸¡Speedã‚’ä½¿ã†ç‰ˆï¼ˆä»Šå›ã¯ã“ã¡ã‚‰ã‚’ä½¿ç”¨ï¼‰
-- baseInterval: nilâ†’8, playerSpeed: nilâ†’10, monsterSpeed: nilâ†’10
-- ä¿‚æ•°0.25ã¯å¾Œã§å¾®èª¿æ•´å¯ï¼ˆ0.25ã€œ0.4ï¼‰
function CombatMath.enemyAttackIntervalWithMSpeed(playerSpeed, monsterSpeed, baseInterval)
	local base = num(baseInterval, 8)
	local p    = num(playerSpeed, 10)
	local m    = num(monsterSpeed, 10)
	local interval = base - (p - m) * 0.25
	return clamp(interval, 5, 11)
end

return CombatMath

===== ./ReplicatedStorage/Util/Logger.lua =====
-- ReplicatedStorage/Util/Logger.lua
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- ========== è¨­å®šèª­ã¿è¾¼ã¿ï¼ˆConfig ã‚’å„ªå…ˆã€ãªã‘ã‚Œã° Utilã€æœ€å¾Œã«ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼‰ ==========
local function loadConfig()
    local cfgMod = nil

    -- â‘  Config/DebugConfig.luaï¼ˆä»Šå›ã®æ–°ãƒ‘ã‚¹ï¼‰
    local configFolder = ReplicatedStorage:FindFirstChild("Config")
    if configFolder then
        cfgMod = configFolder:FindFirstChild("DebugConfig")
    end

    -- â‘¡ äº’æ›: Util/DebugConfig.lua
    if not cfgMod then
        local utilFolder = ReplicatedStorage:FindFirstChild("Util")
        if utilFolder then
            cfgMod = utilFolder:FindFirstChild("DebugConfig")
        end
    end

    -- â‘¢ ç›´ä¸‹: DebugConfig.luaï¼ˆæœ€å¾Œã®ä¿é™ºï¼‰
    if not cfgMod then
        cfgMod = ReplicatedStorage:FindFirstChild("DebugConfig")
    end

    if cfgMod then
        local ok, got = pcall(require, cfgMod)
        if ok and type(got) == "table" then
            return got
        else
            warn("[Logger] DebugConfig require failed; using defaults")
        end
    else
        warn("[Logger] DebugConfig not found; using defaults")
    end

    -- ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
    return {
        level = "INFO",
        onlyTags = nil,
        showTime = true,
        warnForHighLevels = true,
    }
end

local rawCfg = loadConfig()

-- ========== ãƒ¬ãƒ™ãƒ«æ­£è¦åŒ– ==========
local LEVELS = { TRACE=10, DEBUG=20, INFO=30, WARN=40, ERROR=50 }
local NAMES  = {}; for k,v in pairs(LEVELS) do NAMES[v]=k end

local function normalizeLevel(lv)
    if type(lv)=="number" then
        if lv < 15 then return LEVELS.TRACE end
        if lv < 25 then return LEVELS.DEBUG end
        if lv < 35 then return LEVELS.INFO  end
        if lv < 45 then return LEVELS.WARN  end
        return LEVELS.ERROR
    elseif type(lv)=="string" then
        local up = string.upper(lv:match("^%s*(.-)%s*$"))
        return LEVELS[up] or LEVELS.INFO
    end
    return LEVELS.INFO
end

local function normalizeTags(tags)
    if not tags then return nil end
    if type(tags)=="table" then
        -- ã™ã§ã« set å½¢å¼ãªã‚‰ãã®ã¾ã¾
        local isSet = true
        for k,v in pairs(tags) do
            if type(k) ~= "string" or v ~= true then
                isSet = false; break
            end
        end
        if isSet then return tags end

        -- é…åˆ— â†’ set
        local set = {}
        for _,name in ipairs(tags) do
            if type(name)=="string" then set[name]=true end
        end
        return set
    end
    return nil
end

local CONFIG = {
    level = normalizeLevel(rawCfg.level),
    onlyTags = normalizeTags(rawCfg.onlyTags),
    showTime = (rawCfg.showTime ~= false),
    warnForHighLevels = (rawCfg.warnForHighLevels ~= false),
}

-- ========== æœ¬ä½“ ==========
local Logger = {}
Logger._config = CONFIG
Logger._cache  = {}

local function shouldEmit(tag, lvl)
    if CONFIG.onlyTags and not CONFIG.onlyTags[tag] then return false end
    return lvl >= CONFIG.level
end

local function emit(tag, lvl, msg)
    local prefix = string.format("[%s][%s]", NAMES[lvl] or "LOG", tag)
    if CONFIG.showTime then
        prefix = string.format("[%.3f]%s", tick(), prefix)
    end
    local line = prefix .. " " .. tostring(msg)
    if CONFIG.warnForHighLevels and lvl >= LEVELS.WARN then
        warn(line)
    else
        print(line)
    end
end

local function makeLogger(tag)
    tag = tostring(tag or "APP")

    local function logAt(lvl, ...)
        if not shouldEmit(tag, lvl) then return end
        if select("#", ...) == 1 then
            emit(tag, lvl, select(1, ...))
        else
            local parts = {}
            for i=1,select("#", ...) do parts[#parts+1]=tostring(select(i,...)) end
            emit(tag, lvl, table.concat(parts, " "))
        end
    end

    local function logFmt(lvl, fmt, ...)
        if not shouldEmit(tag, lvl) then return end
        emit(tag, lvl, string.format(fmt, ...))
    end

    return {
        trace  = function(...) logAt(LEVELS.TRACE, ...) end,
        debug  = function(...) logAt(LEVELS.DEBUG, ...) end,
        info   = function(...) logAt(LEVELS.INFO , ...) end,
        warn   = function(...) logAt(LEVELS.WARN , ...) end,
        error  = function(...) logAt(LEVELS.ERROR, ...) end,

        tracef = function(fmt, ...) logFmt(LEVELS.TRACE, fmt, ...) end,
        debugf = function(fmt, ...) logFmt(LEVELS.DEBUG, fmt, ...) end,
        infof  = function(fmt, ...) logFmt(LEVELS.INFO , fmt, ...) end,
        warnf  = function(fmt, ...) logFmt(LEVELS.WARN , fmt, ...) end,
        errorf = function(fmt, ...) logFmt(LEVELS.ERROR, fmt, ...) end,
    }
end

function Logger.get(tag)
    if not Logger._cache[tag] then
        Logger._cache[tag] = makeLogger(tag)
    end
    return Logger._cache[tag]
end

-- ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã§å¤‰æ›´ã—ãŸã„ã¨ãç”¨
function Logger.setLevel(lv)     CONFIG.level = normalizeLevel(lv) end
function Logger.setOnlyTags(ts)  CONFIG.onlyTags = normalizeTags(ts) end

return Logger

===== ./ReplicatedStorage/Config/DebugConfig.lua =====
-- ReplicatedStorage/Config/DebugConfig.lua
return {
    -- æ–‡å­— or æ•°å­—ã©ã¡ã‚‰ã§ã‚‚OKï¼ˆTRACE=10, DEBUG=20, INFO=30, WARN=40, ERROR=50ï¼‰
    level = "DEBUG",

    -- {"BattleUI","BattleSystem"} ã®ã‚ˆã†ã«ã‚¿ã‚°ã§çµã‚Šè¾¼ã¿ï¼ˆnil ã§ã‚ªãƒ•ï¼‰
    onlyTags = nil,

    -- å…ˆé ­ã« tick() ã‚’å‡ºã™
    showTime = false,

    -- WARN/ERROR ã¯ warn() ã«æµã™ï¼ˆãã‚Œä»¥å¤–ã¯ printï¼‰
    warnForHighLevels = true,
}

===== ./ReplicatedStorage/Config/DisplayConfig.lua =====
--!strict
-- ReplicatedStorage/Config/DisplayConfig.lua
-- å¤§é™¸åã‚’é…åˆ—ã§æŒ‡å®šã—ã¦ã€å³¶ãƒ©ãƒ™ãƒ«ï¼ˆBillboardGuiï¼‰è¡¨ç¤ºã®å¯¾è±¡ã‚’åˆ‡ã‚Šæ›¿ãˆã‚‹è¨­å®šãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã€‚
-- ã©ã“ã‹ã‚‰å‘¼ã°ã‚Œã¦ã‚‚è½ã¡ãªã„ã‚ˆã†ã«ã€nilã‚¬ãƒ¼ãƒ‰ã‚’å¾¹åº•ã€‚

local M = {}

-- â–¼ ã‚°ãƒ­ãƒ¼ãƒãƒ«ON/OFF
M.enabled = true

-- â–¼ ãƒ©ãƒ™ãƒ«ã‚’å‡ºã™å¤§é™¸åï¼ˆè¤‡æ•°OKï¼‰
--   ä¾‹: { "BananaLand", "Hokkaido", "Kyushu" }
M.continents = {
	"BananaLand",
	"ContinentHokkaido",
	"ContinentKyushu",
}

-- â–¼ æ—¢å®šã®è¡¨ç¤ºãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
M.defaults = {
	showIslandLabel = true, -- åŸºæœ¬ON
	labelOffsetY = 6, -- è¡¨é¢ã‹ã‚‰å°‘ã—ä¸Š
	labelMaxDistance = 2000, -- è¡¨ç¤ºè·é›¢
	font = Enum.Font.GothamBold,
	textSize = 16,
	backgroundTransparency = 0.35,
}

-- â–¼ å¤§é™¸ã”ã¨ã®ä¸Šæ›¸ã
--   ä¾‹: M.overrides["BananaLand"] = { labelOffsetY = 10 }
M.overrides = {}

----------------------------------------------------------------
-- å†…éƒ¨ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ï¼ˆnilã‚¬ãƒ¼ãƒ‰ï¼‰
----------------------------------------------------------------
local function asArray(t)
	-- é…åˆ—ã§ãªã‘ã‚Œã°ç©ºé…åˆ—ã‚’è¿”ã™
	if typeof(t) ~= "table" then
		return {}
	end
	return t
end

local function asTable(t)
	if typeof(t) ~= "table" then
		return {}
	end
	return t
end

local function cloneTable(src)
	local dst = {}
	for k, v in pairs(src) do
		dst[k] = v
	end
	return dst
end

----------------------------------------------------------------
-- å…¬é–‹API
----------------------------------------------------------------

function M.isEnabledFor(continentName: string): boolean
	-- ã‚°ãƒ­ãƒ¼ãƒãƒ«OFFãªã‚‰å³false
	if M.enabled ~= true then
		return false
	end

	-- continents ãŒä¸æ­£/æœªè¨­å®šã§ã‚‚è½ã¡ãªã„
	local list = asArray(M.continents)
	if #list == 0 then
		-- ä½•ã‚‚æŒ‡å®šã•ã‚Œã¦ã„ãªã„å ´åˆã¯ã€Œå…¨ã¦OFFã€ã«ã™ã‚‹é‹ç”¨
		return false
	end

	for _, n in ipairs(list) do
		if n == continentName then
			return true
		end
	end
	return false
end

function M.getParamsFor(continentName: string)
	-- defaults ã‚’ã‚¯ãƒ­ãƒ¼ãƒ³ã—ã¦ã‹ã‚‰ overrides ã‚’ãƒãƒ¼ã‚¸
	local params = cloneTable(asTable(M.defaults))
	local ovAll = asTable(M.overrides)
	local ov = ovAll[continentName]
	if typeof(ov) == "table" then
		for k, v in pairs(ov) do
			params[k] = v
		end
	end
	return params
end

return M

===== ./ReplicatedStorage/Config/GameDebug.lua =====
-- ReplicatedStorage/Config/GameDebug.lua
local GameDebug = {
    BattleLogs = false,         -- ã‚µãƒ¼ãƒ/ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã®è©³ç´°ãƒ­ã‚°
    BattleTelemetry = true,     -- ãƒ†ãƒ¬ãƒ¡ãƒˆãƒªé€ä¿¡æœ‰åŠ¹
    TelemetrySampleCycles = 3,  -- 1ãƒãƒˆãƒ«ã§æœ€åˆã®nã‚µã‚¤ã‚¯ãƒ«ã ã‘åé›†
    DriftWarnMs = 120,          -- ãƒ‰ãƒªãƒ•ãƒˆé–¾å€¤(ms) è¶…éæ™‚ã®ã¿è­¦å‘Šãƒ­ã‚°
}
return GameDebug

===== ./ReplicatedStorage/Continents/BananaLand.lua =====
return {
	name = "BananaLand",
	displayName = "ãƒãƒŠãƒŠãƒ©ãƒ³ãƒ‰",
	islands = {
		"Banana_C1",
		"Banana_C2",
		"Banana_C3",
		"Banana_C4",
		"Banana_C5",
		"Banana_C6",
		"Banana_C7",
		"Banana_C8",
		"Banana_C9",
		"Banana_C10",
		"Banana_C11",
		"Banana_C12",
		"Banana_C13",
		"Banana_C14",
		"Banana_C15",
		"Banana_C16",
		"Banana_C17",
		"Banana_C18",
		"Banana_C19",
		"Banana_C20",
		"Banana_C21",
		"Banana_C22",
		"Banana_C23",
		"Banana_C24",
		"Banana_C25",
		"Banana_C26",
		"Banana_C27",
		"Banana_C28",
		"Banana_C29",
		"Banana_C30",
		"Banana_C31",
		"Banana_C32",
		"Banana_C33",
		"Banana_C34",
		"Banana_C35",
		"Banana_C36",
		"Banana_C37",
		"Banana_C38",
		"Banana_C39",
		"Banana_C40",
		"Banana_C41",
		"Banana_C42",
		"Banana_C43",
		"Banana_C44",
		"Banana_C45",
		"Banana_C46",
		"Banana_C47",
		"Banana_C48",
		"Banana_C49",
		"Banana_C50",
	},

	paths = {
		points = {
			{ 10101.0, 26.3, 71.1 },
			{ 10075.8, 26.4, 102.6 },
			{ 10038.3, 26.4, 122.0 },
			{ 9995.3, 26.6, 120.9 },
			{ 9957.1, 26.6, 103.3 },
			{ 9934.4, 26.3, 66.2 },
			{ 9901.0, 26.6, 11.6 },
			{ 9855.1, 26.6, -7.1 },
			{ 9927.7, 27.1, 56.1 },
			{ 9954.1, 26.2, 54.9 },
			{ 9985.8, 34.5, 48.5 },
		},
		width = 24, -- é“ã®å¹…ï¼ˆstudï¼‰
		-- method = "terrain", -- "terrain"ï¼ˆåœ°å½¢ã‚’å¡—ã‚‹ï¼‰ or "parts"ï¼ˆãƒ‘ãƒ¼ãƒ„æ•·ãï¼‰
		material = Enum.Material.Ground, -- method="terrain"æ™‚ã®å¡—ã‚Šæè³ª
		step = 3, -- ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°é–“éš”ï¼ˆå°ã•ã„ã»ã©æ»‘ã‚‰ã‹ï¼†é‡ã„ï¼‰
		alignToSlope = false, -- æ–œé¢ã«é“é¢ã‚’å‚¾ã‘ã‚‹ã‹ï¼ˆè¦‹ãŸç›®ï¼štrueã€æ­©ãã‚„ã™ã•ï¼šfalseï¼‰
		groundOffset = 4.8, -- ã‚ã‚Šè¾¼ã¿å›é¿ã®å¾®å°ã‚ªãƒ•ã‚»ãƒƒãƒˆ
	},

	--

	-- paths = {
	-- 	{
	-- 		name = "MainRoad01",
	-- 		points = {
	-- 			{ 12720, 10, -220 },
	-- 			{ 12850, 10, -120 },
	-- 			{ 13000, 10, 0 },
	-- 			{ 13150, 10, 40 },
	-- 			{ 13280, 10, 60 },
	-- 		},
	-- 		width = 20,
	-- 		method = "terrain",
	-- 		material = Enum.Material.Ground,
	-- 		step = 3,
	-- 		alignToSlope = false,
	-- 		groundOffset = 0.05,
	-- 	},
	-- },
	-- {
	-- 	model = "Tree1",
	-- 	position = { 12783.8, 25.5, -62.1 },
	-- 	size = 1.8,
	-- 	rotation = { 0, 180, 0 },
	-- 	stickToGround = true, -- çœç•¥å¯ï¼ˆtrueãŒæ—¢å®šï¼‰
	-- 	groundOffset = 0.15, -- èŠç”Ÿã§å°‘ã—æµ®ã‹ã›ãŸã„æ™‚
	-- 	alignToSlope = true, -- æ–œé¢ã«æœ¨ã‚’å‚¾ã‘ãŸããªã„ãªã‚‰false
	-- },
	-- {
	-- 	model = "Chest",
	-- 	position = { 12799.3, 25.2, -99.8 },
	-- 	size = 1.8,
	-- 	rotation = { 0, 180, 0 },
	-- 	stickToGround = true, -- çœç•¥å¯ï¼ˆtrueãŒæ—¢å®šï¼‰
	-- 	groundOffset = 0.15, -- èŠç”Ÿã§å°‘ã—æµ®ã‹ã›ãŸã„æ™‚
	-- 	alignToSlope = true, -- æ–œé¢ã«æœ¨ã‚’å‚¾ã‘ãŸããªã„ãªã‚‰false
	-- },

	fieldObjects = {
		{
			model = "box_closed",
			position = { 9938.7, 26.5, 64.1 },
			mode = "ground",
			size = 1,
			rotation = { 0, 0, 0 },
			stickToGround = false, -- çœç•¥å¯ï¼ˆtrueãŒæ—¢å®šï¼‰
			groundOffset = 0, -- èŠç”Ÿã§å°‘ã—æµ®ã‹ã›ãŸã„æ™‚
			alignToSlope = false, -- æ–œé¢ã«æœ¨ã‚’å‚¾ã‘ãŸããªã„ãªã‚‰false

			interaction = {
				type = "chest", -- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—
				action = "é–‹ã‘ã‚‹", -- ãƒœã‚¿ãƒ³ã«è¡¨ç¤ºã•ã‚Œã‚‹ãƒ†ã‚­ã‚¹ãƒˆ
				key = "E", -- ã‚­ãƒ¼ãƒã‚¤ãƒ³ãƒ‰
				range = 5, -- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³å¯èƒ½è·é›¢ï¼ˆã‚¹ã‚¿ãƒƒãƒ‰ï¼‰

				-- å®ç®±å›ºæœ‰ã®æƒ…å ±
				chestId = "banana_chest_01", -- ãƒ¦ãƒ‹ãƒ¼ã‚¯ID
				openedModel = "box_opened", -- é–‹ã„ãŸçŠ¶æ…‹ã®ãƒ¢ãƒ‡ãƒ«å
				rewards = {
					{ item = "ãƒãƒ¼ã‚·ãƒ§ãƒ³", count = 1 },
					{ item = "ã‚´ãƒ¼ãƒ«ãƒ‰", count = 25 },
				},
				displayDuration = 3, -- å ±é…¬è¡¨ç¤ºæ™‚é–“ï¼ˆç§’ï¼‰
			},
		},
		{
			model = "box_closed",
			position = { 9963.4, 47.0, 105.5 },
			mode = "fixed",
			size = 1,
			rotation = { 0, 0, 0 },
			stickToGround = false, -- çœç•¥å¯ï¼ˆtrueãŒæ—¢å®šï¼‰
			groundOffset = 0, -- èŠç”Ÿã§å°‘ã—æµ®ã‹ã›ãŸã„æ™‚
			alignToSlope = false, -- æ–œé¢ã«æœ¨ã‚’å‚¾ã‘ãŸããªã„ãªã‚‰false

			interaction = {
				type = "chest", -- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—
				action = "é–‹ã‘ã‚‹", -- ãƒœã‚¿ãƒ³ã«è¡¨ç¤ºã•ã‚Œã‚‹ãƒ†ã‚­ã‚¹ãƒˆ
				key = "E", -- ã‚­ãƒ¼ãƒã‚¤ãƒ³ãƒ‰
				range = 5, -- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³å¯èƒ½è·é›¢ï¼ˆã‚¹ã‚¿ãƒƒãƒ‰ï¼‰

				-- å®ç®±å›ºæœ‰ã®æƒ…å ±
				chestId = "banana_chest_02", -- ãƒ¦ãƒ‹ãƒ¼ã‚¯ID
				openedModel = "box_opened", -- é–‹ã„ãŸçŠ¶æ…‹ã®ãƒ¢ãƒ‡ãƒ«å
				rewards = {
					{ item = "ãƒãƒ¼ã‚·ãƒ§ãƒ³", count = 1 },
					{ item = "ã‚´ãƒ¼ãƒ«ãƒ‰", count = 25 },
				},
				displayDuration = 3, -- å ±é…¬è¡¨ç¤ºæ™‚é–“ï¼ˆç§’ï¼‰
			},
		},
	},

	fieldObjects = {},
	BGM = "",
	BGMVolume = 0.2,
}
--

===== ./ReplicatedStorage/Continents/Greenland.lua =====
return {
name = "VerdantPlateau",
displayName = "ç·‘ã®å¤§é™¸",
islands = {
"VerdantPlateau_C1",
"VerdantPlateau_C2",
"VerdantPlateau_C3",
"VerdantPlateau_C4",
},
paths = {
{
name = "MainRoad01",
points = {
{2720, 10, -220},
{2850, 10, -120},
{3000, 10, 0},
{3150, 10, 40},
{3280, 10, 60},
},
width = 20,
method = "terrain",
material = Enum.Material.Ground,
step = 3,
alignToSlope = false,
groundOffset = 0.05
},
},
		{
			model = "Tree1",
			position = {2783.8, 25.5, -62.1},
			size = 1.8,
			rotation = {0, 180, 0},
			stickToGround = true,   -- çœç•¥å¯ï¼ˆtrueãŒæ—¢å®šï¼‰
			groundOffset  = 0.15,   -- èŠç”Ÿã§å°‘ã—æµ®ã‹ã›ãŸã„æ™‚
			alignToSlope  = true,  -- æ–œé¢ã«æœ¨ã‚’å‚¾ã‘ãŸããªã„ãªã‚‰false
		},
        {
			model = "Chest",
			position = {2799.3, 25.2, -99.8},
			size = 1.8,
			rotation = {0, 180, 0},
			stickToGround = true,   -- çœç•¥å¯ï¼ˆtrueãŒæ—¢å®šï¼‰
			groundOffset  = 0.15,   -- èŠç”Ÿã§å°‘ã—æµ®ã‹ã›ãŸã„æ™‚
			alignToSlope  = true,  -- æ–œé¢ã«æœ¨ã‚’å‚¾ã‘ãŸããªã„ãªã‚‰false
		},

fieldObjects = {},
BGM = "",
BGMVolume = 0.2
}
===== ./ReplicatedStorage/Continents/Registry.lua =====
-- ReplicatedStorage/Continents/Registry.lua
local RS = game:GetService("ReplicatedStorage")
local ContinentsFolder = RS:WaitForChild("Continents")

return {
	require(ContinentsFolder.ContientTown),
	require(ContinentsFolder.ContinentHokkaido),
	require(ContinentsFolder.ContinentShikoku),
	require(ContinentsFolder.ContinentKyushu),
	require(ContinentsFolder.Snowland),
	require(ContinentsFolder.BananaLand),
}

===== ./ReplicatedStorage/Continents/Snowland.lua =====
return {
name = "SnowCrescent",
displayName = "é›ªã®ä¸‰æ—¥æœˆ",
islands = {
"SnowCrescent_C1",
"SnowCrescent_C2",
"SnowCrescent_C3",
"SnowCrescent_C4",
"SnowCrescent_C5",
"SnowCrescent_C6",
"SnowCrescent_C7",
"SnowCrescent_C8",
"SnowCrescent_C9",
"SnowCrescent_C10",
"SnowCrescent_C11",
"SnowCrescent_C12",
"SnowCrescent_C13",
"SnowCrescent_C14",
"SnowCrescent_C15",
},
paths = {
{
name = "MainRoad_NS",
points = {
{2850, 14, -560},
{2855, 15, -420},
{2850, 15, -260},
{2845, 16, -120},
{2850, 16, 0},
{2855, 17, 140},
{2850, 18, 300},
{2850, 19, 460},
},
width = 20,
method = "terrain",
material = Enum.Material.Ground,
step = 3,
alignToSlope = false,
groundOffset = 0.05
},
},
fieldObjects = {},
BGM = "",
BGMVolume = 0.2
}
===== ./ReplicatedStorage/Continents/ContinentHokkaido.lua =====
return {
	name = "ContinentHokkaido",
	displayName = "Hokkaido Continent",

	islands = {
		"Hokkaido_W0",
		"Hokkaido_W1",
		"Hokkaido_C1",
		"Hokkaido_C2",
		"Hokkaido_C3",
		"Hokkaido_C4",
		"Hokkaido_C5",
		"Hokkaido_E1",
		"Hokkaido_N1",
		"Hokkaido_N2",
		"Hokkaido_N3",
		"Hokkaido_N4",
		"Hokkaido_NE1",
		"Hokkaido_NE2",
		"Hokkaido_S1",
		"Hokkaido_S2",
		"Hokkaido_SW1",
		"Hokkaido_SW2",
	},

	bridges = {},

	paths = {
		points = {
			{ 3069.8, 17.0, -54.5 },
			{ 3126.1, 22.5, -9.5 },
			{ 3153.8, 24.5, 5.8 },
			{ 3174.6, 19.9, 34.8 },
			{ 3209.4, 16.1, 60.0 },
			{ 3228.9, 16.2, 87.7 },
			{ 3244.1, 16.1, 111.2 },
		},
		width = 24, -- é“ã®å¹…ï¼ˆstudï¼‰
		method = "terrain", -- "terrain"ï¼ˆåœ°å½¢ã‚’å¡—ã‚‹ï¼‰ or "parts"ï¼ˆãƒ‘ãƒ¼ãƒ„æ•·ãï¼‰
		material = Enum.Material.Ground, -- method="terrain"æ™‚ã®å¡—ã‚Šæè³ª
		step = 3, -- ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°é–“éš”ï¼ˆå°ã•ã„ã»ã©æ»‘ã‚‰ã‹ï¼†é‡ã„ï¼‰
		alignToSlope = false, -- æ–œé¢ã«é“é¢ã‚’å‚¾ã‘ã‚‹ã‹ï¼ˆè¦‹ãŸç›®ï¼štrueã€æ­©ãã‚„ã™ã•ï¼šfalseï¼‰
		groundOffset = 4.8, -- ã‚ã‚Šè¾¼ã¿å›é¿ã®å¾®å°ã‚ªãƒ•ã‚»ãƒƒãƒˆ
	},

	portals = {
		{
			name = "Hokkaido_to_Town",
			toZone = "ContinentTown",
			islandName = "Hokkaido_C3",
			offsetX = 0,
			offsetZ = 0,
			label = "â†’ Town",
			color = Color3.fromRGB(255, 200, 100),
		},
	},

	fieldObjects = {
		{
			model = "Tree1",
			position = { 3237.0, 22.0, -10.8 },
			size = 1.5,
			rotation = { 0, 0, 0 },
			stickToGround = true, -- çœç•¥å¯ï¼ˆtrueãŒæ—¢å®šï¼‰
			groundOffset = 0.15, -- èŠç”Ÿã§å°‘ã—æµ®ã‹ã›ãŸã„æ™‚
			alignToSlope = true, -- æ–œé¢ã«æœ¨ã‚’å‚¾ã‘ãŸããªã„ãªã‚‰false
		},
		{
			model = "Tree1",
			position = { 3092.5, 9.1, -175.5 },
			size = 1.0,
			rotation = { 0, 0, 0 },
			stickToGround = true, -- çœç•¥å¯ï¼ˆtrueãŒæ—¢å®šï¼‰
			groundOffset = 0.15, -- èŠç”Ÿã§å°‘ã—æµ®ã‹ã›ãŸã„æ™‚
			alignToSlope = true, -- æ–œé¢ã«æœ¨ã‚’å‚¾ã‘ãŸããªã„ãªã‚‰false
		},

		{
			model = "Tree1",
			position = { 3118.2, 7.3, -182.6 },
			size = 1.0,
			rotation = { 0, 30, 0 },
			stickToGround = true, -- çœç•¥å¯ï¼ˆtrueãŒæ—¢å®šï¼‰
			groundOffset = 0.15, -- èŠç”Ÿã§å°‘ã—æµ®ã‹ã›ãŸã„æ™‚
			alignToSlope = true, -- æ–œé¢ã«æœ¨ã‚’å‚¾ã‘ãŸããªã„ãªã‚‰false
		},

		{
			model = "Small House",
			position = { 3080.8, 32.0, -162.8 },
			size = 1.8,
			rotation = { 0, 180, 0 },
			stickToGround = false, -- çœç•¥å¯ï¼ˆtrueãŒæ—¢å®šï¼‰
			groundOffset = 0.15, -- èŠç”Ÿã§å°‘ã—æµ®ã‹ã›ãŸã„æ™‚
			alignToSlope = false, -- æ–œé¢ã«æœ¨ã‚’å‚¾ã‘ãŸããªã„ãªã‚‰false
		},

		{
			-- model = "Chest",
			model = "koki3D",
			position = { -0.0, 56.3, -12.0 },
			size = 1.0,
			rotation = { 0, 0, 0 },
			stickToGround = true, -- çœç•¥å¯ï¼ˆtrueãŒæ—¢å®šï¼‰
			groundOffset = 0, -- èŠç”Ÿã§å°‘ã—æµ®ã‹ã›ãŸã„æ™‚
			alignToSlope = true, -- æ–œé¢ã«æœ¨ã‚’å‚¾ã‘ãŸããªã„ãªã‚‰false
		},

		{
			model = "box_closed",
			position = { 3152.0, 59.5, -75.2 },
			mode = "fixed",
			size = 1,
			rotation = { 0, 0, 0 },
			stickToGround = false, -- çœç•¥å¯ï¼ˆtrueãŒæ—¢å®šï¼‰
			groundOffset = 0, -- èŠç”Ÿã§å°‘ã—æµ®ã‹ã›ãŸã„æ™‚
			alignToSlope = false, -- æ–œé¢ã«æœ¨ã‚’å‚¾ã‘ãŸããªã„ãªã‚‰false

			interaction = {
				type = "chest", -- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—
				action = "é–‹ã‘ã‚‹", -- ãƒœã‚¿ãƒ³ã«è¡¨ç¤ºã•ã‚Œã‚‹ãƒ†ã‚­ã‚¹ãƒˆ
				key = "E", -- ã‚­ãƒ¼ãƒã‚¤ãƒ³ãƒ‰
				range = 8, -- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³å¯èƒ½è·é›¢ï¼ˆã‚¹ã‚¿ãƒƒãƒ‰ï¼‰

				-- å®ç®±å›ºæœ‰ã®æƒ…å ±
				chestId = "hokkaido_chest_01", -- ãƒ¦ãƒ‹ãƒ¼ã‚¯ID
				openedModel = "box_opened", -- é–‹ã„ãŸçŠ¶æ…‹ã®ãƒ¢ãƒ‡ãƒ«å
				rewards = {
					{ item = "ãƒãƒ¼ã‚·ãƒ§ãƒ³", count = 2 },
					{ item = "ã‚´ãƒ¼ãƒ«ãƒ‰", count = 45 },
				},
				displayDuration = 3, -- å ±é…¬è¡¨ç¤ºæ™‚é–“ï¼ˆç§’ï¼‰
			},
		},

		{
			model = "box_closed",
			position = { 2997.1, 28.9, 10.8 },
			mode = "fixed",
			size = 1,
			rotation = { 0, 0, 0 },
			stickToGround = false, -- çœç•¥å¯ï¼ˆtrueãŒæ—¢å®šï¼‰
			groundOffset = 0, -- èŠç”Ÿã§å°‘ã—æµ®ã‹ã›ãŸã„æ™‚
			alignToSlope = false, -- æ–œé¢ã«æœ¨ã‚’å‚¾ã‘ãŸããªã„ãªã‚‰false

			interaction = {
				type = "chest", -- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—
				action = "é–‹ã‘ã‚‹", -- ãƒœã‚¿ãƒ³ã«è¡¨ç¤ºã•ã‚Œã‚‹ãƒ†ã‚­ã‚¹ãƒˆ
				key = "E", -- ã‚­ãƒ¼ãƒã‚¤ãƒ³ãƒ‰
				range = 8, -- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³å¯èƒ½è·é›¢ï¼ˆã‚¹ã‚¿ãƒƒãƒ‰ï¼‰

				-- å®ç®±å›ºæœ‰ã®æƒ…å ±
				chestId = "hokkaido_chest_02", -- ãƒ¦ãƒ‹ãƒ¼ã‚¯ID
				openedModel = "box_opened", -- é–‹ã„ãŸçŠ¶æ…‹ã®ãƒ¢ãƒ‡ãƒ«å
				rewards = {
					{ item = "ãƒãƒ¼ã‚·ãƒ§ãƒ³", count = 2 },
				},
				displayDuration = 10, -- å ±é…¬è¡¨ç¤ºæ™‚é–“ï¼ˆç§’ï¼‰
			},
		},

		{
			model = "box_closed",
			position = { 3125.8, 47.2, -60.7 },
			mode = "fixed",
			size = 1,
			rotation = { 0, 0, 0 },
			stickToGround = false, -- çœç•¥å¯ï¼ˆtrueãŒæ—¢å®šï¼‰
			groundOffset = 0, -- èŠç”Ÿã§å°‘ã—æµ®ã‹ã›ãŸã„æ™‚
			alignToSlope = false, -- æ–œé¢ã«æœ¨ã‚’å‚¾ã‘ãŸããªã„ãªã‚‰false

			interaction = {
				type = "chest", -- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—
				action = "é–‹ã‘ã‚‹", -- ãƒœã‚¿ãƒ³ã«è¡¨ç¤ºã•ã‚Œã‚‹ãƒ†ã‚­ã‚¹ãƒˆ
				key = "E", -- ã‚­ãƒ¼ãƒã‚¤ãƒ³ãƒ‰
				range = 8, -- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³å¯èƒ½è·é›¢ï¼ˆã‚¹ã‚¿ãƒƒãƒ‰ï¼‰

				-- å®ç®±å›ºæœ‰ã®æƒ…å ±
				chestId = "hokkaido_chest_03", -- ãƒ¦ãƒ‹ãƒ¼ã‚¯ID
				openedModel = "box_opened", -- é–‹ã„ãŸçŠ¶æ…‹ã®ãƒ¢ãƒ‡ãƒ«å
				rewards = {
					{ item = "ã‚´ãƒ¼ãƒ«ãƒ‰", count = 120 },
				},
				displayDuration = 3, -- å ±é…¬è¡¨ç¤ºæ™‚é–“ï¼ˆç§’ï¼‰
			},
		},

		{
			model = "box_closed",
			position = { 3136.9, 47.1, -49.5 },
			mode = "fixed",
			size = 1,
			rotation = { 0, 0, 0 },
			stickToGround = false, -- çœç•¥å¯ï¼ˆtrueãŒæ—¢å®šï¼‰
			groundOffset = 0, -- èŠç”Ÿã§å°‘ã—æµ®ã‹ã›ãŸã„æ™‚
			alignToSlope = false, -- æ–œé¢ã«æœ¨ã‚’å‚¾ã‘ãŸããªã„ãªã‚‰false

			interaction = {
				type = "chest", -- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—
				action = "é–‹ã‘ã‚‹", -- ãƒœã‚¿ãƒ³ã«è¡¨ç¤ºã•ã‚Œã‚‹ãƒ†ã‚­ã‚¹ãƒˆ
				key = "E", -- ã‚­ãƒ¼ãƒã‚¤ãƒ³ãƒ‰
				range = 8, -- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³å¯èƒ½è·é›¢ï¼ˆã‚¹ã‚¿ãƒƒãƒ‰ï¼‰

				-- å®ç®±å›ºæœ‰ã®æƒ…å ±
				chestId = "hokkaido_chest_04", -- ãƒ¦ãƒ‹ãƒ¼ã‚¯ID
				openedModel = "box_opened", -- é–‹ã„ãŸçŠ¶æ…‹ã®ãƒ¢ãƒ‡ãƒ«å
				rewards = {
					{ item = "ã‚´ãƒ¼ãƒ«ãƒ‰", count = 70 },
				},
				displayDuration = 3, -- å ±é…¬è¡¨ç¤ºæ™‚é–“ï¼ˆç§’ï¼‰
			},
		},

		{
			model = "box_closed",
			position = { 3125.2, 48.0, -65.6 },
			mode = "ground",
			size = 1,
			rotation = { 0, 0, 0 },
			stickToGround = false, -- çœç•¥å¯ï¼ˆtrueãŒæ—¢å®šï¼‰
			groundOffset = 0, -- èŠç”Ÿã§å°‘ã—æµ®ã‹ã›ãŸã„æ™‚
			alignToSlope = false, -- æ–œé¢ã«æœ¨ã‚’å‚¾ã‘ãŸããªã„ãªã‚‰false

			interaction = {
				type = "chest", -- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—
				action = "é–‹ã‘ã‚‹", -- ãƒœã‚¿ãƒ³ã«è¡¨ç¤ºã•ã‚Œã‚‹ãƒ†ã‚­ã‚¹ãƒˆ
				key = "E", -- ã‚­ãƒ¼ãƒã‚¤ãƒ³ãƒ‰
				range = 8, -- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³å¯èƒ½è·é›¢ï¼ˆã‚¹ã‚¿ãƒƒãƒ‰ï¼‰

				-- å®ç®±å›ºæœ‰ã®æƒ…å ±
				chestId = "hokkaido_chest_05", -- ãƒ¦ãƒ‹ãƒ¼ã‚¯ID
				openedModel = "box_opened", -- é–‹ã„ãŸçŠ¶æ…‹ã®ãƒ¢ãƒ‡ãƒ«å
				rewards = {
					{ item = "ã‚´ãƒ¼ãƒ«ãƒ‰", count = 50 },
				},
				displayDuration = 3, -- å ±é…¬è¡¨ç¤ºæ™‚é–“ï¼ˆç§’ï¼‰
			},
		},
		{
			model = "box_closed",
			position = { 3140.0, 234.3, -140.9 },
			mode = "ground",
			size = 1,
			rotation = { 0, 0, 0 },
			stickToGround = false, -- çœç•¥å¯ï¼ˆtrueãŒæ—¢å®šï¼‰
			groundOffset = 0, -- èŠç”Ÿã§å°‘ã—æµ®ã‹ã›ãŸã„æ™‚
			alignToSlope = false, -- æ–œé¢ã«æœ¨ã‚’å‚¾ã‘ãŸããªã„ãªã‚‰false

			interaction = {
				type = "chest", -- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—
				action = "é–‹ã‘ã‚‹", -- ãƒœã‚¿ãƒ³ã«è¡¨ç¤ºã•ã‚Œã‚‹ãƒ†ã‚­ã‚¹ãƒˆ
				key = "E", -- ã‚­ãƒ¼ãƒã‚¤ãƒ³ãƒ‰
				range = 8, -- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³å¯èƒ½è·é›¢ï¼ˆã‚¹ã‚¿ãƒƒãƒ‰ï¼‰

				-- å®ç®±å›ºæœ‰ã®æƒ…å ±
				chestId = "hokkaido_chest_05", -- ãƒ¦ãƒ‹ãƒ¼ã‚¯ID
				openedModel = "box_opened", -- é–‹ã„ãŸçŠ¶æ…‹ã®ãƒ¢ãƒ‡ãƒ«å
				rewards = {
					{ item = "ã‚´ãƒ¼ãƒ«ãƒ‰", count = 500000 },
				},
				displayDuration = 3, -- å ±é…¬è¡¨ç¤ºæ™‚é–“ï¼ˆç§’ï¼‰
			},
		},
	},

	BGM = "rbxassetid://115666507179769", -- å¾Œã§ã‚¢ã‚»ãƒƒãƒˆIDã«å¤‰æ›´
	BGMVolume = 0.2, -- éŸ³é‡ï¼ˆ0.0-1.0ï¼‰
}

===== ./ReplicatedStorage/Continents/ContinentShikoku.lua =====
-- ===== ./ReplicatedStorage/Continents/ContinentShikoku.lua (æ–°è¦) =====
return {
	name = "ContinentShikoku",
	displayName = "Shikoku Region",

	islands = {
		"Shikoku_N1", "Shikoku_C1", "Shikoku_S1",
		"Shikoku_E1", "Shikoku_W1",
	},

	bridges = {},

	portals = {
		{
			name = "Shikoku_to_Town",
			toZone = "ContinentTown",
			islandName = "Shikoku_C1", -- ä¸­å¤®ã®å³¶ã‹ã‚‰ãƒãƒ¼ã‚¿ãƒ«
			offsetX = 0,
			offsetZ = 0,
			label = "â†’ Town",
			color = Color3.fromRGB(150, 255, 150), -- ç·‘è‰²ã®ãƒãƒ¼ã‚¿ãƒ«
		}
	},

	BGM = "rbxassetid://139951867631287", -- å¾Œã§ã‚¢ã‚»ãƒƒãƒˆIDã«å¤‰æ›´
	BGMVolume = 0.3,
}
===== ./ReplicatedStorage/Continents/ContinentArena.lua =====
return {
	name = "ContinentArena",
	displayName = "Arena",

	islands = {
		"Arena_01",
		"Arena_02",
	},

	bridges = {},

	paths = {},

	-- â˜…ä¿®æ­£: åŒ—æµ·é“ã€å››å›½ã€ä¹å·ã¸ã®ãƒãƒ¼ã‚¿ãƒ«ã‚’è¿½åŠ 
	fieldObjects = {
		{
			model = "PortalBack",
			position = { 10008.8, 156.0, 1.1 },
			mode = "ground",
			size = 1,
			rotation = { 0, 0, 0 },
			stickToGround = false,
		},
	},

	fieldObjects = {},

	BGM = "rbxassetid://139951867631287", -- å¾Œã§ã‚¢ã‚»ãƒƒãƒˆIDã«å¤‰æ›´
	BGMVolume = 0.2,
}

===== ./ReplicatedStorage/Continents/ContinentKyushu.lua =====
--- Continents ---
return {
	name = "ContinentKyushu",
	displayName = "ContinentKyushu",
	islands = {
		"ContinentKyushu_C1",
		"ContinentKyushu_C2",
		"ContinentKyushu_C3",
		"ContinentKyushu_C4",
		"ContinentKyushu_C5",
		"ContinentKyushu_C6",
		"ContinentKyushu_C7",
		"ContinentKyushu_C8",
		"ContinentKyushu_C9",
		"ContinentKyushu_C10",
		"ContinentKyushu_C11",
		"ContinentKyushu_C12",
		"ContinentKyushu_C13",
		"ContinentKyushu_C14",
		"ContinentKyushu_C15",
		"ContinentKyushu_C16",
		"ContinentKyushu_C17",
		"ContinentKyushu_C18",
		"ContinentKyushu_C19",
		"ContinentKyushu_C20",
		"ContinentKyushu_C21",
		"ContinentKyushu_C22",
		"ContinentKyushu_C23",
		"ContinentKyushu_C24",
	},
	paths = {
		points = {
			{ 2900.0, 27.9, -520.0 },
			{ 2905.2, 24.3, -476.6 },
			{ 2913.0, 29.8, -411.3 },
			{ 2941.8, 35.9, -358.1 },
			{ 2947.1, 27.6, -297.2 },
			{ 2977.9, 26.4, -189.7 },
			{ 3017.4, 27.1, -164.7 },
			{ 3067.9, 26.6, -146.5 },
			{ 3114.1, 21.4, -114.5 },
			{ 3142.8, 19.0, -84.7 },
			{ 3176.9, 24.6, -54.0 },
			{ 3206.0, 30.2, -12.3 },
			{ 3241.6, 27.1, 26.9 },
			{ 3281.9, 20.9, 49.9 },
			{ 3354.5, 22.2, 61.4 },
		},
		width = 24, -- é“ã®å¹…ï¼ˆstudï¼‰
		method = "terrain", -- "terrain"ï¼ˆåœ°å½¢ã‚’å¡—ã‚‹ï¼‰ or "parts"ï¼ˆãƒ‘ãƒ¼ãƒ„æ•·ãï¼‰
		material = Enum.Material.Ground, -- method="terrain"æ™‚ã®å¡—ã‚Šæè³ª
		step = 3, -- ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°é–“éš”ï¼ˆå°ã•ã„ã»ã©æ»‘ã‚‰ã‹ï¼†é‡ã„ï¼‰
		alignToSlope = false, -- æ–œé¢ã«é“é¢ã‚’å‚¾ã‘ã‚‹ã‹ï¼ˆè¦‹ãŸç›®ï¼štrueã€æ­©ãã‚„ã™ã•ï¼šfalseï¼‰
		groundOffset = 4.8, -- ã‚ã‚Šè¾¼ã¿å›é¿ã®å¾®å°ã‚ªãƒ•ã‚»ãƒƒãƒˆ
	},

	--93080.8, 38.0, 166.2
	portals = {
		{
			name = "Kyushu_to_Town",
			toZone = "ContinentTown",
			islandName = "ContinentKyushu_C20",
			offsetX = 100,
			offsetZ = 100,
			label = "â†’ Town",
			color = Color3.fromRGB(255, 255, 255),
		},
		{
			name = "Kyushu_to_Town",
			toZone = "Hokkaido_SW2",
			islandName = "ContinentKyushu_C22",
			offsetX = 100,
			offsetZ = 100,
			label = "â†’ Hokkaido",
			color = Color3.fromRGB(255, 255, 255),
		},
	},

	fieldObjects = {
		{
			model = "box_closed",
			position = { 2895.2, 46.2, -205.6 },
			mode = "ground",
			size = 1,
			rotation = { 0, -90, 0 },
			stickToGround = false, -- çœç•¥å¯ï¼ˆtrueãŒæ—¢å®šï¼‰
			groundOffset = 0, -- èŠç”Ÿã§å°‘ã—æµ®ã‹ã›ãŸã„æ™‚
			alignToSlope = false, -- æ–œé¢ã«æœ¨ã‚’å‚¾ã‘ãŸããªã„ãªã‚‰false

			interaction = {
				type = "chest", -- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—
				action = "é–‹ã‘ã‚‹", -- ãƒœã‚¿ãƒ³ã«è¡¨ç¤ºã•ã‚Œã‚‹ãƒ†ã‚­ã‚¹ãƒˆ
				key = "E", -- ã‚­ãƒ¼ãƒã‚¤ãƒ³ãƒ‰
				range = 18, -- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³å¯èƒ½è·é›¢ï¼ˆã‚¹ã‚¿ãƒƒãƒ‰ï¼‰

				-- å®ç®±å›ºæœ‰ã®æƒ…å ±
				chestId = "kyushu_chest_01", -- ãƒ¦ãƒ‹ãƒ¼ã‚¯ID
				openedModel = "box_opened", -- é–‹ã„ãŸçŠ¶æ…‹ã®ãƒ¢ãƒ‡ãƒ«å
				rewards = {
					{ item = "ãƒãƒ¼ã‚·ãƒ§ãƒ³", count = 1 },
				},
				displayDuration = 2, -- å ±é…¬è¡¨ç¤ºæ™‚é–“ï¼ˆç§’ï¼‰
			},
		},
	},

	BGM = "",
	BGMVolume = 0.2,
}

===== ./ReplicatedStorage/Continents/ContientTown.lua =====
-- ===== ./ReplicatedStorage/Continents/ContientTown.lua =====
return {
	name = "ContinentTown",
	displayName = "Start Town",

	islands = {
		"StartTown",
		"Town_NE",
		"Town_SW",
		"Town_SE",
	},

	bridges = {},

	paths = {
		points = {
			{ 3069.8, 17.0, -54.5 },
			{ 3126.1, 22.5, -9.5 },
			{ 3153.8, 24.5, 5.8 },
			{ 3174.6, 19.9, 34.8 },
			{ 3209.4, 16.1, 60.0 },
			{ 3228.9, 16.2, 87.7 },
			{ 3244.1, 16.1, 111.2 },
		},
		width = 24, -- é“ã®å¹…ï¼ˆstudï¼‰
		method = "terrain", -- "terrain"ï¼ˆåœ°å½¢ã‚’å¡—ã‚‹ï¼‰ or "parts"ï¼ˆãƒ‘ãƒ¼ãƒ„æ•·ãï¼‰
		material = Enum.Material.Ground, -- method="terrain"æ™‚ã®å¡—ã‚Šæè³ª
		step = 3, -- ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°é–“éš”ï¼ˆå°ã•ã„ã»ã©æ»‘ã‚‰ã‹ï¼†é‡ã„ï¼‰
		alignToSlope = false, -- æ–œé¢ã«é“é¢ã‚’å‚¾ã‘ã‚‹ã‹ï¼ˆè¦‹ãŸç›®ï¼štrueã€æ­©ãã‚„ã™ã•ï¼šfalseï¼‰
		groundOffset = 4.8, -- ã‚ã‚Šè¾¼ã¿å›é¿ã®å¾®å°ã‚ªãƒ•ã‚»ãƒƒãƒˆ
	},

	-- â˜…ä¿®æ­£: åŒ—æµ·é“ã€å››å›½ã€ä¹å·ã¸ã®ãƒãƒ¼ã‚¿ãƒ«ã‚’è¿½åŠ 
	portals = {
		{
			name = "Town_to_Hokkaido",
			toZone = "ContinentHokkaido",
			islandName = "StartTown",
			offsetX = 0,
			offsetZ = -50,
			size = Vector3.new(8, 12, 8),
			color = Color3.fromRGB(200, 200, 255),
			label = "â†’ Hokkaido",
		},
		{
			name = "Town_to_Shikoku", -- â˜…æ–°è¦ãƒãƒ¼ã‚¿ãƒ«
			toZone = "ContinentShikoku",
			islandName = "Town_NE",
			offsetX = 0,
			offsetZ = 0,
			size = Vector3.new(8, 12, 8),
			color = Color3.fromRGB(150, 255, 150),
			label = "â†’ Shikoku",
		},
		{
			name = "Town_to_Kyushu", -- â˜…æ–°è¦ãƒãƒ¼ã‚¿ãƒ«
			toZone = "ContinentKyushu",
			islandName = "Town_SE",
			offsetX = 0,
			offsetZ = 0,
			size = Vector3.new(8, 12, 8),
			color = Color3.fromRGB(255, 100, 100),
			label = "â†’ Kyushu",
		},
	},

	fieldObjects = {
		{
			model = "Chest",
			position = { 55, 78, -5.8 },
			mode = "ground",
			size = 1.5,
			rotation = { 0, 0, 0 },
			groundOffset = 0, -- èŠç”Ÿã§å°‘ã—æµ®ã‹ã›ãŸã„æ™‚
			alignToSlope = true, -- æ–œé¢ã«æœ¨ã‚’å‚¾ã‘ãŸããªã„ãªã‚‰false
		},
		{
			model = "koki3D",
			position = { 58.7, 78, -5.8 },
			mode = "ground",
			size = 1,
			rotation = { 0, 0, 0 },
			stickToGround = false, -- çœç•¥å¯ï¼ˆtrueãŒæ—¢å®šï¼‰
			groundOffset = 0, -- èŠç”Ÿã§å°‘ã—æµ®ã‹ã›ãŸã„æ™‚
			alignToSlope = true, -- æ–œé¢ã«æœ¨ã‚’å‚¾ã‘ãŸããªã„ãªã‚‰false
		},

		{
			model = "koki3D",
			position = { 26.1, 57.6, -9.5 },
			mode = "ground",
			size = 0.2,
			rotation = { 0, 0, 0 },
			stickToGround = false, -- çœç•¥å¯ï¼ˆtrueãŒæ—¢å®šï¼‰
			groundOffset = 0, -- èŠç”Ÿã§å°‘ã—æµ®ã‹ã›ãŸã„æ™‚
			alignToSlope = true, -- æ–œé¢ã«æœ¨ã‚’å‚¾ã‘ãŸããªã„ãªã‚‰false
		},

		{
			model = "muichiro",
			position = { 23.2, 57.5, -15.2 },
			mode = "fixed",
			size = 0.2,
			rotation = { 0, 0, 0 },
			stickToGround = false, -- çœç•¥å¯ï¼ˆtrueãŒæ—¢å®šï¼‰
			groundOffset = 10, -- èŠç”Ÿã§å°‘ã—æµ®ã‹ã›ãŸã„æ™‚
			alignToSlope = true, -- æ–œé¢ã«æœ¨ã‚’å‚¾ã‘ãŸããªã„ãªã‚‰false
			-- upAxis = "",
		}, --

		{
			model = "box_closed",
			position = { 42.4, 56.5, 10.9 },
			mode = "ground",
			size = 1,
			rotation = { 0, 0, 0 },
			stickToGround = false, -- çœç•¥å¯ï¼ˆtrueãŒæ—¢å®šï¼‰
			groundOffset = 0, -- èŠç”Ÿã§å°‘ã—æµ®ã‹ã›ãŸã„æ™‚
			alignToSlope = false, -- æ–œé¢ã«æœ¨ã‚’å‚¾ã‘ãŸããªã„ãªã‚‰false

			interaction = {
				type = "chest", -- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—
				action = "é–‹ã‘ã‚‹", -- ãƒœã‚¿ãƒ³ã«è¡¨ç¤ºã•ã‚Œã‚‹ãƒ†ã‚­ã‚¹ãƒˆ
				key = "E", -- ã‚­ãƒ¼ãƒã‚¤ãƒ³ãƒ‰
				range = 8, -- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³å¯èƒ½è·é›¢ï¼ˆã‚¹ã‚¿ãƒƒãƒ‰ï¼‰

				-- å®ç®±å›ºæœ‰ã®æƒ…å ±
				chestId = "town_chest_01", -- ãƒ¦ãƒ‹ãƒ¼ã‚¯ID
				openedModel = "box_opened", -- é–‹ã„ãŸçŠ¶æ…‹ã®ãƒ¢ãƒ‡ãƒ«å
				rewards = {
					{ item = "ãƒãƒ¼ã‚·ãƒ§ãƒ³", count = 3 },
					{ item = "ã‚´ãƒ¼ãƒ«ãƒ‰", count = 50 },
				},
				displayDuration = 3, -- å ±é…¬è¡¨ç¤ºæ™‚é–“ï¼ˆç§’ï¼‰
			},
		},

		{
			model = "box_closed",
			position = { 42.4, 56.5, 20.9 },
			mode = "ground",
			size = 1,
			rotation = { 0, 0, 0 },
			stickToGround = false, -- çœç•¥å¯ï¼ˆtrueãŒæ—¢å®šï¼‰
			groundOffset = 0, -- èŠç”Ÿã§å°‘ã—æµ®ã‹ã›ãŸã„æ™‚
			alignToSlope = false, -- æ–œé¢ã«æœ¨ã‚’å‚¾ã‘ãŸããªã„ãªã‚‰false

			interaction = {
				type = "chest", -- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—
				action = "é–‹ã‘ã‚‹", -- ãƒœã‚¿ãƒ³ã«è¡¨ç¤ºã•ã‚Œã‚‹ãƒ†ã‚­ã‚¹ãƒˆ
				key = "E", -- ã‚­ãƒ¼ãƒã‚¤ãƒ³ãƒ‰
				range = 8, -- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³å¯èƒ½è·é›¢ï¼ˆã‚¹ã‚¿ãƒƒãƒ‰ï¼‰

				-- å®ç®±å›ºæœ‰ã®æƒ…å ±
				chestId = "town_chest_02", -- ãƒ¦ãƒ‹ãƒ¼ã‚¯ID
				openedModel = "box_opened", -- é–‹ã„ãŸçŠ¶æ…‹ã®ãƒ¢ãƒ‡ãƒ«å
				rewards = {
					{ item = "ãƒãƒ¼ã‚·ãƒ§ãƒ³", count = 1 },
					{ item = "ã‚´ãƒ¼ãƒ«ãƒ‰", count = 25 },
				},
				displayDuration = 3, -- å ±é…¬è¡¨ç¤ºæ™‚é–“ï¼ˆç§’ï¼‰
			},
		},

		{
			model = "ModernHouse",
			position = { 92.4, 56.5, 30.9 },
			mode = "ground",
			size = 1,
			rotation = { 0, -45, 45 },
			-- rotation = { 0, 0, 0 },
			stickToGround = false, -- çœç•¥å¯ï¼ˆtrueãŒæ—¢å®šï¼‰
			groundOffset = 0, -- èŠç”Ÿã§å°‘ã—æµ®ã‹ã›ãŸã„æ™‚
			alignToSlope = false, -- æ–œé¢ã«æœ¨ã‚’å‚¾ã‘ãŸããªã„ãªã‚‰false
		},

		{
			model = "golem",
			position = { 31.9, 56.5, 10.9 },
			mode = "ground",
			size = 0.1,
			rotation = { 0, 0, 0 },
			stickToGround = false, -- çœç•¥å¯ï¼ˆtrueãŒæ—¢å®šï¼‰
			alignToSlope = false, -- æ–œé¢ã«æœ¨ã‚’å‚¾ã‘ãŸããªã„ãªã‚‰false
		},
	},
	--m

	BGM = "rbxassetid://139951867631287", -- å¾Œã§ã‚¢ã‚»ãƒƒãƒˆIDã«å¤‰æ›´
	BGMVolume = 0.2,
}

===== ./ReplicatedStorage/Continents/ContinentTown.lua =====
-- ===== ./ReplicatedStorage/Continents/ContinentTown.lua =====
return {
	name = "ContinentTown",
	displayName = "Start Town",

	islands = {
		"StartTown",
		"Town_NE",
		"Town_SW",
		"Town_SE",
	},

	bridges = {},

	paths = {
		points = {
			{ 3069.8, 17.0, -54.5 },
			{ 3126.1, 22.5, -9.5 },
			{ 3153.8, 24.5, 5.8 },
			{ 3174.6, 19.9, 34.8 },
			{ 3209.4, 16.1, 60.0 },
			{ 3228.9, 16.2, 87.7 },
			{ 3244.1, 16.1, 111.2 },
		},
		width = 24, -- é“ã®å¹…ï¼ˆstudï¼‰
		method = "terrain", -- "terrain"ï¼ˆåœ°å½¢ã‚’å¡—ã‚‹ï¼‰ or "parts"ï¼ˆãƒ‘ãƒ¼ãƒ„æ•·ãï¼‰
		material = Enum.Material.Ground, -- method="terrain"æ™‚ã®å¡—ã‚Šæè³ª
		step = 3, -- ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°é–“éš”ï¼ˆå°ã•ã„ã»ã©æ»‘ã‚‰ã‹ï¼†é‡ã„ï¼‰
		alignToSlope = false, -- æ–œé¢ã«é“é¢ã‚’å‚¾ã‘ã‚‹ã‹ï¼ˆè¦‹ãŸç›®ï¼štrueã€æ­©ãã‚„ã™ã•ï¼šfalseï¼‰
		groundOffset = 4.8, -- ã‚ã‚Šè¾¼ã¿å›é¿ã®å¾®å°ã‚ªãƒ•ã‚»ãƒƒãƒˆ
	},

	-- â˜…ä¿®æ­£: åŒ—æµ·é“ã€å››å›½ã€ä¹å·ã¸ã®ãƒãƒ¼ã‚¿ãƒ«ã‚’è¿½åŠ 
	portals = {
		{
			name = "Town_to_Hokkaido",
			toZone = "ContinentHokkaido",
			islandName = "StartTown",
			offsetX = 0,
			offsetZ = -50,
			size = Vector3.new(8, 12, 8),
			color = Color3.fromRGB(200, 200, 255),
			label = "â†’ Hokkaido",
		},
		{
			name = "Town_to_Shikoku", -- â˜…æ–°è¦ãƒãƒ¼ã‚¿ãƒ«
			toZone = "ContinentShikoku",
			islandName = "Town_NE",
			offsetX = 0,
			offsetZ = 0,
			size = Vector3.new(8, 12, 8),
			color = Color3.fromRGB(150, 255, 150),
			label = "â†’ Shikoku",
		},
		{
			name = "Town_to_Kyushu", -- â˜…æ–°è¦ãƒãƒ¼ã‚¿ãƒ«
			toZone = "ContinentKyushu",
			islandName = "Town_SE",
			offsetX = 0,
			offsetZ = 0,
			size = Vector3.new(8, 12, 8),
			color = Color3.fromRGB(255, 100, 100),
			label = "â†’ Kyushu",
		},
	},

	fieldObjects = {
		{
			model = "Chest",
			position = { 55, 78, -5.8 },
			mode = "ground",
			size = 1.5,
			rotation = { 0, 0, 0 },
			groundOffset = 0, -- èŠç”Ÿã§å°‘ã—æµ®ã‹ã›ãŸã„æ™‚
			alignToSlope = true, -- æ–œé¢ã«æœ¨ã‚’å‚¾ã‘ãŸããªã„ãªã‚‰false
		},
		{
			model = "koki3D",
			position = { 58.7, 78, -5.8 },
			mode = "ground",
			size = 1,
			rotation = { 0, 0, 0 },
			stickToGround = false, -- çœç•¥å¯ï¼ˆtrueãŒæ—¢å®šï¼‰
			groundOffset = 0, -- èŠç”Ÿã§å°‘ã—æµ®ã‹ã›ãŸã„æ™‚
			alignToSlope = true, -- æ–œé¢ã«æœ¨ã‚’å‚¾ã‘ãŸããªã„ãªã‚‰false
		},

		{
			model = "koki3D",
			position = { 26.1, 57.6, -9.5 },
			mode = "ground",
			size = 0.2,
			rotation = { 0, 0, 0 },
			stickToGround = false, -- çœç•¥å¯ï¼ˆtrueãŒæ—¢å®šï¼‰
			groundOffset = 0, -- èŠç”Ÿã§å°‘ã—æµ®ã‹ã›ãŸã„æ™‚
			alignToSlope = true, -- æ–œé¢ã«æœ¨ã‚’å‚¾ã‘ãŸããªã„ãªã‚‰false
		},

		{
			model = "muichiro",
			position = { 23.2, 57.5, -15.2 },
			mode = "fixed",
			size = 0.2,
			rotation = { 0, 0, 0 },
			stickToGround = false, -- çœç•¥å¯ï¼ˆtrueãŒæ—¢å®šï¼‰
			groundOffset = 10, -- èŠç”Ÿã§å°‘ã—æµ®ã‹ã›ãŸã„æ™‚
			alignToSlope = true, -- æ–œé¢ã«æœ¨ã‚’å‚¾ã‘ãŸããªã„ãªã‚‰false
			-- upAxis = "",
		}, --

		{
			model = "box_closed",
			position = { 42.4, 56.5, 10.9 },
			mode = "ground",
			size = 1,
			rotation = { 0, 0, 0 },
			stickToGround = false, -- çœç•¥å¯ï¼ˆtrueãŒæ—¢å®šï¼‰
			groundOffset = 0, -- èŠç”Ÿã§å°‘ã—æµ®ã‹ã›ãŸã„æ™‚
			alignToSlope = false, -- æ–œé¢ã«æœ¨ã‚’å‚¾ã‘ãŸããªã„ãªã‚‰false

			interaction = {
				type = "chest", -- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—
				action = "é–‹ã‘ã‚‹", -- ãƒœã‚¿ãƒ³ã«è¡¨ç¤ºã•ã‚Œã‚‹ãƒ†ã‚­ã‚¹ãƒˆ
				key = "E", -- ã‚­ãƒ¼ãƒã‚¤ãƒ³ãƒ‰
				range = 8, -- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³å¯èƒ½è·é›¢ï¼ˆã‚¹ã‚¿ãƒƒãƒ‰ï¼‰

				-- å®ç®±å›ºæœ‰ã®æƒ…å ±
				chestId = "town_chest_01", -- ãƒ¦ãƒ‹ãƒ¼ã‚¯ID
				openedModel = "box_opened", -- é–‹ã„ãŸçŠ¶æ…‹ã®ãƒ¢ãƒ‡ãƒ«å
				rewards = {
					{ item = "ãƒãƒ¼ã‚·ãƒ§ãƒ³", count = 3 },
					{ item = "ã‚´ãƒ¼ãƒ«ãƒ‰", count = 50 },
				},
				displayDuration = 3, -- å ±é…¬è¡¨ç¤ºæ™‚é–“ï¼ˆç§’ï¼‰
			},
		},

		{
			model = "box_closed",
			position = { 42.4, 56.5, 20.9 },
			mode = "ground",
			size = 1,
			rotation = { 0, 0, 0 },
			stickToGround = false, -- çœç•¥å¯ï¼ˆtrueãŒæ—¢å®šï¼‰
			groundOffset = 0, -- èŠç”Ÿã§å°‘ã—æµ®ã‹ã›ãŸã„æ™‚
			alignToSlope = false, -- æ–œé¢ã«æœ¨ã‚’å‚¾ã‘ãŸããªã„ãªã‚‰false

			interaction = {
				type = "chest", -- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—
				action = "é–‹ã‘ã‚‹", -- ãƒœã‚¿ãƒ³ã«è¡¨ç¤ºã•ã‚Œã‚‹ãƒ†ã‚­ã‚¹ãƒˆ
				key = "E", -- ã‚­ãƒ¼ãƒã‚¤ãƒ³ãƒ‰
				range = 8, -- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³å¯èƒ½è·é›¢ï¼ˆã‚¹ã‚¿ãƒƒãƒ‰ï¼‰

				-- å®ç®±å›ºæœ‰ã®æƒ…å ±
				chestId = "town_chest_02", -- ãƒ¦ãƒ‹ãƒ¼ã‚¯ID
				openedModel = "box_opened", -- é–‹ã„ãŸçŠ¶æ…‹ã®ãƒ¢ãƒ‡ãƒ«å
				rewards = {
					{ item = "ãƒãƒ¼ã‚·ãƒ§ãƒ³", count = 1 },
					{ item = "ã‚´ãƒ¼ãƒ«ãƒ‰", count = 25 },
				},
				displayDuration = 3, -- å ±é…¬è¡¨ç¤ºæ™‚é–“ï¼ˆç§’ï¼‰
			},
		},

		{
			model = "PortalToArena",
			position = { 92.4, 56.5, 30.9 },
			mode = "ground",
			size = 1,
			rotation = { 0, -45, 45 },
			stickToGround = false, -- çœç•¥å¯ï¼ˆtrueãŒæ—¢å®šï¼‰
			groundOffset = 0, -- èŠç”Ÿã§å°‘ã—æµ®ã‹ã›ãŸã„æ™‚
			alignToSlope = false, -- æ–œé¢ã«æœ¨ã‚’å‚¾ã‘ãŸããªã„ãªã‚‰false
		},

		{
			model = "golem",
			position = { 31.9, 56.5, 10.9 },
			mode = "ground",
			size = 0.1,
			rotation = { 0, 0, 0 },
			stickToGround = false, -- çœç•¥å¯ï¼ˆtrueãŒæ—¢å®šï¼‰
			alignToSlope = false, -- æ–œé¢ã«æœ¨ã‚’å‚¾ã‘ãŸããªã„ãªã‚‰false
		},
	},
	--m

	BGM = "rbxassetid://139951867631287", -- å¾Œã§ã‚¢ã‚»ãƒƒãƒˆIDã«å¤‰æ›´
	BGMVolume = 0.2,
}

===== ./ReplicatedStorage/Islands/BananaLand.lua =====
return {
	{
		name = "Banana_C1",
		centerX = 9858.5,
		centerZ = -17.0,
		sizeXZ = 118.9,
		baseY = 20,
		thickness = 40,
		grid = 2,
		hillAmplitude = 1,
		hillScale = 1,
		seed = 1,
		generateOcean = true,
		baseMaterial = Enum.Material.Grass,
	},
	{
		name = "Banana_C2",
		centerX = 9863.5,
		centerZ = 21.0,
		sizeXZ = 105.3,
		baseY = 20,
		thickness = 40,
		grid = 2,
		hillAmplitude = 1,
		hillScale = 1,
		seed = 1,
		generateOcean = false,
		baseMaterial = Enum.Material.Grass,
	},
	{
		name = "Banana_C3",
		centerX = 9914.5,
		centerZ = 72.0,
		sizeXZ = 104.4,
		baseY = 20,
		thickness = 40,
		grid = 2,
		hillAmplitude = 1,
		hillScale = 1,
		seed = 1,
		generateOcean = false,
		baseMaterial = Enum.Material.Grass,
	},
	{
		name = "Banana_C4",
		centerX = 9909.5,
		centerZ = 78.0,
		sizeXZ = 99.9,
		baseY = 20,
		thickness = 40,
		grid = 2,
		hillAmplitude = 1,
		hillScale = 1,
		seed = 1,
		generateOcean = false,
		baseMaterial = Enum.Material.Grass,
	},
	{
		name = "Banana_C5",
		centerX = 9900.5,
		centerZ = 37.0,
		sizeXZ = 96.4,
		baseY = 20,
		thickness = 40,
		grid = 2,
		hillAmplitude = 1,
		hillScale = 1,
		seed = 1,
		generateOcean = false,
		baseMaterial = Enum.Material.Grass,
	},
	{
		name = "Banana_C6",
		centerX = 9940.5,
		centerZ = 109.0,
		sizeXZ = 87.7,
		baseY = 20,
		thickness = 40,
		grid = 2,
		hillAmplitude = 1,
		hillScale = 1,
		seed = 1,
		generateOcean = false,
		baseMaterial = Enum.Material.Grass,
	},
	{
		name = "Banana_C7",
		centerX = 9896.5,
		centerZ = 37.0,
		sizeXZ = 82.3,
		baseY = 20,
		thickness = 40,
		grid = 2,
		hillAmplitude = 1,
		hillScale = 1,
		seed = 1,
		generateOcean = false,
		baseMaterial = Enum.Material.Grass,
	},
	{
		name = "Banana_C8",
		centerX = 9932.5,
		centerZ = 100.0,
		sizeXZ = 81.4,
		baseY = 20,
		thickness = 40,
		grid = 2,
		hillAmplitude = 1,
		hillScale = 1,
		seed = 1,
		generateOcean = false,
		baseMaterial = Enum.Material.Grass,
	},
	{
		name = "Banana_C9",
		centerX = 9934.5,
		centerZ = 109.0,
		sizeXZ = 79.4,
		baseY = 20,
		thickness = 40,
		grid = 2,
		hillAmplitude = 1,
		hillScale = 1,
		seed = 1,
		generateOcean = false,
		baseMaterial = Enum.Material.Grass,
	},
	{
		name = "Banana_C10",
		centerX = 9896.5,
		centerZ = 15.0,
		sizeXZ = 76.4,
		baseY = 20,
		thickness = 40,
		grid = 2,
		hillAmplitude = 1,
		hillScale = 1,
		seed = 1,
		generateOcean = false,
		baseMaterial = Enum.Material.Grass,
	},
	{
		name = "Banana_C11",
		centerX = 9922.5,
		centerZ = 95.0,
		sizeXZ = 75.1,
		baseY = 20,
		thickness = 40,
		grid = 2,
		hillAmplitude = 1,
		hillScale = 1,
		seed = 1,
		generateOcean = false,
		baseMaterial = Enum.Material.Grass,
	},
	{
		name = "Banana_C12",
		centerX = 9889.5,
		centerZ = -9.0,
		sizeXZ = 74.0,
		baseY = 20,
		thickness = 40,
		grid = 2,
		hillAmplitude = 1,
		hillScale = 1,
		seed = 1,
		generateOcean = false,
		baseMaterial = Enum.Material.Grass,
	},
	{
		name = "Banana_C13",
		centerX = 9909.5,
		centerZ = 14.0,
		sizeXZ = 73.1,
		baseY = 20,
		thickness = 40,
		grid = 2,
		hillAmplitude = 1,
		hillScale = 1,
		seed = 1,
		generateOcean = false,
		baseMaterial = Enum.Material.Grass,
	},
	{
		name = "Banana_C14",
		centerX = 9943.5,
		centerZ = 112.0,
		sizeXZ = 72.3,
		baseY = 20,
		thickness = 40,
		grid = 2,
		hillAmplitude = 1,
		hillScale = 1,
		seed = 1,
		generateOcean = false,
		baseMaterial = Enum.Material.Grass,
	},
	{
		name = "Banana_C15",
		centerX = 9879.5,
		centerZ = -37.0,
		sizeXZ = 71.2,
		baseY = 20,
		thickness = 40,
		grid = 2,
		hillAmplitude = 1,
		hillScale = 1,
		seed = 1,
		generateOcean = false,
		baseMaterial = Enum.Material.Grass,
	},
	{
		name = "Banana_C16",
		centerX = 9948.5,
		centerZ = 101.0,
		sizeXZ = 70.9,
		baseY = 20,
		thickness = 40,
		grid = 2,
		hillAmplitude = 1,
		hillScale = 1,
		seed = 1,
		generateOcean = false,
		baseMaterial = Enum.Material.Grass,
	},
	{
		name = "Banana_C17",
		centerX = 9956.5,
		centerZ = 107.0,
		sizeXZ = 69.9,
		baseY = 20,
		thickness = 40,
		grid = 2,
		hillAmplitude = 1,
		hillScale = 1,
		seed = 1,
		generateOcean = false,
		baseMaterial = Enum.Material.Grass,
	},
	{
		name = "Banana_C18",
		centerX = 9983.5,
		centerZ = 124.0,
		sizeXZ = 65.4,
		baseY = 20,
		thickness = 40,
		grid = 2,
		hillAmplitude = 1,
		hillScale = 1,
		seed = 1,
		generateOcean = false,
		baseMaterial = Enum.Material.Grass,
	},
	{
		name = "Banana_C19",
		centerX = 9974.5,
		centerZ = 113.0,
		sizeXZ = 63.0,
		baseY = 20,
		thickness = 40,
		grid = 2,
		hillAmplitude = 1,
		hillScale = 1,
		seed = 1,
		generateOcean = false,
		baseMaterial = Enum.Material.Grass,
	},
	{
		name = "Banana_C20",
		centerX = 9999.5,
		centerZ = 127.0,
		sizeXZ = 60.0,
		baseY = 20,
		thickness = 40,
		grid = 2,
		hillAmplitude = 1,
		hillScale = 1,
		seed = 1,
		generateOcean = false,
		baseMaterial = Enum.Material.Grass,
	},
	{
		name = "Banana_C21",
		centerX = 9968.5,
		centerZ = 112.0,
		sizeXZ = 59.7,
		baseY = 20,
		thickness = 40,
		grid = 2,
		hillAmplitude = 1,
		hillScale = 1,
		seed = 1,
		generateOcean = false,
		baseMaterial = Enum.Material.Grass,
	},
	{
		name = "Banana_C22",
		centerX = 9990.5,
		centerZ = 126.0,
		sizeXZ = 59.1,
		baseY = 20,
		thickness = 40,
		grid = 2,
		hillAmplitude = 1,
		hillScale = 1,
		seed = 1,
		generateOcean = false,
		baseMaterial = Enum.Material.Grass,
	},
	{
		name = "Banana_C23",
		centerX = 10017.5,
		centerZ = 127.0,
		sizeXZ = 55.7,
		baseY = 20,
		thickness = 40,
		grid = 2,
		hillAmplitude = 1,
		hillScale = 1,
		seed = 1,
		generateOcean = false,
		baseMaterial = Enum.Material.Grass,
	},
	{
		name = "Banana_C24",
		centerX = 9966.5,
		centerZ = 93.0,
		sizeXZ = 55.7,
		baseY = 20,
		thickness = 40,
		grid = 2,
		hillAmplitude = 1,
		hillScale = 1,
		seed = 1,
		generateOcean = false,
		baseMaterial = Enum.Material.Grass,
	},
	{
		name = "Banana_C25",
		centerX = 10052.5,
		centerZ = 122.0,
		sizeXZ = 54.8,
		baseY = 20,
		thickness = 40,
		grid = 2,
		hillAmplitude = 1,
		hillScale = 1,
		seed = 1,
		generateOcean = false,
		baseMaterial = Enum.Material.Grass,
	},
	{
		name = "Banana_C26",
		centerX = 10046.5,
		centerZ = 116.0,
		sizeXZ = 53.2,
		baseY = 20,
		thickness = 40,
		grid = 2,
		hillAmplitude = 1,
		hillScale = 1,
		seed = 1,
		generateOcean = false,
		baseMaterial = Enum.Material.Grass,
	},
	{
		name = "Banana_C27",
		centerX = 10087.5,
		centerZ = 100.0,
		sizeXZ = 52.4,
		baseY = 20,
		thickness = 40,
		grid = 2,
		hillAmplitude = 1,
		hillScale = 1,
		seed = 1,
		generateOcean = false,
		baseMaterial = Enum.Material.Grass,
	},
	{
		name = "Banana_C28",
		centerX = 10065.5,
		centerZ = 110.0,
		sizeXZ = 51.9,
		baseY = 20,
		thickness = 40,
		grid = 2,
		hillAmplitude = 1,
		hillScale = 1,
		seed = 1,
		generateOcean = false,
		baseMaterial = Enum.Material.Grass,
	},
	{
		name = "Banana_C29",
		centerX = 9950.5,
		centerZ = 73.0,
		sizeXZ = 51.4,
		baseY = 20,
		thickness = 40,
		grid = 2,
		hillAmplitude = 1,
		hillScale = 1,
		seed = 1,
		generateOcean = false,
		baseMaterial = Enum.Material.Grass,
	},
	{
		name = "Banana_C30",
		centerX = 9981.5,
		centerZ = 92.0,
		sizeXZ = 50.0,
		baseY = 20,
		thickness = 40,
		grid = 2,
		hillAmplitude = 1,
		hillScale = 1,
		seed = 1,
		generateOcean = false,
		baseMaterial = Enum.Material.Grass,
	},
	{
		name = "Banana_C31",
		centerX = 10094.5,
		centerZ = 82.0,
		sizeXZ = 49.5,
		baseY = 20,
		thickness = 40,
		grid = 2,
		hillAmplitude = 1,
		hillScale = 1,
		seed = 1,
		generateOcean = false,
		baseMaterial = Enum.Material.Grass,
	},
	{
		name = "Banana_C32",
		centerX = 10116.5,
		centerZ = 60.0,
		sizeXZ = 48.7,
		baseY = 20,
		thickness = 40,
		grid = 2,
		hillAmplitude = 1,
		hillScale = 1,
		seed = 1,
		generateOcean = false,
		baseMaterial = Enum.Material.Grass,
	},
	{
		name = "Banana_C33",
		centerX = 9968.5,
		centerZ = 60.0,
		sizeXZ = 47.7,
		baseY = 20,
		thickness = 40,
		grid = 2,
		hillAmplitude = 1,
		hillScale = 1,
		seed = 1,
		generateOcean = false,
		baseMaterial = Enum.Material.Grass,
	},
	{
		name = "Banana_C34",
		centerX = 10132.5,
		centerZ = 33.0,
		sizeXZ = 46.4,
		baseY = 20,
		thickness = 40,
		grid = 2,
		hillAmplitude = 1,
		hillScale = 1,
		seed = 1,
		generateOcean = false,
		baseMaterial = Enum.Material.Grass,
	},
	{
		name = "Banana_C35",
		centerX = 9979.5,
		centerZ = 53.0,
		sizeXZ = 45.6,
		baseY = 20,
		thickness = 40,
		grid = 2,
		hillAmplitude = 10,
		hillScale = 120,
		seed = 1,
		generateOcean = false,
		baseMaterial = Enum.Material.Grass,
	},
	{
		name = "Banana_C36",
		centerX = 10147.5,
		centerZ = 9.0,
		sizeXZ = 44.8,
		baseY = 20,
		thickness = 40,
		grid = 2,
		hillAmplitude = 1,
		hillScale = 1,
		seed = 1,
		generateOcean = false,
		baseMaterial = Enum.Material.Grass,
	},
	{
		name = "Banana_C37",
		centerX = 10153.5,
		centerZ = -18.0,
		sizeXZ = 43.4,
		baseY = 20,
		thickness = 40,
		grid = 2,
		hillAmplitude = 1,
		hillScale = 1,
		seed = 1,
		generateOcean = false,
		baseMaterial = Enum.Material.Grass,
	},
	{
		name = "Banana_C38",
		centerX = 9993.5,
		centerZ = 49.0,
		sizeXZ = 42.4,
		baseY = 20,
		thickness = 40,
		grid = 2,
		hillAmplitude = 50,
		hillScale = 150,
		seed = 1,
		generateOcean = false,
		baseMaterial = Enum.Material.Grass,
	},
	{
		name = "Banana_C39",
		centerX = 9990.5,
		centerZ = 29.0,
		sizeXZ = 41.0,
		baseY = 20,
		thickness = 40,
		grid = 2,
		hillAmplitude = 80,
		hillScale = 150,
		seed = 1,
		generateOcean = false,
		baseMaterial = Enum.Material.Grass,
	},
	{
		name = "Banana_C40",
		centerX = 10154.5,
		centerZ = -45.0,
		sizeXZ = 39.3,
		baseY = 20,
		thickness = 40,
		grid = 2,
		hillAmplitude = 1,
		hillScale = 1,
		seed = 1,
		generateOcean = false,
		baseMaterial = Enum.Material.Grass,
	},
	{
		name = "Banana_C41",
		centerX = 10166.5,
		centerZ = -65.0,
		sizeXZ = 37.8,
		baseY = 20,
		thickness = 40,
		grid = 2,
		hillAmplitude = 1,
		hillScale = 1,
		seed = 1,
		generateOcean = false,
		baseMaterial = Enum.Material.Grass,
	},
	{
		name = "Banana_C42",
		centerX = 10176.5,
		centerZ = -87.0,
		sizeXZ = 35.9,
		baseY = 20,
		thickness = 40,
		grid = 2,
		hillAmplitude = 1,
		hillScale = 1,
		seed = 1,
		generateOcean = false,
		baseMaterial = Enum.Material.Grass,
	},
	{
		name = "Banana_C43",
		centerX = 10182.5,
		centerZ = -105.0,
		sizeXZ = 34.4,
		baseY = 20,
		thickness = 40,
		grid = 2,
		hillAmplitude = 1,
		hillScale = 1,
		seed = 1,
		generateOcean = false,
		baseMaterial = Enum.Material.Grass,
	},
	{
		name = "Banana_C44",
		centerX = 10187.5,
		centerZ = -124.0,
		sizeXZ = 31.4,
		baseY = 20,
		thickness = 40,
		grid = 2,
		hillAmplitude = 1,
		hillScale = 1,
		seed = 1,
		generateOcean = false,
		baseMaterial = Enum.Material.Grass,
	},
	{
		name = "Banana_C45",
		centerX = 10195.5,
		centerZ = -141.0,
		sizeXZ = 29.8,
		baseY = 20,
		thickness = 40,
		grid = 2,
		hillAmplitude = 1,
		hillScale = 1,
		seed = 1,
		generateOcean = false,
		baseMaterial = Enum.Material.Grass,
	},
	{
		name = "Banana_C46",
		centerX = 10203.5,
		centerZ = -156.0,
		sizeXZ = 27.8,
		baseY = 20,
		thickness = 40,
		grid = 2,
		hillAmplitude = 1,
		hillScale = 1,
		seed = 1,
		generateOcean = false,
		baseMaterial = Enum.Material.Grass,
	},
	{
		name = "Banana_C47",
		centerX = 10212.5,
		centerZ = -170.0,
		sizeXZ = 25.8,
		baseY = 20,
		thickness = 40,
		grid = 2,
		hillAmplitude = 1,
		hillScale = 1,
		seed = 1,
		generateOcean = false,
		baseMaterial = Enum.Material.Grass,
	},
	{
		name = "Banana_C48",
		centerX = 10220.5,
		centerZ = -182.0,
		sizeXZ = 24.2,
		baseY = 20,
		thickness = 40,
		grid = 2,
		hillAmplitude = 1,
		hillScale = 1,
		seed = 1,
		generateOcean = false,
		baseMaterial = Enum.Material.Grass,
	},
	{
		name = "Banana_C49",
		centerX = 10230.5,
		centerZ = -195.0,
		sizeXZ = 22.4,
		baseY = 20,
		thickness = 40,
		grid = 2,
		hillAmplitude = 1,
		hillScale = 1,
		seed = 1,
		generateOcean = false,
		baseMaterial = Enum.Material.Grass,
	},
	{
		name = "Banana_C50",
		centerX = 10240.5,
		centerZ = -205.0,
		sizeXZ = 20.4,
		baseY = 20,
		thickness = 40,
		grid = 2,
		hillAmplitude = 1,
		hillScale = 1,
		seed = 1,
		generateOcean = false,
		baseMaterial = Enum.Material.Grass,
	},
}

===== ./ReplicatedStorage/Islands/Bridges.lua =====
return {
	{
		name = "Bridge_Start_to_Forest",
		fromIsland = 1,
		toIsland = 2,
		width = 15,  -- 20ã‹ã‚‰15ã«å¤‰æ›´ï¼ˆæ©‹ã‚‚å°‘ã—ç´°ãï¼‰
		height = 5,
	},
}
===== ./ReplicatedStorage/Islands/GreenLand.lua =====
return {
	{
		name = "VerdantPlateau_C1",
		centerX = 3000,
		centerZ = 0,
		sizeXZ = 300,
		baseY = 8,
		thickness = 14,
		grid = 14,
		hillAmplitude = 6,
		hillScale = 160,
		seed = 41021,
		generateOcean = false,
		baseMaterial = Enum.Material.Grass,
	},
	{
		name = "VerdantPlateau_C2",
		centerX = 3280,
		centerZ = -120,
		sizeXZ = 290,
		baseY = 8,
		thickness = 14,
		grid = 14,
		hillAmplitude = 6,
		hillScale = 160,
		seed = 51239,
		generateOcean = false,
		baseMaterial = Enum.Material.Grass,
	},
	{
		name = "VerdantPlateau_C3",
		centerX = 2720,
		centerZ = -100,
		sizeXZ = 280,
		baseY = 8,
		thickness = 14,
		grid = 14,
		hillAmplitude = 6,
		hillScale = 160,
		seed = 63917,
		generateOcean = false,
		baseMaterial = Enum.Material.Grass,
	},
	{
		name = "VerdantPlateau_C4",
		centerX = 3000,
		centerZ = 260,
		sizeXZ = 270,
		baseY = 8,
		thickness = 14,
		grid = 14,
		hillAmplitude = 6,
		hillScale = 160,
		seed = 74288,
		generateOcean = false,
		baseMaterial = Enum.Material.Grass,
	},
}

===== ./ReplicatedStorage/Islands/Town.lua =====
-- ReplicatedStorage/Islands/Town.lua (4ã¤ã®å³¶ã§æ§‹æˆã•ã‚Œã‚‹Townã‚¨ãƒªã‚¢ - é‡è¤‡ç‰ˆ)

return {
	-- 1. StartTown (North-West, ãƒ¡ã‚¤ãƒ³ã‚¹ãƒãƒ¼ãƒ³åœ°ç‚¹)
	{
		name = "StartTown",
		centerX = -50, -- â˜…ä¿®æ­£: -100ã‹ã‚‰-50ã¸ (X:-150ã€œ150)
		centerZ = 50, -- â˜…ä¿®æ­£: 100ã‹ã‚‰50ã¸ (Z:-150ã€œ150)
		sizeXZ = 200,
		baseY = 50,
		thickness = 8,
		grid = 10,
		hillAmplitude = 3,
		hillScale = 80,
		seed = 77777,
		generateOcean = true,
		safeZone = true,
		baseMaterial = Enum.Material.Slate,
	},

	-- 2. Town_NE (North-East)
	{
		name = "Town_NE",
		centerX = 50, -- â˜…ä¿®æ­£: 100ã‹ã‚‰50ã¸
		centerZ = 50, -- â˜…ä¿®æ­£: 100ã‹ã‚‰50ã¸
		sizeXZ = 200,
		baseY = 50,
		thickness = 8,
		grid = 10,
		hillAmplitude = 3,
		hillScale = 80,
		seed = 77778,
		generateOcean = false,
		safeZone = true,
		baseMaterial = Enum.Material.Slate,
	},

	-- 3. Town_SW (South-West)
	{
		name = "Town_SW",
		centerX = -50, -- â˜…ä¿®æ­£: -100ã‹ã‚‰-50ã¸
		centerZ = -50, -- â˜…ä¿®æ­£: -100ã‹ã‚‰-50ã¸
		sizeXZ = 200,
		baseY = 50,
		thickness = 8,
		grid = 10,
		hillAmplitude = 3,
		hillScale = 80,
		seed = 77779,
		generateOcean = false,
		safeZone = true,
		baseMaterial = Enum.Material.Slate,
	},

	-- 4. Town_SE (South-East)
	{
		name = "Town_SE",
		centerX = 50, -- â˜…ä¿®æ­£: 100ã‹ã‚‰50ã¸
		centerZ = -50, -- â˜…ä¿®æ­£: -100ã‹ã‚‰-50ã¸
		sizeXZ = 200,
		baseY = 50,
		thickness = 8,
		grid = 10,
		hillAmplitude = 3,
		hillScale = 80,
		seed = 77780,
		generateOcean = false,
		safeZone = true,
		baseMaterial = Enum.Material.Slate,
	},
}

===== ./ReplicatedStorage/Islands/HokkaidoIslands.lua =====
-- ReplicatedStorage/Islands/HokkaidoIslands
return {
	-- ä¸­å¤®éƒ¨ --2935.0, 15.8, 1.4)
	{
		name = "Hokkaido_W0",
		centerX = 2935,
		centerZ = 1.4,
		sizeXZ = 40,
		baseY = 10,
		thickness = 40,
		grid = 2,
		hillAmplitude = 15,
		hillScale = 1,
		seed = 0,
		generateOcean = false,
		baseMaterial = Enum.Material.LeafyGrass,
	},
	{
		name = "Hokkaido_W1",
		centerX = 3000,
		centerZ = 0,
		sizeXZ = 160,
		baseY = 10,
		thickness = 40,
		grid = 3,
		hillAmplitude = 15,
		hillScale = 1,
		seed = 0,
		generateOcean = false,
		baseMaterial = Enum.Material.LeafyGrass,
	},
	{
		name = "Hokkaido_C1",
		centerX = 3080,
		centerZ = 0,
		sizeXZ = 160,
		baseY = 10,
		thickness = 40,
		grid = 3,
		hillAmplitude = 15,
		hillScale = 1,
		seed = 0,
		generateOcean = false,
		baseMaterial = Enum.Material.LeafyGrass,
	},
	{
		name = "Hokkaido_C2",
		centerX = 3160,
		centerZ = 0,
		sizeXZ = 160,
		baseY = 10,
		thickness = 40,
		grid = 3,
		hillAmplitude = 15,
		hillScale = 1,
		seed = 0,
		generateOcean = false,
		baseMaterial = Enum.Material.LeafyGrass,
	},
	{
		name = "Hokkaido_C3",
		centerX = 3240,
		centerZ = 0,
		sizeXZ = 160,
		baseY = 10,
		thickness = 40,
		grid = 3,
		hillAmplitude = 15,
		hillScale = 1,
		seed = 0,
		generateOcean = false,
		baseMaterial = Enum.Material.LeafyGrass,
	},
	{
		name = "Hokkaido_C4",
		centerX = 3320,
		centerZ = 0,
		sizeXZ = 160,
		baseY = 10,
		thickness = 40,
		grid = 3,
		hillAmplitude = 15,
		hillScale = 1,
		seed = 0,
		generateOcean = false,
		baseMaterial = Enum.Material.LeafyGrass,
	},
	{
		name = "Hokkaido_C5",
		centerX = 3400,
		centerZ = 0,
		sizeXZ = 160,
		baseY = 10,
		thickness = 40,
		grid = 3,
		hillAmplitude = 15,
		hillScale = 1,
		seed = 0,
		generateOcean = false,
		baseMaterial = Enum.Material.LeafyGrass,
	},
	{
		name = "Hokkaido_E1",
		centerX = 3480,
		centerZ = 0,
		sizeXZ = 160,
		baseY = 10,
		thickness = 40,
		grid = 2,
		hillAmplitude = 160,
		hillScale = 160,
		seed = 0,
		generateOcean = false,
		baseMaterial = Enum.Material.LeafyGrass,
	},

	-- åŒ—éƒ¨
	{
		name = "Hokkaido_N1",
		centerX = 3080,
		centerZ = 80,
		sizeXZ = 160,
		baseY = 10,
		thickness = 10,
		grid = 3,
		hillAmplitude = 1,
		hillScale = 500,
		seed = 0,
		generateOcean = false,
		baseMaterial = Enum.Material.LeafyGrass,
	},
	{
		name = "Hokkaido_N2",
		centerX = 3160,
		centerZ = 80,
		sizeXZ = 160,
		baseY = 10,
		thickness = 10,
		grid = 3,
		hillAmplitude = 1,
		hillScale = 500,
		seed = 0,
		generateOcean = false,
		baseMaterial = Enum.Material.LeafyGrass,
	},
	{
		name = "Hokkaido_N3",
		centerX = 3240,
		centerZ = 80,
		sizeXZ = 160,
		baseY = 10,
		thickness = 10,
		grid = 3,
		hillAmplitude = 1,
		hillScale = 500,
		seed = 0,
		generateOcean = false,
		baseMaterial = Enum.Material.LeafyGrass,
	},
	{
		name = "Hokkaido_N4",
		centerX = 3320,
		centerZ = 80,
		sizeXZ = 160,
		baseY = 10,
		thickness = 10,
		grid = 3,
		hillAmplitude = 1,
		hillScale = 500,
		seed = 0,
		generateOcean = false,
		baseMaterial = Enum.Material.LeafyGrass,
	},

	-- åŒ—æ±éƒ¨ï¼ˆçŸ¥åºŠï¼‰
	{
		name = "Hokkaido_NE1",
		centerX = 3320,
		centerZ = 160,
		sizeXZ = 160,
		baseY = 10,
		thickness = 10,
		grid = 3,
		hillAmplitude = 10,
		hillScale = 500,
		seed = 50000,
		generateOcean = false,
		baseMaterial = Enum.Material.LeafyGrass,
	},
	{
		name = "Hokkaido_NE2",
		centerX = 3400,
		centerZ = 160,
		sizeXZ = 160,
		baseY = 10,
		thickness = 10,
		grid = 3,
		hillAmplitude = 10,
		hillScale = 500,
		seed = 50000,
		generateOcean = false,
		baseMaterial = Enum.Material.LeafyGrass,
	},

	-- å—éƒ¨
	{
		name = "Hokkaido_S1",
		centerX = 3160,
		centerZ = -80,
		sizeXZ = 200,
		baseY = 10,
		thickness = 10,
		grid = 2,
		hillAmplitude = 120,
		hillScale = 100,
		seed = 50000,
		generateOcean = false,
		baseMaterial = Enum.Material.LeafyGrass,
	},
	{
		name = "Hokkaido_S2",
		centerX = 3240,
		centerZ = -80,
		sizeXZ = 200,
		baseY = 10,
		thickness = 10,
		grid = 1,
		hillAmplitude = 200,
		hillScale = 200,
		seed = 50000,
		generateOcean = false,
		baseMaterial = Enum.Material.LeafyGrass,
	},

	-- å—è¥¿éƒ¨ï¼ˆæ¸¡å³¶ï¼‰
	{
		name = "Hokkaido_SW1",
		centerX = 3080,
		centerZ = -160,
		sizeXZ = 160,
		baseY = 10,
		thickness = 10,
		grid = 1,
		hillAmplitude = 300,
		hillScale = 160,
		seed = 50000,
		generateOcean = false,
		baseMaterial = Enum.Material.LeafyGrass,
	},
	{
		name = "Hokkaido_SW2",
		centerX = 3160,
		centerZ = -160,
		sizeXZ = 160,
		baseY = 10,
		thickness = 10,
		grid = 1,
		hillAmplitude = 400,
		hillScale = 20,
		seed = 50000,
		generateOcean = true,
		baseMaterial = Enum.Material.LeafyGrass,
		oceanRadius = 2000,
	},
}

===== ./ReplicatedStorage/Islands/Registry.lua =====
-- ===== ./ReplicatedStorage/Islands/Registry.lua =====
-- ReplicatedStorage/Islands/Registry.lua (å…¨ã‚³ãƒ¼ãƒ‰)
local RS = game:GetService("ReplicatedStorage")
local IslandsFolder = RS:WaitForChild("Islands")

local allIslands = {}

-- å³¶å®šç¾©ã®ãƒªã‚¹ãƒˆ
local islandModules = {
	IslandsFolder:WaitForChild("Town"), -- ã€ä¿®æ­£ã€‘Town.lua ã‚’å‚ç…§
	IslandsFolder:WaitForChild("HokkaidoIslands"),
	IslandsFolder:WaitForChild("ShikokuIslands"),
	IslandsFolder:WaitForChild("KyushuIslands"),
	IslandsFolder:WaitForChild("Snowland"),
	IslandsFolder:WaitForChild("BananaLand"),
}

-- å„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’èª­ã¿è¾¼ã¿
for _, module in ipairs(islandModules) do
	local result = require(module)

	-- Town (å˜ä¸€ãƒ†ãƒ¼ãƒ–ãƒ«) ã¨ Hokkaido (é…åˆ—) ã®ä¸¡æ–¹ã‚’å‡¦ç†
	if result and result.name then
		-- å˜ä¸€ã®å³¶å®šç¾© (Town)
		table.insert(allIslands, result)
	elseif type(result) == "table" and #result > 0 then
		-- è¤‡æ•°ã®å³¶å®šç¾©ï¼ˆé…åˆ—, Hokkaidoï¼‰
		for _, island in ipairs(result) do
			if island and island.name then
				table.insert(allIslands, island)
			else
				warn(
					("[Islands/Registry] '%s' ã‹ã‚‰å–å¾—ã—ãŸãƒªã‚¹ãƒˆã«ç„¡åŠ¹ãªè¦ç´ ãŒã‚ã‚Šã¾ã™"):format(
						module.Name
					)
				)
			end
		end
	else
		warn(("[Islands/Registry] ä¸æ­£ãªå³¶å®šç¾©: '%s'"):format(module.Name))
	end
end

print(("[Islands/Registry] åˆè¨ˆ %d å€‹ã®å³¶ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ"):format(#allIslands))

return allIslands

===== ./ReplicatedStorage/Islands/Snowland.lua =====
return {
{
name = "SnowCrescent_C1",
centerX = 2880,
centerZ = -550,
sizeXZ = 200,
baseY = 400,
thickness = 60,
grid = 12,
hillAmplitude = 8,
hillScale = 150,
seed = 18431,
generateOcean = true,
oceanRadius = 1000,
baseMaterial = Enum.Material.Snow,
},
{
name = "SnowCrescent_C2",
centerX = 2860,
centerZ = -480,
sizeXZ = 210,
baseY = 400,
thickness = 60,
grid = 12,
hillAmplitude = 7,
hillScale = 150,
seed = 29455,
generateOcean = true,
oceanRadius = 1000,
baseMaterial = Enum.Material.Snow,
},
{
name = "SnowCrescent_C3",
centerX = 2850,
centerZ = -420,
sizeXZ = 220,
baseY = 400,
thickness = 62,
grid = 12,
hillAmplitude = 9,
hillScale = 150,
seed = 37512,
generateOcean = true,
oceanRadius = 1000,
baseMaterial = Enum.Material.Snow,
},
{
name = "SnowCrescent_C4",
centerX = 2840,
centerZ = -360,
sizeXZ = 220,
baseY = 400,
thickness = 62,
grid = 12,
hillAmplitude = 8,
hillScale = 150,
seed = 51234,
generateOcean = true,
oceanRadius = 1000,
baseMaterial = Enum.Material.Snow,
},
{
name = "SnowCrescent_C5",
centerX = 2830,
centerZ = -300,
sizeXZ = 210,
baseY = 400,
thickness = 62,
grid = 12,
hillAmplitude = 7,
hillScale = 150,
seed = 63821,
generateOcean = true,
oceanRadius = 1000,
baseMaterial = Enum.Material.Snow,
},
{
name = "SnowCrescent_C6",
centerX = 2825,
centerZ = -230,
sizeXZ = 200,
baseY = 400,
thickness = 64,
grid = 12,
hillAmplitude = 6,
hillScale = 150,
seed = 74092,
generateOcean = true,
oceanRadius = 1000,
baseMaterial = Enum.Material.Snow,
},
{
name = "SnowCrescent_C7",
centerX = 2815,
centerZ = -170,
sizeXZ = 190,
baseY = 400,
thickness = 64,
grid = 12,
hillAmplitude = 6,
hillScale = 150,
seed = 81937,
generateOcean = true,
oceanRadius = 1000,
baseMaterial = Enum.Material.Snow,
},
{
name = "SnowCrescent_C8",
centerX = 2805,
centerZ = -110,
sizeXZ = 190,
baseY = 400,
thickness = 64,
grid = 12,
hillAmplitude = 6,
hillScale = 150,
seed = 92741,
generateOcean = true,
oceanRadius = 1000,
baseMaterial = Enum.Material.Snow,
},
{
name = "SnowCrescent_C9",
centerX = 2800,
centerZ = -50,
sizeXZ = 190,
baseY = 400,
thickness = 66,
grid = 12,
hillAmplitude = 6,
hillScale = 150,
seed = 103885,
generateOcean = true,
oceanRadius = 1000,
baseMaterial = Enum.Material.Snow,
},
{
name = "SnowCrescent_C10",
centerX = 2805,
centerZ = 10,
sizeXZ = 190,
baseY = 400,
thickness = 66,
grid = 12,
hillAmplitude = 7,
hillScale = 150,
seed = 118234,
generateOcean = true,
oceanRadius = 1000,
baseMaterial = Enum.Material.Snow,
},
{
name = "SnowCrescent_C11",
centerX = 2815,
centerZ = 70,
sizeXZ = 200,
baseY = 400,
thickness = 70,
grid = 12,
hillAmplitude = 32,
hillScale = 160,
seed = 129776,
generateOcean = true,
oceanRadius = 1000,
baseMaterial = Enum.Material.Snow,
},
{
name = "SnowCrescent_C12",
centerX = 2825,
centerZ = 140,
sizeXZ = 210,
baseY = 400,
thickness = 72,
grid = 12,
hillAmplitude = 36,
hillScale = 165,
seed = 130992,
generateOcean = true,
oceanRadius = 1000,
baseMaterial = Enum.Material.Snow,
},
{
name = "SnowCrescent_C13",
centerX = 2835,
centerZ = 220,
sizeXZ = 220,
baseY = 400,
thickness = 74,
grid = 12,
hillAmplitude = 38,
hillScale = 170,
seed = 145332,
generateOcean = true,
oceanRadius = 1000,
baseMaterial = Enum.Material.Snow,
},
{
name = "SnowCrescent_C14",
centerX = 2850,
centerZ = 320,
sizeXZ = 220,
baseY = 400,
thickness = 76,
grid = 12,
hillAmplitude = 40,
hillScale = 170,
seed = 158221,
generateOcean = true,
oceanRadius = 1000,
baseMaterial = Enum.Material.Snow,
},
{
name = "SnowCrescent_C15",
centerX = 2870,
centerZ = 440,
sizeXZ = 220,
baseY = 400,
thickness = 78,
grid = 12,
hillAmplitude = 40,
hillScale = 175,
seed = 169554,
generateOcean = true,
oceanRadius = 1000,
baseMaterial = Enum.Material.Snow,
},
}
===== ./ReplicatedStorage/Islands/Arena.lua =====
return {
	{
		name = "Arena_01",
		centerX = 10000, -- â˜…ä¿®æ­£: -100ã‹ã‚‰-50ã¸ (X:-150ã€œ150)
		centerZ = 50, -- â˜…ä¿®æ­£: 100ã‹ã‚‰50ã¸ (Z:-150ã€œ150)
		sizeXZ = 200,
		baseY = 150,
		thickness = 8,
		grid = 10,
		hillAmplitude = 3,
		hillScale = 80,
		seed = 77777,
		generateOcean = true,
		safeZone = true,
		baseMaterial = Enum.Material.Slate,
	},

	-- 2. Town_NE (North-East)
	{
		name = "Arena_02",
		centerX = 10050, -- â˜…ä¿®æ­£: 100ã‹ã‚‰50ã¸
		centerZ = 50, -- â˜…ä¿®æ­£: 100ã‹ã‚‰50ã¸
		sizeXZ = 200,
		baseY = 150,
		thickness = 8,
		grid = 10,
		hillAmplitude = 3,
		hillScale = 80,
		seed = 77778,
		generateOcean = false,
		safeZone = true,
		baseMaterial = Enum.Material.Slate,
	},
}

===== ./ReplicatedStorage/Islands/ShikokuIslands.lua =====
-- ===== ./ReplicatedStorage/Islands/ShikokuIslands.lua (æ–°è¦) =====
return {
	-- åŒ—éƒ¨
	{
        name = "Shikoku_N1", centerX = 550, centerZ = 50, sizeXZ = 150, baseY = 10, thickness = 10, grid = 10,
        hillAmplitude = 15, hillScale = 100, seed = 60001, generateOcean = false, baseMaterial = Enum.Material.Sand,
    },
    -- ä¸­å¤®
	{
        name = "Shikoku_C1", centerX = 600, centerZ = 0, sizeXZ = 180, baseY = 10, thickness = 10, grid = 10,
        hillAmplitude = 20, hillScale = 120, seed = 60002, generateOcean = false, baseMaterial = Enum.Material.Sand,
    },
    -- å—éƒ¨
	{
        name = "Shikoku_S1", centerX = 650, centerZ = -50, sizeXZ = 150, baseY = 10, thickness = 10, grid = 10,
        hillAmplitude = 15, hillScale = 100, seed = 60003, generateOcean = false, baseMaterial = Enum.Material.Sand,
    },
    -- æ±éƒ¨
	{
        name = "Shikoku_E1", centerX = 650, centerZ = 50, sizeXZ = 100, baseY = 10, thickness = 10, grid = 10,
        hillAmplitude = 10, hillScale = 80, seed = 60004, generateOcean = false, baseMaterial = Enum.Material.Sand,
    },
    -- è¥¿éƒ¨
	{
        name = "Shikoku_W1", centerX = 550, centerZ = -50, sizeXZ = 100, baseY = 10, thickness = 10, grid = 10,
        hillAmplitude = 10, hillScale = 80, seed = 60005, generateOcean = true, oceanRadius = 1000, baseMaterial = Enum.Material.Sand,
    },
}
===== ./ReplicatedStorage/Islands/KyushuIslands.lua =====
--- Islands ---
return {
	{
		name = "ContinentKyushu_C1",
		centerX = 2900,
		centerZ = -520,
		sizeXZ = 320,
		baseY = 10,
		thickness = 30,
		grid = 5,
		hillAmplitude = 64,
		hillScale = 260,
		seed = 0,
		generateOcean = true,
		oceanRadius = 2000,
		baseMaterial = Enum.Material.LeafyGrass,
	},
	{
		name = "ContinentKyushu_C2",
		centerX = 3050,
		centerZ = -520,
		sizeXZ = 340,
		baseY = 10,
		thickness = 30,
		grid = 5,
		hillAmplitude = 68,
		hillScale = 260,
		seed = 0,
		generateOcean = true,
		oceanRadius = 2000,
		baseMaterial = Enum.Material.LeafyGrass,
	},
	{
		name = "ContinentKyushu_C3",
		centerX = 3200,
		centerZ = -480,
		sizeXZ = 300,
		baseY = 10,
		thickness = 30,
		grid = 5,
		hillAmplitude = 60,
		hillScale = 270,
		seed = 0,
		generateOcean = true,
		oceanRadius = 2000,
		baseMaterial = Enum.Material.LeafyGrass,
	},
	{
		name = "ContinentKyushu_C4",
		centerX = 3000,
		centerZ = -420,
		sizeXZ = 360,
		baseY = 10,
		thickness = 30,
		grid = 5,
		hillAmplitude = 72,
		hillScale = 250,
		seed = 0,
		generateOcean = true,
		oceanRadius = 2000,
		baseMaterial = Enum.Material.LeafyGrass,
	},
	{
		name = "ContinentKyushu_C5",
		centerX = 2800,
		centerZ = -420,
		sizeXZ = 300,
		baseY = 9,
		thickness = 30,
		grid = 5,
		hillAmplitude = 60,
		hillScale = 260,
		seed = 0,
		generateOcean = true,
		oceanRadius = 2000,
		baseMaterial = Enum.Material.LeafyGrass,
	},
	{
		name = "ContinentKyushu_C6",
		centerX = 3150,
		centerZ = -360,
		sizeXZ = 320,
		baseY = 10,
		thickness = 30,
		grid = 5,
		hillAmplitude = 64,
		hillScale = 260,
		seed = 0,
		generateOcean = true,
		oceanRadius = 2000,
		baseMaterial = Enum.Material.LeafyGrass,
	},
	{
		name = "ContinentKyushu_C7",
		centerX = 2920,
		centerZ = -340,
		sizeXZ = 280,
		baseY = 10,
		thickness = 30,
		grid = 5,
		hillAmplitude = 56,
		hillScale = 270,
		seed = 0,
		generateOcean = true,
		oceanRadius = 2000,
		baseMaterial = Enum.Material.LeafyGrass,
	},
	{
		name = "ContinentKyushu_C8",
		centerX = 3050,
		centerZ = -240,
		sizeXZ = 380,
		baseY = 11,
		thickness = 30,
		grid = 2,
		hillAmplitude = 80,
		hillScale = 180,
		seed = 0,
		generateOcean = true,
		oceanRadius = 2000,
		baseMaterial = Enum.Material.LeafyGrass,
	},
	{
		name = "ContinentKyushu_C9",
		centerX = 3200,
		centerZ = -200,
		sizeXZ = 320,
		baseY = 11,
		thickness = 30,
		grid = 5,
		hillAmplitude = 60,
		hillScale = 200,
		seed = 0,
		generateOcean = true,
		oceanRadius = 2000,
		baseMaterial = Enum.Material.LeafyGrass,
	},
	{
		name = "ContinentKyushu_C10",
		centerX = 2900,
		centerZ = -200,
		sizeXZ = 300,
		baseY = 11,
		thickness = 30,
		grid = 6,
		hillAmplitude = 50,
		hillScale = 210,
		seed = 0,
		generateOcean = true,
		oceanRadius = 2000,
		baseMaterial = Enum.Material.LeafyGrass,
	},
	{
		name = "ContinentKyushu_C11",
		centerX = 3300,
		centerZ = -80,
		sizeXZ = 340,
		baseY = 11,
		thickness = 30,
		grid = 5,
		hillAmplitude = 70,
		hillScale = 210,
		seed = 0,
		generateOcean = true,
		oceanRadius = 2000,
		baseMaterial = Enum.Material.LeafyGrass,
	},
	{
		name = "ContinentKyushu_C12",
		centerX = 3000,
		centerZ = -40,
		sizeXZ = 360,
		baseY = 12,
		thickness = 30,
		grid = 6,
		hillAmplitude = 80,
		hillScale = 190,
		seed = 0,
		generateOcean = true,
		oceanRadius = 2000,
		baseMaterial = Enum.Material.LeafyGrass,
	},
	{
		name = "ContinentKyushu_C13",
		centerX = 3150,
		centerZ = 60,
		sizeXZ = 340,
		baseY = 12,
		thickness = 30,
		grid = 6,
		hillAmplitude = 70,
		hillScale = 190,
		seed = 0,
		generateOcean = true,
		oceanRadius = 2000,
		baseMaterial = Enum.Material.LeafyGrass,
	},
	{
		name = "ContinentKyushu_C14",
		centerX = 3000,
		centerZ = 160,
		sizeXZ = 360,
		baseY = 12,
		thickness = 30,
		grid = 8,
		hillAmplitude = 80,
		hillScale = 180,
		seed = 0,
		generateOcean = true,
		oceanRadius = 2000,
		baseMaterial = Enum.Material.LeafyGrass,
	},
	{
		name = "ContinentKyushu_C15",
		centerX = 2850,
		centerZ = 220,
		sizeXZ = 300,
		baseY = 11,
		thickness = 30,
		grid = 5,
		hillAmplitude = 50,
		hillScale = 190,
		seed = 0,
		generateOcean = true,
		oceanRadius = 2000,
		baseMaterial = Enum.Material.LeafyGrass,
	},
	{
		name = "ContinentKyushu_C16",
		centerX = 3120,
		centerZ = 300,
		sizeXZ = 320,
		baseY = 11,
		thickness = 30,
		grid = 5,
		hillAmplitude = 60,
		hillScale = 190,
		seed = 0,
		generateOcean = true,
		oceanRadius = 2000,
		baseMaterial = Enum.Material.LeafyGrass,
	},
	{
		name = "ContinentKyushu_C17",
		centerX = 3000,
		centerZ = 380,
		sizeXZ = 300,
		baseY = 11,
		thickness = 30,
		grid = 8,
		hillAmplitude = 50,
		hillScale = 180,
		seed = 0,
		generateOcean = true,
		oceanRadius = 2000,
		baseMaterial = Enum.Material.LeafyGrass,
	},
	{
		name = "ContinentKyushu_C18",
		centerX = 3180,
		centerZ = 470,
		sizeXZ = 240,
		baseY = 12,
		thickness = 30,
		grid = 2,
		hillAmplitude = 140,
		hillScale = 160,
		seed = 0,
		generateOcean = true,
		oceanRadius = 2000,
		baseMaterial = Enum.Material.Basalt,
	},
	{
		name = "ContinentKyushu_C19",
		centerX = 2760,
		centerZ = -60,
		sizeXZ = 220,
		baseY = 10,
		thickness = 30,
		grid = 5,
		hillAmplitude = 70,
		hillScale = 220,
		seed = 0,
		generateOcean = true,
		oceanRadius = 2000,
		baseMaterial = Enum.Material.LeafyGrass,
	},
	{
		name = "ContinentKyushu_C20",
		centerX = 2700,
		centerZ = 40,
		sizeXZ = 200,
		baseY = 10,
		thickness = 30,
		grid = 5,
		hillAmplitude = 15,
		hillScale = 220,
		seed = 0,
		generateOcean = true,
		oceanRadius = 2000,
		baseMaterial = Enum.Material.LeafyGrass,
	},
	{
		name = "ContinentKyushu_C21",
		centerX = 2680,
		centerZ = 140,
		sizeXZ = 180,
		baseY = 10,
		thickness = 30,
		grid = 5,
		hillAmplitude = 15,
		hillScale = 220,
		seed = 0,
		generateOcean = true,
		oceanRadius = 2000,
		baseMaterial = Enum.Material.LeafyGrass,
	},
	{
		name = "ContinentKyushu_C22",
		centerX = 2750,
		centerZ = 220,
		sizeXZ = 200,
		baseY = 10,
		thickness = 30,
		grid = 5,
		hillAmplitude = 15,
		hillScale = 220,
		seed = 0,
		generateOcean = true,
		oceanRadius = 2000,
		baseMaterial = Enum.Material.LeafyGrass,
	},
	{
		name = "ContinentKyushu_C23",
		centerX = 3350,
		centerZ = 40,
		sizeXZ = 320,
		baseY = 10,
		thickness = 30,
		grid = 5,
		hillAmplitude = 15,
		hillScale = 260,
		seed = 0,
		generateOcean = true,
		oceanRadius = 2000,
		baseMaterial = Enum.Material.LeafyGrass,
	},
	{
		name = "ContinentKyushu_C24",
		centerX = 3420,
		centerZ = 160,
		sizeXZ = 300,
		baseY = 9,
		thickness = 30,
		grid = 5,
		hillAmplitude = 15,
		hillScale = 270,
		seed = 0,
		generateOcean = true,
		oceanRadius = 2000,
		baseMaterial = Enum.Material.LeafyGrass,
	},
}

===== ./ReplicatedStorage/GameEvents.lua =====
-- ReplicatedStorage/GameEvents.lua
-- ã‚¤ãƒ™ãƒ³ãƒˆé§†å‹•é€šä¿¡ã‚·ã‚¹ãƒ†ãƒ ï¼ˆå¾ªç’°ä¾å­˜ã‚’é˜²ããŸã‚ã®é€šä¿¡ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼‰

local GameEvents = {}

local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- ã‚¤ãƒ™ãƒ³ãƒˆæ ¼ç´ç”¨ãƒ•ã‚©ãƒ«ãƒ€ã‚’ä½œæˆ
local eventFolder = ReplicatedStorage:FindFirstChild("GameEventBindables")
if not eventFolder then
	eventFolder = Instance.new("Folder")
	eventFolder.Name = "GameEventBindables"
	eventFolder.Parent = ReplicatedStorage
end

-- ã‚¤ãƒ™ãƒ³ãƒˆã‚’å–å¾—ã¾ãŸã¯ä½œæˆ
local function getOrCreateEvent(name)
	local event = eventFolder:FindFirstChild(name)
	if not event then
		event = Instance.new("BindableEvent")
		event.Name = name
		event.Parent = eventFolder
		print(("[GameEvents] Created event: %s"):format(name))
	end
	return event
end

-- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼é–¢é€£ã‚¤ãƒ™ãƒ³ãƒˆ
GameEvents.MonsterCountRequest = getOrCreateEvent("MonsterCountRequest")
GameEvents.MonsterCountResponse = getOrCreateEvent("MonsterCountResponse")
GameEvents.MonsterSpawned = getOrCreateEvent("MonsterSpawned")
GameEvents.MonsterDespawned = getOrCreateEvent("MonsterDespawned")

-- ã‚»ãƒ¼ãƒ–/ãƒ­ãƒ¼ãƒ‰é–¢é€£ã‚¤ãƒ™ãƒ³ãƒˆ
GameEvents.SaveRequest = getOrCreateEvent("SaveRequest")
GameEvents.SaveComplete = getOrCreateEvent("SaveComplete")
GameEvents.LoadComplete = getOrCreateEvent("LoadComplete")

-- ã‚¾ãƒ¼ãƒ³é–¢é€£ã‚¤ãƒ™ãƒ³ãƒˆ
GameEvents.ZoneChanged = getOrCreateEvent("ZoneChanged")
GameEvents.ZoneLoadStart = getOrCreateEvent("ZoneLoadStart")
GameEvents.ZoneLoadComplete = getOrCreateEvent("ZoneLoadComplete")

-- ãƒãƒˆãƒ«é–¢é€£ã‚¤ãƒ™ãƒ³ãƒˆ
GameEvents.BattleStateChanged = getOrCreateEvent("BattleStateChanged")

-- ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°ï¼šã‚¤ãƒ™ãƒ³ãƒˆç™ºç«ï¼ˆãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°ä»˜ãï¼‰
function GameEvents.Fire(eventName, ...)
	local event = GameEvents[eventName]
	if event then
		print(("[GameEvents] Firing: %s"):format(eventName))
		event:Fire(...)
	else
		warn(("[GameEvents] Event not found: %s"):format(eventName))
	end
end

-- ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°ï¼šã‚¤ãƒ™ãƒ³ãƒˆå¾…æ©Ÿï¼ˆã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆä»˜ãï¼‰
function GameEvents.Wait(eventName, timeout)
	local event = GameEvents[eventName]
	if not event then
		warn(("[GameEvents] Event not found: %s"):format(eventName))
		return nil
	end

	timeout = timeout or 5
	local startTime = tick()
	local result = nil

	local connection
	connection = event.Event:Connect(function(...)
		result = {...}
	end)

	-- ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆå¾…æ©Ÿ
	while not result and (tick() - startTime) < timeout do
		task.wait(0.1)
	end

	connection:Disconnect()

	if not result then
		warn(("[GameEvents] Timeout waiting for: %s"):format(eventName))
	end

	return result and unpack(result) or nil
end

print("[GameEvents] Module initialized")

return GameEvents
===== ./ReplicatedStorage/Typing/WordPicker.lua =====
-- ReplicatedStorage/Typing/WordPicker.lua
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TypingWords = require(ReplicatedStorage.Typing.TypingWords)

local M = {}

local function weightedPick(levels)
	local sum = 0
	for _, e in ipairs(levels) do sum += (e.weight or 0) end
	local r = math.random() * sum
	for _, e in ipairs(levels) do
		r -= (e.weight or 0)
		if r <= 0 then return e.level end
	end
	return levels[#levels].level
end

function M.pickWord(levels, opts)
	-- opts: {category1="n"} ãªã©ä»»æ„
	local levelName = weightedPick(levels)
	local pool = TypingWords[levelName]
	if opts and opts.category1 then
		local f = {}
		for _, it in ipairs(pool) do
			if it.category1 == opts.category1 then table.insert(f, it) end
		end
		if #f > 0 then pool = f end
	end
	return pool[math.random(1, #pool)], levelName
end

return M

===== ./ReplicatedStorage/Typing/TypingWords.lua =====
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LevelsFolder = ReplicatedStorage:WaitForChild("Typing"):WaitForChild("Levels")

local cache = {}
local TypingWords = {}

local function load(levelName)
  if not cache[levelName] then
    local m = LevelsFolder:FindFirstChild(levelName)
    if m and m:IsA("ModuleScript") then
      cache[levelName] = require(m)
    else
      warn("[TypingWords] level not found: " .. tostring(levelName))
      cache[levelName] = {}
    end
  end
  return cache[levelName]
end

-- === TypingWords.lua ã®æœ«å°¾ã«ç½®ãï¼ˆã“ã“ã‹ã‚‰ï¼‰ ===
setmetatable(TypingWords, {
  __index = function(_, k)
    -- é€šå¸¸ãƒ­ãƒ¼ãƒ‰ï¼ˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ä½¿ç”¨ï¼‰
    return load(k, false)
  end
})

-- é–¢æ•°ã¨ã—ã¦ã® reloadï¼ˆãƒ‰ãƒƒãƒˆå®šç¾©ï¼ï¼‰
function TypingWords.reload(levelName)
  return load(levelName, true)  -- å¼·åˆ¶å†èª­è¾¼ï¼ˆã‚¯ãƒ­ãƒ¼ãƒ³ requireï¼‰
end

return TypingWords

===== ./ReplicatedStorage/Typing/TypingWords copy.lua =====
-- ReplicatedStorage/TypingWords
-- ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ç”¨ã®å˜èªãƒªã‚¹ãƒˆï¼ˆå¤šè¨€èªå¯¾å¿œï¼‰

return {
	level_1 = {
		{word = "cat", ja = "çŒ«", es = "gato", fr = "chat"},
		{word = "dog", ja = "çŠ¬", es = "perro", fr = "chien"},
		{word = "pen", ja = "ãƒšãƒ³", es = "pluma", fr = "stylo"},
		{word = "cup", ja = "ã‚«ãƒƒãƒ—", es = "taza", fr = "tasse"},
		{word = "sun", ja = "å¤ªé™½", es = "sol", fr = "soleil"},
		{word = "red", ja = "èµ¤", es = "rojo", fr = "rouge"},
		{word = "big", ja = "å¤§ãã„", es = "grande", fr = "grand"},
		{word = "run", ja = "èµ°ã‚‹", es = "correr", fr = "courir"},
		{word = "fly", ja = "é£›ã¶", es = "volar", fr = "voler"},
		{word = "eat", ja = "é£Ÿã¹ã‚‹", es = "comer", fr = "manger"},
	},
	level_2 = {
		{word = "apple", ja = "ã‚Šã‚“ã”", es = "manzana", fr = "pomme"},
		{word = "house", ja = "å®¶", es = "casa", fr = "maison"},
		{word = "water", ja = "æ°´", es = "agua", fr = "eau"},
		{word = "sleep", ja = "çœ ã‚‹", es = "dormir", fr = "dormir"},
		{word = "happy", ja = "å¹¸ã›", es = "feliz", fr = "heureux"},
		{word = "green", ja = "ç·‘", es = "verde", fr = "vert"},
		{word = "river", ja = "å·", es = "rÃ­o", fr = "riviÃ¨re"},
		{word = "night", ja = "å¤œ", es = "noche", fr = "nuit"},
		{word = "music", ja = "éŸ³æ¥½", es = "mÃºsica", fr = "musique"},
		{word = "stone", ja = "çŸ³", es = "piedra", fr = "pierre"},
	},
	level_3 = {
		{word = "banana", ja = "ãƒãƒŠãƒŠ", es = "plÃ¡tano", fr = "banane"},
		{word = "orange", ja = "ã‚ªãƒ¬ãƒ³ã‚¸", es = "naranja", fr = "orange"},
		{word = "yellow", ja = "é»„è‰²", es = "amarillo", fr = "jaune"},
		{word = "purple", ja = "ç´«", es = "morado", fr = "violet"},
		{word = "animal", ja = "å‹•ç‰©", es = "animal", fr = "animal"},
		{word = "window", ja = "çª“", es = "ventana", fr = "fenÃªtre"},
		{word = "garden", ja = "åº­", es = "jardÃ­n", fr = "jardin"},
		{word = "bridge", ja = "æ©‹", es = "puente", fr = "pont"},
		{word = "planet", ja = "æƒ‘æ˜Ÿ", es = "planeta", fr = "planÃ¨te"},
		{word = "forest", ja = "æ£®", es = "bosque", fr = "forÃªt"},
	},
	level_4 = {
		{word = "monday", ja = "æœˆæ›œæ—¥", es = "lunes", fr = "lundi"},
		{word = "sunday", ja = "æ—¥æ›œæ—¥", es = "domingo", fr = "dimanche"},
		{word = "friday", ja = "é‡‘æ›œæ—¥", es = "viernes", fr = "vendredi"},
		{word = "winter", ja = "å†¬", es = "invierno", fr = "hiver"},
		{word = "summer", ja = "å¤", es = "verano", fr = "Ã©tÃ©"},
		{word = "spring", ja = "æ˜¥", es = "primavera", fr = "printemps"},
		{word = "autumn", ja = "ç§‹", es = "otoÃ±o", fr = "automne"},
		{word = "dragon", ja = "ãƒ‰ãƒ©ã‚´ãƒ³", es = "dragÃ³n", fr = "dragon"},
		{word = "castle", ja = "åŸ", es = "castillo", fr = "chÃ¢teau"},
		{word = "warrior", ja = "æˆ¦å£«", es = "guerrero", fr = "guerrier"},
	},
	level_5 = {
		{word = "mountain", ja = "å±±", es = "montaÃ±a", fr = "montagne"},
		{word = "keyboard", ja = "ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰", es = "teclado", fr = "clavier"},
		{word = "computer", ja = "ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿", es = "computadora", fr = "ordinateur"},
		{word = "adventure", ja = "å†’é™º", es = "aventura", fr = "aventure"},
		{word = "beautiful", ja = "ç¾ã—ã„", es = "hermoso", fr = "beau"},
		{word = "champion", ja = "ãƒãƒ£ãƒ³ãƒ”ã‚ªãƒ³", es = "campeÃ³n", fr = "champion"},
		{word = "treasure", ja = "å®ç‰©", es = "tesoro", fr = "trÃ©sor"},
		{word = "butterfly", ja = "è¶", es = "mariposa", fr = "papillon"},
		{word = "elephant", ja = "è±¡", es = "elefante", fr = "Ã©lÃ©phant"},
		{word = "challenge", ja = "æŒ‘æˆ¦", es = "desafÃ­o", fr = "dÃ©fi"},
	},
}
===== ./ReplicatedStorage/Typing/WordInfo.lua =====
-- ReplicatedStorage/Typing/WordInfo.lua
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TypingWords = require(ReplicatedStorage.Typing.TypingWords)

local sizeCache = {}
local M = {}

function M.levelSize(levelName)
  if not sizeCache[levelName] then
    -- åˆå›ã ã‘æ•°ãˆã¦ã‚­ãƒ£ãƒƒã‚·ãƒ¥
    sizeCache[levelName] = #TypingWords[levelName]
  end
  return sizeCache[levelName]
end

return M

===== ./ReplicatedStorage/Typing/CategoryLabels.lua =====
-- ä¾‹: ReplicatedStorage/Typing/CategoryLabels.lua
-- ã‚«ãƒ†ã‚´ãƒªãƒ¼1ï¼ˆn=åè©, v=å‹•è©, a=å½¢å®¹è©, o=ãã®ä»–ï¼‰ã®å¤šè¨€èªè¡¨è¨˜
return {
  ja = { n = "åè©", v = "å‹•è©", a = "å½¢å®¹è©", o = "ãã®ä»–" },
  es = { n = "sustantivo", v = "verbo", a = "adjetivo", o = "otros" },
  fr = { n = "nom", v = "verbe", a = "adjectif", o = "autres" },
  de = { n = "Substantiv", v = "Verb", a = "Adjektiv", o = "Sonstiges" },
  tl = { n = "pangngalan", v = "pandiwa", a = "pang-uri", o = "iba pa" },
}

===== ./ReplicatedStorage/Typing/Levels/level_2.lua =====
return {
		{no = 11, word = "apple", ja = "ã‚Šã‚“ã”", es = "manzana", fr = "pomme", de = "Apfel", tl = "mansanas", category1 = "n", category2 = {ja = "é£Ÿã¹ç‰©", es = "comida", fr = "nourriture", de = "Lebensmittel", tl = "pagkain"}},
		{no = 12, word = "house", ja = "å®¶", es = "casa", fr = "maison", de = "Haus", tl = "bahay", category1 = "n", category2 = {ja = "ãƒ¢ãƒ", es = "objeto", fr = "objet", de = "Gegenstand", tl = "bagay"}},
		{no = 13, word = "sleep", ja = "çœ ã‚‹", es = "dormir", fr = "dormir", de = "schlafen", tl = "matulog", category1 = "v", category2 = {ja = "çŠ¶æ…‹", es = "estado", fr = "Ã©tat", de = "Zustand", tl = "kalagayan"}},
		{no = 14, word = "green", ja = "ç·‘", es = "verde", fr = "vert", de = "grÃ¼n", tl = "berde", category1 = "o", category2 = {ja = "è‰²", es = "color", fr = "couleur", de = "Farbe", tl = "kulay"}},
		{no = 15, word = "river", ja = "å·", es = "rÃ­o", fr = "riviÃ¨re", de = "Fluss", tl = "ilog", category1 = "n", category2 = {ja = "è‡ªç„¶", es = "naturaleza", fr = "nature", de = "Natur", tl = "kalikasan"}},
		{no = 16, word = "night", ja = "å¤œ", es = "noche", fr = "nuit", de = "Nacht", tl = "gabi", category1 = "n", category2 = {ja = "æ™‚é–“", es = "tiempo", fr = "temps", de = "Zeit", tl = "oras"}},
		{no = 17, word = "music", ja = "éŸ³æ¥½", es = "mÃºsica", fr = "musique", de = "Musik", tl = "musika", category1 = "n", category2 = {ja = "è¡¨ç¾", es = "expresiÃ³n", fr = "expression", de = "Ausdruck", tl = "pagpapahayag"}},
		{no = 18, word = "stone", ja = "çŸ³", es = "piedra", fr = "pierre", de = "Stein", tl = "bato", category1 = "n", category2 = {ja = "ãƒ¢ãƒ", es = "objeto", fr = "objet", de = "Gegenstand", tl = "bagay"}},
		{no = 19, word = "fast", ja = "é€Ÿã„", es = "rÃ¡pido", fr = "rapide", de = "schnell", tl = "mabilis", category1 = "a", category2 = {ja = "æ§˜å­", es = "aspecto", fr = "apparence", de = "Aussehen", tl = "itsura"}},
		{no = 20, word = "write", ja = "æ›¸ã", es = "escribir", fr = "Ã©crire", de = "schreiben", tl = "sumulat", category1 = "v", category2 = {ja = "è¡¨ç¾", es = "expresiÃ³n", fr = "expression", de = "Ausdruck", tl = "pagpapahayag"}},

}
===== ./ReplicatedStorage/Typing/Levels/level_3.lua =====
return {
		{no = 21, word = "teacher", ja = "å…ˆç”Ÿ", es = "maestro", fr = "professeur", de = "Lehrer", tl = "guro", category1 = "n", category2 = {ja = "äºº", es = "persona", fr = "personne", de = "Person", tl = "tao"}},
		{no = 22, word = "draw", ja = "æã", es = "dibujar", fr = "dessiner", de = "zeichnen", tl = "gumuhit", category1 = "v", category2 = {ja = "è¡¨ç¾", es = "expresiÃ³n", fr = "expression", de = "Ausdruck", tl = "pagpapahayag"}},
		{no = 23, word = "mountain", ja = "å±±", es = "montaÃ±a", fr = "montagne", de = "Berg", tl = "bundok", category1 = "n", category2 = {ja = "è‡ªç„¶", es = "naturaleza", fr = "nature", de = "Natur", tl = "kalikasan"}},
		{no = 24, word = "decide", ja = "æ±ºã‚ã‚‹", es = "decidir", fr = "dÃ©cider", de = "entscheiden", tl = "magpasya", category1 = "v", category2 = {ja = "æ€è€ƒ", es = "pensamiento", fr = "pensÃ©e", de = "Gedanke", tl = "pag-iisip"}},
		{no = 25, word = "kind", ja = "è¦ªåˆ‡ãª", es = "amable", fr = "gentil", de = "freundlich", tl = "mabait", category1 = "a", category2 = {ja = "æ°—æŒã¡", es = "sentimiento", fr = "sentiment", de = "GefÃ¼hl", tl = "damdamin"}},
		{no = 26, word = "road", ja = "é“", es = "camino", fr = "route", de = "StraÃŸe", tl = "kalsada", category1 = "n", category2 = {ja = "å ´æ‰€", es = "lugar", fr = "lieu", de = "Ort", tl = "lugar"}},
		{no = 27, word = "laugh", ja = "ç¬‘ã†", es = "reÃ­r", fr = "rire", de = "lachen", tl = "tumawa", category1 = "v", category2 = {ja = "è¡¨ç¾", es = "expresiÃ³n", fr = "expression", de = "Ausdruck", tl = "pagpapahayag"}},
		{no = 28, word = "blue", ja = "é’", es = "azul", fr = "bleu", de = "blau", tl = "asul", category1 = "o", category2 = {ja = "è‰²", es = "color", fr = "couleur", de = "Farbe", tl = "kulay"}},
		{no = 29, word = "bird", ja = "é³¥", es = "pÃ¡jaro", fr = "oiseau", de = "Vogel", tl = "ibon", category1 = "n", category2 = {ja = "ç”Ÿãç‰©", es = "ser vivo", fr = "Ãªtre vivant", de = "Lebewesen", tl = "nilalang"}},
		{no = 30, word = "help", ja = "åŠ©ã‘ã‚‹", es = "ayudar", fr = "aider", de = "helfen", tl = "tumulong", category1 = "v", category2 = {ja = "è¡Œå‹•", es = "acciÃ³n", fr = "action", de = "Handlung", tl = "kilos"}},

}
===== ./ReplicatedStorage/Typing/Levels/level_1.lua =====
return {
	{
		no = 1,
		word = "cat",
		ja = "çŒ«",
		es = "gato",
		fr = "chat",
		de = "Katze",
		tl = "pusa",
		category1 = "n",
		category2 = { ja = "ç”Ÿãç‰©", es = "ser vivo", fr = "Ãªtre vivant", de = "Lebewesen", tl = "nilalang" },
	},
	{
		no = 2,
		word = "dog",
		ja = "çŠ¬",
		es = "perro",
		fr = "chien",
		de = "Hund",
		tl = "aso",
		category1 = "n",
		category2 = { ja = "ç”Ÿãç‰©", es = "ser vivo", fr = "Ãªtre vivant", de = "Lebewesen", tl = "nilalang" },
	},
	{
		no = 3,
		word = "run",
		ja = "èµ°ã‚‹",
		es = "correr",
		fr = "courir",
		de = "laufen",
		tl = "tumakbo",
		category1 = "v",
		category2 = { ja = "è¡Œå‹•", es = "acciÃ³n", fr = "action", de = "Handlung", tl = "kilos" },
	},
	{
		no = 4,
		word = "big",
		ja = "å¤§ãã„",
		es = "grande",
		fr = "grand",
		de = "groÃŸ",
		tl = "malaki",
		category1 = "a",
		category2 = { ja = "æ§˜å­", es = "aspecto", fr = "apparence", de = "Aussehen", tl = "itsura" },
	},
	{
		no = 5,
		word = "sun",
		ja = "å¤ªé™½",
		es = "sol",
		fr = "soleil",
		de = "Sonne",
		tl = "araw",
		category1 = "n",
		category2 = { ja = "è‡ªç„¶", es = "naturaleza", fr = "nature", de = "Natur", tl = "kalikasan" },
	},
	{
		no = 6,
		word = "book",
		ja = "æœ¬",
		es = "libro",
		fr = "livre",
		de = "Buch",
		tl = "aklat",
		category1 = "n",
		category2 = { ja = "ãƒ¢ãƒ", es = "objeto", fr = "objet", de = "Gegenstand", tl = "bagay" },
	},
	{
		no = 7,
		word = "eat",
		ja = "é£Ÿã¹ã‚‹",
		es = "comer",
		fr = "manger",
		de = "essen",
		tl = "kumain",
		category1 = "v",
		category2 = { ja = "è¡Œå‹•", es = "acciÃ³n", fr = "action", de = "Handlung", tl = "kilos" },
	},
	{
		no = 8,
		word = "red",
		ja = "èµ¤",
		es = "rojo",
		fr = "rouge",
		de = "rot",
		tl = "pula",
		category1 = "o",
		category2 = { ja = "è‰²", es = "color", fr = "couleur", de = "Farbe", tl = "kulay" },
	},
	{
		no = 9,
		word = "water",
		ja = "æ°´",
		es = "agua",
		fr = "eau",
		de = "Wasser",
		tl = "tubig",
		category1 = "n",
		category2 = { ja = "è‡ªç„¶", es = "naturaleza", fr = "nature", de = "Natur", tl = "kalikasan" },
	},
	{
		no = 10,
		word = "happy",
		ja = "å¹¸ã›",
		es = "feliz",
		fr = "heureux",
		de = "glÃ¼cklich",
		tl = "masaya",
		category1 = "a",
		category2 = { ja = "æ°—æŒã¡", es = "sentimiento", fr = "sentiment", de = "GefÃ¼hl", tl = "damdamin" },
	},
}

===== ./ReplicatedStorage/FieldGen.lua =====
-- ReplicatedStorage/FieldGen

local FieldGen = {}

-- ãƒã‚¤ã‚ºé–¢æ•°ï¼ˆå¤‰æ›´ãªã—ï¼‰
local function noise2D(x, z, scale)
	local s = (x / scale + z / scale * 57)
	return (math.sin(s * 12.9898) * 43758.5453) % 1
end

local function smoothNoise(x, z, scale)
	local intX, intZ = math.floor(x / scale), math.floor(z / scale)
	local fracX, fracZ = (x / scale) - intX, (z / scale) - intZ

	local v1 = noise2D(intX, intZ, 1)
	local v2 = noise2D(intX + 1, intZ, 1)
	local v3 = noise2D(intX, intZ + 1, 1)
	local v4 = noise2D(intX + 1, intZ + 1, 1)

	local i1 = v1 * (1 - fracX) + v2 * fracX
	local i2 = v3 * (1 - fracX) + v4 * fracX

	return i1 * (1 - fracZ) + i2 * fracZ
end

-- ã€æœ€é©åŒ–1ã€‘ãƒãƒƒãƒç”Ÿæˆã‚·ã‚¹ãƒ†ãƒ 
local function fillTerrainBatch(terrain, blocks)
	local batchSize = 200 -- ä¸€åº¦ã«å‡¦ç†ã™ã‚‹æ•°
	local totalBlocks = #blocks
	print("[FieldGen] ãƒãƒƒãƒç”Ÿæˆã‚¹ã‚¿ãƒ¼ãƒˆ")
	for i = 1, totalBlocks, batchSize do
		local endIdx = math.min(i + batchSize - 1, totalBlocks)

		for j = i, endIdx do
			local block = blocks[j]
			terrain:FillBlock(block.cframe, block.size, block.material)
		end

		-- ã‚µãƒ¼ãƒãƒ¼ã®è² è·åˆ†æ•£
		if i % 2000 == 0 then
			task.wait()
			print(("[FieldGen] é€²è¡ŒçŠ¶æ³: %d/%d (%.1f%%)"):format(i, totalBlocks, i / totalBlocks * 100))
		end
	end
	print("[FieldGen] ãƒãƒƒãƒç”Ÿæˆçµ‚äº†")
end

-- ReplicatedStorage/FieldGen.lua
-- ã€ä¿®æ­£ã€‘generateIsland é–¢æ•°å…¨ä½“
function FieldGen.generateIsland(config)
	-- å³¶ãƒ”ãƒ³ï¼ˆåœ°é¢ã‹ã‚‰ã®ç™ºå…‰ãƒãƒ¼ãƒ«ï¼‹å…ˆç«¯ãƒ©ãƒ™ãƒ«ï¼‰ç”Ÿæˆ
	local function createIslandLabel(cfg)
		if not (cfg and cfg.showIslandLabel) then
			return
		end

		-- ---------------------------
		-- 1) World ãƒ•ã‚©ãƒ«ãƒ€ã¨æ—¢å­˜æƒé™¤
		-- ---------------------------
		local worldFolder = workspace:FindFirstChild("World")
		if not worldFolder then
			worldFolder = Instance.new("Folder")
			worldFolder.Name = "World"
			worldFolder.Parent = workspace
		end

		-- åå‰ãƒ™ãƒ¼ã‚¹
		local baseName = tostring(cfg.name or "Island")
		-- æ®‹ã£ã¦ã„ã‚‹å¤ã„ã‚¢ãƒ³ã‚«ãƒ¼é¡ã‚’æƒé™¤
		for _, child in ipairs(worldFolder:GetChildren()) do
			if child:IsA("BasePart") then
				if
					child.Name == (baseName .. "_LabelAnchor")
					or child.Name == (baseName .. "_Pin")
					or child.Name == (baseName .. "_NameAnchor")
				then
					child:Destroy()
				end
			end
		end

		-- ---------------------------
		-- 2) åœ°é¢Yã‚’æ¸¬ã£ã¦ãƒ”ãƒ³ã®å¯¸æ³•ã‚’æ±ºã‚ã‚‹
		-- ---------------------------
		local x, z = cfg.centerX, cfg.centerZ
		local startY = (cfg.baseY or 0) + (cfg.thickness or 0) + 200 -- å……åˆ†ä¸Šã‹ã‚‰è½ã¨ã™
		local rayParams = RaycastParams.new()
		rayParams.FilterType = Enum.RaycastFilterType.Include
		rayParams.FilterDescendantsInstances = { workspace.Terrain }
		rayParams.IgnoreWater = false

		local res = workspace:Raycast(Vector3.new(x, startY, z), Vector3.new(0, -5000, 0), rayParams)
		local groundY = res and res.Position.Y or ((cfg.baseY or 0) + 1)

		-- ãƒ”ãƒ³ã®é«˜ã•ï¼šå³¶è¡¨é¢ï¼ˆã ã„ãŸã„ baseY+thicknessï¼‰ã¾ã§ä¼¸ã°ã—ã€å°‘ã—é ­å‡ºã—
		local islandTopY = (cfg.baseY or 0) + (cfg.thickness or 0)
		local poleHeight = math.max(12, (islandTopY - groundY) + (cfg.labelOffsetY or 6))

		-- 3) æ—¢å­˜æƒé™¤ï¼ˆé‡è¤‡é˜²æ­¢ï¼‰â€» _PinBase/_PinBeam/_PinCyl ã‚‚æ¶ˆã™
		for _, child in ipairs(worldFolder:GetChildren()) do
			if child:IsA("BasePart") then
				if
					child.Name == (baseName .. "_LabelAnchor")
					or child.Name == (baseName .. "_Pin")
					or child.Name == (baseName .. "_PinBase")
					or child.Name == (baseName .. "_NameAnchor")
					or child.Name == (baseName .. "_PinCyl")
				then
					child:Destroy()
				end
			elseif child:IsA("Beam") and child.Name == (baseName .. "_PinBeam") then
				child:Destroy()
			end
		end

		-- 3-a) é€æ˜ã®åŸºéƒ¨/å…ˆç«¯ã‚¢ãƒ³ã‚«ãƒ¼ï¼ˆAttachmentç”¨ï¼‰
		local base = Instance.new("Part")
		base.Name = baseName .. "_PinBase"
		base.Anchored = true
		base.CanCollide = false
		base.CanQuery = false
		base.CastShadow = false
		base.Transparency = 1
		base.Size = Vector3.new(0.2, 0.2, 0.2)
		base.CFrame = CFrame.new(x, groundY + 0.1, z)
		base.Parent = worldFolder

		local tip = Instance.new("Part")
		tip.Name = baseName .. "_NameAnchor"
		tip.Anchored = true
		tip.CanCollide = false
		tip.CanQuery = false
		tip.CastShadow = false
		tip.Transparency = 1
		tip.Size = Vector3.new(0.2, 0.2, 0.2)
		tip.CFrame = CFrame.new(x, groundY + poleHeight, z)
		tip.Parent = worldFolder

		local a0 = Instance.new("Attachment")
		a0.Name = "PinA0"
		a0.Parent = base
		local a1 = Instance.new("Attachment")
		a1.Name = "PinA1"
		a1.Parent = tip

		-- 3-b) Beamï¼ˆåœ°é¢â†’å…ˆç«¯ã®å…‰ã‚‹ç·šï¼‰
		local beam = Instance.new("Beam")
		beam.Name = baseName .. "_PinBeam"
		beam.Attachment0 = a0
		beam.Attachment1 = a1
		beam.FaceCamera = false
		beam.Width0 = 1.2
		beam.Width1 = 1.2
		beam.LightEmission = 1
		beam.LightInfluence = 0
		beam.Transparency = NumberSequence.new(0)
		beam.Color = ColorSequence.new(Color3.fromRGB(255, 223, 79))
		beam.Segments = 12
		beam.Parent = worldFolder -- â† å®‰å®šã®ãŸã‚ World ç›´ä¸‹

		-- 3-c) è¦–èªæ€§ã®ãŸã‚ã®â€œç¸¦ã®æ£’â€ãƒ–ãƒ­ãƒƒã‚¯ï¼ˆNeonï¼‰
		local solid = Instance.new("Part")
		solid.Name = baseName .. "_PinSolid"
		solid.Anchored = true
		solid.CanCollide = false
		solid.CanQuery = false
		solid.CastShadow = false
		solid.Material = Enum.Material.Neon
		solid.Color = Color3.fromRGB(255, 223, 79)
		-- ç¸¦æ–¹å‘(Y)ã«é•·ã„æ£’ï¼šå¹…0.6 Ã— é«˜ã• poleHeight Ã— å¥¥è¡Œ0.6
		solid.Size = Vector3.new(0.6, poleHeight, 0.6)
		solid.CFrame = CFrame.new(x, groundY + poleHeight * 0.5, z)
		solid.Parent = worldFolder

		-- ï¼ˆä»»æ„ï¼‰Cylinder ã‚’ä½µèµ°ã•ã›ãŸã„å ´åˆã¯ç¸¦å‘ãã«90åº¦å›ã—ã¦é…ç½®
		-- â€» Robloxã®Cylinderã¯â€œé•·æ‰‹ãŒXè»¸â€ãªã®ã§ã€Zè»¸ã¸90åº¦å›ã—ã¦â€œç¸¦(Y)â€ã«ã—ã¾ã™
		--[[
local cyl = Instance.new("Part")
cyl.Name = baseName .. "_PinCyl"
cyl.Anchored = true
cyl.CanCollide = false
cyl.CanQuery = false
cyl.CastShadow = false
cyl.Material = Enum.Material.Neon
cyl.Color = Color3.fromRGB(255, 223, 79)
local radius = 0.5
cyl.Shape = Enum.PartType.Cylinder
cyl.Size = Vector3.new(poleHeight, radius * 2, radius * 2) -- é•·æ‰‹ã‚’Xè»¸ã«æŒã¤ãŸã‚ã€X=é«˜ã•
cyl.CFrame = CFrame.new(x, groundY + poleHeight * 0.5, z) * CFrame.Angles(0, 0, math.rad(90))
cyl.Parent = worldFolder
]]

		-- 3-d) å…ˆç«¯ã‚°ãƒ­ãƒ¼ï¼ˆæ§ãˆã‚ã«ï¼‰
		local glow = Instance.new("PointLight")
		glow.Brightness = 1.5
		glow.Range = math.clamp(poleHeight * 0.6, 8, 40)
		glow.Color = Color3.fromRGB(255, 223, 79)
		glow.Parent = tip

		-- ---------------------------
		-- 4) å…ˆç«¯ã‚¢ãƒ³ã‚«ãƒ¼ï¼ˆå°ã•ãªé€æ˜ãƒ‘ãƒ¼ãƒ„ï¼‰
		-- ---------------------------
		local tip = Instance.new("Part")
		tip.Name = baseName .. "_NameAnchor"
		tip.Anchored = true
		tip.CanCollide = false
		tip.CanQuery = false
		tip.CastShadow = false
		tip.Transparency = 1
		tip.Size = Vector3.new(0.2, 0.2, 0.2)
		tip.CFrame = CFrame.new(x, groundY + poleHeight, z)
		tip.Parent = worldFolder

		-- ---------------------------
		-- 5) å³¶åã ã‘ã® BillboardGuiï¼ˆåº§æ¨™ã¯å‡ºã•ãªã„ï¼‰
		-- ---------------------------
		local bb = Instance.new("BillboardGui")
		bb.Name = "Nameplate"
		bb.AlwaysOnTop = true
		bb.MaxDistance = cfg.labelMaxDistance or 5000
		bb.Size = UDim2.fromOffset(140, 40) -- å°ã•ã‚
		bb.Parent = tip

		local bg = Instance.new("Frame")
		bg.BackgroundTransparency = 0.25
		bg.BackgroundColor3 = Color3.fromRGB(10, 10, 10)
		bg.BorderSizePixel = 0
		bg.Size = UDim2.fromScale(1, 1)
		bg.Parent = bb
		local corner = Instance.new("UICorner")
		corner.CornerRadius = UDim.new(0, 8)
		corner.Parent = bg

		local label = Instance.new("TextLabel")
		label.BackgroundTransparency = 1
		label.Size = UDim2.fromScale(1, 1)
		label.TextWrapped = true
		label.RichText = false
		label.Font = cfg._labelFont or Enum.Font.GothamBold
		label.TextScaled = false
		label.TextSize = cfg._labelTextSize or 16
		label.TextColor3 = Color3.fromRGB(255, 255, 255)
		label.TextStrokeTransparency = 0.5
		label.Text = tostring(cfg.name or "Island") -- å³¶åã ã‘
		label.Parent = bg
		local pad = Instance.new("UIPadding")
		pad.PaddingTop, pad.PaddingBottom = UDim.new(0, 6), UDim.new(0, 6)
		pad.PaddingLeft, pad.PaddingRight = UDim.new(0, 10), UDim.new(0, 10)
		pad.Parent = bg

		-- ---------------------------
		-- 6) ãƒ­ã‚°å‡ºåŠ›ï¼ˆå³¶åã¨(X,Z)ã®ãƒšã‚¢ï¼‰
		-- ---------------------------
		-- print(("[IslandPin] %s\t(%.1f, %.1f)"):format(baseName, cfg.centerX, cfg.centerZ))
		local cx = tonumber(cfg.centerX) or 0
		local cz = tonumber(cfg.centerZ) or 0
		print(string.format("[IslandPin] %s\t(%.1f, %.1f)", baseName, cx, cz))
	end

	local terrain = workspace.Terrain

	local cfg = {
		name = config.name or "Island",
		centerX = config.centerX or 0,
		centerZ = config.centerZ or 0,
		sizeXZ = config.sizeXZ or 500,
		baseY = config.baseY or 0,
		thickness = config.thickness or 10,
		hillAmplitude = config.hillAmplitude or 20,
		hillScale = config.hillScale or 150,
		seed = config.seed or 12345,
		generateOcean = config.generateOcean ~= false,
		oceanRadius = config.oceanRadius or 1500,
		grid = config.grid or 12,
		showIslandLabel = config.showIslandLabel,
		labelOffsetY = config.labelOffsetY,
		labelMaxDistance = config.labelMaxDistance,
		_labelFont = config._labelFont,
		_labelTextSize = config._labelTextSize,
		_labelBgTrans = config._labelBgTrans,

		-- ã€ä¿®æ­£ç‚¹ Aã€‘æ–°ã—ã„ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’å–å¾—ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ Grass ã«è¨­å®š
		baseMaterial = config.baseMaterial or Enum.Material.Grass,
	}

	-- print(("[FieldGen] ç”Ÿæˆé–‹å§‹: %s at (%.0f, %.0f, Material: %s)"):format(cfg.name, cfg.centerX, cfg.centerZ, tostring(cfg.baseMaterial)))

	math.randomseed(cfg.seed)

	local halfSize = cfg.sizeXZ / 2
	local oceanY = cfg.baseY - 10
	local cliffHeight = oceanY + 8

	-- ã€é‡è¦ã€‘ãƒ–ãƒ­ãƒƒã‚¯ã‚’é…åˆ—ã«æºœã‚ã¦ã‹ã‚‰ãƒãƒƒãƒå‡¦ç†
	local terrainBlocks = {}
	local waterBlocks = {}

	-- åœ°å½¢ãƒ–ãƒ­ãƒƒã‚¯ã‚’æº–å‚™
	for x = -halfSize, halfSize, cfg.grid do
		for z = -halfSize, halfSize, cfg.grid do
			local worldX = cfg.centerX + x
			local worldZ = cfg.centerZ + z

			local distFromCenter = math.sqrt(x * x + z * z)
			local normalizedDist = distFromCenter / halfSize
			local edgeFade = math.max(0, 1 - normalizedDist * 1.2)

			if edgeFade > 0 then
				local height = smoothNoise(worldX + cfg.seed, worldZ + cfg.seed, cfg.hillScale)
				local hillY = cfg.baseY + (height * cfg.hillAmplitude * edgeFade)
				local targetY = math.max(hillY, cliffHeight)

				table.insert(terrainBlocks, {
					cframe = CFrame.new(worldX, targetY - cfg.thickness / 2, worldZ),
					size = Vector3.new(cfg.grid, cfg.thickness, cfg.grid),

					-- ã€ä¿®æ­£ç‚¹ Bã€‘ãƒãƒ¼ãƒ‰ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸ Material ã‚’è¨­å®šå€¤ã«ç½®ãæ›ãˆ
					material = cfg.baseMaterial,
				})
			end
		end
	end

	-- print(("[FieldGen] åœ°å½¢ãƒ–ãƒ­ãƒƒã‚¯æ•°: %d"):format(#terrainBlocks))
	fillTerrainBatch(terrain, terrainBlocks)
	createIslandLabel(cfg)

	-- æµ·ã®ç”Ÿæˆ
	if cfg.generateOcean then
		local oceanGrid = 20
		local oceanHalfSize = cfg.oceanRadius / 2
		local maxDistWithTerrain = halfSize * 0.8

		for x = -oceanHalfSize, oceanHalfSize, oceanGrid do
			for z = -oceanHalfSize, oceanHalfSize, oceanGrid do
				local dist = math.sqrt(x * x + z * z)
				if dist > maxDistWithTerrain then
					table.insert(waterBlocks, {
						cframe = CFrame.new(cfg.centerX + x, oceanY, cfg.centerZ + z),
						size = Vector3.new(oceanGrid, 20, oceanGrid),
						material = Enum.Material.Water,
					})
				end
			end
		end

		print(("[FieldGen] æµ·ãƒ–ãƒ­ãƒƒã‚¯æ•°: %d"):format(#waterBlocks))
		fillTerrainBatch(terrain, waterBlocks)
	end

	-- ãƒãƒ¼ã‚«ãƒ¼ä½œæˆ
	local worldFolder = workspace:FindFirstChild("World")
	if not worldFolder then
		worldFolder = Instance.new("Folder")
		worldFolder.Name = "World"
		worldFolder.Parent = workspace
	end

	-- ğŸŒ³ã€è¿½åŠ ã€‘FieldObjectsï¼ˆæœ¨ã‚„å²©ãªã©ï¼‰ã‚’é…ç½®ã™ã‚‹
	if config.fieldObjects then
		print("[FieldGen]config.fieldObjetsã«å…¥ã‚Šã¾ã—ãŸ")
		local templateFolder = game:GetService("ServerStorage"):FindFirstChild("FieldObjectTemplates")
		if not templateFolder then
			warn("[FieldGen] FieldObjectTemplates ãƒ•ã‚©ãƒ«ãƒ€ãŒ ServerStorage ã«å­˜åœ¨ã—ã¾ã›ã‚“")
			return
		end

		local fieldFolder = workspace:FindFirstChild("FieldObjects")
		if not fieldFolder then
			fieldFolder = Instance.new("Folder")
			fieldFolder.Name = "FieldObjects"
			fieldFolder.Parent = workspace
		end

		for _, obj in ipairs(config.fieldObjects) do
			local template = templateFolder:FindFirstChild(obj.model)
			if template then
				local instance = template:Clone()
				instance.Anchored = true
				instance.Position = Vector3.new(unpack(obj.position))

				if obj.size then
					instance.Size = instance.Size * obj.size
				end

				if obj.rotationY then
					instance.Orientation = Vector3.new(0, obj.rotationY, 0)
				end

				instance.Parent = fieldFolder
			else
				warn(("[FieldGen] ãƒ¢ãƒ‡ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: %s"):format(obj.model))
			end
		end
	end

	-- print(("[FieldGen] å®Œäº†: %s"):format(cfg.name))
end

-- ãƒ¬ã‚¤ã‚­ãƒ£ã‚¹ãƒˆï¼ˆå¤‰æ›´ãªã—ï¼‰
function FieldGen.raycastGroundY(x, z, startY)
	startY = startY or 500

	local params = RaycastParams.new()
	params.FilterType = Enum.RaycastFilterType.Include
	params.FilterDescendantsInstances = { workspace.Terrain }
	params.IgnoreWater = false

	local origin = Vector3.new(x, startY, z)
	local direction = Vector3.new(0, -startY - 500, 0)

	local result = workspace:Raycast(origin, direction, params)
	return result and result.Position.Y or nil
end

-- æ©‹ã®ç”Ÿæˆï¼ˆãƒãƒƒãƒå‡¦ç†ç‰ˆï¼‰
function FieldGen.generateBridge(fromIsland, toIsland, config)
	local terrain = workspace.Terrain

	local cfg = {
		name = config.name or "Bridge",
		width = config.width or 20,
		height = config.height or 5,
		thickness = config.thickness or 5,
	}

	print(("[FieldGen] æ©‹ã‚’ç”Ÿæˆä¸­: %s"):format(cfg.name))

	local x1, z1 = fromIsland.centerX, fromIsland.centerZ
	local x2, z2 = toIsland.centerX, toIsland.centerZ

	local dx = x2 - x1
	local dz = z2 - z1
	local distance = math.sqrt(dx * dx + dz * dz)

	local bridgeY = ((fromIsland.baseY or 0) + (toIsland.baseY or 0)) / 2 + cfg.height
	local segments = math.ceil(distance / 10)

	local bridgeBlocks = {}

	for i = 0, segments do
		local t = i / segments
		local x = x1 + dx * t
		local z = z1 + dz * t

		local perpX = -dz / distance
		local perpZ = dx / distance

		for w = -cfg.width / 2, cfg.width / 2, 8 do
			local worldX = x + perpX * w
			local worldZ = z + perpZ * w

			table.insert(bridgeBlocks, {
				cframe = CFrame.new(worldX, bridgeY, worldZ),
				size = Vector3.new(8, cfg.thickness, 8),
				material = Enum.Material.Slate,
			})
		end
	end

	fillTerrainBatch(terrain, bridgeBlocks)
	createIslandLabel(cfg)
	print(("[FieldGen] æ©‹ç”Ÿæˆå®Œäº†: %s (è·é›¢: %.1f)"):format(cfg.name, distance))
end

-- ===== Field Objects Placement =====
local ServerStorage = game:GetService("ServerStorage")

local function ensureFolder(parent: Instance, name: string): Instance
	local f = parent:FindFirstChild(name)
	if not f then
		f = Instance.new("Folder")
		f.Name = name
		f.Parent = parent
	end
	return f
end

local function setAnchoredAll(inst: Instance, anchored: boolean)
	for _, d in ipairs(inst:GetDescendants()) do
		if d:IsA("BasePart") then
			d.Anchored = anchored
		end
	end
end

local function ensurePrimaryPart(model: Model)
	if model.PrimaryPart then
		return
	end
	local pp = model:FindFirstChild("HumanoidRootPart") or model:FindFirstChildWhichIsA("BasePart")
	if pp then
		model.PrimaryPart = pp
	end
end

local function pivotModel(model: Model, cf: CFrame)
	ensurePrimaryPart(model)
	if model.PrimaryPart then
		model:PivotTo(cf)
	else
		-- ã©ã†ã—ã¦ã‚‚PrimaryPartãŒç„¡ã„å ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
		for _, d in ipairs(model:GetDescendants()) do
			if d:IsA("BasePart") then
				d.CFrame = cf
			end
		end
	end
end

function FieldGen.placeFieldObjects(continentName: string?, objects: { any }, player: Player?)
	if not objects or #objects == 0 then
		return
	end

	task.wait(1)

	-- ã€ä¿®æ­£ã€‘å…¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å–å¾—æ¸ˆã¿ã‚¢ã‚¤ãƒ†ãƒ ã‚’åé›†
	local allCollectedItems = {}
	local Players = game:GetService("Players")
	local ServerScriptService = game:GetService("ServerScriptService")

	local success, PlayerStatsModule = pcall(function()
		return require(ServerScriptService:WaitForChild("PlayerStats"))
	end)

	if success then
		-- å…¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ãƒ«ãƒ¼ãƒ—
		for _, plr in ipairs(Players:GetPlayers()) do
			local stats = PlayerStatsModule.getStats(plr)
			if stats and stats.CollectedItems then
				-- å…¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å–å¾—æ¸ˆã¿ã‚¢ã‚¤ãƒ†ãƒ ã‚’ãƒãƒ¼ã‚¸
				for chestId, _ in pairs(stats.CollectedItems) do
					allCollectedItems[chestId] = true
				end

				print(("[FieldGen] %s ã®å–å¾—æ¸ˆã¿ã‚¢ã‚¤ãƒ†ãƒ ã‚’èª­ã¿è¾¼ã¿"):format(plr.Name))
			end
		end

		-- ã€ãƒ‡ãƒãƒƒã‚°ã€‘å–å¾—æ¸ˆã¿ã‚¢ã‚¤ãƒ†ãƒ ç·æ•°ã‚’è¡¨ç¤º
		local count = 0
		for _ in pairs(allCollectedItems) do
			count = count + 1
		end
		print(("[FieldGen] å…¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å–å¾—æ¸ˆã¿ã‚¢ã‚¤ãƒ†ãƒ ç·æ•°: %d"):format(count))

		-- å…·ä½“çš„ãªIDã‚’è¡¨ç¤º
		for chestId, _ in pairs(allCollectedItems) do
			print(("[FieldGen] å–å¾—æ¸ˆã¿: %s"):format(chestId))
		end
	else
		warn("[FieldGen] PlayerStatsModuleã®èª­ã¿è¾¼ã¿ã«å¤±æ•—")
	end

	local ServerStorage = game:GetService("ServerStorage")
	local templatesRoot = ServerStorage:FindFirstChild("FieldObjects")
	if not templatesRoot then
		warn("[FieldGen] ServerStorage/FieldObjects ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚é…ç½®ã‚¹ã‚­ãƒƒãƒ—")
		return
	end

	local function ensureFolder(parent: Instance, name: string): Instance
		local f = parent:FindFirstChild(name)
		if not f then
			f = Instance.new("Folder")
			f.Name = name
			f.Parent = parent
		end
		return f
	end

	local function setAnchoredAll(inst: Instance, anchored: boolean)
		for _, d in ipairs(inst:GetDescendants()) do
			if d:IsA("BasePart") then
				d.Anchored = anchored
			end
		end
	end

	local function ensurePrimaryPart(model: Model)
		if model.PrimaryPart then
			return
		end
		local pp = model:FindFirstChild("HumanoidRootPart") or model:FindFirstChildWhichIsA("BasePart")
		if pp then
			model.PrimaryPart = pp
		end
	end

	local function pivotModel(model: Model, cf: CFrame)
		ensurePrimaryPart(model)
		if model.PrimaryPart then
			model:PivotTo(cf)
		else
			for _, d in ipairs(model:GetDescendants()) do
				if d:IsA("BasePart") then
					d.CFrame = cf
				end
			end
		end
	end

	local root = ensureFolder(workspace, "FieldObjects")
	local parentFolder = continentName and ensureFolder(root, continentName) or root

	-- åœ°é¢ãƒ¬ã‚¤ã‚­ãƒ£ã‚¹ãƒˆï¼ˆæ³•ç·šã‚‚å–å¾—ï¼‰
	local function rayToTerrain(x: number, z: number, startY: number)
		local params = RaycastParams.new()
		params.FilterType = Enum.RaycastFilterType.Include
		params.FilterDescendantsInstances = { workspace.Terrain }
		params.IgnoreWater = false
		local origin = Vector3.new(x, startY, z)
		local result = workspace:Raycast(origin, Vector3.new(0, -startY - 1000, 0), params)
		return result -- result.Position, result.Normal ã‚’æŒã¤
	end

	for _, obj in ipairs(objects) do
		-- å–å¾—æ¸ˆã¿ã‚¢ã‚¤ãƒ†ãƒ ã¯ã‚¹ã‚­ãƒƒãƒ—
		if obj.interaction and obj.interaction.chestId then
			local chestId = obj.interaction.chestId

			if allCollectedItems[chestId] then
				print(("[FieldGen] â­ï¸ å–å¾—æ¸ˆã¿ã®ãŸã‚é…ç½®ã‚¹ã‚­ãƒƒãƒ—: %s"):format(chestId))
				continue
			else
				print(("[FieldGen] âœ… é…ç½®ã—ã¾ã™: %s"):format(chestId))
			end
		end

		local template = templatesRoot:FindFirstChild(tostring(obj.model or ""))
		if not template then
			warn(("[FieldGen] ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: %s"):format(tostring(obj.model)))
			continue
		end

		local p = obj.position or { 0, 0, 0 }
		local x, y, z = p[1] or 0, p[2] or 0, p[3] or 0

		local clone = template:Clone()
		setAnchoredAll(clone, true) -- ãƒ‡ãƒ•ã‚©ã§ã‚¢ãƒ³ã‚«ãƒ¼å›ºå®š

		-- ã‚¹ã‚±ãƒ¼ãƒ«
		local scale = tonumber(obj.size) or 1
		if clone:IsA("Model") then
			if scale ~= 1 then
				pcall(function()
					clone:ScaleTo(scale)
				end)
			end
		elseif clone:IsA("BasePart") then
			if scale ~= 1 then
				clone.Size = clone.Size * scale
			end
		end

		-- Upè»¸è£œæ­£
		local upAxis = tostring(obj.upAxis or "Y")
		local baseRot = CFrame.new()
		if upAxis == "Z" then
			baseRot = CFrame.Angles(math.rad(-90), 0, 0)
		elseif upAxis == "X" then
			baseRot = CFrame.Angles(0, 0, math.rad(90))
		end

		-- è¿½åŠ å›è»¢ï¼ˆrotation = {x,y,z} or å€‹åˆ¥æŒ‡å®šï¼‰
		local rot = obj.rotation or {}
		local rx = math.rad(rot[1] or obj.rotationX or 0)
		local ry = math.rad(rot[2] or obj.rotationY or 0)
		local rz = math.rad(rot[3] or obj.rotationZ or 0)
		local userRot = CFrame.Angles(rx, ry, rz)

		-- === é…ç½®ãƒ¢ãƒ¼ãƒ‰å‡¦ç† ===
		local mode = obj.mode or "ground" -- æ—¢å®š: ground
		local offset = tonumber(obj.groundOffset) or 0
		local align = (obj.alignToSlope == true)

		if mode == "fixed" then
			-- ===== åº§æ¨™å›ºå®šãƒ¢ãƒ¼ãƒ‰ =====
			-- æŒ‡å®šåº§æ¨™ã«ãã®ã¾ã¾é…ç½®ï¼ˆç©ºä¸­ã‚‚å¯èƒ½ï¼‰
			local finalCF = CFrame.new(x, y, z) * baseRot * userRot

			if clone:IsA("Model") then
				pivotModel(clone, finalCF)
			elseif clone:IsA("BasePart") then
				clone.CFrame = finalCF
			end

			print(("[FieldGen] '%s' å›ºå®šé…ç½® at (%.1f, %.1f, %.1f)"):format(tostring(obj.model), x, y, z))
		else
			-- ===== åœ°é¢æ¥åœ°ãƒ¢ãƒ¼ãƒ‰ï¼ˆæ—¢å®šï¼‰ =====
			local startY = 3000
			local hit = nil
			do
				local params = RaycastParams.new()
				params.FilterType = Enum.RaycastFilterType.Include
				params.FilterDescendantsInstances = { workspace.Terrain }
				params.IgnoreWater = false
				hit = workspace:Raycast(Vector3.new(x, startY, z), Vector3.new(0, -6000, 0), params)
			end

			if hit then
				local groundY = hit.Position.Y
				local up = align and hit.Normal or Vector3.yAxis

				print(
					("[FieldGen] '%s' æ¥åœ° at (%.1f, _, %.1f), groundY=%.1f, offset=%.2f"):format(
						tostring(obj.model),
						x,
						z,
						groundY,
						offset
					)
				)

				if clone:IsA("Model") then
					-- Step 1: å›è»¢ã®ã¿é©ç”¨ã—ã¦ä»®é…ç½®
					local tempCF = CFrame.new(x, groundY + 100, z) * baseRot * userRot
					pivotModel(clone, tempCF)

					-- Step 2: ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹ã®åº•é¢ã‚’å–å¾—
					local bbCFrame, bbSize = clone:GetBoundingBox()
					local bottomY = bbCFrame.Position.Y - (bbSize.Y * 0.5)

					-- Step 3: åº•é¢ãŒåœ°é¢ã«æ¥ã™ã‚‹ã‚ˆã†ã«èª¿æ•´
					local deltaY = (groundY + offset) - bottomY

					if align then
						-- æ–œé¢å¯¾å¿œ
						local look = clone:GetPivot().LookVector
						local tangent = (look - look:Dot(up) * up).Unit
						local right = tangent:Cross(up).Unit
						local pos = bbCFrame.Position + Vector3.new(0, deltaY, 0)
						local newCF = CFrame.fromMatrix(pos, right, up)
						pivotModel(clone, newCF)
					else
						-- å‚ç›´é…ç½®
						pivotModel(clone, clone:GetPivot() + Vector3.new(0, deltaY, 0))
					end
				elseif clone:IsA("BasePart") then
					-- MeshPartã®å ´åˆ
					local height = clone.Size.Y * 0.5

					if align then
						local right = clone.CFrame.RightVector
						local forward = right:Cross(up).Unit
						right = up:Cross(forward).Unit
						clone.CFrame = CFrame.fromMatrix(Vector3.new(x, groundY + height + offset, z), right, up)
					else
						clone.CFrame = CFrame.new(x, groundY + height + offset, z) * (baseRot * userRot)
					end
				end
			else
				warn(("[FieldGen] åœ°é¢æ¤œå‡ºå¤±æ•— at (%.1f, %.1f) for '%s'"):format(x, z, tostring(obj.model)))
			end
		end

		-- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³æƒ…å ±ã‚’Attributeã«è¨­å®š
		if obj.interaction then
			local interaction = obj.interaction

			-- åŸºæœ¬æƒ…å ±
			clone:SetAttribute("HasInteraction", true)
			clone:SetAttribute("InteractionType", interaction.type or "unknown")
			clone:SetAttribute("InteractionAction", interaction.action or "èª¿ã¹ã‚‹")
			clone:SetAttribute("InteractionKey", interaction.key or "E")
			clone:SetAttribute("InteractionRange", interaction.range or 8)

			-- ã‚¿ã‚¤ãƒ—åˆ¥ã®æƒ…å ±
			if interaction.type == "chest" then
				clone:SetAttribute("ChestId", interaction.chestId)
				clone:SetAttribute("OpenedModel", interaction.openedModel)
				clone:SetAttribute("DisplayDuration", interaction.displayDuration or 5)

				-- å ±é…¬æƒ…å ±ã‚’JSONåŒ–ã—ã¦ä¿å­˜
				local HttpService = game:GetService("HttpService")
				local rewardsJson = HttpService:JSONEncode(interaction.rewards or {})
				clone:SetAttribute("RewardsData", rewardsJson)

				print(
					("[FieldGen] ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³è¨­å®š: %s (ChestId: %s, Range: %d)"):format(
						interaction.action,
						interaction.chestId,
						interaction.range
					)
				)

				-- è¨­å®šå¾Œã«ç¢ºèª
				task.wait(0.1)
				if not clone:GetAttribute("HasInteraction") then
					warn(("[FieldGen] âš ï¸ å±æ€§ãŒæ¶ˆãˆãŸ: %s"):format(interaction.chestId))
				end
			end
		end

		clone.Parent = parentFolder
	end
end

--=====================================================
-- Paths (MVP): Catmull-Rom spline -> Terrain FillBlock
--=====================================================

-- {x,y,z} -> Vector3
local function v3(arr)
	return Vector3.new(arr[1] or 0, arr[2] or 0, arr[3] or 0)
end

-- Catmull-Rom è£œé–“ï¼ˆMVP: æ¨™æº–ä¿‚æ•°0.5ï¼‰
local function catmullRom(p0, p1, p2, p3, t: number)
	local t2, t3 = t * t, t * t * t
	-- 0.5 * (2P1 + (-P0+P2)t + (2P0-5P1+4P2-P3)t^2 + (-P0+3P1-3P2+P3)t^3)
	return 0.5 * ((2 * p1) + (-p0 + p2) * t + (2 * p0 - 5 * p1 + 4 * p2 - p3) * t2 + (-p0 + 3 * p1 - 3 * p2 + p3) * t3)
end

-- åŒºé–“é•·ã«å¿œã˜ã¦ã‚µãƒ³ãƒ—ãƒ«æ•°ã‚’æ±ºã‚ã‚‹ï¼ˆç­‰é–“éš”ã£ã½ãï¼‰
local function sampleSegment(p1, p2, stepStuds)
	local dist = (p2 - p1).Magnitude
	local n = math.max(2, math.floor(dist / math.max(0.1, stepStuds)))
	return n
end

-- pointsç«¯ã®ã‚¬ãƒ¼ãƒ‰ï¼ˆp[-1]=p[0], p[n+1]=p[n]ï¼‰
local function getPoint(points, i)
	if i < 1 then
		return points[1]
	elseif i > #points then
		return points[#points]
	else
		return points[i]
	end
end

-- é“ãƒ–ãƒ­ãƒƒã‚¯1æšã‚’Terrainã«å¡—ã‚‹
local function fillRoadSlice(
	terrain,
	centerPos: Vector3,
	forward: Vector3,
	up: Vector3,
	width: number,
	length: number,
	thickness: number,
	material
)
	-- ç›´äº¤åŸºåº•
	local fwd = forward.Magnitude > 0 and forward.Unit or Vector3.zAxis
	local upv = up.Magnitude > 0 and up.Unit or Vector3.yAxis
	local right = fwd:Cross(upv)
	if right.Magnitude < 1e-6 then
		-- ã»ã¼å¹³è¡Œãªã‚‰å³ã‚’Xè»¸ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
		right = Vector3.xAxis
	end
	right = right.Unit
	upv = right:Cross(fwd).Unit

	-- CFrame.fromMatrix(pos, right, up, back)
	local cf = CFrame.fromMatrix(centerPos, right, upv, -fwd)
	local size = Vector3.new(length, thickness, width)
	terrain:FillBlock(cf, size, material)
end

-- å…¬é–‹APIï¼šå¤§é™¸åï¼ˆãƒ­ã‚°/è¦ªãƒ•ã‚©ãƒ«ãƒ€åç”¨ï¼‰ã¨ paths é…åˆ—ã‚’å—ã‘å–ã‚Šã€é“ã‚’Terrainã«å¡—ã‚‹
function FieldGen.buildPaths(continentName: string?, paths: { any })
	if not paths or #paths == 0 then
		return
	end

	local terrain = workspace.Terrain
	local logPrefix = ("[FieldGen/Paths]%s "):format(continentName and ("[" .. continentName .. "]") or "")

	for _, path in ipairs(paths) do
		local pts = path.points or {}
		if #pts < 2 then
			warn(logPrefix .. "points ãŒä¸è¶³ï¼ˆæœ€ä½2ç‚¹ï¼‰: " .. tostring(path.name))
			continue
		end

		-- æ—¢å®šå€¤
		local width = tonumber(path.width) or 12
		local step = tonumber(path.step) or 3 -- ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°é–“éš”ï¼ˆç›®å®‰ï¼‰
		local mat = path.material or Enum.Material.Ground
		local stick = (path.stickToGround ~= false) -- æ—¢å®štrue
		local align = (path.alignToSlope == true) -- æ—¢å®šfalse
		local yOffset = tonumber(path.groundOffset) or 0.05
		local thick = 2 -- åœ°å½¢å¡—ã‚Šåšã¿ï¼ˆåŸ‹ã‚æ¼ã‚Œé˜²æ­¢ï¼‰

		-- Vector3åˆ—ã«å¤‰æ›ï¼ˆYã¯é©å½“ã§ã‚‚OKã€‚ä¸‹ã§å¸ç€ã™ã‚‹ï¼‰
		local P = table.create(#pts)
		for i = 1, #pts do
			P[i] = v3(pts[i])
		end

		local slices = 0
		for seg = 1, #P - 1 do
			-- ã‚»ã‚°ãƒ¡ãƒ³ãƒˆ p1->p2 ã‚’Catmull-Romã§è£œé–“
			local p0 = getPoint(P, seg - 1)
			local p1 = getPoint(P, seg)
			local p2 = getPoint(P, seg + 1)
			local p3 = getPoint(P, seg + 2)

			local n = sampleSegment(p1, p2, step)
			for j = 0, n - 1 do
				local t0 = j / n
				local t1 = (j + 1) / n

				local a = catmullRom(p0, p1, p2, p3, t0)
				local b = catmullRom(p0, p1, p2, p3, t1)
				local mid = (a + b) * 0.5
				local dir = (b - a)
				if dir.Magnitude < 1e-6 then
					dir = Vector3.zAxis
				end

				-- åœ°é¢ã«å¸ç€ï¼ˆã‚µãƒ³ãƒ—ãƒ«åŒºé–“ã®ä¸­å¿ƒç‚¹ï¼‰
				local useY = mid.Y
				local up = Vector3.yAxis
				if stick then
					local startY = 1000
					local params = RaycastParams.new()
					params.FilterType = Enum.RaycastFilterType.Include
					params.FilterDescendantsInstances = { workspace.Terrain }
					params.IgnoreWater = false

					local res = workspace:Raycast(Vector3.new(mid.X, startY, mid.Z), Vector3.new(0, -2000, 0), params)
					if res then
						useY = res.Position.Y + (yOffset or -3)
						if align then
							up = res.Normal
						end
					else
						warn(("åœ°é¢æœªæ¤œå‡º: (%.1f, %.1f)"):format(mid.X, mid.Z))
					end
				end

				-- ãƒ–ãƒ­ãƒƒã‚¯ã®ä¸­å¿ƒã‚’åŠåˆ†æ²ˆã‚ã¦è¨­ç½®
				local centerY = useY - (thick / 2) - 5
				fillRoadSlice(
					terrain,
					Vector3.new(mid.X, centerY, mid.Z),
					dir.Unit,
					up,
					width,
					(b - a).Magnitude,
					thick,
					mat
				)

				slices += 1
			end
		end

		print(
			("%sdraw path '%s': points=%d, slices=%d, width=%.1f, step=%.1f"):format(
				logPrefix,
				tostring(path.name or "?"),
				#P,
				slices,
				width,
				step
			)
		)
	end
end

return FieldGen

===== ./ReplicatedStorage/SharedState.lua =====
-- ReplicatedStorage/SharedState.lua
-- å…±æœ‰çŠ¶æ…‹ç®¡ç†ï¼ˆå¾ªç’°ä¾å­˜ã‚’é˜²ããŸã‚ã®ä¸­å¤®ãƒ‡ãƒ¼ã‚¿ã‚¹ãƒˆã‚¢ï¼‰

local SharedState = {}

-- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼é–¢é€£
SharedState.MonsterCounts = {}
-- å½¢å¼: {[zoneName] = {[monsterName] = count}}
-- ä¾‹: {["ContinentA"] = {["Slime"] = 5, ["Mage"] = 3}}

SharedState.SpawnQueue = {}
-- ãƒªã‚¹ãƒãƒ¼ãƒ³å¾…ã¡ã®ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æƒ…å ±

-- ãƒãƒˆãƒ«é–¢é€£
SharedState.ActiveBattles = {}
-- å½¢å¼: {[player] = battleData}

-- ã‚¾ãƒ¼ãƒ³é–¢é€£
SharedState.PlayerZones = {}
-- å½¢å¼: {[player] = zoneName}

-- ãƒ­ãƒƒã‚¯ç®¡ç†ï¼ˆéåŒæœŸå‡¦ç†ã®æ’ä»–åˆ¶å¾¡ç”¨ï¼‰
SharedState.Locks = {}
-- å½¢å¼: {[lockName] = boolean}

-- ãƒ‡ãƒãƒƒã‚°ç”¨
function SharedState.printState()
	print("[SharedState] === Current State ===")
	print("MonsterCounts:", game:GetService("HttpService"):JSONEncode(SharedState.MonsterCounts))
	print("ActiveBattles:", #SharedState.ActiveBattles)
	print("PlayerZones:", game:GetService("HttpService"):JSONEncode(SharedState.PlayerZones))
	print("Locks:", game:GetService("HttpService"):JSONEncode(SharedState.Locks))
end

print("[SharedState] Module initialized")

return SharedState
===== ./ReplicatedStorage/Monsters/Registry.lua =====
local RS = game:GetService("ReplicatedStorage")
local Monsters = RS:WaitForChild("Monsters")

return {
	require(Monsters.Slime),
	require(Monsters.Slime_pink),
	require(Monsters.golem),
	-- å°†æ¥è¿½åŠ ã™ã‚‹ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼:
	-- require(Monsters.Dragon),
	-- require(Monsters.Goblin),
}

===== ./ReplicatedStorage/Monsters/Slime.lua =====
-- ReplicatedStorage/Monsters/Slime.lua
-- ReplicatedStorage/Monsters/Slime
-- ã‚¹ãƒ©ã‚¤ãƒ ã®å®šç¾©ï¼ˆã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ‹¡å¼µç‰ˆï¼‰

return {
	Name = "Slime",
	TemplatePath = {"ServerStorage", "EnemyTemplates", "Slime"},
	WalkSpeed = 10,
	RespawnTime = 10,

	-- ã€æ–°ã€‘ãƒãƒˆãƒ«ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
	HP = 50,           -- ãƒ©ã‚¤ãƒ•
	Speed = 5,         -- ç´ æ—©ã•
	Attack = 20,        -- æ”»æ’ƒåŠ›
	Defense = 5,       -- å®ˆå‚™åŠ›

	-- ã€æ–°ã€‘å ±é…¬
	Experience = 200,   -- å€’ã—ãŸæ™‚ã«å¾—ã‚‰ã‚Œã‚‹çµŒé¨“å€¤
	Gold = 10,         -- å€’ã—ãŸæ™‚ã«å¾—ã‚‰ã‚Œã‚‹ã‚´ãƒ¼ãƒ«ãƒ‰

	-- ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ãƒ¬ãƒ™ãƒ«ï¼ˆé‡ã¿ä»˜ãï¼‰
	TypingLevels = {
		{level = "level_1", weight = 70},  -- 70%ã®ç¢ºç‡ã§ãƒ¬ãƒ™ãƒ«1
		{level = "level_2", weight = 30},  -- 30%ã®ç¢ºç‡ã§ãƒ¬ãƒ™ãƒ«2
	},

	-- æ—§è¨­å®šï¼ˆäº’æ›æ€§ã®ãŸã‚æ®‹ã™ï¼‰
	Damage = 1,  -- å¾Œã§å‰Šé™¤äºˆå®š

	-- ã‚¹ãƒãƒ¼ãƒ³è¨­å®š
	SpawnLocations = {
		{
			islandName = "Hokkaido_N1",
			count = 7,
			radiusPercent = 95,  -- å³¶ã®ã‚µã‚¤ã‚ºã®75%ç¯„å›²å†…
		},
		{
			islandName = "Hokkaido_N4",
			count = 15,
			radiusPercent = 55,  -- å³¶ã®ã‚µã‚¤ã‚ºã®75%ç¯„å›²å†…
		},
				{
			islandName = "Kyushu_NE1",
			count = 5,
			radiusPercent = 55,  -- å³¶ã®ã‚µã‚¤ã‚ºã®75%ç¯„å›²å†…
		},

	},

	-- AIè¨­å®š
	ChaseDistance = 60,
	EscapeDistance = 80,
	WanderRadius = 30,
	UpdateNearby = 0.2,
	UpdateFar = 1.0,
}
===== ./ReplicatedStorage/Monsters/fire_slime.lua =====
return {
	Name = "fire_slime",
	TemplatePath = { "ServerStorage", "EnemyTemplates", "fire_slime" },
	WalkSpeed = 10,
	RespawnTime = 10,

	-- ã€æ–°ã€‘ãƒãƒˆãƒ«ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
	HP = 250, -- ãƒ©ã‚¤ãƒ•
	Speed = 5, -- ç´ æ—©ã•
	Attack = 20, -- æ”»æ’ƒåŠ›
	Defense = 5, -- å®ˆå‚™åŠ›

	-- ã€æ–°ã€‘å ±é…¬
	Experience = 400, -- å€’ã—ãŸæ™‚ã«å¾—ã‚‰ã‚Œã‚‹çµŒé¨“å€¤
	Gold = 100, -- å€’ã—ãŸæ™‚ã«å¾—ã‚‰ã‚Œã‚‹ã‚´ãƒ¼ãƒ«ãƒ‰

	-- ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ãƒ¬ãƒ™ãƒ«ï¼ˆé‡ã¿ä»˜ãï¼‰
	TypingLevels = {
		{ level = "level_2", weight = 70 }, -- 70%ã®ç¢ºç‡ã§ãƒ¬ãƒ™ãƒ«1
		{ level = "level_3", weight = 30 }, -- 30%ã®ç¢ºç‡ã§ãƒ¬ãƒ™ãƒ«2
	},

	-- æ—§è¨­å®šï¼ˆäº’æ›æ€§ã®ãŸã‚æ®‹ã™ï¼‰
	Damage = 1, -- å¾Œã§å‰Šé™¤äºˆå®š

	-- ã‚¹ãƒãƒ¼ãƒ³è¨­å®š
	SpawnLocations = {
		{
			islandName = "Hokkaido_N1",
			count = 7,
			radiusPercent = 95, -- å³¶ã®ã‚µã‚¤ã‚ºã®75%ç¯„å›²å†…
		},
		{
			islandName = "Hokkaido_N4",
			count = 5,
			radiusPercent = 55, -- å³¶ã®ã‚µã‚¤ã‚ºã®75%ç¯„å›²å†…
		},
		{
			islandName = "Kyushu_NE1",
			count = 5,
			radiusPercent = 55, -- å³¶ã®ã‚µã‚¤ã‚ºã®75%ç¯„å›²å†…
		},
	},

	-- AIè¨­å®š
	ChaseDistance = 60,
	EscapeDistance = 80,
	WanderRadius = 30,
	UpdateNearby = 0.2,
	UpdateFar = 1.0,
}

===== ./ReplicatedStorage/Monsters/Slime_pink.lua =====
return {
	Name = "Slime_pink",
	TemplatePath = {"ServerStorage", "EnemyTemplates", "Slime_pink"},
	WalkSpeed = 5,
	RespawnTime = 5,

	-- ã€æ–°ã€‘ãƒãƒˆãƒ«ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
	HP = 120,           -- ãƒ©ã‚¤ãƒ•
	Speed = 80,         -- ç´ æ—©ã•
	Attack = 40,        -- æ”»æ’ƒåŠ›
	Defense = 12,       -- å®ˆå‚™åŠ›

	-- ã€æ–°ã€‘å ±é…¬
	Experience = 300,   -- å€’ã—ãŸæ™‚ã«å¾—ã‚‰ã‚Œã‚‹çµŒé¨“å€¤
	Gold = 25,         -- å€’ã—ãŸæ™‚ã«å¾—ã‚‰ã‚Œã‚‹ã‚´ãƒ¼ãƒ«ãƒ‰

	-- ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ãƒ¬ãƒ™ãƒ«ï¼ˆé‡ã¿ä»˜ãï¼‰
	TypingLevels = {
		{level = "level_2", weight = 10},  -- 70%ã®ç¢ºç‡ã§ãƒ¬ãƒ™ãƒ«1
		{level = "level_3", weight = 90},  -- 30%ã®ç¢ºç‡ã§ãƒ¬ãƒ™ãƒ«2
	},

	-- æ—§è¨­å®šï¼ˆäº’æ›æ€§ã®ãŸã‚æ®‹ã™ï¼‰
	Damage = 1,  -- å¾Œã§å‰Šé™¤äºˆå®š

	-- ã‚¹ãƒãƒ¼ãƒ³è¨­å®š
	SpawnLocations = {
		{
			islandName = "Hokkaido_N1",
			count = 7,
			radiusPercent = 65,  -- å³¶ã®ã‚µã‚¤ã‚ºã®75%ç¯„å›²å†…
		},
		{
			islandName = "Hokkaido_N4",
			count = 15,
			radiusPercent = 85,  -- å³¶ã®ã‚µã‚¤ã‚ºã®75%ç¯„å›²å†…
		},
				{
			islandName = "Kyushu_NE1",
			count = 5,
			radiusPercent = 55,  -- å³¶ã®ã‚µã‚¤ã‚ºã®75%ç¯„å›²å†…
		},
		{
			islandName = "Kyushu_C22",
			count = 5,
			radiusPercent = 55,  -- å³¶ã®ã‚µã‚¤ã‚ºã®75%ç¯„å›²å†…
		},
		{
			islandName = "ContinentKyushu_C20",
			count = 5,
			radiusPercent = 55,  -- å³¶ã®ã‚µã‚¤ã‚ºã®75%ç¯„å›²å†…
		},
		{
			islandName = "ContinentKyushu_C21",
			count = 5,
			radiusPercent = 55,  -- å³¶ã®ã‚µã‚¤ã‚ºã®75%ç¯„å›²å†…
		},
		{
			islandName = "ContinentKyushu_C22",
			count = 5,
			radiusPercent = 55,  -- å³¶ã®ã‚µã‚¤ã‚ºã®75%ç¯„å›²å†…
		},
--
	},

	-- AIè¨­å®š
	ChaseDistance = 60,
	EscapeDistance = 80,
	WanderRadius = 30,
	UpdateNearby = 0.2,
	UpdateFar = 1.0,
}
===== ./ReplicatedStorage/Monsters/golem.lua =====
return {
	Name = "golem",
	TemplatePath = { "ServerStorage", "EnemyTemplates", "golem" },
	WalkSpeed = 10,
	RespawnTime = 10,

	-- ã€æ–°ã€‘ãƒãƒˆãƒ«ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
	HP = 250, -- ãƒ©ã‚¤ãƒ•
	Speed = 5, -- ç´ æ—©ã•
	Attack = 20, -- æ”»æ’ƒåŠ›
	Defense = 5, -- å®ˆå‚™åŠ›

	-- ã€æ–°ã€‘å ±é…¬
	Experience = 400, -- å€’ã—ãŸæ™‚ã«å¾—ã‚‰ã‚Œã‚‹çµŒé¨“å€¤
	Gold = 100, -- å€’ã—ãŸæ™‚ã«å¾—ã‚‰ã‚Œã‚‹ã‚´ãƒ¼ãƒ«ãƒ‰

	-- ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ãƒ¬ãƒ™ãƒ«ï¼ˆé‡ã¿ä»˜ãï¼‰
	TypingLevels = {
		{ level = "level_2", weight = 70 }, -- 70%ã®ç¢ºç‡ã§ãƒ¬ãƒ™ãƒ«1
		{ level = "level_3", weight = 30 }, -- 30%ã®ç¢ºç‡ã§ãƒ¬ãƒ™ãƒ«2
	},

	-- æ—§è¨­å®šï¼ˆäº’æ›æ€§ã®ãŸã‚æ®‹ã™ï¼‰
	Damage = 1, -- å¾Œã§å‰Šé™¤äºˆå®š

	-- ã‚¹ãƒãƒ¼ãƒ³è¨­å®š
	SpawnLocations = {
		{
			islandName = "Hokkaido_N1",
			count = 3,
			radiusPercent = 95, -- å³¶ã®ã‚µã‚¤ã‚ºã®75%ç¯„å›²å†…
		},
		{
			islandName = "Hokkaido_N4",
			count = 3,
			radiusPercent = 55, -- å³¶ã®ã‚µã‚¤ã‚ºã®75%ç¯„å›²å†…
		},
		{
			islandName = "Kyushu_NE1",
			count = 3,
			radiusPercent = 55, -- å³¶ã®ã‚µã‚¤ã‚ºã®75%ç¯„å›²å†…
		},
	},

	-- AIè¨­å®š
	ChaseDistance = 60,
	EscapeDistance = 80,
	WanderRadius = 30,
	UpdateNearby = 0.2,
	UpdateFar = 1.0,
}

