total 8
drwxr-xr-x  12 yabea  staff  384 10 12 08:58 ReplicatedStorage
drwxr-xr-x  16 yabea  staff  512 10 12 21:46 ServerScriptService
drwxr-xr-x  15 yabea  staff  480 10 12 21:46 StartPlayerScripts
-rwxr-xr-x   1 yabea  staff  976 10  4 11:52 go.sh
-rw-r--r--   1 yabea  staff    0 10 13 04:05 out.txt

./ReplicatedStorage:
total 72
drwxr-xr-x   9 yabea  staff    288 10 11 11:12 Continents
-rw-r--r--   1 yabea  staff  22644 10 12 22:06 FieldGen.lua
drwxr-xr-x   2 yabea  staff     64 10 12 08:58 FieldObjects
-rw-r--r--   1 yabea  staff   2722 10  6 18:17 GameEvents.lua
drwxr-xr-x  10 yabea  staff    320 10 11 11:12 Islands
drwxr-xr-x   5 yabea  staff    160 10  6 14:42 Monsters
-rw-r--r--   1 yabea  staff   1153 10  6 18:17 SharedState.lua
drwxr-xr-x   2 yabea  staff     64 10  4 10:07 Sounds
-rw-r--r--   1 yabea  staff   3512 10  3 18:05 TypingWords.lua

./ReplicatedStorage/Continents:
total 72
-rw-r--r--  1 yabea  staff  5276 10 12 18:55 ContientTown.lua
-rw-r--r--  1 yabea  staff  7568 10 13 00:04 ContinentHokkaido.lua
-rw-r--r--  1 yabea  staff  2819 10 13 00:08 ContinentKyushu.lua
-rw-r--r--  1 yabea  staff   616 10 10 16:43 ContinentShikoku.lua
-rw-r--r--  1 yabea  staff  1079 10 11 11:28 Greenland.lua
-rw-r--r--  1 yabea  staff   428 10 11 11:13 Registry.lua
-rw-r--r--  1 yabea  staff   726 10 11 10:50 Snowland.lua

./ReplicatedStorage/FieldObjects:
total 0

./ReplicatedStorage/Islands:
total 72
-rw-r--r--  1 yabea  staff   162 10  3 18:05 Bridges.lua
-rw-r--r--  1 yabea  staff   910 10 11 11:12 Greenland.lua
-rw-r--r--  1 yabea  staff  3933 10 12 23:45 HokkaidoIslands.lua
-rw-r--r--  1 yabea  staff  5995 10 11 20:41 KyushuIslands.lua
-rw-r--r--  1 yabea  staff  1547 10 11 11:13 Registry.lua
-rw-r--r--  1 yabea  staff  1356 10  6 10:43 ShikokuIslands.lua
-rw-r--r--  1 yabea  staff  3679 10 11 11:06 Snowland.lua
-rw-r--r--  1 yabea  staff  1900 10  5 20:30 Town.lua

./ReplicatedStorage/Monsters:
total 24
-rw-r--r--  1 yabea  staff   260 10 11 16:06 Registry.lua
-rw-r--r--  1 yabea  staff  1359 10  7 09:51 Slime.lua
-rw-r--r--  1 yabea  staff  1709 10 11 20:33 Slime_pink.lua

./ReplicatedStorage/Sounds:
total 0

./ServerScriptService:
total 304
-rw-r--r--  1 yabea  staff  27966 10 10 13:04 BattleSystem.lua
-rw-r--r--  1 yabea  staff  13702 10 10 13:40 Bootstrap.server.lua
-rw-r--r--  1 yabea  staff   3932 10 12 11:46 DataCollectors.lua
-rw-r--r--  1 yabea  staff   3617 10 12 06:34 DataStoreManager.lua
-rw-r--r--  1 yabea  staff   3249 10 13 04:01 DebugCommands.server.lua
-rw-r--r--  1 yabea  staff   3764 10 11 10:30 FastTravelSystem.server.lua
-rw-r--r--  1 yabea  staff   7911 10 12 21:53 InteractionSystem.server.lua
-rw-r--r--  1 yabea  staff    708 10  9 15:11 LoadTest.server.lua
-rw-r--r--  1 yabea  staff  26859 10  9 14:56 MonsterSpawner.server.lua
-rw-r--r--  1 yabea  staff   2313 10  5 17:26 OceanSafety.server.lua
-rw-r--r--  1 yabea  staff  12225 10 12 11:49 PlayerStats.lua
-rw-r--r--  1 yabea  staff   5612 10  5 20:34 TowerPlacement.server.lua
-rw-r--r--  1 yabea  staff  12653 10 10 13:04 WarpPortal.server.lua
-rw-r--r--  1 yabea  staff  10369 10 12 22:07 ZoneManager.lua

./StartPlayerScripts:
total 304
-rw-r--r--  1 yabea  staff   4870 10  5 08:26 BGMManager.client.lua
-rw-r--r--  1 yabea  staff  26090 10  5 20:30 BattleUI.client.lua
-rw-r--r--  1 yabea  staff   7575 10  3 18:05 DeathUI.client.lua
-rw-r--r--  1 yabea  staff   3155 10 12 22:32 DebugButtons.client.lua
-rw-r--r--  1 yabea  staff   7786 10 11 10:36 FastTravelUI.client.lua
-rw-r--r--  1 yabea  staff   5920 10 12 21:52 InteractionUI.client.lua
-rw-r--r--  1 yabea  staff   5844 10  3 18:05 LevelUpUI.client.lua
-rw-r--r--  1 yabea  staff   2872 10  9 20:42 LoadingScreen.client.lua
-rw-r--r--  1 yabea  staff  31638 10  9 15:01 MenuUI.client.lua
-rw-r--r--  1 yabea  staff  20744 10 10 13:40 Minimap.client.lua
-rw-r--r--  1 yabea  staff   5948 10 12 18:45 RewardPopup.client.lua
-rw-r--r--  1 yabea  staff   6847 10  9 13:33 StatusUI.client.lua
-rw-r--r--  1 yabea  staff   2045 10  6 10:49 WarpUI.client.lua
===== ./StartPlayerScripts/DebugButtons.client.lua =====
-- StarterPlayer/StarterPlayerScripts/DebugButtons.client.lua
-- デバッグ用ボタン（開発時のみ使用）

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

print("[DebugButtons] 初期化開始")

-- デバッグモード（本番環境ではfalseに）
local DEBUG_MODE = true

if not DEBUG_MODE then
	print("[DebugButtons] デバッグモードOFF")
	return
end

-- RemoteEvent取得（サーバーが作成するまで待機）
local DebugCommandEvent = ReplicatedStorage:WaitForChild("DebugCommand", 10)
if not DebugCommandEvent then
	warn("[DebugButtons] DebugCommandEventが見つかりません")
	return
end

print("[DebugButtons] RemoteEventを取得しました")

-- ScreenGui作成
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "DebugButtonsUI"
screenGui.ResetOnSpawn = false
screenGui.IgnoreGuiInset = true
screenGui.DisplayOrder = 300
screenGui.Parent = playerGui

-- ボタンコンテナ（右上から左に並ぶ）
local container = Instance.new("Frame")
container.Name = "ButtonContainer"
container.Size = UDim2.new(0, 600, 0, 50)
container.Position = UDim2.new(1, -620, 0, 20) -- 右上
container.BackgroundTransparency = 1
container.Parent = screenGui

local listLayout = Instance.new("UIListLayout")
listLayout.FillDirection = Enum.FillDirection.Horizontal
listLayout.HorizontalAlignment = Enum.HorizontalAlignment.Right
listLayout.VerticalAlignment = Enum.VerticalAlignment.Top
listLayout.Padding = UDim.new(0, 10)
listLayout.Parent = container

-- デバッグボタン作成関数
local function createDebugButton(text, callback)
	local button = Instance.new("TextButton")
	button.Size = UDim2.new(0, 180, 0, 40)
	button.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
	button.BackgroundTransparency = 0.2
	button.BorderSizePixel = 2
	button.BorderColor3 = Color3.new(1, 1, 1)
	button.Text = text
	button.TextColor3 = Color3.new(1, 1, 1)
	button.TextSize = 16
	button.Font = Enum.Font.SourceSansBold
	button.AutoButtonColor = true
	button.Parent = container

	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 8)
	corner.Parent = button

	-- ホバーエフェクト
	button.MouseEnter:Connect(function()
		button.BackgroundTransparency = 0
	end)

	button.MouseLeave:Connect(function()
		button.BackgroundTransparency = 0.2
	end)

	-- クリックイベント
	button.MouseButton1Click:Connect(callback)

	return button
end

-- 【ボタン1】宝箱リセット
createDebugButton("🔄 宝箱リセット", function()
	print("[DebugButtons] 宝箱リセットボタンをクリック")
	DebugCommandEvent:FireServer("reset_chests")
	print("[DebugButtons] サーバーにリセット要求を送信しました")
end)

-- 【将来追加予定のボタン例】
-- createDebugButton("💰 ゴールド+1000", function()
-- 	DebugCommandEvent:FireServer("add_gold", 1000)
-- end)

-- createDebugButton("⬆️ レベルアップ", function()
-- 	DebugCommandEvent:FireServer("level_up")
-- end)

print("[DebugButtons] 初期化完了")
===== ./StartPlayerScripts/Minimap.client.lua =====
-- StarterPlayer/StarterPlayerScripts/Minimap.client.lua
-- ミニマップシステム（ズーム機能・ポータル表示対応版）

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

print("[Minimap] 初期化開始")

-- ズームレベル設定
local ZOOM_LEVELS = {
	{
		name = "詳細",
		scale = 2,           -- 2スタッド/ピクセル
		terrainGrid = 45,    -- 60→45に削減（負荷軽減）
		terrainUpdateInterval = 0.25,  -- 0.15秒 → 0.25秒（更新頻度を下げる）
		iconUpdateInterval = 0.05,
		monsterIconSize = 7,
		portalIconSize = 9,
	},
	{
		name = "中間",
		scale = 4,           -- 4スタッド/ピクセル
		terrainGrid = 50,    -- 50x50グリッド
		terrainUpdateInterval = 0.25,
		iconUpdateInterval = 0.05,
		monsterIconSize = 5,
		portalIconSize = 7,
	},
	{
		name = "広域",
		scale = 8,           -- 8スタッド/ピクセル
		terrainGrid = 40,    -- 40x40グリッド（広域は負荷軽減）
		terrainUpdateInterval = 0.4,
		iconUpdateInterval = 0.08,
		monsterIconSize = 3,
		portalIconSize = 5,
	},
}

local currentZoomLevel = 1

-- 現在の設定を取得
local function getCurrentSettings()
	return ZOOM_LEVELS[currentZoomLevel]
end

-- 基本設定
local MINIMAP_SIZE = 200
local WATER_LEVEL = -15

-- 色設定
local LAND_COLOR = Color3.fromRGB(50, 70, 50)
local SEA_COLOR = Color3.fromRGB(30, 30, 30)
local PLAYER_COLOR = Color3.fromRGB(100, 200, 255)
local MONSTER_COLOR = Color3.fromRGB(255, 50, 50)
local PORTAL_TOWN_COLOR = Color3.fromRGB(255, 200, 100)
local PORTAL_OTHER_COLOR = Color3.fromRGB(200, 100, 255)

-- ScreenGui作成
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "MinimapUI"
screenGui.ResetOnSpawn = false
screenGui.IgnoreGuiInset = true
screenGui.Parent = playerGui

-- ミニマップの背景フレーム
local minimapFrame = Instance.new("Frame")
minimapFrame.Name = "MinimapFrame"
minimapFrame.Size = UDim2.new(0, MINIMAP_SIZE, 0, MINIMAP_SIZE)
minimapFrame.Position = UDim2.new(0, 20, 1, -MINIMAP_SIZE - 20)
minimapFrame.BackgroundColor3 = SEA_COLOR
minimapFrame.BackgroundTransparency = 0.3
minimapFrame.BorderSizePixel = 2
minimapFrame.BorderColor3 = Color3.fromRGB(255, 255, 255)
minimapFrame.Parent = screenGui

local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(0, 8)
corner.Parent = minimapFrame

-- 地形レイヤー
local terrainLayer = Instance.new("Frame")
terrainLayer.Name = "TerrainLayer"
terrainLayer.Size = UDim2.new(1, 0, 1, 0)
terrainLayer.BackgroundTransparency = 1
terrainLayer.ClipsDescendants = true
terrainLayer.ZIndex = 1
terrainLayer.Parent = minimapFrame

-- タイトル（ズームレベル表示）
local titleLabel = Instance.new("TextLabel")
titleLabel.Name = "Title"
titleLabel.Size = UDim2.new(1, 0, 0, 20)
titleLabel.Position = UDim2.new(0, 0, 0, -25)
titleLabel.BackgroundTransparency = 1
titleLabel.Text = "MAP [Z: 詳細]"
titleLabel.TextColor3 = Color3.new(1, 1, 1)
titleLabel.TextSize = 14
titleLabel.Font = Enum.Font.SourceSansBold
titleLabel.TextStrokeTransparency = 0.5
titleLabel.Parent = minimapFrame

-- プレイヤーアイコン（縦長の矢印型）
-- local playerIconContainer = Instance.new("Frame")
-- playerIconContainer.Name = "PlayerIconContainer"
-- playerIconContainer.Size = UDim2.new(0, 12, 0, 18)
-- playerIconContainer.AnchorPoint = Vector2.new(0.5, 0.5)
-- playerIconContainer.Position = UDim2.new(0.5, 0, 0.5, 0)
-- playerIconContainer.BackgroundTransparency = 1
-- playerIconContainer.ZIndex = 10
-- playerIconContainer.Parent = minimapFrame
local playerIcon = Instance.new("ImageLabel")
playerIcon.Name = "PlayerIcon"
playerIcon.Size = UDim2.new(0, 24, 0, 24) -- サイズは調整可能
playerIcon.AnchorPoint = Vector2.new(0.5, 0.5)
playerIcon.Position = UDim2.new(0.5, 0, 0.5, 0)
playerIcon.BackgroundTransparency = 1
playerIcon.Image = "rbxassetid://137204683713117" -- 上向
-- playerIcon.Image = "rbxassetid://88281133700630"
playerIcon.ImageColor3 = PLAYER_COLOR
playerIcon.ZIndex = 10
playerIcon.Parent = minimapFrame


-- アイコンを格納するフォルダ
local monstersFolder = Instance.new("Folder")
monstersFolder.Name = "MonsterIcons"
monstersFolder.Parent = minimapFrame

local portalsFolder = Instance.new("Folder")
portalsFolder.Name = "PortalIcons"
portalsFolder.Parent = minimapFrame

-- 地形タイルのプール
local terrainTilePool = {}
local activeTiles = {}

local function getTerrainTile()
	for _, tile in ipairs(terrainTilePool) do
		if not tile.Visible then
			tile.Visible = true
			return tile
		end
	end

	local tile = Instance.new("Frame")
	tile.Name = "TerrainTile"
	tile.BackgroundColor3 = LAND_COLOR
	tile.BackgroundTransparency = 0.2
	tile.BorderSizePixel = 0
	tile.ZIndex = 2
	tile.Parent = terrainLayer

	table.insert(terrainTilePool, tile)
	return tile
end

local function hideAllTerrainTiles()
	for _, tile in ipairs(terrainTilePool) do
		tile.Visible = false
	end
	activeTiles = {}
end

-- モンスターアイコンのプール
local monsterIconPool = {}

local function getMonsterIcon(size)
	for _, icon in ipairs(monsterIconPool) do
		if not icon.Visible then
			icon.Visible = true
			icon.Size = UDim2.new(0, size, 0, size)
			return icon
		end
	end

	local icon = Instance.new("Frame")
	icon.Name = "MonsterIcon"
	icon.Size = UDim2.new(0, size, 0, size)
	icon.AnchorPoint = Vector2.new(0.5, 0.5)
	icon.BackgroundColor3 = MONSTER_COLOR
	icon.BorderSizePixel = 0
	icon.ZIndex = 5
	icon.Parent = monstersFolder

	local iconCorner = Instance.new("UICorner")
	iconCorner.CornerRadius = UDim.new(1, 0)
	iconCorner.Parent = icon

	table.insert(monsterIconPool, icon)
	return icon
end

local function hideAllMonsterIcons()
	for _, icon in ipairs(monsterIconPool) do
		icon.Visible = false
	end
end

-- ポータルアイコンのプール
local portalIconPool = {}

local function getPortalIcon(size)
	for _, icon in ipairs(portalIconPool) do
		if not icon.Visible then
			icon.Visible = true
			icon.Size = UDim2.new(0, size, 0, size)
			return icon
		end
	end

	local icon = Instance.new("Frame")
	icon.Name = "PortalIcon"
	icon.Size = UDim2.new(0, size, 0, size)
	icon.AnchorPoint = Vector2.new(0.5, 0.5)
	icon.BackgroundColor3 = PORTAL_OTHER_COLOR
	icon.BorderSizePixel = 0
	icon.ZIndex = 6
	icon.Parent = portalsFolder

	local iconCorner = Instance.new("UICorner")
	iconCorner.CornerRadius = UDim.new(1, 0)
	iconCorner.Parent = icon

	table.insert(portalIconPool, icon)
	return icon
end

local function hideAllPortalIcons()
	for _, icon in ipairs(portalIconPool) do
		icon.Visible = false
	end
end

-- レイキャストで地形チェック
local function isLand(worldX, worldZ)
	local params = RaycastParams.new()
	params.FilterType = Enum.RaycastFilterType.Include
	params.FilterDescendantsInstances = {workspace.Terrain}
	params.IgnoreWater = false

	local origin = Vector3.new(worldX, 200, worldZ)
	local direction = Vector3.new(0, -250, 0)

	local result = workspace:Raycast(origin, direction, params)

	if result then
		if result.Material == Enum.Material.Water then
			return false
		end
		if result.Position.Y > WATER_LEVEL then
			return true
		end
	end

	return false
end

-- 地形マップを更新
local lastTerrainUpdate = 0
local lastPlayerPos = nil

local function updateTerrainMap()
	local settings = getCurrentSettings()
	local now = os.clock()

	if now - lastTerrainUpdate < settings.terrainUpdateInterval then
		return
	end

	local character = player.Character
	if not character then return end

	local hrp = character:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	local playerPos = hrp.Position

	-- プレイヤーがあまり動いていなければスキップ
	if lastPlayerPos then
		local distance = (playerPos - lastPlayerPos).Magnitude
		-- 詳細モードは移動距離の閾値を上げる（頻繁に更新しない）
		local threshold = (settings.name == "詳細") and 8 or 5
		if distance < threshold then
			return
		end
	end

	lastTerrainUpdate = now
	lastPlayerPos = playerPos

	-- チラつき防止：古いタイルは残したまま、新しいタイルを配置
	local tileSize = MINIMAP_SIZE / settings.terrainGrid
	local newActiveTiles = {}
	local usedTileIndex = 1

	-- 一気に処理（task.wait()なし）
	for gridX = 0, settings.terrainGrid - 1 do
		for gridZ = 0, settings.terrainGrid - 1 do
			local mapX = (gridX + 0.5) / settings.terrainGrid
			local mapZ = (gridZ + 0.5) / settings.terrainGrid

			local relativeX = (mapX - 0.5) * MINIMAP_SIZE * settings.scale
			local relativeZ = (mapZ - 0.5) * MINIMAP_SIZE * settings.scale

			local worldX = playerPos.X + relativeX
			local worldZ = playerPos.Z + relativeZ

			-- 地形チェック
			if isLand(worldX, worldZ) then
				local tile = getTerrainTile()
				tile.Size = UDim2.new(0, tileSize + 1, 0, tileSize + 1)
				tile.Position = UDim2.new(0, gridX * tileSize, 0, gridZ * tileSize)
				table.insert(newActiveTiles, tile)
			end
		end
	end

	-- 古いタイルを非表示（新しいタイルを表示した後）
	for _, tile in ipairs(activeTiles) do
		local isStillActive = false
		for _, newTile in ipairs(newActiveTiles) do
			if tile == newTile then
				isStillActive = true
				break
			end
		end
		if not isStillActive then
			tile.Visible = false
		end
	end

	activeTiles = newActiveTiles

	-- print(("[Minimap] 地形マップ更新完了: 陸=%d"):format(#activeTiles))
end

-- ワールド座標をミニマップ座標に変換
local function worldToMinimap(worldPos, playerPos)
	local settings = getCurrentSettings()

	local relativeX = worldPos.X - playerPos.X
	local relativeZ = worldPos.Z - playerPos.Z

	local minimapX = (relativeX / settings.scale)
	-- local minimapZ = -(relativeZ / settings.scale)
	local minimapZ = (relativeZ / settings.scale)

	local normalizedX = 0.5 + (minimapX / MINIMAP_SIZE)
	local normalizedZ = 0.5 + (minimapZ / MINIMAP_SIZE)

	return normalizedX, normalizedZ
end

local function isInRange(worldPos, playerPos)
	local settings = getCurrentSettings()
	local range = (MINIMAP_SIZE * settings.scale) / 2

	local dx = worldPos.X - playerPos.X
	local dz = worldPos.Z - playerPos.Z
	local distance = math.sqrt(dx * dx + dz * dz)
	return distance <= range
end

-- プレイヤーアイコンの向きを更新
local function updatePlayerRotation_debug()
	local character = player.Character
	if not character then return end

	local hrp = character:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	if not playerIcon then return end

	-- プレイヤーの向きを取得
	local lookVector = hrp.CFrame.LookVector

	-- 8パターン全て試す
	local patterns = {
		{name = "パターン1", calc = function() return math.atan2(lookVector.X, lookVector.Z) end},
		{name = "パターン2", calc = function() return math.atan2(lookVector.Z, lookVector.X) end},
		{name = "パターン3", calc = function() return math.atan2(-lookVector.X, lookVector.Z) end},
		{name = "パターン4", calc = function() return math.atan2(lookVector.X, -lookVector.Z) end},
		{name = "パターン5", calc = function() return math.atan2(-lookVector.Z, lookVector.X) end},
		{name = "パターン6", calc = function() return math.atan2(lookVector.Z, -lookVector.X) end},
		{name = "パターン7", calc = function() return math.atan2(-lookVector.X, -lookVector.Z) end},
		{name = "パターン8", calc = function() return math.atan2(-lookVector.Z, -lookVector.X) end},
	}

	-- パターン1を使用（後で変更できる）
	local angle = patterns[1].calc()
	local degrees = math.deg(angle)

	-- 回転を適用
	playerIcon.Rotation = degrees

	-- 5秒に1回デバッグ情報を表示
	if os.clock() % 5 < 0.1 then
		print(string.format("[Minimap DEBUG] LookVector: (%.2f, %.2f, %.2f)", lookVector.X, lookVector.Y, lookVector.Z))
		print(string.format("[Minimap DEBUG] 角度: %.1f度", degrees))
	end
end


-- デバッグ版（方角名も表示）
local function updatePlayerRotation_news()
	local character = player.Character
	if not character then return end

	local hrp = character:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	if not playerIcon then return end

	local lookVector = hrp.CFrame.LookVector

	-- 方角を判定
	local direction = ""
	if math.abs(lookVector.Z) > math.abs(lookVector.X) then
		direction = lookVector.Z < 0 and "北" or "南"
	else
		direction = lookVector.X > 0 and "東" or "西"
	end

	local angle = math.atan2(lookVector.Z, lookVector.X)
	local degrees = math.deg(angle)

	playerIcon.Rotation = degrees

	if os.clock() % 5 < 0.1 then
		print(string.format("[Minimap DEBUG] 方角: %s", direction))
		print(string.format("[Minimap DEBUG] LookVector: (%.2f, %.2f, %.2f)", lookVector.X, lookVector.Y, lookVector.Z))
		print(string.format("[Minimap DEBUG] 角度: %.1f度", degrees))
	end
end

local function updatePlayerRotation()
	local character = player.Character
	if not character then return end

	local hrp = character:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	if not playerIcon then return end

	-- 【変更】CFrameから直接Y軸回転を取得
	local _, yRotation, _ = hrp.CFrame:ToOrientation()
	local degrees = math.deg(yRotation)

	-- 座標系を合わせる（地形マップと同じ反転）
	playerIcon.Rotation = -degrees

	-- if os.clock() % 1 < 0.1 then
	-- 	print(string.format("[DEBUG] Y軸回転: %.1f度 → 表示: %.1f度", degrees, -degrees))
	-- end
end


-- モンスターアイコンを更新
local lastIconUpdate = 0
local function updateMonsterIcons()
	local settings = getCurrentSettings()
	local now = os.clock()

	if now - lastIconUpdate < settings.iconUpdateInterval then
		return
	end
	lastIconUpdate = now

	local character = player.Character
	if not character then return end

	local hrp = character:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	local playerPos = hrp.Position

	hideAllMonsterIcons()

	-- Monstersフォルダから取得
	local monstersWorkspace = workspace:FindFirstChild("Monsters")
	if monstersWorkspace then
		for _, model in ipairs(monstersWorkspace:GetChildren()) do
			if model:IsA("Model") then
				local monsterHrp = model:FindFirstChild("HumanoidRootPart")
				if monsterHrp then
					local monsterPos = monsterHrp.Position
					if isInRange(monsterPos, playerPos) then
						local mapX, mapZ = worldToMinimap(monsterPos, playerPos)
						if mapX >= 0 and mapX <= 1 and mapZ >= 0 and mapZ <= 1 then
							local icon = getMonsterIcon(settings.monsterIconSize)
							icon.Position = UDim2.new(mapX, 0, mapZ, 0)
						end
					end
				end
			end
		end
	end

	-- 旧形式（IsEnemy属性）にも対応
	for _, model in ipairs(workspace:GetChildren()) do
		if model:IsA("Model") and model:GetAttribute("IsEnemy") then
			local monsterHrp = model:FindFirstChild("HumanoidRootPart")
			if monsterHrp then
				local monsterPos = monsterHrp.Position
				if isInRange(monsterPos, playerPos) then
					local mapX, mapZ = worldToMinimap(monsterPos, playerPos)
					if mapX >= 0 and mapX <= 1 and mapZ >= 0 and mapZ <= 1 then
						local icon = getMonsterIcon(settings.monsterIconSize)
						icon.Position = UDim2.new(mapX, 0, mapZ, 0)
					end
				end
			end
		end
	end

	-- プレイヤーの向きを更新
	updatePlayerRotation()
end

-- ポータルアイコンを更新
local portalDebugDone = false
local function updatePortalIcons()
	local settings = getCurrentSettings()
	local character = player.Character
	if not character then return end

	local hrp = character:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	local playerPos = hrp.Position

	hideAllPortalIcons()

	-- デバッグ: ポータルの配置場所を確認
	if not portalDebugDone then
		print("[Minimap DEBUG] ポータル検索開始")

		-- workspace.Worldの中身を確認
		local worldFolder = workspace:FindFirstChild("World")
		if worldFolder then
			print("[Minimap DEBUG] workspace.World発見: " .. #worldFolder:GetChildren() .. "個のオブジェクト")
			local portalCount = 0
			for _, obj in ipairs(worldFolder:GetChildren()) do
				local toZone = obj:GetAttribute("ToZone")
				if toZone then
					portalCount = portalCount + 1
					print("[Minimap DEBUG]   - " .. obj.Name .. " → " .. toZone .. " (Pos: " .. tostring(obj.Position) .. ")")
				end
			end
			print("[Minimap DEBUG] ポータル総数: " .. portalCount)
		else
			print("[Minimap DEBUG] workspace.Worldが見つかりません")
		end

		portalDebugDone = true
	end

	-- workspace.Worldからポータルを取得
	local worldFolder = workspace:FindFirstChild("World")
	if worldFolder then
		for _, portal in ipairs(worldFolder:GetChildren()) do
			-- ToZone属性があるものをポータルとして認識
			if portal:IsA("BasePart") and portal:GetAttribute("ToZone") then
				local portalPos = portal.Position
				if isInRange(portalPos, playerPos) then
					local mapX, mapZ = worldToMinimap(portalPos, playerPos)
					if mapX >= 0 and mapX <= 1 and mapZ >= 0 and mapZ <= 1 then
						local icon = getPortalIcon(settings.portalIconSize)
						icon.Position = UDim2.new(mapX, 0, mapZ, 0)

						-- Townへのポータルかそれ以外かで色分け
						local toZone = portal:GetAttribute("ToZone")
						if toZone == "StartTown" then
							-- Townへのポータル → オレンジ
							icon.BackgroundColor3 = PORTAL_TOWN_COLOR
						else
							-- それ以外（他の大陸へ） → ポータルの色またはデフォルト紫
							icon.BackgroundColor3 = portal.Color or PORTAL_OTHER_COLOR
						end
					end
				end
			end
		end
	end
end

-- ズーム切り替え
local function changeZoomLevel(delta)
	currentZoomLevel = math.clamp(currentZoomLevel + delta, 1, #ZOOM_LEVELS)
	local settings = getCurrentSettings()

	titleLabel.Text = "MAP [Z: " .. settings.name .. "]"

	-- 地形マップを即座に更新
	lastTerrainUpdate = 0
	lastPlayerPos = nil

	print("[Minimap] ズーム変更: " .. settings.name)
end

-- マウスホイール入力
UserInputService.InputChanged:Connect(function(input, gameProcessed)
	if gameProcessed then return end

	if input.UserInputType == Enum.UserInputType.MouseWheel then
		local mousePos = UserInputService:GetMouseLocation()
		local framePos = minimapFrame.AbsolutePosition
		local frameSize = minimapFrame.AbsoluteSize

		if mousePos.X >= framePos.X and mousePos.X <= framePos.X + frameSize.X and
			mousePos.Y >= framePos.Y and mousePos.Y <= framePos.Y + frameSize.Y then
			if input.Position.Z > 0 then
				changeZoomLevel(-1)
			else
				changeZoomLevel(1)
			end
		end
	end
end)

-- Zキー入力
UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then return end

	if input.KeyCode == Enum.KeyCode.Z then
		local nextLevel = currentZoomLevel + 1
		if nextLevel > #ZOOM_LEVELS then
			nextLevel = 1
		end
		changeZoomLevel(nextLevel - currentZoomLevel)
	end
end)

-- メイン更新ループ
RunService.Heartbeat:Connect(function()
	updateTerrainMap()
	updateMonsterIcons()
	updatePlayerRotation()
end)

-- ポータル専用の高速更新ループ（独立）
task.spawn(function()
	while true do
		task.wait(0.1)  -- 0.1秒ごとに更新（高速）
		updatePortalIcons()
	end
end)

-- 初期化時に即座にポータルを検索
task.spawn(function()
	task.wait(0.5)  -- 少し待ってからポータル検索
	updatePortalIcons()
end)

-- workspace.Worldの変化を監視（ポータル追加時に即反映）
task.spawn(function()
	local worldFolder = workspace:WaitForChild("World", 10)
	if worldFolder then
		worldFolder.ChildAdded:Connect(function(child)
			if child:IsA("BasePart") and child:GetAttribute("ToZone") then
				print("[Minimap] 新しいポータル検出: " .. child.Name)
				task.wait(0.1)
				updatePortalIcons()
			end
		end)
	end
end)

UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then return end

	if input.KeyCode == Enum.KeyCode.P then
		local character = player.Character
		if not character then return end

		local hrp = character:FindFirstChild("HumanoidRootPart")
		if not hrp then return end

		local position = hrp.Position

		local continent = player:GetAttribute("ContinentName") or "?"
		local island = player:GetAttribute("IslandName") or "?"

		print("📍 現在地情報 -------------------------")
		print("🗺️ 大陸名: " .. continent)
		-- print("🏝️ 島名: " .. island)
		print(string.format("📌 座標: (%.1f, %.1f, %.1f)", position.X, position.Y, position.Z))
		print("--------------------------------------")
	end
end)



print("[Minimap] 初期化完了（ズーム機能付き）")
===== ./StartPlayerScripts/MenuUI.client.lua =====
-- StarterPlayer/StarterPlayerScripts/MenuUI.client.lua
-- メニューシステム（ステータス、アイテム、スキル等）

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

print("[MenuUI] 初期化中...")

-- 状態管理
local currentModal = nil
local isInBattle = false

-- RemoteEvent取得
local RequestStatusEvent = ReplicatedStorage:WaitForChild("RequestStatus", 1)
local SaveGameEvent = ReplicatedStorage:WaitForChild("SaveGame", 1)
local SaveSuccessEvent = ReplicatedStorage:WaitForChild("SaveSuccess", 1)
local RequestLoadRespawnEvent = ReplicatedStorage:WaitForChild("RequestLoadRespawn", 1)


-- UIコンテナ
local menuGui = nil
local menuFrame = nil

-- プレイヤーステータスキャッシュ
local cachedStats = {
	Level = 1,
	MaxHP = 100,
	CurrentHP = 100,
	Speed = 10,
	Attack = 10,
	Defense = 10,
	Gold = 0,
	MonstersDefeated = 0
}

-- ステータス更新を受信 (既存ロジック)
local StatusUpdateEvent = ReplicatedStorage:FindFirstChild("StatusUpdate")
if StatusUpdateEvent then
	StatusUpdateEvent.OnClientEvent:Connect(function(hp, maxHP, level, exp, expToNext, gold)
		cachedStats.CurrentHP = hp or cachedStats.CurrentHP
		cachedStats.MaxHP = maxHP or cachedStats.MaxHP
		cachedStats.Level = level or cachedStats.Level
		cachedStats.Gold = gold or cachedStats.Gold
	end)
end

-- 戦歴更新を受信 (既存ロジック)
task.spawn(function()
	print("[MenuUI] StatsDetailイベント接続を開始...")

	local StatsDetailEvent = ReplicatedStorage:WaitForChild("StatsDetail", 5)
	if not StatsDetailEvent then
		warn("[MenuUI] StatsDetailイベントが見つかりません！")
		return
	end

	print("[MenuUI] StatsDetailイベントを発見しました")

	StatsDetailEvent.OnClientEvent:Connect(function(stats)
		print("[MenuUI] ========================================")
		print("[MenuUI] 🎯 StatsDetail受信イベント発火！")
		if stats then
			for key, value in pairs(stats) do
				cachedStats[key] = value
			end
			print("[MenuUI] ✅ キャッシュ更新完了")
		else
			warn("[MenuUI] ❌ statsがnilです！")
		end
		print("[MenuUI] ========================================")
	end)

	print("[MenuUI] StatsDetailイベント接続完了")
end)

-- バトル状態を監視 (既存ロジック)
local BattleStartEvent = ReplicatedStorage:FindFirstChild("BattleStart")
local BattleEndEvent = ReplicatedStorage:FindFirstChild("BattleEnd")

if BattleStartEvent then
	BattleStartEvent.OnClientEvent:Connect(function()
		isInBattle = true
		if menuFrame then
			for _, button in ipairs(menuFrame:GetChildren()) do
				if button:IsA("TextButton") then
					button.Active = false
					button.BackgroundTransparency = 0.7
					button.TextTransparency = 0.5
				end
			end
		end
		if currentModal then
			closeModal()
		end
	end)
end

if BattleEndEvent then
	BattleEndEvent.OnClientEvent:Connect(function()
		isInBattle = false
		if menuFrame then
			for _, button in ipairs(menuFrame:GetChildren()) do
				if button:IsA("TextButton") then
					button.Active = true
					button.BackgroundTransparency = 0.2
					button.TextTransparency = 0
				end
			end
		end
	end)
end

-- モーダルウィンドウを閉じる (既存ロジック)
function closeModal()
    if not currentModal then return end -- 防御的な早期終了

    local modalToDestroy = currentModal
    currentModal = nil -- ★即座にnilに設定し、他の処理による競合を防止

	if modalToDestroy then
		local background = modalToDestroy:FindFirstChild("Background")
		if background then
			local tween = TweenService:Create(background, TweenInfo.new(0.2), {
				BackgroundTransparency = 1
			})
			tween:Play()
		end

		local panel = modalToDestroy:FindFirstChild("Panel")
		if panel then
			local tween = TweenService:Create(panel, TweenInfo.new(0.2), {
				BackgroundTransparency = 1
			})
			tween:Play()

			for _, child in ipairs(panel:GetDescendants()) do
				if child:IsA("TextLabel") or child:IsA("TextButton") then
					TweenService:Create(child, TweenInfo.new(0.2), {
						TextTransparency = 1
					}):Play()
				end
			end
		end

		task.wait(0.2)
		modalToDestroy:Destroy() -- ★ローカル参照を使用
	end
end

-- モーダルウィンドウを作成 (既存ロジック)
local function createModal(title, contentBuilder)
	if currentModal then
		closeModal()
	end

	local modal = Instance.new("ScreenGui")
	modal.Name = "ModalUI"
	modal.ResetOnSpawn = false
	modal.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	modal.Parent = playerGui

	-- 背景（暗転）
	local background = Instance.new("Frame")
	background.Name = "Background"
	background.Size = UDim2.fromScale(1, 1)
	background.BackgroundColor3 = Color3.new(0, 0, 0)
	background.BackgroundTransparency = 1
	background.BorderSizePixel = 0
	background.ZIndex = 50
	background.Parent = modal

	TweenService:Create(background, TweenInfo.new(0.2), {
		BackgroundTransparency = 0.5
	}):Play()

	-- パネル
	local panel = Instance.new("Frame")
	panel.Name = "Panel"
	panel.Size = UDim2.new(0, 500, 0, 400)
	panel.Position = UDim2.fromScale(0.5, 0.5)
	panel.AnchorPoint = Vector2.new(0.5, 0.5)
	panel.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
	panel.BackgroundTransparency = 1
	panel.BorderSizePixel = 0
	panel.ZIndex = 51
	panel.Parent = modal

	TweenService:Create(panel, TweenInfo.new(0.2), {
		BackgroundTransparency = 0.1
	}):Play()

	local panelCorner = Instance.new("UICorner")
	panelCorner.CornerRadius = UDim.new(0, 12)
	panelCorner.Parent = panel

	-- タイトル
	local titleLabel = Instance.new("TextLabel")
	titleLabel.Name = "Title"
	titleLabel.Size = UDim2.new(1, -20, 0, 40)
	titleLabel.Position = UDim2.new(0, 10, 0, 10)
	titleLabel.BackgroundTransparency = 1
	titleLabel.TextColor3 = Color3.fromRGB(255, 215, 0)
	titleLabel.TextStrokeTransparency = 0.5
	titleLabel.Font = Enum.Font.GothamBold
	titleLabel.TextSize = 24
	titleLabel.Text = title
	titleLabel.TextXAlignment = Enum.TextXAlignment.Left
	titleLabel.TextTransparency = 1
	titleLabel.ZIndex = 52
	titleLabel.Parent = panel

	TweenService:Create(titleLabel, TweenInfo.new(0.2), {
		TextTransparency = 0,
		TextStrokeTransparency = 0.5
	}):Play()

	-- 閉じるボタン
	local closeButton = Instance.new("TextButton")
	closeButton.Name = "CloseButton"
	closeButton.Size = UDim2.new(0, 40, 0, 40)
	closeButton.Position = UDim2.new(1, -50, 0, 10)
	closeButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
	closeButton.BackgroundTransparency = 1
	closeButton.BorderSizePixel = 0
	closeButton.Font = Enum.Font.GothamBold
	closeButton.TextSize = 24
	closeButton.Text = "✕"
	closeButton.TextColor3 = Color3.new(1, 1, 1)
	closeButton.TextTransparency = 1
	closeButton.ZIndex = 52
	closeButton.Parent = panel

	TweenService:Create(closeButton, TweenInfo.new(0.2), {
		BackgroundTransparency = 0.2,
		TextTransparency = 0
	}):Play()

	local closeCorner = Instance.new("UICorner")
	closeCorner.CornerRadius = UDim.new(0, 8)
	closeCorner.Parent = closeButton

	closeButton.MouseButton1Click:Connect(function()
		closeModal()
	end)

	closeButton.MouseEnter:Connect(function()
		closeButton.BackgroundColor3 = Color3.fromRGB(255, 70, 70)
	end)
	closeButton.MouseLeave:Connect(function()
		closeButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
	end)

	-- コンテンツエリア
	local contentFrame = Instance.new("Frame")
	contentFrame.Name = "Content"
	contentFrame.Size = UDim2.new(1, -20, 1, -70)
	contentFrame.Position = UDim2.new(0, 10, 0, 60)
	contentFrame.BackgroundTransparency = 1
	contentFrame.ZIndex = 52
	contentFrame.Parent = panel

	if contentBuilder then
		contentBuilder(contentFrame)
	end

	background.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			closeModal()
		end
	end)

	currentModal = modal
	return modal
end

local function showSaveModal()
    if not SaveGameEvent or not SaveSuccessEvent then
        createModal("セーブエラー", function(content)
            local label = Instance.new("TextLabel")
            label.Size = UDim2.fromScale(1, 1)
            label.BackgroundTransparency = 1
            label.TextColor3 = Color3.fromRGB(255, 100, 100)
            label.TextStrokeTransparency = 0.7
            label.Font = Enum.Font.Gotham
            label.TextSize = 18
            label.Text = "セーブ機能がサーバーで初期化されていません。"
            label.Parent = content
        end)
        return
    end

    -- セーブイベントをサーバーに送信
    SaveGameEvent:FireServer()

    local connection = nil -- ★FIX 1: connectionをローカル宣言

    createModal("セーブ中", function(content)
        local label = Instance.new("TextLabel")
        label.Size = UDim2.fromScale(1, 1)
        label.BackgroundTransparency = 1
        label.TextColor3 = Color3.fromRGB(255, 255, 255)
        label.TextStrokeTransparency = 0.7
        label.Font = Enum.Font.Gotham
        label.TextSize = 18
        label.Text = "💾 セーブ中..."
        label.Parent = content
        -- ... (label setup)

        -- セーブ完了のフィードバックを待機
        connection = SaveSuccessEvent.OnClientEvent:Connect(function(success)
            if connection and connection.Connected then connection:Disconnect() end -- ★FIX 2: Disconnect前にnil/Connectedチェック

            if success then
                label.Text = "✅ セーブ完了！"
                label.TextColor3 = Color3.fromRGB(46, 204, 113)
            else
                label.Text = "❌ セーブ失敗..."
                label.TextColor3 = Color3.fromRGB(231, 76, 60)
            end
            task.wait(1.5)
            closeModal()
        end)

        -- モーダルが強制終了された場合、接続を解除
        -- 閉じるボタン（✕）のイベント接続を再利用
        local closeButton = content.Parent:FindFirstChild("CloseButton")
        if closeButton then
            closeButton.MouseButton1Click:Connect(function()
                if connection and connection.Connected then connection:Disconnect() end -- ★FIX 3: 終了ボタンもnil/Connectedチェック
                closeModal()
            end)
        end

        -- 背景クリック（強制終了）のイベント接続を再利用
        local background = content.Parent.Parent:FindFirstChild("Background")
        if background then
             background.InputBegan:Connect(function(input)
                if input.UserInputType == Enum.UserInputType.MouseButton1 then
                    if connection and connection.Connected then connection:Disconnect() end
                    closeModal()
                end
            end)
        end
    end)
end

local function showLoadModal()

    createModal("ロード", function(content)
        local warningLabel = Instance.new("TextLabel")
        warningLabel.Size = UDim2.new(1, 0, 0, 60)
		warningLabel.Position = UDim2.new(0, 0, 0, 20)
		warningLabel.BackgroundTransparency = 1
		warningLabel.TextColor3 = Color3.fromRGB(255, 255, 100)
		warningLabel.TextStrokeTransparency = 0.7
		warningLabel.Font = Enum.Font.Gotham
		warningLabel.TextSize = 18
		warningLabel.Text = "現在、ロードは再接続によって行われます。\nゲームを再起動しますか？"
		warningLabel.TextWrapped = true
		warningLabel.TextTransparency = 1
		warningLabel.ZIndex = 53
		warningLabel.Parent = content

        TweenService:Create(warningLabel, TweenInfo.new(0.2), {TextTransparency = 0, TextStrokeTransparency = 0.7}):Play()

        -- ロードボタン (サーバーにロード要求を送り、キックする)
        local loadButton = Instance.new("TextButton")
		loadButton.Size = UDim2.new(0, 150, 0, 50)
		loadButton.Position = UDim2.new(0.5, -160, 1, -70)
		loadButton.BackgroundColor3 = Color3.fromRGB(52, 152, 219)
		loadButton.BackgroundTransparency = 0.2
        loadButton.BorderSizePixel = 0
        loadButton.Font = Enum.Font.GothamBold
        loadButton.TextSize = 18
		loadButton.Text = "ゲームを再起動"
        loadButton.TextColor3 = Color3.new(1, 1, 1)
        loadButton.TextTransparency = 1
        loadButton.ZIndex = 53
        loadButton.Parent = content

        TweenService:Create(loadButton, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0.1), {
			BackgroundTransparency = 0.2,
			TextTransparency = 0
		}):Play()

        local loadCorner = Instance.new("UICorner")
		loadCorner.CornerRadius = UDim.new(0, 8)
		loadCorner.Parent = loadButton

        -- ロード処理はキックを実行
        loadButton.MouseButton1Click:Connect(function()
            closeModal()

            -- ★修正ブロック開始: Studioと実環境で処理を分ける
            if game:GetService("RunService"):IsStudio() then
                if RequestLoadRespawnEvent then
                    -- Studioの場合、サーバーにリスポーンを要求
                    RequestLoadRespawnEvent:FireServer()
                    print("[MenuUI] Studioモード: サーバーにロードリスポーンを要求しました")
                else
                    warn("[MenuUI] RequestLoadRespawnEventが見つかりません！")
                end
            else
                -- 実際のゲームの場合、キックして再接続を促す
                player:Kick("セーブデータをロードするため再起動します")
            end
            -- ★修正ブロック終了
        end)

        -- キャンセルボタン (showLogoutから流用)
		local cancelButton = Instance.new("TextButton")
		cancelButton.Size = UDim2.new(0, 150, 0, 50)
		cancelButton.Position = UDim2.new(0.5, 10, 1, -70)
		cancelButton.BackgroundColor3 = Color3.fromRGB(149, 165, 166)
		cancelButton.BackgroundTransparency = 0.2
		cancelButton.BorderSizePixel = 0
		cancelButton.Font = Enum.Font.GothamBold
		cancelButton.TextSize = 18
		cancelButton.Text = "キャンセル"
		cancelButton.TextColor3 = Color3.new(1, 1, 1)
		cancelButton.TextTransparency = 1
		cancelButton.ZIndex = 53
		cancelButton.Parent = content

        TweenService:Create(cancelButton, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0,
        false, 0.15), {
			BackgroundTransparency = 0.2,
			TextTransparency = 0
		}):Play()

        local cancelCorner = Instance.new("UICorner")
		cancelCorner.CornerRadius = UDim.new(0, 8)
		cancelCorner.Parent = cancelButton

		cancelButton.MouseButton1Click:Connect(function()
			closeModal()
		end)

    end)
end

-- ★新規機能: 初期化処理
local function showResetModal()
    createModal("データ初期化", function(content)
        local warningLabel = Instance.new("TextLabel")
		warningLabel.Size = UDim2.new(1, 0, 0, 60)
		warningLabel.Position = UDim2.new(0, 0, 0, 20)
		warningLabel.BackgroundTransparency = 1
		warningLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
		warningLabel.TextStrokeTransparency = 0.7
		warningLabel.Font = Enum.Font.Gotham
		warningLabel.TextSize = 18
		warningLabel.Text = "!! 警告 !!\nすべての進行状況を失います。本当に初期化しますか？"
		warningLabel.TextWrapped = true
		warningLabel.TextTransparency = 1
		warningLabel.ZIndex = 53
		warningLabel.Parent = content

		TweenService:Create(warningLabel, TweenInfo.new(0.2), {
			TextTransparency = 0,
			TextStrokeTransparency = 0.7
		}):Play()

		local resetButton = Instance.new("TextButton")
		resetButton.Size = UDim2.new(0, 150, 0, 50)
		resetButton.Position = UDim2.new(0.5, -160, 1, -70)
		resetButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
		resetButton.BackgroundTransparency = 0.2
        resetButton.BorderSizePixel = 0
        resetButton.Font = Enum.Font.GothamBold
        resetButton.TextSize = 18
		resetButton.Text = "初期化する"
		resetButton.TextColor3 = Color3.new(1, 1, 1)
		resetButton.TextTransparency = 1
		resetButton.ZIndex = 53
		resetButton.Parent = content

        local resetCorner = Instance.new("UICorner")
		resetCorner.CornerRadius = UDim.new(0, 8)
		resetCorner.Parent = resetButton

		TweenService:Create(resetButton, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0.1), {
			BackgroundTransparency = 0.2,
			TextTransparency = 0
		}):Play()

		resetButton.MouseButton1Click:Connect(function()
			-- TODO: FireServer Reset Event
			player:Kick("データを初期化しました")
		end)

		local cancelButton = Instance.new("TextButton")
		cancelButton.Size = UDim2.new(0, 150, 0, 50)
		cancelButton.Position = UDim2.new(0.5, 10, 1, -70)
		cancelButton.BackgroundColor3 = Color3.fromRGB(149, 165, 166)
		cancelButton.BackgroundTransparency = 0.2
		cancelButton.BorderSizePixel = 0
		cancelButton.Font = Enum.Font.GothamBold
		cancelButton.TextSize = 18
		cancelButton.Text = "キャンセル"
		cancelButton.TextColor3 = Color3.new(1, 1, 1)
		cancelButton.TextTransparency = 1
		cancelButton.ZIndex = 53
		cancelButton.Parent = content

		TweenService:Create(cancelButton, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0.15), {
			BackgroundTransparency = 0.2,
			TextTransparency = 0
		}):Play()

		local cancelCorner = Instance.new("UICorner")
		cancelCorner.CornerRadius = UDim.new(0, 8)
		cancelCorner.Parent = cancelButton

		cancelButton.MouseButton1Click:Connect(function()
			closeModal()
		end)
    end)
end


-- ステータス画面 (既存ロジック)
local function showStatus()
	createModal("ステータス", function(content)
		local stats = {
			{"レベル", cachedStats.Level},
			{"最大HP", cachedStats.MaxHP},
			{"攻撃力", cachedStats.Attack},
			{"防御力", cachedStats.Defense},
			{"素早さ", cachedStats.Speed},
		}

		for i, stat in ipairs(stats) do
			local label = Instance.new("TextLabel")
			label.Size = UDim2.new(1, 0, 0, 40)
			label.Position = UDim2.new(0, 0, 0, (i - 1) * 50)
			label.BackgroundTransparency = 1
			label.TextColor3 = Color3.fromRGB(255, 255, 255)
			label.TextStrokeTransparency = 0.7
			label.Font = Enum.Font.Gotham
			label.TextSize = 20
			label.Text = string.format("%s: %d", stat[1], stat[2])
			label.TextXAlignment = Enum.TextXAlignment.Left
			label.TextTransparency = 1
			label.ZIndex = 53
			label.Parent = content

			TweenService:Create(label, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, i * 0.05), {
				TextTransparency = 0,
				TextStrokeTransparency = 0.7
			}):Play()
		end
	end)
end

-- アイテム画面 (既存ロジック)
local function showItems()
	createModal("アイテム", function(content)
		local emptyLabel = Instance.new("TextLabel")
		emptyLabel.Size = UDim2.fromScale(1, 1)
		emptyLabel.BackgroundTransparency = 1
		emptyLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
		emptyLabel.TextStrokeTransparency = 0.7
		emptyLabel.Font = Enum.Font.Gotham
		emptyLabel.TextSize = 18
		emptyLabel.Text = "アイテムがありません"
		emptyLabel.TextTransparency = 1
		emptyLabel.ZIndex = 53
		emptyLabel.Parent = content

		TweenService:Create(emptyLabel, TweenInfo.new(0.2), {
			TextTransparency = 0,
			TextStrokeTransparency = 0.7
		}):Play()
	end)
end

-- スキル画面 (既存ロジック)
local function showSkills()
	createModal("スキル", function(content)
		local emptyLabel = Instance.new("TextLabel")
		emptyLabel.Size = UDim2.fromScale(1, 1)
		emptyLabel.BackgroundTransparency = 1
		emptyLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
		emptyLabel.TextStrokeTransparency = 0.7
		emptyLabel.Font = Enum.Font.Gotham
		emptyLabel.TextSize = 18
		emptyLabel.Text = "習得済みスキルなし"
		emptyLabel.TextTransparency = 1
		emptyLabel.ZIndex = 53
		emptyLabel.Parent = content

		TweenService:Create(emptyLabel, TweenInfo.new(0.2), {
			TextTransparency = 0,
			TextStrokeTransparency = 0.7
		}):Play()
	end)
end

-- 戦歴画面 (既存ロジック)
local function showRecords()
	createModal("戦歴", function(content)
		print("[MenuUI] ========================================")
		print("[MenuUI] 戦歴画面を開きました")
		print("[MenuUI] キャッシュされた値:", cachedStats.MonstersDefeated or 0)

		-- ラベルを先に作成
		local label = Instance.new("TextLabel")
		label.Size = UDim2.new(1, 0, 0, 40)
		label.Position = UDim2.new(0, 0, 0, 0)
		label.BackgroundTransparency = 1
		label.TextColor3 = Color3.fromRGB(255, 255, 255)
		label.TextStrokeTransparency = 0.7
		label.Font = Enum.Font.Gotham
		label.TextSize = 20
		label.Text = string.format("倒したモンスター数: %d (取得中...)", cachedStats.MonstersDefeated or 0)
		label.TextXAlignment = Enum.TextXAlignment.Left
		label.TextTransparency = 1
		label.ZIndex = 53
		label.Parent = content

		TweenService:Create(label, TweenInfo.new(0.2), {
			TextTransparency = 0,
			TextStrokeTransparency = 0.7
		}):Play()

		-- サーバーに最新の戦歴をリクエスト
		local RequestStatsDetailEvent = ReplicatedStorage:FindFirstChild("RequestStatsDetail")
		if RequestStatsDetailEvent then
			print("[MenuUI] サーバーに詳細ステータスをリクエスト中...")
			RequestStatsDetailEvent:FireServer()

			-- 0.5秒後にラベルを更新（サーバーからのレスポンスを待つ）
			task.delay(0.5, function()
				if label and label.Parent then
					label.Text = string.format("倒したモンスター数: %d", cachedStats.MonstersDefeated or 0)
					print("[MenuUI] ラベル更新: MonstersDefeated =", cachedStats.MonstersDefeated)
				end
			end)
		else
			warn("[MenuUI] RequestStatsDetailEventが見つかりません")
		end

		print("[MenuUI] ========================================")
	end)
end

-- 設定画面 (既存ロジック)
local function showSettings()
	createModal("設定", function(content)
		local bgmLabel = Instance.new("TextLabel")
		bgmLabel.Size = UDim2.new(1, 0, 0, 30)
		bgmLabel.Position = UDim2.new(0, 0, 0, 20)
		bgmLabel.BackgroundTransparency = 1
		bgmLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
		bgmLabel.TextStrokeTransparency = 0.7
		bgmLabel.Font = Enum.Font.Gotham
		bgmLabel.TextSize = 18
		bgmLabel.Text = "BGM音量（未実装）"
		bgmLabel.TextXAlignment = Enum.TextXAlignment.Left
		bgmLabel.TextTransparency = 1
		bgmLabel.ZIndex = 53
		bgmLabel.Parent = content

		TweenService:Create(bgmLabel, TweenInfo.new(0.2), {
			TextTransparency = 0,
			TextStrokeTransparency = 0.7
		}):Play()

		local seLabel = Instance.new("TextLabel")
		seLabel.Size = UDim2.new(1, 0, 0, 30)
		seLabel.Position = UDim2.new(0, 0, 0, 80)
		seLabel.BackgroundTransparency = 1
		seLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
		seLabel.TextStrokeTransparency = 0.7
		seLabel.Font = Enum.Font.Gotham
		seLabel.TextSize = 18
		seLabel.Text = "SE音量（未実装）"
		seLabel.TextXAlignment = Enum.TextXAlignment.Left
		seLabel.TextTransparency = 1
		seLabel.ZIndex = 53
		seLabel.Parent = content

		TweenService:Create(seLabel, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0.05), {
			TextTransparency = 0,
			TextStrokeTransparency = 0.7
		}):Play()
	end)
end

-- ログアウト確認 (showSystemに統合されるため、ここでは非公開の関数として残す)
local function showLogoutInner()
    createModal("ログアウト", function(content)
		local warningLabel = Instance.new("TextLabel")
		warningLabel.Size = UDim2.new(1, 0, 0, 60)
		warningLabel.Position = UDim2.new(0, 0, 0, 20)
		warningLabel.BackgroundTransparency = 1
		warningLabel.TextColor3 = Color3.fromRGB(255, 200, 100)
		warningLabel.TextStrokeTransparency = 0.7
		warningLabel.Font = Enum.Font.Gotham
		warningLabel.TextSize = 18
		warningLabel.Text = "本当にログアウトしますか？\n\n※ 現在、進行状況は保存されません"
		warningLabel.TextWrapped = true
		warningLabel.TextTransparency = 1
		warningLabel.ZIndex = 53
		warningLabel.Parent = content

		TweenService:Create(warningLabel, TweenInfo.new(0.2), {
			TextTransparency = 0,
			TextStrokeTransparency = 0.7
		}):Play()

		local logoutButton = Instance.new("TextButton")
		logoutButton.Size = UDim2.new(0, 150, 0, 50)
		logoutButton.Position = UDim2.new(0.5, -160, 1, -70)
		logoutButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
		logoutButton.BackgroundTransparency = 0.2
		logoutButton.BorderSizePixel = 0
		logoutButton.Font = Enum.Font.GothamBold
		logoutButton.TextSize = 18
		logoutButton.Text = "ログアウト"
		logoutButton.TextColor3 = Color3.new(1, 1, 1)
		logoutButton.TextTransparency = 1
		logoutButton.ZIndex = 53
		logoutButton.Parent = content

		TweenService:Create(logoutButton, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0.1), {
			BackgroundTransparency = 0.2,
			TextTransparency = 0
		}):Play()

		local logoutCorner = Instance.new("UICorner")
		logoutCorner.CornerRadius = UDim.new(0, 8)
		logoutCorner.Parent = logoutButton

		logoutButton.MouseButton1Click:Connect(function()
			player:Kick("ログアウトしました")
		end)

		local cancelButton = Instance.new("TextButton")
		cancelButton.Size = UDim2.new(0, 150, 0, 50)
		cancelButton.Position = UDim2.new(0.5, 10, 1, -70)
		cancelButton.BackgroundColor3 = Color3.fromRGB(149, 165, 166)
		cancelButton.BackgroundTransparency = 0.2
		cancelButton.BorderSizePixel = 0
		cancelButton.Font = Enum.Font.GothamBold
		cancelButton.TextSize = 18
		cancelButton.Text = "キャンセル"
		cancelButton.TextColor3 = Color3.new(1, 1, 1)
		cancelButton.TextTransparency = 1
		cancelButton.ZIndex = 53
		cancelButton.Parent = content

		TweenService:Create(cancelButton, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0.15), {
			BackgroundTransparency = 0.2,
			TextTransparency = 0
		}):Play()

		local cancelCorner = Instance.new("UICorner")
		cancelCorner.CornerRadius = UDim.new(0, 8)
		cancelCorner.Parent = cancelButton

		cancelButton.MouseButton1Click:Connect(function()
			closeModal()
		end)
	end)
end


-- ★新規機能: システムメニュー (2x2グリッド)
local function showSystem()
	createModal("システム", function(content)
        -- コンテンツフレームを基準に、2x2グリッドを中央に配置
        local systemFrame = Instance.new("Frame")
        systemFrame.Size = UDim2.new(1, 0, 1, 0)
        systemFrame.BackgroundTransparency = 1
        systemFrame.Parent = content

        local systemButtons = {
            {name = "セーブ", func = showSaveModal, row = 0, col = 0, color = Color3.fromRGB(46, 204, 113)}, -- 緑
            {name = "ロード", func = showLoadModal, row = 0, col = 1, color = Color3.fromRGB(52, 152, 219)}, -- 青
            {name = "初期化", func = showResetModal, row = 1, col = 0, color = Color3.fromRGB(231, 76, 60)}, -- 赤
            {name = "ログアウト", func = showLogoutInner, row = 1, col = 1, color = Color3.fromRGB(149, 165, 166)}, -- 灰色
        }

        local buttonWidth = 160
        local buttonHeight = 65
        local spacing = 15

        local totalWidth = buttonWidth * 2 + spacing
        local totalHeight = buttonHeight * 2 + spacing

        for _, btnData in ipairs(systemButtons) do
            local button = Instance.new("TextButton")
            button.Name = btnData.name .. "Button"
            button.Size = UDim2.new(0, buttonWidth, 0, buttonHeight)

            -- グリッドの中心に配置するためのオフセット計算（手動調整が容易なようにAnchorPointを使用しない）
            local gridX = btnData.col * (buttonWidth + spacing)
            local gridY = btnData.row * (buttonHeight + spacing)

            -- AbsoluteSizeは実行時にしか確定しないため、AnchorPoint 0.5で相対位置を計算
            button.Position = UDim2.new(0.5, gridX - totalWidth / 2, 0.5, gridY - totalHeight / 2)

            button.BackgroundColor3 = btnData.color
            button.BackgroundTransparency = 0.2
            button.BorderSizePixel = 0
            button.Font = Enum.Font.GothamBold
            button.TextSize = 18
            button.Text = btnData.name
            button.TextColor3 = Color3.new(1, 1, 1)
            button.TextStrokeTransparency = 0.7
            button.ZIndex = 53
            button.Parent = systemFrame

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 8)
            corner.Parent = button

            button.MouseButton1Click:Connect(function()
                if not isInBattle then
                    -- Systemモーダルを閉じてから、次のモーダルまたはアクションを実行
                    -- showLogoutInnerは内部でcloseModalを呼ばないため、ここでcloseModalする
                    if btnData.name ~= "ログアウト" and btnData.name ~= "初期化" then
                        closeModal()
                    end
                    btnData.func()
                end
            end)

            button.MouseEnter:Connect(function()
                if not isInBattle then
                    button.BackgroundColor3 = btnData.color:Lerp(Color3.new(1,1,1), 0.3)
                end
            end)
            button.MouseLeave:Connect(function()
                button.BackgroundColor3 = btnData.color
            end)
        end
	end)
end


-- メニューUI作成
local function createMenuUI()
	menuGui = Instance.new("ScreenGui")
	menuGui.Name = "MenuUI"
	menuGui.ResetOnSpawn = false
	menuGui.Parent = playerGui

	menuFrame = Instance.new("Frame")
	menuFrame.Name = "MenuFrame"
	menuFrame.Size = UDim2.new(0, 250, 0, 120)
	menuFrame.Position = UDim2.new(1, -270, 1, -270)
	menuFrame.BackgroundTransparency = 1
	menuFrame.Parent = menuGui

	local menuButtons = {
		{name = "ステータス", func = showStatus, row = 0, col = 0},
		{name = "アイテム", func = showItems, row = 0, col = 1},
		{name = "スキル", func = showSkills, row = 0, col = 2},
		{name = "戦歴", func = showRecords, row = 1, col = 0},
		{name = "設定", func = showSettings, row = 1, col = 1},
		{name = "システム", func = showSystem, row = 1, col = 2}, -- ★修正: ログアウトをシステムに置き換え
	}

	local buttonWidth = 80
	local buttonHeight = 50
	local spacing = 5

	for _, btnData in ipairs(menuButtons) do
		local button = Instance.new("TextButton")
		button.Name = btnData.name .. "Button"
		button.Size = UDim2.new(0, buttonWidth, 0, buttonHeight)
		button.Position = UDim2.new(0, btnData.col * (buttonWidth + spacing), 0, btnData.row * (buttonHeight + spacing))
		button.BackgroundColor3 = Color3.fromRGB(50, 50, 60)
		button.BackgroundTransparency = 0.2
		button.BorderSizePixel = 0
		button.Font = Enum.Font.GothamBold
		button.TextSize = 14
		button.Text = btnData.name
		button.TextColor3 = Color3.new(1, 1, 1)
		button.TextStrokeTransparency = 0.7
		button.Parent = menuFrame

		local corner = Instance.new("UICorner")
		corner.CornerRadius = UDim.new(0, 8)
		corner.Parent = button

		button.MouseButton1Click:Connect(function()
			if not isInBattle then
				btnData.func()
			end
		end)

		button.MouseEnter:Connect(function()
			if not isInBattle then
				button.BackgroundColor3 = Color3.fromRGB(70, 70, 80)
			end
		end)
		button.MouseLeave:Connect(function()
			button.BackgroundColor3 = Color3.fromRGB(50, 50, 60)
		end)
	end

	print("[MenuUI] メニューUI作成完了")
end

createMenuUI()

if RequestStatusEvent then
	task.wait(1)
	RequestStatusEvent:FireServer()
end

print("[MenuUI] 初期化完了")
===== ./StartPlayerScripts/LevelUpUI.client.lua =====
-- StarterPlayer/StarterPlayerScripts/LevelUpUI.client.lua
-- レベルアップ演出

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

print("[LevelUpUI] 初期化中...")

-- UI要素
local levelUpGui = nil

-- レベルアップ演出を表示
local function showLevelUp(level, maxHP, speed, attack, defense)
	print(("[LevelUpUI] ========================================"):format())
	print(("[LevelUpUI] レベルアップ演出開始！"):format())
	print(("[LevelUpUI] Lv.%d, HP:%d, 素早さ:%d, 攻撃:%d, 守備:%d"):format(
		level, maxHP, speed, attack, defense
		))
	print(("[LevelUpUI] ========================================"):format())

	-- 既存のGUIを削除
	if levelUpGui then
		levelUpGui:Destroy()
	end

	-- 新しいGUIを作成
	levelUpGui = Instance.new("ScreenGui")
	levelUpGui.Name = "LevelUpUI"
	levelUpGui.ResetOnSpawn = false
	levelUpGui.Parent = playerGui

	-- 背景（暗い）
	local background = Instance.new("Frame")
	background.Size = UDim2.fromScale(1, 1)
	background.Position = UDim2.fromScale(0, 0)
	background.BackgroundColor3 = Color3.new(0, 0, 0)
	background.BackgroundTransparency = 1
	background.BorderSizePixel = 0
	background.ZIndex = 100
	background.Parent = levelUpGui

	-- 背景を暗くする
	local bgTween = TweenService:Create(background, TweenInfo.new(0.3), {
		BackgroundTransparency = 0.5
	})
	bgTween:Play()

	-- レベルアップテキスト
	local levelUpText = Instance.new("TextLabel")
	levelUpText.Size = UDim2.new(0, 600, 0, 100)
	levelUpText.Position = UDim2.new(0.5, -300, 0.35, -50)
	levelUpText.BackgroundTransparency = 1
	levelUpText.TextColor3 = Color3.fromRGB(255, 215, 0)
	levelUpText.TextStrokeTransparency = 0
	levelUpText.TextStrokeColor3 = Color3.new(0, 0, 0)
	levelUpText.Font = Enum.Font.GothamBold
	levelUpText.TextSize = 60
	levelUpText.Text = "LEVEL UP!"
	levelUpText.TextTransparency = 1
	levelUpText.ZIndex = 101
	levelUpText.Parent = levelUpGui

	-- テキストをフェードイン
	local textTween = TweenService:Create(levelUpText, TweenInfo.new(0.5), {
		TextTransparency = 0,
		TextStrokeTransparency = 0
	})
	textTween:Play()

	-- レベル表示
	local levelText = Instance.new("TextLabel")
	levelText.Size = UDim2.new(0, 600, 0, 60)
	levelText.Position = UDim2.new(0.5, -300, 0.45, 0)
	levelText.BackgroundTransparency = 1
	levelText.TextColor3 = Color3.fromRGB(255, 255, 255)
	levelText.TextStrokeTransparency = 0
	levelText.Font = Enum.Font.GothamBold
	levelText.TextSize = 40
	levelText.Text = string.format("Level %d", level)
	levelText.TextTransparency = 1
	levelText.ZIndex = 101
	levelText.Parent = levelUpGui

	-- レベルテキストをフェードイン
	local levelTextTween = TweenService:Create(levelText, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0.2), {
		TextTransparency = 0,
		TextStrokeTransparency = 0.5
	})
	levelTextTween:Play()

	-- ステータス表示フレーム
	local statsFrame = Instance.new("Frame")
	statsFrame.Size = UDim2.new(0, 400, 0, 150)
	statsFrame.Position = UDim2.new(0.5, -200, 0.55, 0)
	statsFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
	statsFrame.BackgroundTransparency = 1
	statsFrame.BorderSizePixel = 0
	statsFrame.ZIndex = 101
	statsFrame.Parent = levelUpGui

	-- 角を丸くする
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 10)
	corner.Parent = statsFrame

	-- フレームをフェードイン
	local frameTween = TweenService:Create(statsFrame, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0.3), {
		BackgroundTransparency = 0.2
	})
	frameTween:Play()

	-- ステータステキスト
	local statsText = Instance.new("TextLabel")
	statsText.Size = UDim2.new(1, -40, 1, -40)
	statsText.Position = UDim2.new(0, 20, 0, 20)
	statsText.BackgroundTransparency = 1
	statsText.TextColor3 = Color3.fromRGB(200, 255, 200)
	statsText.TextStrokeTransparency = 0.5
	statsText.Font = Enum.Font.Gotham
	statsText.TextSize = 20
	statsText.Text = string.format(
		"HP: %d (+10)\n素早さ: %d (+2)\n攻撃力: %d (+2)\n守備力: %d (+2)",
		maxHP, speed, attack, defense
	)
	statsText.TextTransparency = 1
	statsText.TextYAlignment = Enum.TextYAlignment.Top
	statsText.ZIndex = 102
	statsText.Parent = statsFrame

	-- ステータステキストをフェードイン
	local statsTween = TweenService:Create(statsText, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0.4), {
		TextTransparency = 0,
		TextStrokeTransparency = 0.5
	})
	statsTween:Play()

	-- 2.5秒後にフェードアウト
	task.delay(2.5, function()
		local fadeOutTween = TweenService:Create(background, TweenInfo.new(0.5), {
			BackgroundTransparency = 1
		})
		fadeOutTween:Play()

		TweenService:Create(levelUpText, TweenInfo.new(0.5), {
			TextTransparency = 1,
			TextStrokeTransparency = 1
		}):Play()

		TweenService:Create(levelText, TweenInfo.new(0.5), {
			TextTransparency = 1,
			TextStrokeTransparency = 1
		}):Play()

		TweenService:Create(statsFrame, TweenInfo.new(0.5), {
			BackgroundTransparency = 1
		}):Play()

		TweenService:Create(statsText, TweenInfo.new(0.5), {
			TextTransparency = 1,
			TextStrokeTransparency = 1
		}):Play()

		-- 3秒後に削除
		task.wait(0.5)
		if levelUpGui then
			levelUpGui:Destroy()
			levelUpGui = nil
		end
	end)
end

-- RemoteEventを待機
local LevelUpEvent = ReplicatedStorage:WaitForChild("LevelUp", 10)
if LevelUpEvent then
	LevelUpEvent.OnClientEvent:Connect(showLevelUp)
	print("[LevelUpUI] LevelUpイベント接続完了")
else
	warn("[LevelUpUI] LevelUpイベントが見つかりません")
end

print("[LevelUpUI] 初期化完了")
===== ./StartPlayerScripts/BattleUI.client.lua =====
-- StarterPlayer/StarterPlayerScripts/BattleUI.client.lua
-- タイピングバトルUI制御（クライアント側）

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local StarterGui = game:GetService("StarterGui")
local ContextActionService = game:GetService("ContextActionService")
local LocalizationService = game:GetService("LocalizationService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

print("[BattleUI] クライアント起動中...")

-- ユーザーのロケールを取得
local userLocale = string.lower(LocalizationService.RobloxLocaleId)
local localeCode = string.match(userLocale, "^(%a+)") or "en"  -- "ja-jp" → "ja"

-- 【開発用】強制的に日本語表示（本番では削除可能）
local FORCE_LOCALE = "ja"  -- ここを変更すると表示言語が変わる（nil で自動検出）
if FORCE_LOCALE then
	localeCode = FORCE_LOCALE
	print(("[BattleUI] 言語を強制設定: %s"):format(localeCode))
end

print(("[BattleUI] ユーザーロケール: %s → 表示言語: %s"):format(userLocale, localeCode))

-- RemoteEventsを待機
local BattleStartEvent = ReplicatedStorage:WaitForChild("BattleStart", 30)
local BattleEndEvent = ReplicatedStorage:WaitForChild("BattleEnd", 30)
local BattleDamageEvent = ReplicatedStorage:WaitForChild("BattleDamage", 30)

if not BattleStartEvent or not BattleEndEvent or not BattleDamageEvent then
	warn("[BattleUI] RemoteEventの取得に失敗しました")
	return
end

-- 単語リストを読み込み
local TypingWords = require(ReplicatedStorage:WaitForChild("TypingWords"))

-- デバッグ：単語リストの内容を確認
print("[BattleUI DEBUG] TypingWords.level_1[1]:")
if TypingWords.level_1 and TypingWords.level_1[1] then
	local firstWord = TypingWords.level_1[1]
	print("  Type:", type(firstWord))
	if type(firstWord) == "table" then
		print("  word:", firstWord.word)
		print("  ja:", firstWord.ja)
	else
		print("  Value:", firstWord)
	end
end

print("[BattleUI] RemoteEvents取得完了")

-- 状態
local inBattle = false
local currentWord = ""
local currentWordData = nil  -- 翻訳データを含む単語情報
local lastWord = nil  -- 前回の単語（連続回避用）
local currentIndex = 1
local typingLevels = {}
local currentBattleTimeout = nil
local monsterHP = 0
local monsterMaxHP = 0
local playerHP = 0  -- プレイヤーの現在HP
local playerMaxHP = 0  -- プレイヤーの最大HP
local damagePerKey = 1

-- カメラ設定保存用
local originalCameraMaxZoom = nil
local originalCameraMinZoom = nil

-- UI要素
local battleGui = nil
local darkenFrame = nil
local wordFrame = nil
local wordLabel = nil
local translationLabel = nil  -- 翻訳表示用
local hpBarBackground = nil
local hpBarFill = nil
local hpLabel = nil

-- システムキーをブロックする関数
local function blockSystemKeys()
	-- カメラズームを完全に固定
	originalCameraMaxZoom = player.CameraMaxZoomDistance
	originalCameraMinZoom = player.CameraMinZoomDistance

	-- 現在のズーム距離を取得して固定
	local camera = workspace.CurrentCamera
	local currentZoom = (camera.CFrame.Position - player.Character.HumanoidRootPart.Position).Magnitude
	player.CameraMaxZoomDistance = currentZoom
	player.CameraMinZoomDistance = currentZoom

	print(("[BattleUI] カメラを固定しました (距離: %.1f)"):format(currentZoom))
end

-- ブロック解除
local function unblockSystemKeys()
	-- カメラズームを復元
	if originalCameraMaxZoom and originalCameraMinZoom then
		player.CameraMaxZoomDistance = originalCameraMaxZoom
		player.CameraMinZoomDistance = originalCameraMinZoom
		print("[BattleUI] カメラ設定を復元しました")
	end
end

-- 【forward declaration】
local onBattleEnd
local updateDisplay
local setNextWord

-- HPバーの色を取得（HP割合に応じて変化）
local function getHPColor(hpPercent)
	if hpPercent > 0.6 then
		-- 緑
		return Color3.fromRGB(46, 204, 113)
	elseif hpPercent > 0.3 then
		-- 黄色
		return Color3.fromRGB(241, 196, 15)
	else
		-- 赤
		return Color3.fromRGB(231, 76, 60)
	end
end

-- 表示を更新
updateDisplay = function()
	if not wordLabel then return end

	-- 入力済み文字を緑、未入力を白で表示
	local typedPart = string.sub(currentWord, 1, currentIndex - 1)
	local remainingPart = string.sub(currentWord, currentIndex)

	wordLabel.Text = string.format('<font color="#00FF00">%s</font>%s', typedPart, remainingPart)

	-- 敵HPバー更新
	if hpBarFill and hpLabel then
		local hpPercent = monsterHP / monsterMaxHP

		-- バーの長さをアニメーション
		local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
		local tween = TweenService:Create(hpBarFill, tweenInfo, {
			Size = UDim2.new(hpPercent, 0, 1, 0)
		})
		tween:Play()

		-- 色を変更
		hpBarFill.BackgroundColor3 = getHPColor(hpPercent)

		-- テキスト更新
		hpLabel.Text = string.format("Enemy HP: %d / %d", monsterHP, monsterMaxHP)
	end
end

-- 単語を選択する関数
local function selectWord()
	if #typingLevels == 0 then
		-- デフォルト：level_1のみ
		typingLevels = {{level = "level_1", weight = 100}}
	end

	-- 重み付きランダム選択
	local totalWeight = 0
	for _, config in ipairs(typingLevels) do
		totalWeight = totalWeight + config.weight
	end

	local randomValue = math.random(1, totalWeight)
	local cumulativeWeight = 0
	local selectedLevel = "level_1"

	for _, config in ipairs(typingLevels) do
		cumulativeWeight = cumulativeWeight + config.weight
		if randomValue <= cumulativeWeight then
			selectedLevel = config.level
			break
		end
	end

	-- 選択されたレベルから単語を取得
	local wordList = TypingWords[selectedLevel]
	if wordList and #wordList > 0 then
		-- 前回と同じ単語を避ける（最大5回まで再抽選）
		local wordData = nil
		local attempts = 0

		repeat
			wordData = wordList[math.random(1, #wordList)]
			attempts = attempts + 1

			-- 新形式（テーブル）か旧形式（文字列）か判定
			local currentWordStr = type(wordData) == "table" and wordData.word or wordData

			-- 前回と違う単語が出たら、または5回試したらループ終了
			if currentWordStr ~= lastWord or attempts >= 5 or #wordList == 1 then
				break
			end
		until false

		-- 新形式（テーブル）か旧形式（文字列）か判定
		if type(wordData) == "table" then
			return wordData
		else
			-- 旧形式の場合は互換性のためテーブルに変換
			return {word = wordData}
		end
	else
		return {word = "apple", ja = "りんご"}  -- フォールバック
	end
end

-- 次の単語を設定
setNextWord = function()
	currentWordData = selectWord()
	currentWord = currentWordData.word
	currentIndex = 1

	-- 今回の単語を記憶（次回の連続回避用）
	lastWord = currentWord

	print(("[BattleUI DEBUG] currentWordData:"):format())
	print(currentWordData)
	print(("[BattleUI DEBUG] localeCode: %s"):format(localeCode))

	-- 翻訳を表示（フォールバック付き）
	if translationLabel then
		-- 優先順位：指定言語 → 日本語 → スペイン語 → フランス語 → 空
		local translation = currentWordData[localeCode]
			or currentWordData.ja
			or currentWordData.es
			or currentWordData.fr
			or ""

		translationLabel.Text = translation
		translationLabel.Visible = translation ~= ""
		print(("[BattleUI DEBUG] translation: %s"):format(translation))
	else
		warn("[BattleUI DEBUG] translationLabel が nil です！")
	end

	updateDisplay()
	print(("[BattleUI] 次の単語: %s (%s)"):format(currentWord, currentWordData[localeCode] or currentWordData.ja or ""))
end

-- UI作成
local function createBattleUI()
	battleGui = Instance.new("ScreenGui")
	battleGui.Name = "BattleUI"
	battleGui.ResetOnSpawn = false
	battleGui.Enabled = false
	battleGui.Parent = playerGui

	-- 暗転用フレーム
	darkenFrame = Instance.new("Frame")
	darkenFrame.Name = "DarkenFrame"
	darkenFrame.Size = UDim2.fromScale(1, 1)
	darkenFrame.Position = UDim2.fromScale(0, 0)
	darkenFrame.BackgroundColor3 = Color3.new(0, 0, 0)
	darkenFrame.BackgroundTransparency = 1
	darkenFrame.BorderSizePixel = 0
	darkenFrame.ZIndex = 1
	darkenFrame.Parent = battleGui

	-- 敵HPバー背景
	hpBarBackground = Instance.new("Frame")
	hpBarBackground.Name = "HPBarBackground"
	hpBarBackground.Size = UDim2.new(0, 500, 0, 40)
	hpBarBackground.Position = UDim2.new(0.5, -250, 0.25, 0)
	hpBarBackground.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
	hpBarBackground.BorderSizePixel = 0
	hpBarBackground.ZIndex = 2
	hpBarBackground.Parent = battleGui

	-- HPバー背景の角を丸くする
	local hpBarCorner = Instance.new("UICorner")
	hpBarCorner.CornerRadius = UDim.new(0, 8)
	hpBarCorner.Parent = hpBarBackground

	-- HPバー（塗りつぶし部分）
	hpBarFill = Instance.new("Frame")
	hpBarFill.Name = "HPBarFill"
	hpBarFill.Size = UDim2.new(1, 0, 1, 0)
	hpBarFill.Position = UDim2.new(0, 0, 0, 0)
	hpBarFill.BackgroundColor3 = Color3.fromRGB(46, 204, 113)
	hpBarFill.BorderSizePixel = 0
	hpBarFill.ZIndex = 3
	hpBarFill.Parent = hpBarBackground

	-- HPバーの角を丸くする
	local hpFillCorner = Instance.new("UICorner")
	hpFillCorner.CornerRadius = UDim.new(0, 8)
	hpFillCorner.Parent = hpBarFill

	-- HPテキスト（バーの上に表示）
	hpLabel = Instance.new("TextLabel")
	hpLabel.Name = "HPLabel"
	hpLabel.Size = UDim2.new(1, 0, 1, 0)
	hpLabel.Position = UDim2.new(0, 0, 0, 0)
	hpLabel.BackgroundTransparency = 1
	hpLabel.TextColor3 = Color3.new(1, 1, 1)
	hpLabel.TextStrokeTransparency = 0.5
	hpLabel.Font = Enum.Font.GothamBold
	hpLabel.TextSize = 20
	hpLabel.Text = "HP: 10 / 10"
	hpLabel.ZIndex = 4
	hpLabel.Parent = hpBarBackground

	-- 単語表示用フレーム（枠）
	wordFrame = Instance.new("Frame")
	wordFrame.Name = "WordFrame"
	wordFrame.Size = UDim2.new(0, 700, 0, 150)
	wordFrame.Position = UDim2.new(0.5, -350, 0.5, -75)
	wordFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
	wordFrame.BorderSizePixel = 3
	wordFrame.BorderColor3 = Color3.fromRGB(100, 200, 255)
	wordFrame.ZIndex = 2
	wordFrame.Parent = battleGui

	-- 枠の角を丸くする
	local wordFrameCorner = Instance.new("UICorner")
	wordFrameCorner.CornerRadius = UDim.new(0, 12)
	wordFrameCorner.Parent = wordFrame

	-- 枠に光るエフェクト（UIStroke）
	local wordFrameStroke = Instance.new("UIStroke")
	wordFrameStroke.Color = Color3.fromRGB(100, 200, 255)
	wordFrameStroke.Thickness = 3
	wordFrameStroke.Transparency = 0
	wordFrameStroke.Parent = wordFrame

	-- 単語表示（RichText対応）
	wordLabel = Instance.new("TextLabel")
	wordLabel.Name = "WordLabel"
	wordLabel.Size = UDim2.new(1, -40, 0.6, 0)
	wordLabel.Position = UDim2.new(0, 20, 0, 10)
	wordLabel.BackgroundTransparency = 1
	wordLabel.TextColor3 = Color3.new(1, 1, 1)
	wordLabel.TextStrokeTransparency = 0
	wordLabel.Font = Enum.Font.GothamBold
	wordLabel.TextSize = 60
	wordLabel.Text = "apple"
	wordLabel.RichText = true
	wordLabel.ZIndex = 3
	wordLabel.Parent = wordFrame

	-- 翻訳表示（単語の下）
	translationLabel = Instance.new("TextLabel")
	translationLabel.Name = "TranslationLabel"
	translationLabel.Size = UDim2.new(1, -40, 0.35, 0)
	translationLabel.Position = UDim2.new(0, 20, 0.65, 0)
	translationLabel.BackgroundTransparency = 1
	translationLabel.TextColor3 = Color3.fromRGB(150, 200, 255)
	translationLabel.TextStrokeTransparency = 0.3
	translationLabel.Font = Enum.Font.Gotham
	translationLabel.TextSize = 28
	translationLabel.Text = "テスト"  -- デバッグ用の初期値
	translationLabel.TextYAlignment = Enum.TextYAlignment.Top
	translationLabel.Visible = true
	translationLabel.ZIndex = 3
	translationLabel.Parent = wordFrame

	print("[BattleUI DEBUG] translationLabel 作成完了")

	print("[BattleUI] UI作成完了")
end

local Sounds = ReplicatedStorage:WaitForChild("Sounds", 10)
local TypingCorrectSound = Sounds and Sounds:WaitForChild("TypingCorrect", 5)
local TypingErrorSound = Sounds and Sounds:WaitForChild("TypingError", 5)

if not TypingCorrectSound then
	warn("[BattleUI] TypingCorrect効果音が見つかりません (WaitForChild タイムアウト)")
end
if not TypingErrorSound then
	warn("[BattleUI] TypingError効果音が見つかりません (WaitForChild タイムアウト)")
end

-- バトル開始処理
local function onBattleStart(monsterName, hp, maxHP, damage, levels, pHP, pMaxHP)
	print("[BattleUI] === onBattleStart呼び出し ===")

	-- nil チェックとデフォルト値
	monsterName = monsterName or "Unknown"
	hp = hp or 10
	maxHP = maxHP or 10
	damage = damage or 1
	levels = levels or {{level = "level_1", weight = 100}}
	pHP = pHP or 100
	pMaxHP = pMaxHP or 100

	print(("[BattleUI] バトル開始: vs %s (敵HP: %d, プレイヤーHP: %d/%d, Damage: %d)"):format(
		monsterName, hp, pHP, pMaxHP, damage
		))

	if inBattle then
		print("[BattleUI DEBUG] すでに戦闘中")
		return
	end

	inBattle = true
	monsterHP = hp
	monsterMaxHP = maxHP
	playerHP = pHP
	playerMaxHP = pMaxHP
	damagePerKey = damage
	typingLevels = levels

	-- システムキーをブロック
	blockSystemKeys()

	print("[BattleUI] プレイヤー停止処理開始")

	-- プレイヤーの入力を完全にブロック
	local character = player.Character
	if character then
		local humanoid = character:FindFirstChildOfClass("Humanoid")
		if humanoid then
			humanoid.WalkSpeed = 0
			humanoid.JumpPower = 0
			humanoid.JumpHeight = 0
		end
	end

	print("[BattleUI] RobloxのUIを無効化")

	-- RobloxのUIを無効化
	pcall(function()
		StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Chat, false)
		StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, false)
		StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, false)
		StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.EmotesMenu, false)
	end)

	print("[BattleUI] UIを表示")

	battleGui.Enabled = true

	-- 【重要】RichTextを確実に有効化、全ラベルをリセット
	print("[BattleUI] UI要素をリセット")
	if wordLabel then
		wordLabel.RichText = true
		wordLabel.TextColor3 = Color3.new(1, 1, 1)
		wordLabel.Text = ""
		wordLabel.TextTransparency = 0  -- 追加
		wordLabel.TextStrokeTransparency = 0  -- 追加
	end
	if translationLabel then
		translationLabel.TextColor3 = Color3.fromRGB(150, 200, 255)
		translationLabel.Text = ""
		translationLabel.Visible = true
		translationLabel.TextTransparency = 0  -- 追加
		translationLabel.TextStrokeTransparency = 0.3  -- 追加
	end
	if hpLabel then
		hpLabel.TextColor3 = Color3.new(1, 1, 1)
		hpLabel.Text = ""
		hpLabel.TextTransparency = 0  -- 追加
		hpLabel.TextStrokeTransparency = 0.5  -- 追加
	end
	if hpBarFill then
		hpBarFill.Size = UDim2.new(1, 0, 1, 0)
		hpBarFill.BackgroundColor3 = Color3.fromRGB(46, 204, 113)
		hpBarFill.BackgroundTransparency = 0  -- 追加
	end
	if hpBarBackground then
		hpBarBackground.BackgroundTransparency = 0  -- 追加
	end
	if playerHPBarFill then
		playerHPBarFill.Size = UDim2.new(1, 0, 1, 0)
		playerHPBarFill.BackgroundColor3 = Color3.fromRGB(46, 204, 113)
	end

	-- 枠の色をリセット（青に戻す）
	if wordFrame then
		wordFrame.BorderColor3 = Color3.fromRGB(100, 200, 255)
		wordFrame.BackgroundTransparency = 0.2  -- 追加
		local frameStroke = wordFrame:FindFirstChildOfClass("UIStroke")
		if frameStroke then
			frameStroke.Color = Color3.fromRGB(100, 200, 255)
			frameStroke.Transparency = 0  -- 追加
		end
	end

	-- 背景の透明度をリセット
	if darkenFrame then
		darkenFrame.BackgroundTransparency = 0.4  -- 追加
	end
	print("[BattleUI] 暗転処理")

	-- 画面を薄暗くする
	darkenFrame.BackgroundTransparency = 0.4

	print("[BattleUI] 単語設定")

	-- 最初の単語を設定
	setNextWord()

	print("[BattleUI] タイムアウト設定")

	-- タイムアウト機能：30秒経過したら強制終了
	currentBattleTimeout = task.delay(30, function()
		if inBattle then
			warn("[BattleUI] バトルタイムアウト！強制終了します")
			onBattleEnd(false)
		end
	end)

	print("[BattleUI] === バトル開始処理完了 ===")
end

-- バトル終了処理
onBattleEnd = function(victory)
	print("[BattleUI] === バトル終了開始: " .. tostring(victory) .. " ===")

	-- 既にバトルが終了している場合はスキップ
	if not inBattle and not battleGui.Enabled then
		print("[BattleUI] 既にバトル終了済み")
		return
	end

	-- 【最優先】バトル状態を即座にクリア（キー入力を停止）
	inBattle = false
	currentWord = ""
	currentWordData = nil
	currentIndex = 1
	playerHP = 0
	playerMaxHP = 0

	-- タイムアウトをキャンセル
	if currentBattleTimeout then
		task.cancel(currentBattleTimeout)
		currentBattleTimeout = nil
	end

	-- 勝利時の処理
	-- 勝利時の処理
	if victory then
		-- システムキーのブロックを解除
		unblockSystemKeys()

		print("[BattleUI] Roblox UI再有効化")

		-- Roblox UIを再有効化
		pcall(function()
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Chat, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.EmotesMenu, true)
		end)

		-- 勝利メッセージを表示
		if wordLabel then
			wordLabel.RichText = false
			wordLabel.Text = "VICTORY!"
			wordLabel.TextColor3 = Color3.fromRGB(255, 215, 0)
			wordLabel.TextTransparency = 0
			wordLabel.TextStrokeTransparency = 0

			-- 0.5秒かけてフェードアウト
			TweenService:Create(wordLabel, TweenInfo.new(0.5), {
				TextTransparency = 1,
				TextStrokeTransparency = 1
			}):Play()
		end

		-- 翻訳ラベルを非表示
		if translationLabel then
			translationLabel.Visible = false
		end

		-- 枠を金色にしてフェードアウト
		if wordFrame then
			wordFrame.BorderColor3 = Color3.fromRGB(255, 215, 0)
			local frameStroke = wordFrame:FindFirstChildOfClass("UIStroke")
			if frameStroke then
				frameStroke.Color = Color3.fromRGB(255, 215, 0)
				TweenService:Create(frameStroke, TweenInfo.new(0.5), {
					Transparency = 1
				}):Play()
			end

			TweenService:Create(wordFrame, TweenInfo.new(0.5), {
				BackgroundTransparency = 1
			}):Play()
		end

		-- HPバーをフェードアウト
		if hpBarBackground then
			TweenService:Create(hpBarBackground, TweenInfo.new(0.5), {
				BackgroundTransparency = 1
			}):Play()
		end

		if hpBarFill then
			TweenService:Create(hpBarFill, TweenInfo.new(0.5), {
				BackgroundTransparency = 1
			}):Play()
		end

		if hpLabel then
			TweenService:Create(hpLabel, TweenInfo.new(0.5), {
				TextTransparency = 1,
				TextStrokeTransparency = 1
			}):Play()
		end

		-- プレイヤーの入力ブロックを解除
		local character = player.Character
		if character then
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			if humanoid then
				humanoid.WalkSpeed = 16
				humanoid.JumpPower = 50
				humanoid.JumpHeight = 7.2
			end
		end

		-- 画面を明るく戻す
		TweenService:Create(darkenFrame, TweenInfo.new(0.5), {
			BackgroundTransparency = 1
		}):Play()

		-- UIを非表示にするための遅延実行（別スレッドで）
		task.spawn(function()
			task.wait(0.6)  -- アニメーション完了を待つ
			if not inBattle then  -- まだ次のバトルが始まっていないことを確認
				battleGui.Enabled = false
			end
		end)
	else
		-- 敗北時：UIを維持したまま死亡選択UIを待つ
		print("[BattleUI] 敗北 - UIを維持します")

		-- 敗北メッセージ
		if wordLabel then
			wordLabel.RichText = false
			wordLabel.Text = "DEFEAT..."
			wordLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
		end

		-- 翻訳ラベルを非表示
		if translationLabel then
			translationLabel.Visible = false
		end

		-- 枠の色も変更
		if wordFrame then
			local frameStroke = wordFrame:FindFirstChildOfClass("UIStroke")
			if frameStroke then
				frameStroke.Color = Color3.fromRGB(255, 100, 100)
			end
		end

		-- システムキーのブロックとRoblox UIは維持
		-- プレイヤーの移動制限も維持
		-- 死亡選択UIで選んだ後に解除する
	end

	print("[BattleUI] === バトル終了完了 ===")
end

-- HP更新処理（敵）
local function onHPUpdate(newHP)
	monsterHP = newHP

	print(("[BattleUI] ========================================"):format())
	print(("[BattleUI] 敵HP更新"):format())
	print(("  新HP: %d"):format(newHP))
	print(("  最大HP: %d"):format(monsterMaxHP))
	print(("  HP割合: %.1f%%"):format((newHP / monsterMaxHP) * 100))
	print(("[BattleUI] ========================================"):format())

	updateDisplay()

	-- HPが0になったら勝利（サーバーからの通知も来るが念のため）
	if monsterHP <= 0 then
		print("[BattleUI] ⚠️ 敵HPが0になりました（クライアント側で検出）")
	end
end

-- HP更新処理（プレイヤー）
local function onPlayerHPUpdate(newHP, newMaxHP)
	playerHP = newHP
	playerMaxHP = newMaxHP or playerMaxHP
	updateDisplay()

	print(("[BattleUI] プレイヤーHP更新: %d / %d"):format(playerHP, playerMaxHP))

	-- HPが0になったら敗北（サーバーからの通知も来るが念のため）
	if playerHP <= 0 then
		print("[BattleUI] プレイヤーHPが0になりました")
	end
end

-- システムキーをブロックする入力処理（最優先）
UserInputService.InputBegan:Connect(function(input, gameProcessed)
	-- バトル中にシステムキーが押された場合、先に処理して消費する
	if inBattle and input.UserInputType == Enum.UserInputType.Keyboard then
		local blockedKeys = {
			[Enum.KeyCode.I] = true,
			[Enum.KeyCode.O] = true,
			[Enum.KeyCode.Slash] = true,
			[Enum.KeyCode.Backquote] = true,
			[Enum.KeyCode.Tab] = true,
			[Enum.KeyCode.BackSlash] = true,
			[Enum.KeyCode.Equals] = true,
			[Enum.KeyCode.Minus] = true,
		}

		if blockedKeys[input.KeyCode] then
			-- このキーはタイピング処理に回す（ズームなどは発動させない）
			return
		end
	end
end)

-- キー入力処理
local function onKeyPress(input, gameProcessed)
	if not inBattle then return end

	if input.UserInputType == Enum.UserInputType.Keyboard then
		local keyCode = input.KeyCode
		local keyString = UserInputService:GetStringForKeyCode(keyCode):lower()

		-- 英字のみ受け付け
		if #keyString == 1 and keyString:match("%a") then
			local expectedChar = string.sub(currentWord, currentIndex, currentIndex):lower()

			if keyString == expectedChar then
				-- 正解
				currentIndex = currentIndex + 1

				-- 正解音を再生
				if TypingCorrectSound then
					TypingCorrectSound:Play()
				end

				-- サーバーにダメージ通知
				BattleDamageEvent:FireServer(damagePerKey)

				-- 単語完成チェック
				if currentIndex > #currentWord then
					task.wait(0.3)
					if inBattle then
						setNextWord()
					end
				else
					updateDisplay()
				end
			else
				-- タイプミス
				if TypingErrorSound then
					TypingErrorSound:Play()
				end

				-- 枠を赤く光らせる（点滅エフェクト）
				if wordFrame then
					-- 背景を赤く
					wordFrame.BackgroundColor3 = Color3.fromRGB(255, 50, 50)
					wordFrame.BackgroundTransparency = 0.3  -- 少し濃く

					-- 枠線も赤く
					local frameStroke = wordFrame:FindFirstChildOfClass("UIStroke")
					if frameStroke then
						frameStroke.Color = Color3.fromRGB(255, 50, 50)
					end

					-- 0.3秒かけて元に戻す
					TweenService:Create(wordFrame, TweenInfo.new(0.3), {
						BackgroundColor3 = Color3.fromRGB(30, 30, 40),
						BackgroundTransparency = 0.2
					}):Play()

					if frameStroke then
						TweenService:Create(frameStroke, TweenInfo.new(0.3), {
							Color = Color3.fromRGB(100, 200, 255)
						}):Play()
					end
				end

				-- タイプミス時のダメージをサーバーに通知
				local TypingMistakeEvent = ReplicatedStorage:FindFirstChild("TypingMistake")
				if TypingMistakeEvent then
					TypingMistakeEvent:FireServer()
				end
			end
		end
	end
end

-- 初期化
createBattleUI()

print("[BattleUI] イベント接続中...")
BattleStartEvent.OnClientEvent:Connect(onBattleStart)
BattleEndEvent.OnClientEvent:Connect(onBattleEnd)

-- HP更新イベント（敵）
local HPUpdateEvent = ReplicatedStorage:FindFirstChild("BattleHPUpdate")
if HPUpdateEvent then
	HPUpdateEvent.OnClientEvent:Connect(onHPUpdate)
end

-- HP更新イベント（プレイヤー）
local PlayerHPUpdateEvent = ReplicatedStorage:FindFirstChild("PlayerHPUpdate")

if PlayerHPUpdateEvent then
	PlayerHPUpdateEvent.OnClientEvent:Connect(onPlayerHPUpdate)
else
	warn("[BattleUI] PlayerHPUpdate イベントが見つかりません")
end

UserInputService.InputBegan:Connect(onKeyPress)

-- 緊急脱出用：Escキーで強制終了
UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if input.KeyCode == Enum.KeyCode.Escape and battleGui.Enabled then
		warn("[BattleUI] Escキーで強制終了")

		-- システムキーのブロックを解除
		unblockSystemKeys()

		-- Roblox UIを再有効化
		pcall(function()
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Chat, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.EmotesMenu, true)
		end)

		darkenFrame.BackgroundTransparency = 1
		battleGui.Enabled = false
		inBattle = false
		currentWord = ""
		currentWordData = nil
		currentIndex = 1
		playerHP = 0
		playerMaxHP = 0

		local character = player.Character
		if character then
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			if humanoid then
				humanoid.WalkSpeed = 16
				humanoid.JumpPower = 50
				humanoid.JumpHeight = 7.2
			end
		end
	end
end)

print("[BattleUI] クライアント初期化完了（タイピングモード）")
===== ./StartPlayerScripts/RewardPopup.client.lua =====
-- StarterPlayer/StarterPlayerScripts/RewardPopup.client.lua
-- 報酬取得時のポップアップ表示

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

print("[RewardPopup] 初期化開始")

-- RemoteEvent取得
local InteractionResponseEvent = ReplicatedStorage:WaitForChild("InteractionResponse", 10)
if not InteractionResponseEvent then
	warn("[RewardPopup] InteractionResponseが見つかりません")
	return
end

-- ScreenGui作成
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "RewardPopupUI"
screenGui.ResetOnSpawn = false
screenGui.IgnoreGuiInset = true
screenGui.DisplayOrder = 200
screenGui.Parent = playerGui

-- ポップアップを表示
local function showRewardPopup(rewards, duration)
	duration = duration or 3
	print(("[RewardPopup] 報酬を表示: %d個, 表示時間: %d秒"):format(#rewards, duration))

	-- メインフレーム
	local frame = Instance.new("Frame")
	frame.Name = "RewardFrame"
	frame.Size = UDim2.new(0, 400, 0, 0) -- 高さは動的に調整
	frame.Position = UDim2.new(0.5, -200, 0.3, 0)
	frame.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
	frame.BackgroundTransparency = 0.2
	frame.BorderSizePixel = 0
	frame.Parent = screenGui

	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 12)
	corner.Parent = frame

	-- タイトル
	local title = Instance.new("TextLabel")
	title.Size = UDim2.new(1, -20, 0, 40)
	title.Position = UDim2.new(0, 10, 0, 10)
	title.BackgroundTransparency = 1
	title.Text = "✨ アイテムを手に入れた！"
	title.TextColor3 = Color3.fromRGB(255, 220, 100)
	title.TextSize = 24
	title.Font = Enum.Font.GothamBold
	title.TextXAlignment = Enum.TextXAlignment.Left
	title.Parent = frame

	-- 報酬リストコンテナ
	local listContainer = Instance.new("Frame")
	listContainer.Size = UDim2.new(1, -20, 1, -60)
	listContainer.Position = UDim2.new(0, 10, 0, 50)
	listContainer.BackgroundTransparency = 1
	listContainer.Parent = frame

	local listLayout = Instance.new("UIListLayout")
	listLayout.SortOrder = Enum.SortOrder.LayoutOrder
	listLayout.Padding = UDim.new(0, 8)
	listLayout.Parent = listContainer

	-- 各報酬を表示
	for i, reward in ipairs(rewards) do
		local rewardFrame = Instance.new("Frame")
		rewardFrame.Size = UDim2.new(1, 0, 0, 35)
		rewardFrame.BackgroundColor3 = Color3.fromRGB(60, 60, 70)
		rewardFrame.BackgroundTransparency = 0.5
		rewardFrame.BorderSizePixel = 0
		rewardFrame.LayoutOrder = i
		rewardFrame.Parent = listContainer

		local rewardCorner = Instance.new("UICorner")
		rewardCorner.CornerRadius = UDim.new(0, 8)
		rewardCorner.Parent = rewardFrame

		-- アイテム名
		local itemLabel = Instance.new("TextLabel")
		itemLabel.Size = UDim2.new(0.7, 0, 1, 0)
		itemLabel.Position = UDim2.new(0, 15, 0, 0)
		itemLabel.BackgroundTransparency = 1
		itemLabel.Text = reward.item
		itemLabel.TextColor3 = Color3.new(1, 1, 1)
		itemLabel.TextSize = 20
		itemLabel.Font = Enum.Font.SourceSansBold
		itemLabel.TextXAlignment = Enum.TextXAlignment.Left
		itemLabel.Parent = rewardFrame

		-- 個数
		local countLabel = Instance.new("TextLabel")
		countLabel.Size = UDim2.new(0.3, -15, 1, 0)
		countLabel.Position = UDim2.new(0.7, 0, 0, 0)
		countLabel.BackgroundTransparency = 1
		countLabel.Text = "x" .. tostring(reward.count)
		countLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
		countLabel.TextSize = 20
		countLabel.Font = Enum.Font.SourceSansBold
		countLabel.TextXAlignment = Enum.TextXAlignment.Right
		countLabel.Parent = rewardFrame
	end

	-- フレームの高さを調整
	local contentHeight = 60 + (#rewards * 35) + ((#rewards - 1) * 8)
	frame.Size = UDim2.new(0, 400, 0, contentHeight)

	-- フェードイン
	frame.BackgroundTransparency = 1
	title.TextTransparency = 1

	for _, child in ipairs(listContainer:GetChildren()) do
		if child:IsA("Frame") then
			child.BackgroundTransparency = 1
			for _, label in ipairs(child:GetChildren()) do
				if label:IsA("TextLabel") then
					label.TextTransparency = 1
				end
			end
		end
	end

	-- アニメーション：フェードイン
	TweenService:Create(frame, TweenInfo.new(0.5), {
		BackgroundTransparency = 0.2
	}):Play()

	TweenService:Create(title, TweenInfo.new(0.5), {
		TextTransparency = 0
	}):Play()

	for _, child in ipairs(listContainer:GetChildren()) do
		if child:IsA("Frame") then
			TweenService:Create(child, TweenInfo.new(0.5), {
				BackgroundTransparency = 0.5
			}):Play()

			for _, label in ipairs(child:GetChildren()) do
				if label:IsA("TextLabel") then
					TweenService:Create(label, TweenInfo.new(0.5), {
						TextTransparency = 0
					}):Play()
				end
			end
		end
	end

	-- 5秒後にフェードアウト
	task.wait(5)

	-- アニメーション：フェードアウト
	local fadeOut = TweenService:Create(frame, TweenInfo.new(1), {
		BackgroundTransparency = 1
	})

	TweenService:Create(title, TweenInfo.new(1), {
		TextTransparency = 1
	}):Play()

	for _, child in ipairs(listContainer:GetChildren()) do
		if child:IsA("Frame") then
			TweenService:Create(child, TweenInfo.new(1), {
				BackgroundTransparency = 1
			}):Play()

			for _, label in ipairs(child:GetChildren()) do
				if label:IsA("TextLabel") then
					TweenService:Create(label, TweenInfo.new(1), {
						TextTransparency = 1
					}):Play()
				end
			end
		end
	end

	fadeOut:Play()
	fadeOut.Completed:Connect(function()
		frame:Destroy()
		print("[RewardPopup] ポップアップを削除しました")
	end)
end

-- サーバーからの報酬情報を受信
InteractionResponseEvent.OnClientEvent:Connect(function(data)
	if data.success and data.type == "chest" and data.rewards then
		local duration = data.displayDuration or 3
		showRewardPopup(data.rewards, duration)
	end
end)

print("[RewardPopup] 初期化完了")
===== ./StartPlayerScripts/FastTravelUI.client.lua =====
-- StarterPlayer/StarterPlayerScripts/FastTravelUI.client.lua
-- ファストトラベルUIシステム

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

print("[FastTravelUI] 初期化開始")

-- RemoteEvent取得
local FastTravelEvent = ReplicatedStorage:WaitForChild("FastTravelEvent", 10)
local GetContinentsEvent = ReplicatedStorage:WaitForChild("GetContinentsEvent", 10)

if not FastTravelEvent or not GetContinentsEvent then
	warn("[FastTravelUI] RemoteEventが見つかりません")
	return
end

-- UIコンテナ
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "FastTravelUI"
screenGui.ResetOnSpawn = false
screenGui.IgnoreGuiInset = true
-- screenGui.ZIndex = 100
screenGui.Parent = playerGui

-- ワープボタン（ミニマップの上）
local warpButton = Instance.new("TextButton")
warpButton.Name = "WarpButton"
warpButton.Size = UDim2.new(0, 200, 0, 35) -- ミニマップと同じ横幅200、高さ35
warpButton.Position = UDim2.new(0, 20, 1, -300) -- ミニマップの上に配置
warpButton.BackgroundColor3 = Color3.fromRGB(50, 120, 200)
warpButton.BackgroundTransparency = 0.2
warpButton.BorderSizePixel = 2
warpButton.BorderColor3 = Color3.fromRGB(255, 255, 255)
warpButton.Text = "ワープ"
warpButton.TextColor3 = Color3.new(1, 1, 1)
warpButton.TextSize = 18
warpButton.Font = Enum.Font.SourceSansBold
warpButton.Parent = screenGui

local warpButtonCorner = Instance.new("UICorner")
warpButtonCorner.CornerRadius = UDim.new(0, 6)
warpButtonCorner.Parent = warpButton

-- モーダル背景
local modalBackground = Instance.new("Frame")
modalBackground.Name = "ModalBackground"
modalBackground.Size = UDim2.fromScale(1, 1)
modalBackground.Position = UDim2.fromScale(0, 0)
modalBackground.BackgroundColor3 = Color3.new(0, 0, 0)
modalBackground.BackgroundTransparency = 1
modalBackground.Visible = false
modalBackground.ZIndex = 101
modalBackground.Parent = screenGui

-- モーダルウィンドウ
local modalWindow = Instance.new("Frame")
modalWindow.Name = "ModalWindow"
modalWindow.Size = UDim2.new(0, 400, 0, 500)
modalWindow.Position = UDim2.new(0.5, -200, 0.5, -250)
modalWindow.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
modalWindow.BackgroundTransparency = 0.1
modalWindow.BorderSizePixel = 3
modalWindow.BorderColor3 = Color3.fromRGB(100, 150, 255)
modalWindow.ZIndex = 102
modalWindow.Parent = modalBackground

local modalCorner = Instance.new("UICorner")
modalCorner.CornerRadius = UDim.new(0, 12)
modalCorner.Parent = modalWindow

-- タイトル
local titleLabel = Instance.new("TextLabel")
titleLabel.Name = "Title"
titleLabel.Size = UDim2.new(1, 0, 0, 50)
titleLabel.Position = UDim2.new(0, 0, 0, 0)
titleLabel.BackgroundTransparency = 1
titleLabel.Text = "ワープ先を選択"
titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
titleLabel.TextSize = 24
titleLabel.Font = Enum.Font.GothamBold
titleLabel.ZIndex = 103
titleLabel.Parent = modalWindow

-- 閉じるボタン
local closeButton = Instance.new("TextButton")
closeButton.Name = "CloseButton"
closeButton.Size = UDim2.new(0, 40, 0, 40)
closeButton.Position = UDim2.new(1, -50, 0, 5)
closeButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
closeButton.BackgroundTransparency = 0.3
closeButton.BorderSizePixel = 0
closeButton.Text = "✕"
closeButton.TextColor3 = Color3.new(1, 1, 1)
closeButton.TextSize = 24
closeButton.Font = Enum.Font.SourceSansBold
closeButton.ZIndex = 103
closeButton.Parent = modalWindow

local closeButtonCorner = Instance.new("UICorner")
closeButtonCorner.CornerRadius = UDim.new(0, 8)
closeButtonCorner.Parent = closeButton

-- スクロールフレーム（大陸一覧）
local scrollFrame = Instance.new("ScrollingFrame")
scrollFrame.Name = "ContinentsList"
scrollFrame.Size = UDim2.new(1, -40, 1, -100)
scrollFrame.Position = UDim2.new(0, 20, 0, 70)
scrollFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 30)
scrollFrame.BackgroundTransparency = 0.5
scrollFrame.BorderSizePixel = 0
scrollFrame.ScrollBarThickness = 8
scrollFrame.ZIndex = 102
scrollFrame.Parent = modalWindow

local scrollCorner = Instance.new("UICorner")
scrollCorner.CornerRadius = UDim.new(0, 8)
scrollCorner.Parent = scrollFrame

local listLayout = Instance.new("UIListLayout")
listLayout.SortOrder = Enum.SortOrder.LayoutOrder
listLayout.Padding = UDim.new(0, 10)
listLayout.Parent = scrollFrame

local listPadding = Instance.new("UIPadding")
listPadding.PaddingTop = UDim.new(0, 10)
listPadding.PaddingBottom = UDim.new(0, 10)
listPadding.PaddingLeft = UDim.new(0, 10)
listPadding.PaddingRight = UDim.new(0, 10)
listPadding.Parent = scrollFrame

-- モーダルを開く
local function openModal()
	print("[FastTravelUI] モーダルを開く")

	-- 大陸一覧を取得
	local success, continents = pcall(function()
		return GetContinentsEvent:InvokeServer()
	end)

	if not success or not continents then
		warn("[FastTravelUI] 大陸一覧の取得に失敗しました")
		return
	end

	-- 既存のボタンをクリア
	for _, child in ipairs(scrollFrame:GetChildren()) do
		if child:IsA("TextButton") then
			child:Destroy()
		end
	end

	-- 大陸ボタンを作成
	for i, continent in ipairs(continents) do
		local button = Instance.new("TextButton")
		button.Name = continent.name
		button.Size = UDim2.new(1, -20, 0, 60)
		button.BackgroundColor3 = Color3.fromRGB(60, 100, 180)
		button.BackgroundTransparency = 0.2
		button.BorderSizePixel = 0
		button.Text = continent.displayName
		button.TextColor3 = Color3.new(1, 1, 1)
		button.TextSize = 20
		button.Font = Enum.Font.SourceSansBold
		button.LayoutOrder = i
		button.ZIndex = 103
		button.Parent = scrollFrame

		local buttonCorner = Instance.new("UICorner")
		buttonCorner.CornerRadius = UDim.new(0, 8)
		buttonCorner.Parent = button

		-- ホバーエフェクト
		button.MouseEnter:Connect(function()
			TweenService:Create(button, TweenInfo.new(0.2), {
				BackgroundTransparency = 0
			}):Play()
		end)

		button.MouseLeave:Connect(function()
			TweenService:Create(button, TweenInfo.new(0.2), {
				BackgroundTransparency = 0.2
			}):Play()
		end)

		-- クリックイベント
		button.MouseButton1Click:Connect(function()
			print(("[FastTravelUI] %s へワープ要求"):format(continent.name))
			FastTravelEvent:FireServer(continent.name)
			closeModal()
		end)
	end

	-- スクロールフレームのサイズ調整
	scrollFrame.CanvasSize = UDim2.new(0, 0, 0, listLayout.AbsoluteContentSize.Y + 20)

	-- モーダル表示
	modalBackground.Visible = true
	modalBackground.BackgroundTransparency = 0.5

	-- フェードイン
	TweenService:Create(modalBackground, TweenInfo.new(0.3), {
		BackgroundTransparency = 0.3
	}):Play()
end

-- モーダルを閉じる
function closeModal()
	print("[FastTravelUI] モーダルを閉じる")

	TweenService:Create(modalBackground, TweenInfo.new(0.3), {
		BackgroundTransparency = 1
	}):Play()

	task.wait(0.3)
	modalBackground.Visible = false
end

-- イベント接続
warpButton.MouseButton1Click:Connect(openModal)
closeButton.MouseButton1Click:Connect(closeModal)

-- 背景クリックで閉じる
modalBackground.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		-- モーダルウィンドウ外をクリックした場合
		local mousePos = input.Position
		local windowPos = modalWindow.AbsolutePosition
		local windowSize = modalWindow.AbsoluteSize

		if mousePos.X < windowPos.X or mousePos.X > windowPos.X + windowSize.X or
		   mousePos.Y < windowPos.Y or mousePos.Y > windowPos.Y + windowSize.Y then
			closeModal()
		end
	end
end)

print("[FastTravelUI] 初期化完了")
===== ./StartPlayerScripts/LoadingScreen.client.lua =====
-- StarterPlayer/StarterPlayerScripts/LoadingScreen.client.lua
-- 初回ロード時のローディング画面

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

print("[LoadingScreen] 初期化中...")

-- ローディング画面のUI
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "InitialLoadingUI"
screenGui.ResetOnSpawn = false
screenGui.IgnoreGuiInset = true
screenGui.DisplayOrder = 1000 -- 最前面に表示
screenGui.Parent = playerGui

local frame = Instance.new("Frame")
frame.Name = "LoadingFrame"
frame.Size = UDim2.new(1, 0, 1, 0)
frame.BackgroundColor3 = Color3.new(0, 0, 0)
frame.BackgroundTransparency = 0
frame.Visible = true
frame.Parent = screenGui

local label = Instance.new("TextLabel")
label.Size = UDim2.new(0.6, 0, 0.2, 0)
label.Position = UDim2.new(0.2, 0, 0.4, 0)
label.BackgroundTransparency = 1
label.Text = "Loading..."
label.TextColor3 = Color3.new(1, 1, 1)
label.TextScaled = true
label.Font = Enum.Font.SourceSansBold
label.Parent = frame

-- ヒントテキスト（オプション）
local hintLabel = Instance.new("TextLabel")
hintLabel.Size = UDim2.new(0.8, 0, 0.1, 0)
hintLabel.Position = UDim2.new(0.1, 0, 0.6, 0)
hintLabel.BackgroundTransparency = 1
hintLabel.Text = "タイピングを練習してモンスターを倒そう！"
hintLabel.TextColor3 = Color3.new(0.8, 0.8, 0.8)
hintLabel.TextSize = 18
hintLabel.Font = Enum.Font.Gotham
hintLabel.Parent = frame

-- サーバーからの準備完了信号を待つ
local spawnReadyEvent = ReplicatedStorage:WaitForChild("SpawnReady", 10)

if spawnReadyEvent then
    spawnReadyEvent.OnClientEvent:Connect(function()
        print("[LoadingScreen] スポーン準備完了、フェードアウト開始")

        -- フェードアウトアニメーション
        local fadeOut = TweenService:Create(frame, TweenInfo.new(1, Enum.EasingStyle.Quad), {
            BackgroundTransparency = 1
        })

        local labelFadeOut = TweenService:Create(label, TweenInfo.new(1, Enum.EasingStyle.Quad), {
            TextTransparency = 1
        })

        local hintFadeOut = TweenService:Create(hintLabel, TweenInfo.new(1, Enum.EasingStyle.Quad), {
            TextTransparency = 1
        })

        fadeOut:Play()
        labelFadeOut:Play()
        hintFadeOut:Play()

        fadeOut.Completed:Connect(function()
            screenGui:Destroy()
            print("[LoadingScreen] ローディング画面を削除")
        end)
    end)
else
    warn("[LoadingScreen] SpawnReadyイベントが見つかりません")
    -- フォールバック：3秒後に自動で消す
    task.wait(3)
    screenGui:Destroy()
end

print("[LoadingScreen] 初期化完了")
===== ./StartPlayerScripts/StatusUI.client.lua =====
-- StarterPlayer/StarterPlayerScripts/StatusUI.client.lua
-- 画面左下に常時表示するプレイヤーステータス

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

print("[StatusUI] 初期化中...")

-- 現在のステータス
local currentHP = 100
local currentMaxHP = 100
local currentLevel = 1
local currentExp = 0
local currentExpToNext = 100
local currentGold = 0

-- UI要素
local statusGui = nil
local hpBarBackground = nil
local hpBarFill = nil
local hpLabel = nil
local levelLabel = nil
local expLabel = nil
local goldLabel = nil

-- HPの色を取得
local function getHPColor(hpPercent)
	if hpPercent > 0.6 then
		return Color3.fromRGB(46, 204, 113)  -- 緑
	elseif hpPercent > 0.3 then
		return Color3.fromRGB(241, 196, 15)  -- 黄色
	else
		return Color3.fromRGB(231, 76, 60)  -- 赤
	end
end

-- 表示を更新
local function updateDisplay()
	if hpBarFill and hpLabel then
		local hpPercent = currentHP / currentMaxHP

		-- バーの長さをアニメーション
		local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
		local tween = TweenService:Create(hpBarFill, tweenInfo, {
			Size = UDim2.new(hpPercent, 0, 1, 0)
		})
		tween:Play()

		-- 色を変更
		hpBarFill.BackgroundColor3 = getHPColor(hpPercent)

		-- テキスト更新
		hpLabel.Text = string.format("%d / %d", currentHP, currentMaxHP)
	end

	if levelLabel then
		levelLabel.Text = string.format("Lv.%d", currentLevel)
	end

	if expLabel then
		expLabel.Text = string.format("EXP: %d / %d", currentExp, currentExpToNext)
	end

	if goldLabel then
		goldLabel.Text = string.format("💰 %d G", currentGold)
	end
end

-- UI作成
local function createStatusUI()
	statusGui = Instance.new("ScreenGui")
	statusGui.Name = "StatusUI"
	statusGui.ResetOnSpawn = false
	statusGui.Parent = playerGui

	-- 背景フレーム
	local backgroundFrame = Instance.new("Frame")
	backgroundFrame.Name = "StatusBackground"
	backgroundFrame.Size = UDim2.new(0, 250, 0, 120)
	backgroundFrame.Position = UDim2.new(1, -270, 1, -140)
	backgroundFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
	backgroundFrame.BackgroundTransparency = 0.3
	backgroundFrame.BorderSizePixel = 0
	backgroundFrame.Parent = statusGui

	-- 角を丸くする
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 10)
	corner.Parent = backgroundFrame

	-- レベル表示
	levelLabel = Instance.new("TextLabel")
	levelLabel.Name = "LevelLabel"
	levelLabel.Size = UDim2.new(0, 80, 0, 25)
	levelLabel.Position = UDim2.new(0, 10, 0, 10)
	levelLabel.BackgroundTransparency = 1
	levelLabel.TextColor3 = Color3.fromRGB(255, 215, 0)
	levelLabel.TextStrokeTransparency = 0.5
	levelLabel.Font = Enum.Font.GothamBold
	levelLabel.TextSize = 20
	levelLabel.Text = "Lv.1"
	levelLabel.TextXAlignment = Enum.TextXAlignment.Left
	levelLabel.Parent = backgroundFrame

	-- HPバー背景
	hpBarBackground = Instance.new("Frame")
	hpBarBackground.Name = "HPBarBackground"
	hpBarBackground.Size = UDim2.new(1, -20, 0, 20)
	hpBarBackground.Position = UDim2.new(0, 10, 0, 40)
	hpBarBackground.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
	hpBarBackground.BorderSizePixel = 0
	hpBarBackground.Parent = backgroundFrame

	-- HPバー背景の角を丸くする
	local hpBarCorner = Instance.new("UICorner")
	hpBarCorner.CornerRadius = UDim.new(0, 5)
	hpBarCorner.Parent = hpBarBackground

	-- HPバー（塗りつぶし）
	hpBarFill = Instance.new("Frame")
	hpBarFill.Name = "HPBarFill"
	hpBarFill.Size = UDim2.new(1, 0, 1, 0)
	hpBarFill.Position = UDim2.new(0, 0, 0, 0)
	hpBarFill.BackgroundColor3 = Color3.fromRGB(46, 204, 113)
	hpBarFill.BorderSizePixel = 0
	hpBarFill.Parent = hpBarBackground

	-- HPバーの角を丸くする
	local hpFillCorner = Instance.new("UICorner")
	hpFillCorner.CornerRadius = UDim.new(0, 5)
	hpFillCorner.Parent = hpBarFill

	-- HPテキスト
	hpLabel = Instance.new("TextLabel")
	hpLabel.Name = "HPLabel"
	hpLabel.Size = UDim2.new(1, 0, 1, 0)
	hpLabel.Position = UDim2.new(0, 0, 0, 0)
	hpLabel.BackgroundTransparency = 1
	hpLabel.TextColor3 = Color3.new(1, 1, 1)
	hpLabel.TextStrokeTransparency = 0.5
	hpLabel.Font = Enum.Font.GothamBold
	hpLabel.TextSize = 14
	hpLabel.Text = "100 / 100"
	hpLabel.Parent = hpBarBackground

	-- 経験値表示
	expLabel = Instance.new("TextLabel")
	expLabel.Name = "ExpLabel"
	expLabel.Size = UDim2.new(1, -20, 0, 18)
	expLabel.Position = UDim2.new(0, 10, 0, 65)
	expLabel.BackgroundTransparency = 1
	expLabel.TextColor3 = Color3.fromRGB(150, 200, 255)
	expLabel.TextStrokeTransparency = 0.7
	expLabel.Font = Enum.Font.Gotham
	expLabel.TextSize = 14
	expLabel.Text = "EXP: 0 / 100"
	expLabel.TextXAlignment = Enum.TextXAlignment.Left
	expLabel.Parent = backgroundFrame

	-- ゴールド表示
	goldLabel = Instance.new("TextLabel")
	goldLabel.Name = "GoldLabel"
	goldLabel.Size = UDim2.new(1, -20, 0, 18)
	goldLabel.Position = UDim2.new(0, 10, 0, 88)
	goldLabel.BackgroundTransparency = 1
	goldLabel.TextColor3 = Color3.fromRGB(255, 215, 0)
	goldLabel.TextStrokeTransparency = 0.7
	goldLabel.Font = Enum.Font.GothamBold
	goldLabel.TextSize = 14
	goldLabel.Text = "💰 0 G"
	goldLabel.TextXAlignment = Enum.TextXAlignment.Left
	goldLabel.Parent = backgroundFrame

	print("[StatusUI] UI作成完了")
end

-- ステータス更新イベント
local function onStatusUpdate(hp, maxHP, level, exp, expToNext, gold)
	print(("[StatusUI] ステータス更新受信: HP=%d/%d, Lv=%d, EXP=%d/%d, Gold=%d"):format(
		hp or 0, maxHP or 0, level or 0, exp or 0, expToNext or 0, gold or 0
		))

	currentHP = hp or currentHP
	currentMaxHP = maxHP or currentMaxHP
	currentLevel = level or currentLevel
	currentExp = exp or currentExp
	currentExpToNext = expToNext or currentExpToNext
	currentGold = gold or currentGold

	updateDisplay()
end

-- 初期化
createStatusUI()

print("[StatusUI] RemoteEventを待機中...")

-- RemoteEventを待機（最大30秒）
task.spawn(function()
	local StatusUpdateEvent = ReplicatedStorage:WaitForChild("StatusUpdate", 10)
	if StatusUpdateEvent then
		StatusUpdateEvent.OnClientEvent:Connect(onStatusUpdate)
		print("[StatusUI] StatusUpdateイベント接続完了")

		-- 初回のステータス要求
		task.wait(1)  -- 1秒待ってから要求
		local RequestStatusEvent = ReplicatedStorage:FindFirstChild("RequestStatus")
		if RequestStatusEvent then
			print("[StatusUI] 初回ステータスを要求")
			RequestStatusEvent:FireServer()
		else
			warn("[StatusUI] RequestStatusイベントが見つかりません")
		end
	else
		warn("[StatusUI] StatusUpdateイベントの待機がタイムアウトしました")
	end
end)

print("[StatusUI] 初期化完了")
===== ./StartPlayerScripts/WarpUI.client.lua =====
-- ===== ./StartPlayerScripts/WarpUI.client.lua =====
-- StarterPlayer/StarterPlayerScripts/WarpUI.client.lua
-- ワープ時のロード画面

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- RemoteEventを取得 - タイムアウトを短く設定
local warpEvent = ReplicatedStorage:WaitForChild("WarpEvent", 5) -- ★修正: タイムアウトを5秒に設定

if not warpEvent then
    warn("[WarpUI] WarpEventが見つかりません。ワープUIは機能しません。")
    return
end

print("[WarpUI] 初期化完了")

-- ロード画面のUI
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "WarpLoadingUI"
screenGui.ResetOnSpawn = false
screenGui.IgnoreGuiInset = true
screenGui.Parent = playerGui

local frame = Instance.new("Frame")
frame.Name = "LoadingFrame"
frame.Size = UDim2.new(1, 0, 1, 0)
frame.BackgroundColor3 = Color3.new(0, 0, 0)
frame.BackgroundTransparency = 1
frame.Visible = false
frame.Parent = screenGui

local label = Instance.new("TextLabel")
label.Size = UDim2.new(0.6, 0, 0.2, 0)
label.Position = UDim2.new(0.2, 0, 0.4, 0)
label.BackgroundTransparency = 1
label.Text = "Loading..."
label.TextColor3 = Color3.new(1, 1, 1)
label.TextScaled = true
label.Font = Enum.Font.SourceSansBold
label.Parent = frame

-- RemoteEventを受信
warpEvent.OnClientEvent:Connect(function(action, zoneName)
	if action == "StartLoading" then
		print("[WarpUI] ロード画面表示:", zoneName)
		label.Text = "Warping to " .. (zoneName or "???") .. "..."
		frame.BackgroundTransparency = 0.3
		frame.Visible = true

		-- フェードイン
		for i = 0.3, 0.7, 0.1 do
			frame.BackgroundTransparency = 1 - i
			task.wait(0.05)
		end

	elseif action == "EndLoading" then
		print("[WarpUI] ロード画面非表示")

		-- フェードアウト
		for i = 0.7, 0, -0.1 do
			frame.BackgroundTransparency = 1 - i
			task.wait(0.05)
		end

		frame.Visible = false
	end
end)
===== ./StartPlayerScripts/DeathUI.client.lua =====
-- StarterPlayer/StarterPlayerScripts/DeathUI.client.lua
-- 死亡時の選択UI（街に戻る / ゴールドロストで復活）

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

print("[DeathUI] 初期化中...")

-- UI要素
local deathGui = nil

-- 死亡UIを表示
local function showDeathUI(currentGold, reviveCost)
	print(("[DeathUI] ========================================"):format())
	print(("[DeathUI] 死亡UI表示"):format())
	print(("[DeathUI] 所持金: %d G, 復活コスト: %d G"):format(currentGold, reviveCost))
	print(("[DeathUI] ========================================"):format())

	-- 既存のGUIを削除
	if deathGui then
		deathGui:Destroy()
	end

	-- 新しいGUIを作成
	deathGui = Instance.new("ScreenGui")
	deathGui.Name = "DeathUI"
	deathGui.ResetOnSpawn = false
	deathGui.Parent = playerGui

	-- 背景（暗い）
	local background = Instance.new("Frame")
	background.Size = UDim2.fromScale(1, 1)
	background.Position = UDim2.fromScale(0, 0)
	background.BackgroundColor3 = Color3.new(0, 0, 0)
	background.BackgroundTransparency = 0.3
	background.BorderSizePixel = 0
	background.ZIndex = 200
	background.Parent = deathGui

	-- タイトル
	local titleText = Instance.new("TextLabel")
	titleText.Size = UDim2.new(0, 600, 0, 80)
	titleText.Position = UDim2.new(0.5, -300, 0.3, 0)
	titleText.BackgroundTransparency = 1
	titleText.TextColor3 = Color3.fromRGB(255, 100, 100)
	titleText.TextStrokeTransparency = 0
	titleText.Font = Enum.Font.GothamBold
	titleText.TextSize = 50
	titleText.Text = "YOU DIED"
	titleText.ZIndex = 201
	titleText.Parent = deathGui

	-- 選択フレーム
	local choiceFrame = Instance.new("Frame")
	choiceFrame.Size = UDim2.new(0, 600, 0, 200)
	choiceFrame.Position = UDim2.new(0.5, -300, 0.45, 0)
	choiceFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
	choiceFrame.BackgroundTransparency = 0.2
	choiceFrame.BorderSizePixel = 0
	choiceFrame.ZIndex = 201
	choiceFrame.Parent = deathGui

	-- 角を丸くする
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 10)
	corner.Parent = choiceFrame

	-- 説明テキスト
	local descText = Instance.new("TextLabel")
	descText.Size = UDim2.new(1, -40, 0, 60)
	descText.Position = UDim2.new(0, 20, 0, 20)
	descText.BackgroundTransparency = 1
	descText.TextColor3 = Color3.fromRGB(255, 255, 255)
	descText.TextStrokeTransparency = 0.5
	descText.Font = Enum.Font.Gotham
	descText.TextSize = 18
	descText.Text = "敗北しました。どうしますか？"
	descText.TextWrapped = true
	descText.ZIndex = 202
	descText.Parent = choiceFrame

	-- 「街に戻る」ボタン
	local returnButton = Instance.new("TextButton")
	returnButton.Size = UDim2.new(0, 250, 0, 50)
	returnButton.Position = UDim2.new(0.5, -260, 0, 100)
	returnButton.BackgroundColor3 = Color3.fromRGB(52, 152, 219)
	returnButton.BorderSizePixel = 0
	returnButton.Font = Enum.Font.GothamBold
	returnButton.TextSize = 20
	returnButton.Text = "🏠 街に戻る"
	returnButton.TextColor3 = Color3.new(1, 1, 1)
	returnButton.ZIndex = 202
	returnButton.Parent = choiceFrame

	-- ボタンの角を丸くする
	local returnCorner = Instance.new("UICorner")
	returnCorner.CornerRadius = UDim.new(0, 8)
	returnCorner.Parent = returnButton

	-- 「ゴールドで復活」ボタン
	local reviveButton = Instance.new("TextButton")
	reviveButton.Size = UDim2.new(0, 250, 0, 50)
	reviveButton.Position = UDim2.new(0.5, 10, 0, 100)
	reviveButton.BorderSizePixel = 0
	reviveButton.Font = Enum.Font.GothamBold
	reviveButton.TextSize = 20
	reviveButton.TextColor3 = Color3.new(1, 1, 1)
	reviveButton.ZIndex = 202
	reviveButton.Parent = choiceFrame

	-- ボタンの角を丸くする
	local reviveCorner = Instance.new("UICorner")
	reviveCorner.CornerRadius = UDim.new(0, 8)
	reviveCorner.Parent = reviveButton

	-- ゴールドが足りるかチェック
	if currentGold >= reviveCost then
		reviveButton.BackgroundColor3 = Color3.fromRGB(46, 204, 113)
		reviveButton.Text = string.format("💰 復活 (%d G)", reviveCost)
	else
		reviveButton.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
		reviveButton.Text = string.format("💰 復活 (%d G) - 不足", reviveCost)
		reviveButton.Active = false
	end

	-- ボタンのホバーエフェクト
	returnButton.MouseEnter:Connect(function()
		returnButton.BackgroundColor3 = Color3.fromRGB(62, 172, 239)
	end)
	returnButton.MouseLeave:Connect(function()
		returnButton.BackgroundColor3 = Color3.fromRGB(52, 152, 219)
	end)

	if currentGold >= reviveCost then
		reviveButton.MouseEnter:Connect(function()
			reviveButton.BackgroundColor3 = Color3.fromRGB(56, 224, 133)
		end)
		reviveButton.MouseLeave:Connect(function()
			reviveButton.BackgroundColor3 = Color3.fromRGB(46, 204, 113)
		end)
	end

	-- 「街に戻る」ボタンクリック
	returnButton.MouseButton1Click:Connect(function()
		print("[DeathUI] 街に戻るを選択")

		-- サーバーに通知
		local DeathChoiceEvent = ReplicatedStorage:FindFirstChild("DeathChoice")
		if DeathChoiceEvent then
			DeathChoiceEvent:FireServer("return")
		end

		-- バトルUIを閉じる
		local battleUI = playerGui:FindFirstChild("BattleUI")
		if battleUI then
			battleUI.Enabled = false
		end

		-- システムキーのブロックを解除
		local ContextActionService = game:GetService("ContextActionService")
		ContextActionService:UnbindAction("BlockSystemKeys")

		-- Roblox UIを再有効化
		local StarterGui = game:GetService("StarterGui")
		pcall(function()
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Chat, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.EmotesMenu, true)
		end)

		-- UIを閉じる
		if deathGui then
			deathGui:Destroy()
			deathGui = nil
		end
	end)

	-- 「ゴールドで復活」ボタンクリック
	reviveButton.MouseButton1Click:Connect(function()
		if currentGold < reviveCost then
			print("[DeathUI] ゴールド不足")
			return
		end

		print("[DeathUI] ゴールドで復活を選択")

		-- サーバーに通知
		local DeathChoiceEvent = ReplicatedStorage:FindFirstChild("DeathChoice")
		if DeathChoiceEvent then
			DeathChoiceEvent:FireServer("revive")
		end

		-- バトルUIを閉じる
		local battleUI = playerGui:FindFirstChild("BattleUI")
		if battleUI then
			battleUI.Enabled = false
		end

		-- システムキーのブロックを解除
		local ContextActionService = game:GetService("ContextActionService")
		ContextActionService:UnbindAction("BlockSystemKeys")

		-- Roblox UIを再有効化
		local StarterGui = game:GetService("StarterGui")
		pcall(function()
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Chat, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.EmotesMenu, true)
		end)

		-- UIを閉じる
		if deathGui then
			deathGui:Destroy()
			deathGui = nil
		end
	end)
end

-- RemoteEventを待機
local ShowDeathUIEvent = ReplicatedStorage:WaitForChild("ShowDeathUI", 10)
if ShowDeathUIEvent then
	ShowDeathUIEvent.OnClientEvent:Connect(showDeathUI)
	print("[DeathUI] ShowDeathUIイベント接続完了")
else
	warn("[DeathUI] ShowDeathUIイベントが見つかりません")
end

print("[DeathUI] 初期化完了")
===== ./StartPlayerScripts/BGMManager.client.lua =====
-- StarterPlayer/StarterPlayerScripts/BGMManager.client.lua
-- 大陸BGM管理システム (バトル中の音量調整対応版)

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local SoundService = game:GetService("SoundService")
local TweenService = game:GetService("TweenService") -- TweenServiceを追加

local player = Players.LocalPlayer

-- 大陸情報を読み込み
local ContinentsRegistry = require(ReplicatedStorage.Continents.Registry)
local Continents = {}
for _, continent in ipairs(ContinentsRegistry) do
	Continents[continent.name] = continent
end

-- BGM状態
local currentBGM = nil
local currentZone = nil
local isBattleActive = false
local bgmSound = nil
local originalVolume = 0.3 -- 【追加・修正1】元の音量を保持する変数を追加（デフォルト値 0.3）

-- BGMサウンドを作成
local function createBGMSound(assetId, volume)
	if bgmSound then
		bgmSound:Stop()
		bgmSound:Destroy()
	end

	bgmSound = Instance.new("Sound")
	bgmSound.Name = "BGM"
	bgmSound.SoundId = assetId

	-- 【修正2】音量を設定し、originalVolumeを更新
	local finalVolume = volume or 0.3
	bgmSound.Volume = finalVolume
	originalVolume = finalVolume -- 取得した音量を保存

	bgmSound.Looped = true
	bgmSound.Parent = SoundService

	return bgmSound
end

-- BGMを再生
local function playBGM(assetId, volume)
	if currentBGM == assetId and bgmSound and bgmSound.IsPlaying and not isBattleActive then
		-- 既に同じBGMが再生中で、戦闘中でなければ何もしない
		return
	end

	print(("[BGMManager] BGM再生: %s, Volume: %.2f"):format(assetId, volume or 0.3))

	currentBGM = assetId
	local sound = createBGMSound(assetId, volume)
	sound:Play()

	-- 新しく再生するBGMが戦闘中に切り替わった場合、音量を下げる
	if isBattleActive and bgmSound then
		bgmSound.Volume = originalVolume * 0.3
	end
end

-- BGMを停止
local function stopBGM()
	if bgmSound then
		print("[BGMManager] BGM停止")

        -- 【修正3】Tweenを使ってスムーズに停止
        TweenService:Create(bgmSound, TweenInfo.new(0.5), {
            Volume = 0
        }):Play()

        task.delay(0.5, function()
            -- 0.5秒後、音量が0であることを確認して停止・削除
            if bgmSound and bgmSound.Volume == 0 then
                bgmSound:Stop()
                bgmSound:Destroy()
                bgmSound = nil -- 参照をクリア
            end
        end)
	end
	currentBGM = nil
end

-- ゾーン変更時のBGM処理
local function onZoneChange(zoneName, isActive)
	if isActive then
		-- ゾーンに入った
		currentZone = zoneName

		-- 大陸のBGM設定を取得
		local continent = Continents[zoneName]
		if continent and continent.BGM then
			-- BGMVolumeをplayBGMに渡して、originalVolumeに保存させる
			playBGM(continent.BGM, continent.BGMVolume or 0.3)
		else
			-- BGM設定がない場合は停止
			stopBGM()
		end
	else
		-- ゾーンから出た場合もBGMを停止
		if currentZone == zoneName then
			stopBGM()
			currentZone = nil
		end
	end
end

-- バトル開始イベント
local BattleStartEvent = ReplicatedStorage:WaitForChild("BattleStart", 10)
if BattleStartEvent then
	BattleStartEvent.OnClientEvent:Connect(function()
		print("[BGMManager] バトル開始を検知")
		isBattleActive = true

		-- 【修正4】BGMを停止せず、音量を50%に下げる
		if bgmSound and bgmSound.IsPlaying then
			local targetVolume = originalVolume * 0.3 -- 元の音量の50%
			print(("[BGMManager] BGM音量を %.2f から %.2f に調整"):format(bgmSound.Volume, targetVolume))
			TweenService:Create(bgmSound, TweenInfo.new(0.5), {
				Volume = targetVolume
			}):Play()
		end

	end)
end

-- バトル終了イベント
local BattleEndEvent = ReplicatedStorage:WaitForChild("BattleEnd", 10)
if BattleEndEvent then
	BattleEndEvent.OnClientEvent:Connect(function()
		print("[BGMManager] バトル終了を検知")
		isBattleActive = false

		-- 【修正5】BGMを元の音量に戻す
		if bgmSound and bgmSound.IsPlaying then
			print(("[BGMManager] BGM音量を %.2f に戻す"):format(originalVolume))
			TweenService:Create(bgmSound, TweenInfo.new(0.5), {
				Volume = originalVolume
			}):Play()
		end
	end)
end

-- ゾーン変更を監視
task.spawn(function()
	local ZoneChangeEvent = ReplicatedStorage:FindFirstChild("ZoneChange")
	if not ZoneChangeEvent then
		warn("[BGMManager] ZoneChangeイベントが見つかりません")
		return
	end

	ZoneChangeEvent.OnClientEvent:Connect(function(zoneName, isActive)
		print(("[BGMManager] ゾーン変更: %s - %s"):format(zoneName, isActive and "入った" or "出た"))
		onZoneChange(zoneName, isActive)
	end)

	print("[BGMManager] ZoneChangeイベント接続完了")
end)

print("[BGMManager] 初期化完了")
===== ./StartPlayerScripts/InteractionUI.client.lua =====
-- StarterPlayer/StarterPlayerScripts/InteractionUI.client.lua
-- インタラクション検出とUIボタン表示

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

print("[InteractionUI] 初期化開始")

-- RemoteEvent取得
local InteractEvent = ReplicatedStorage:WaitForChild("InteractEvent", 10)
if not InteractEvent then
	warn("[InteractionUI] InteractEventが見つかりません")
	return
end

-- RemoteFunctionで取得済みリストを取得
local GetCollectedItemsFunc = ReplicatedStorage:FindFirstChild("GetCollectedItems")
if not GetCollectedItemsFunc then
	GetCollectedItemsFunc = Instance.new("RemoteFunction")
	GetCollectedItemsFunc.Name = "GetCollectedItems"
	GetCollectedItemsFunc.Parent = ReplicatedStorage
end

-- 現在のインタラクション対象
local currentTarget = nil
local currentButton = nil

-- インタラクション済みのオブジェクトを記録
local interactedObjects = {}

-- インタラクションボタンUI作成
local function createInteractionButton(targetObject, actionText, key)
	-- 既存のボタンを削除
	if currentButton then
		currentButton:Destroy()
		currentButton = nil
	end

	-- ScreenGuiに配置（画面中央下部）
	local screenGui = playerGui:FindFirstChild("InteractionButtonGui")
	if not screenGui then
		screenGui = Instance.new("ScreenGui")
		screenGui.Name = "InteractionButtonGui"
		screenGui.ResetOnSpawn = false
		screenGui.DisplayOrder = 150
		screenGui.Parent = playerGui
	end

	-- 背景フレーム
	local frame = Instance.new("Frame")
	frame.Name = "InteractionFrame"
	frame.Size = UDim2.new(0, 250, 0, 60)
	frame.Position = UDim2.new(0.5, -125, 0.85, 0) -- 画面下部中央
	frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	frame.BackgroundTransparency = 0.3
	frame.BorderSizePixel = 0
	frame.Parent = screenGui

	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 12)
	corner.Parent = frame

	-- ボタン
	local button = Instance.new("TextButton")
	button.Size = UDim2.new(0.9, 0, 0.7, 0)
	button.Position = UDim2.new(0.05, 0, 0.15, 0)
	button.BackgroundColor3 = Color3.fromRGB(255, 200, 100)
	button.BackgroundTransparency = 0.2
	button.BorderSizePixel = 2
	button.BorderColor3 = Color3.new(1, 1, 1)
	button.Text = string.format("%s [%s]", actionText, key)
	button.TextColor3 = Color3.new(0, 0, 0)
	button.TextSize = 20
	button.Font = Enum.Font.SourceSansBold
	button.AutoButtonColor = true
	button.Parent = frame

	local buttonCorner = Instance.new("UICorner")
	buttonCorner.CornerRadius = UDim.new(0, 8)
	buttonCorner.Parent = button

	-- ボタンクリック
	button.MouseButton1Click:Connect(function()
		print("[InteractionUI DEBUG] ===== ボタンクリックイベント発火 =====")
		print(("[InteractionUI] ボタンクリック: %s"):format(targetObject.Name))

		-- インタラクション済みに記録
		interactedObjects[targetObject] = true

		-- サーバーに送信
		InteractEvent:FireServer(targetObject)

		-- 即座にボタンを削除
		if currentButton then
			currentButton:Destroy()
			currentButton = nil
		end
		currentTarget = nil
	end)

	-- デバッグ：ホバー検出
	button.MouseEnter:Connect(function()
		print("[InteractionUI DEBUG] マウスがボタンに入った")
		button.BackgroundTransparency = 0 -- ハイライト
	end)

	button.MouseLeave:Connect(function()
		print("[InteractionUI DEBUG] マウスがボタンから出た")
		button.BackgroundTransparency = 0.2
	end)

	currentButton = frame
	return frame
end

-- インタラクション可能なオブジェクトを検出
local function findNearestInteractable()
	local character = player.Character
	if not character then return nil end

	local hrp = character:FindFirstChild("HumanoidRootPart")
	if not hrp then return nil end

	local nearestObject = nil
	local nearestDistance = math.huge

	-- workspace内の全オブジェクトをチェック
	for _, obj in ipairs(workspace:GetDescendants()) do
		if obj:IsA("BasePart") and obj:GetAttribute("HasInteraction") then
			-- インタラクション済みならスキップ
			if interactedObjects[obj] then
				continue
			end

			local distance = (hrp.Position - obj.Position).Magnitude
			local range = obj:GetAttribute("InteractionRange") or 8

			if distance <= range and distance < nearestDistance then
				nearestObject = obj
				nearestDistance = distance
			end
		end
	end

	return nearestObject
end

-- メインループ
RunService.Heartbeat:Connect(function()
	local nearest = findNearestInteractable()

	-- 対象が変わった場合
	if nearest ~= currentTarget then
		-- 古いボタンを削除
		if currentButton then
			currentButton:Destroy()
			currentButton = nil
		end

		currentTarget = nearest

		-- 新しいボタンを作成
		if nearest then
			local action = nearest:GetAttribute("InteractionAction") or "調べる"
			local key = nearest:GetAttribute("InteractionKey") or "E"
			createInteractionButton(nearest, action, key)

			print(("[InteractionUI] インタラクション可能: %s"):format(action))
		end
	end
end)

-- キー入力
UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then return end

	if currentTarget and input.KeyCode == Enum.KeyCode.E then
		local action = currentTarget:GetAttribute("InteractionAction") or "調べる"
		print(("[InteractionUI] Eキー押下: %s"):format(action))

		-- インタラクション済みに記録
		interactedObjects[currentTarget] = true

		-- サーバーに送信
		InteractEvent:FireServer(currentTarget)

		-- 即座にボタンを削除
		if currentButton then
			currentButton:Destroy()
			currentButton = nil
		end
		currentTarget = nil
	end
end)


===== ./ServerScriptService/ZoneManager.lua =====
-- ServerScriptService/ZoneManager.lua (IslandとContinentの両方に対応した安定版)
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local FieldGen = require(ReplicatedStorage:WaitForChild("FieldGen"))
local Players = game:GetService("Players")
local ZoneManager = {}

ZoneManager.ActiveZones = {}
ZoneManager.PlayerZones = {}

-- 島と大陸の設定を読み込み
local IslandsRegistry = require(ReplicatedStorage.Islands.Registry)
local ContinentsRegistry = require(ReplicatedStorage.Continents.Registry)

-- 島の設定をマップ化
local Islands = {}
for _, island in ipairs(IslandsRegistry) do
    Islands[island.name] = island
end

-- 大陸の設定をマップ化
local Continents = {}
for _, continent in ipairs(ContinentsRegistry) do
    if continent and continent.name then
        Continents[continent.name] = continent
    else
        warn("[ZoneManager] 名前が設定されていない大陸定義をスキップしました")
    end
end

print("[ZoneManager] 初期化完了。島数:", #IslandsRegistry, "大陸数:", #ContinentsRegistry)

-- ZoneChangeイベントを作成（クライアントへの通知用）
local ZoneChangeEvent = ReplicatedStorage:FindFirstChild("ZoneChange")
if not ZoneChangeEvent then
    ZoneChangeEvent = Instance.new("RemoteEvent")
    ZoneChangeEvent.Name = "ZoneChange"
    ZoneChangeEvent.Parent = ReplicatedStorage
    print("[ZoneManager] ZoneChangeイベントを作成しました")
end

-- ゾーンが大陸かチェック
local function isContinent(zoneName)
    return Continents[zoneName] ~= nil
end

-- ゾーンが島かチェック (Townが大陸化されたため、この関数は実質未使用に)
local function isIsland(zoneName)
    return Islands[zoneName] ~= nil and not isContinent(zoneName)
end

-- プレイヤーのゾーンを更新 (ワープポータルで使用)
local function updatePlayerZone(player, newZone)
    local oldZone = ZoneManager.PlayerZones[player]

    if oldZone == newZone then
        return
    end

    -- 古いゾーンから出た
    if oldZone then
        print(("[ZoneManager] %s が %s から出ました"):format(player.Name, oldZone))
        ZoneChangeEvent:FireClient(player, oldZone, false)
    end

    -- 新しいゾーンに入った
    if newZone then
        print(("[ZoneManager] %s が %s に入りました"):format(player.Name, newZone))
        ZoneManager.PlayerZones[player] = newZone
        ZoneChangeEvent:FireClient(player, newZone, true)
    else
        ZoneManager.PlayerZones[player] = nil
    end
end

-- 大陸をロード（複数の島と橋を生成）
local function loadContinent(continentName)
    local continent = Continents[continentName]
    if not continent then
        warn(("[ZoneManager] 大陸 '%s' が見つかりません"):format(continentName))
        return false
    end

    print(("[ZoneManager] 大陸生成開始: %s"):format(continentName))

    -- 含まれる全ての島を生成
    for _, islandName in ipairs(continent.islands) do
        local islandConfig = Islands[islandName]
        if islandConfig then
            print(("[ZoneManager]   - 島を生成: %s"):format(islandName))
            FieldGen.generateIsland(islandConfig)
        else
            warn(("[ZoneManager]   - 島が見つかりません: %s (Island/Registryを確認してください)"):format(islandName))
        end
    end

    -- 橋を生成
    if continent.bridges then
        for _, bridgeConfig in ipairs(continent.bridges) do
            local fromIsland = Islands[bridgeConfig.fromIsland]
            local toIsland = Islands[bridgeConfig.toIsland]

            if fromIsland and toIsland then
                print(("[ZoneManager]   - 橋を生成: %s"):format(bridgeConfig.name))
                FieldGen.generateBridge(fromIsland, toIsland, bridgeConfig)
            else
                warn(("[ZoneManager]   - 橋の生成失敗: %s"):format(bridgeConfig.name))
            end
        end
    end

    ZoneManager.ActiveZones[continentName] = {
        config = continent,
        loadedAt = os.time(),
    }

    local RS = game:GetService("ReplicatedStorage")
    local FieldGen = require(RS:WaitForChild("FieldGen"))

    if continent.fieldObjects and #continent.fieldObjects > 0 then
        print(("[ZoneManager] 追加オブジェクトを配置: %d 個"):format(#continent.fieldObjects))
        FieldGen.placeFieldObjects(continent.name, continent.fieldObjects)  -- player引数なし
    end

    local RS = game:GetService("ReplicatedStorage")
    local FieldGen = require(RS:WaitForChild("FieldGen"))

    -- …大陸・島を生成し終わったあと
    if continent.paths and #continent.paths > 0 then
        FieldGen.buildPaths(continent.name, continent.paths)
    end

        print(("[ZoneManager] 大陸生成完了: %s"):format(continentName))
        return true
    end


-- ゾーンをロード（島または大陸をロード）
function ZoneManager.LoadZone(zoneName)
    if ZoneManager.ActiveZones[zoneName] then
        print(("[ZoneManager] %s は既に生成済みです"):format(zoneName))
        return true
    end

    if isContinent(zoneName) then
        return loadContinent(zoneName)
    else
        -- ★修正: 単一の島をロードするロジックを削除。すべて大陸経由でロード。
        warn(("[ZoneManager] ゾーン '%s' は大陸ではありません。ロードをスキップしました。"):format(zoneName))
        return false
    end
end

-- ゾーンをアンロード（省略）
function ZoneManager.UnloadZone(zoneName)
    if not ZoneManager.ActiveZones[zoneName] then
        return
    end

    print(("[ZoneManager] ゾーン削除開始: %s"):format(zoneName))

    local terrain = workspace.Terrain
    local configsToUnload = {}

    -- ★修正: 大陸としてのみ処理
    if isContinent(zoneName) then
        -- 大陸の場合は含まれる全ての島を削除
        local continent = Continents[zoneName]
        for _, islandName in ipairs(continent.islands) do
            table.insert(configsToUnload, Islands[islandName])
        end
    else
         -- ★修正: 大陸でないゾーンはアンロードできない
         warn(("[ZoneManager] ゾーン '%s' は大陸ではありません。アンロードをスキップしました。"):format(zoneName))
         return
    end

    -- 各島の地形を削除
    for _, config in ipairs(configsToUnload) do
        if config then
            local halfSize = config.sizeXZ / 2 + 50
            local region = Region3.new(
                Vector3.new(config.centerX - halfSize, config.baseY - 50, config.centerZ - halfSize),
                Vector3.new(config.centerX + halfSize, config.baseY + 100, config.centerZ + halfSize)
            )
            region = region:ExpandToGrid(4)
            terrain:FillRegion(region, 4, Enum.Material.Air)

            -- マーカ削除は FieldGen.lua で行うためZoneManagerからは削除
        end
    end

    -- モンスター削除
    for _, model in ipairs(workspace:GetChildren()) do
        if model:IsA("Model") and model:GetAttribute("IsEnemy") then
            local spawnZone = model:GetAttribute("SpawnZone")
            if spawnZone == zoneName then
                model:Destroy()
            end
        end
    end

    ZoneManager.ActiveZones[zoneName] = nil
    print(("[ZoneManager] ゾーン削除完了: %s"):format(zoneName))
end


-- プレイヤーをワープ
function ZoneManager.WarpPlayerToZone(player, zoneName)
    print(("[ZoneManager] %s を %s にワープ中..."):format(player.Name, zoneName))

    -- ワープ先に地形がない場合はロード
    ZoneManager.LoadZone(zoneName)

    local character = player.Character
    if not character then
        warn(("[ZoneManager] %s のキャラクターが見つかりません"):format(player.Name))
        return false
    end

    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end

    -- ワープ先の座標を決定 (常に大陸の最初の島を参照するように統一)
    local targetX, targetZ, baseY, hillAmplitude

    if isContinent(zoneName) then
        -- 大陸の場合（Townも含む）
        local continent = Continents[zoneName]
        local firstIslandName = continent.islands[1]
        local firstIsland = Islands[firstIslandName]

        if not firstIsland then
             warn(("[ZoneManager] 大陸 '%s' の最初の島 '%s' が見つかりません。"):format(zoneName, firstIslandName))
             return false
        end

        targetX = firstIsland.centerX
        targetZ = firstIsland.centerZ
        baseY = firstIsland.baseY
        hillAmplitude = firstIsland.hillAmplitude or 20
    else
        -- ★修正: 島単独でのワープはエラーとする
        warn(("[ZoneManager] ゾーン '%s' は大陸ではありません。ワープできません。"):format(zoneName))
        return false
    end

    -- 十分に高い位置からレイキャスト
    local FieldGen = require(ReplicatedStorage:WaitForChild("FieldGen"))
    local rayStartY = baseY + hillAmplitude + 100
    local groundY = FieldGen.raycastGroundY(targetX, targetZ, rayStartY)

    local spawnY
    if groundY then
        spawnY = groundY + 5
        print(("[ZoneManager] 地面検出成功: Y=%.1f"):format(groundY))
    else
        -- 安全な高度：baseY + hillAmplitude * 0.6 + 10 に固定
        spawnY = baseY + (hillAmplitude * 0.6) + 10
        warn(("[ZoneManager] 地面検出失敗、予想高度使用: Y=%.1f"):format(spawnY))
    end

    hrp.CFrame = CFrame.new(targetX, spawnY, targetZ)

    updatePlayerZone(player, zoneName)

    print(("[ZoneManager] %s を %s にワープ完了 (%.1f, %.1f, %.1f)"):format(
        player.Name, zoneName, targetX, spawnY, targetZ
        ))
    return true
end

function ZoneManager.GetPlayerZone(player)
    return ZoneManager.PlayerZones[player]
end

-- プレイヤーが退出した時の処理 (省略)
Players.PlayerRemoving:Connect(function(player)
    local oldZone = ZoneManager.PlayerZones[player]
    if oldZone then
        print(("[ZoneManager] %s が退出しました。ゾーン: %s"):format(player.Name, oldZone))
        ZoneManager.PlayerZones[player] = nil
    end
end)

return ZoneManager
===== ./ServerScriptService/FastTravelSystem.server.lua =====
-- ServerScriptService/FastTravelSystem.server.lua
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")

print("[FastTravel] 初期化開始")

-- 依存モジュール
local ContinentsRegistry = require(ReplicatedStorage:WaitForChild("Continents"):WaitForChild("Registry"))
local IslandsRegistry = require(ReplicatedStorage:WaitForChild("Islands"):WaitForChild("Registry"))
local ZoneManager = require(ServerScriptService:WaitForChild("ZoneManager"))

-- 【追加】IslandsRegistryを辞書形式に変換
local Islands = {}
for _, island in ipairs(IslandsRegistry) do
	if island and island.name then
		Islands[island.name] = island
	end
end

-- RemoteEvent作成
local FastTravelEvent = ReplicatedStorage:FindFirstChild("FastTravelEvent")
if not FastTravelEvent then
	FastTravelEvent = Instance.new("RemoteEvent")
	FastTravelEvent.Name = "FastTravelEvent"
	FastTravelEvent.Parent = ReplicatedStorage
end

local GetContinentsEvent = ReplicatedStorage:FindFirstChild("GetContinentsEvent")
if not GetContinentsEvent then
	GetContinentsEvent = Instance.new("RemoteFunction")
	GetContinentsEvent.Name = "GetContinentsEvent"
	GetContinentsEvent.Parent = ReplicatedStorage
end

-- 大陸一覧を取得
local function getContinentsList()
	local continents = {}

	for _, continent in ipairs(ContinentsRegistry) do
		table.insert(continents, {
			name = continent.name,
			displayName = continent.displayName or continent.name
		})
	end

	return continents
end

-- ワープ処理
local function handleFastTravel(player, continentName)
	print(("[FastTravel] %s が %s へのワープを要求"):format(player.Name, continentName))

	-- 大陸情報を取得
	local continent = nil
	for _, cont in ipairs(ContinentsRegistry) do
		if cont.name == continentName then
			continent = cont
			break
		end
	end

	if not continent then
		warn(("[FastTravel] 大陸 '%s' が見つかりません"):format(continentName))
		return false
	end

	-- 最初の島を取得
	local firstIslandName = continent.islands[1]
	if not firstIslandName then
		warn(("[FastTravel] 大陸 '%s' に島がありません"):format(continentName))
		return false
	end

	-- 辞書から島を取得
	local island = Islands[firstIslandName]
	if not island then
		warn(("[FastTravel] 島 '%s' が見つかりません"):format(firstIslandName))
		return false
	end

	-- ワープ実行
	local success = ZoneManager.WarpPlayerToZone(
		player,
		continentName,
		island.centerX,
		island.baseY + 25,
		island.centerZ,
		true
	)

	if success then
		print(("[FastTravel] %s を %s にワープしました"):format(player.Name, continentName))

		-- 【追加】モンスターとポータルを生成
		task.spawn(function()
			task.wait(1) -- ゾーンロード完了を待つ

			-- モンスター生成
			if _G.SpawnMonstersForZone then
				_G.SpawnMonstersForZone(continentName)
				print(("[FastTravel] %s のモンスターを生成しました"):format(continentName))
			else
				warn("[FastTravel] SpawnMonstersForZone が見つかりません")
			end

			-- ポータル生成
			if _G.CreatePortalsForZone then
				_G.CreatePortalsForZone(continentName)
				print(("[FastTravel] %s のポータルを生成しました"):format(continentName))
			else
				warn("[FastTravel] CreatePortalsForZone が見つかりません")
			end
		end)
	else
		warn(("[FastTravel] %s のワープに失敗しました"):format(player.Name))
	end

	return success
end

-- イベント接続
GetContinentsEvent.OnServerInvoke = function(player)
	return getContinentsList()
end

FastTravelEvent.OnServerEvent:Connect(function(player, continentName)
	handleFastTravel(player, continentName)
end)

print("[FastTravel] 初期化完了")
===== ./ServerScriptService/PlayerStats.lua =====
-- ServerScriptService/PlayerStats.lua
-- プレイヤーのステータスを管理するModuleScript
-- ステップ2: SharedState/GameEvents統合版

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- 【ステップ2】SharedStateとGameEventsをロード
local SharedState = require(ReplicatedStorage:WaitForChild("SharedState"))
local GameEvents = require(ReplicatedStorage:WaitForChild("GameEvents"))

local DataStoreManager = require(script.Parent:WaitForChild("DataStoreManager"))

local PlayerStats = {}
local LoadedDataCache = {}

-- RemoteEventを取得する関数
local function getRemoteEvent(name)
	return ReplicatedStorage:WaitForChild(name, 10)
end

-- デフォルトステータス
local DEFAULT_STATS = {
	Level = 1,
	Experience = 0,
	Gold = 100,  -- 初期ゴールド100G

	MaxHP = 100,
	CurrentHP = 100,

	Speed = 10,      -- 素早さ
	Attack = 10,     -- 攻撃力
	Defense = 10,    -- 守備力
	MonstersDefeated = 0,


	MonsterCounts = {}, 	-- モンスターカウント追加
	CollectedItems = {},	-- 取得済みアイテム
}

-- レベルアップに必要な経験値（レベル * 100)
local function getRequiredExp(level)
	return level * 100
end

-- 各プレイヤーのステータスを保存
local PlayerData = {}

-- プレイヤーのステータスを初期化
function PlayerStats.initPlayer(player: Player)
	if PlayerData[player] then
		warn(("[PlayerStats] %s は既に初期化済みです"):format(player.Name))
        -- 既に初期化済みの場合はLocationを返却
        return PlayerData[player].Location or {
            ZoneName = "ContinentTown", X = DEFAULT_STATS.MaxHP, Y = DEFAULT_STATS.MaxHP, Z = DEFAULT_STATS.MaxHP
        }
	end

	-- デフォルト値でステータスを作成
	local stats = {}
	for key, value in pairs(DEFAULT_STATS) do
		stats[key] = value
	end

	-- ★DataStoreからデータをロード（ブロッキング）
	local loadedData = DataStoreManager.LoadData(player)
	LoadedDataCache[player] = loadedData

	local loadedLocation = nil

	if loadedData and loadedData.PlayerState then
		local playerState = loadedData.PlayerState

		-- ステータスを適用
		for key, value in pairs(playerState.Stats) do
			if stats[key] ~= nil then
				stats[key] = value
			end
		end

		-- Locationを適用
		if playerState.Location then
			loadedLocation = playerState.Location
			print(("[PlayerStats] %s のセーブデータを適用しました: %s (%.0f, %.0f, %.0f)"):format(
				player.Name,
				loadedLocation.ZoneName,
				loadedLocation.X,
				loadedLocation.Y,
				loadedLocation.Z
			))
		end

		 stats.CollectedItems = loadedData.CollectedItems or {}

		print(("[PlayerStats] %s の取得済みアイテム数: %d"):format(
			player.Name,
			next(stats.CollectedItems) and #stats.CollectedItems or 0
		))
	else
		print(("[PlayerStats] %s の新規データ、またはロード失敗（デフォルト値使用）"):format(player.Name))
	end

	PlayerData[player] = stats
	print(("[PlayerStats] %s のステータスを初期化しました（DataStore適用後）"):format(player.Name))

	-- 【ステップ2】SharedStateにプレイヤーゾーンを初期化
	SharedState.PlayerZones[player] = nil
	-- ★ロードされたLocation情報を返す
	return loadedLocation
end

function PlayerStats.getLastLoadedData(player: Player)
    return LoadedDataCache[player]
end

-- プレイヤーのステータスを取得
function PlayerStats.getStats(player: Player)
	return PlayerData[player]
end

-- 特定のステータスを取得
function PlayerStats.getStat(player: Player, statName: string)
	local stats = PlayerData[player]
	if not stats then
		warn(("[PlayerStats] %s のステータスが見つかりません"):format(player.Name))
		return nil
	end
	return stats[statName]
end

-- 特定のステータスを設定
function PlayerStats.setStat(player: Player, statName: string, value)
	local stats = PlayerData[player]
	if not stats then
		warn(("[PlayerStats] %s のステータスが見つかりません"):format(player.Name))
		return
	end

	stats[statName] = value
	print(("[PlayerStats] %s の %s を %s に設定"):format(player.Name, statName, tostring(value)))
end

-- HPを回復
function PlayerStats.healHP(player: Player, amount: number)
	local stats = PlayerData[player]
	if not stats then return end

	stats.CurrentHP = math.min(stats.CurrentHP + amount, stats.MaxHP)
	print(("[PlayerStats] %s のHPを %d 回復（現在: %d/%d)"):format(
		player.Name, amount, stats.CurrentHP, stats.MaxHP
		))
end

-- HPを全回復
function PlayerStats.fullHeal(player: Player)
	local stats = PlayerData[player]
	if not stats then return end

	stats.CurrentHP = stats.MaxHP
	print(("[PlayerStats] %s のHPを全回復"):format(player.Name))
end

-- ダメージを受ける
function PlayerStats.takeDamage(player: Player, damage: number): boolean
	local stats = PlayerData[player]
	if not stats then return false end

	stats.CurrentHP = math.max(0, stats.CurrentHP - damage)
	print(("[PlayerStats] %s が %d ダメージを受けた（残りHP: %d/%d)"):format(
		player.Name, damage, stats.CurrentHP, stats.MaxHP
		))

	-- ステータス更新を送信
	local StatusUpdateEvent = getRemoteEvent("StatusUpdate")
	if StatusUpdateEvent then
		local expToNext = getRequiredExp(stats.Level)
		StatusUpdateEvent:FireClient(
			player,
			stats.CurrentHP,
			stats.MaxHP,
			stats.Level,
			stats.Experience,
			expToNext,
			stats.Gold
		)
	end

	-- 死亡判定
	if stats.CurrentHP <= 0 then
		print(("[PlayerStats] %s は倒れた！"):format(player.Name))
		return true  -- 死亡
	end

	return false  -- 生存
end

-- 経験値を追加
function PlayerStats.addExperience(player: Player, exp: number)
	local stats = PlayerData[player]
	if not stats then return end

	stats.Experience = stats.Experience + exp
	print(("[PlayerStats] %s が経験値 %d を獲得（合計: %d)"):format(
		player.Name, exp, stats.Experience
		))

	-- レベルアップチェック
	local requiredExp = getRequiredExp(stats.Level)
	while stats.Experience >= requiredExp do
		PlayerStats.levelUp(player)
		requiredExp = getRequiredExp(stats.Level)
	end

	-- ステータス更新を送信
	local StatusUpdateEvent = getRemoteEvent("StatusUpdate")
	if StatusUpdateEvent then
		local expToNext = getRequiredExp(stats.Level)
		StatusUpdateEvent:FireClient(
			player,
			stats.CurrentHP,
			stats.MaxHP,
			stats.Level,
			stats.Experience,
			expToNext,
			stats.Gold
		)
	end
end

-- ゴールドを追加
function PlayerStats.addGold(player: Player, gold: number)
	local stats = PlayerData[player]
	if not stats then return end

	stats.Gold = stats.Gold + gold
	print(("[PlayerStats] %s がゴールド %d を獲得（合計: %d)"):format(
		player.Name, gold, stats.Gold
		))

	-- ステータス更新を送信
	local StatusUpdateEvent = getRemoteEvent("StatusUpdate")
	if StatusUpdateEvent then
		local expToNext = getRequiredExp(stats.Level)
		StatusUpdateEvent:FireClient(
			player,
			stats.CurrentHP,
			stats.MaxHP,
			stats.Level,
			stats.Experience,
			expToNext,
			stats.Gold
		)
	end
end

-- ゴールドを減らす
function PlayerStats.removeGold(player: Player, gold: number): boolean
	local stats = PlayerData[player]
	if not stats then return false end

	if stats.Gold < gold then
		print(("[PlayerStats] %s のゴールドが不足しています"):format(player.Name))
		return false
	end

	stats.Gold = stats.Gold - gold
	print(("[PlayerStats] %s がゴールド %d を失った（残り: %d)"):format(
		player.Name, gold, stats.Gold
		))
	return true
end

-- 倒したモンスター数を追加
function PlayerStats.addMonstersDefeated(player: Player, count: number)
	print(("[PlayerStats] ========================================"):format())
	print(("[PlayerStats] addMonstersDefeated 呼び出し"):format())
	print(("  プレイヤー: %s"):format(player.Name))
	print(("  追加数: %d"):format(count or 1))

	local stats = PlayerData[player]
	if not stats then
		warn(("[PlayerStats] ❌ %s のステータスが見つかりません（モンスターカウント失敗)"):format(player.Name))
		print(("[PlayerStats] ========================================"):format())
		return
	end

	local oldCount = stats.MonstersDefeated
	count = count or 1
	stats.MonstersDefeated = stats.MonstersDefeated + count

	print(("  変更前: %d"):format(oldCount))
	print(("  変更後: %d"):format(stats.MonstersDefeated))
	print(("[PlayerStats] ✅ モンスター撃破数更新成功"):format())
	print(("[PlayerStats] ========================================"):format())
end

-- レベルアップ
function PlayerStats.levelUp(player: Player)
	local stats = PlayerData[player]
	if not stats then return end

	local oldLevel = stats.Level
	stats.Level = stats.Level + 1

	-- ステータスアップ
	stats.MaxHP = stats.MaxHP + 10
	stats.CurrentHP = stats.MaxHP  -- 全回復
	stats.Speed = stats.Speed + 2
	stats.Attack = stats.Attack + 2
	stats.Defense = stats.Defense + 2

	print(("[PlayerStats] 🎉 %s がレベルアップ！ %d → %d"):format(
		player.Name, oldLevel, stats.Level
		))
	print(("  HP: %d, 素早さ: %d, 攻撃: %d, 守備: %d"):format(
		stats.MaxHP, stats.Speed, stats.Attack, stats.Defense
		))

	-- クライアントにレベルアップ演出を通知
	local LevelUpEvent = getRemoteEvent("LevelUp")
	if LevelUpEvent then
		LevelUpEvent:FireClient(player, stats.Level, stats.MaxHP, stats.Speed, stats.Attack, stats.Defense)
	end

	-- ステータス更新を送信
	local StatusUpdateEvent = getRemoteEvent("StatusUpdate")
	if StatusUpdateEvent then
		local expToNext = stats.Level * 100
		StatusUpdateEvent:FireClient(
			player,
			stats.CurrentHP,
			stats.MaxHP,
			stats.Level,
			stats.Experience,
			expToNext,
			stats.Gold
		)
	end
end

-- 【ステップ2】モンスターカウントを更新
function PlayerStats.updateMonsterCounts(player: Player, zoneName: string)
	local stats = PlayerData[player]
	if not stats then return end

	-- SharedStateから最新のカウントを取得
	if SharedState.MonsterCounts[zoneName] then
		stats.MonsterCounts[zoneName] = SharedState.MonsterCounts[zoneName]
		print(("[PlayerStats] %s のゾーン %s のモンスターカウントを更新"):format(
			player.Name, zoneName
		))
	end
end

-- プレイヤーが退出したらデータをクリア
function PlayerStats.removePlayer(player: Player)
    PlayerData[player] = nil
    LoadedDataCache[player] = nil -- 【追加】
    SharedState.PlayerZones[player] = nil
    print(("[PlayerStats] %s のデータを削除しました"):format(player.Name))
end

-- 初期化
function PlayerStats.init()
	-- 既存のプレイヤーを初期化
	for _, player in ipairs(Players:GetPlayers()) do
		PlayerStats.initPlayer(player)
	end

	-- 新規参加プレイヤーを初期化
	Players.PlayerAdded:Connect(function(player)
		PlayerStats.initPlayer(player)
	end)

	-- 退出時にデータをクリア
	Players.PlayerRemoving:Connect(function(player)
		PlayerStats.removePlayer(player)
	end)

	-- 詳細ステータスリクエスト用RemoteEvent
	local RequestStatsDetailEvent = ReplicatedStorage:FindFirstChild("RequestStatsDetail")
	if not RequestStatsDetailEvent then
		RequestStatsDetailEvent = Instance.new("RemoteEvent")
		RequestStatsDetailEvent.Name = "RequestStatsDetail"
		RequestStatsDetailEvent.Parent = ReplicatedStorage
	end

	RequestStatsDetailEvent.OnServerEvent:Connect(function(player)
		local stats = PlayerStats.getStats(player)
		if stats then
			-- StatsDetailEventを取得または作成
			local StatsDetailEvent = ReplicatedStorage:FindFirstChild("StatsDetail")
			if not StatsDetailEvent then
				StatsDetailEvent = Instance.new("RemoteEvent")
				StatsDetailEvent.Name = "StatsDetail"
				StatsDetailEvent.Parent = ReplicatedStorage
				print("[PlayerStats] StatsDetailイベントを作成しました")
			end

			print(("[PlayerStats] 詳細ステータスを送信: MonstersDefeated=%d"):format(stats.MonstersDefeated or 0))
			StatsDetailEvent:FireClient(player, stats)
		end
	end)

	print("[PlayerStats] 初期化完了（ステップ2: SharedState統合版）")
end

return PlayerStats
===== ./ServerScriptService/Bootstrap.server.lua =====
-- ServerScriptService/Bootstrap.server.lua
-- ゲーム初期化スクリプト（最終安定版 - DataStoreロード安定化）

local ServerScriptService = game:GetService("ServerScriptService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

print("[Bootstrap] === ゲーム初期化開始 (最終安定版) ===")

-- ZoneManagerを読み込み（ServerScriptServiceの兄弟モジュール）
local ZoneManager = require(script.Parent:WaitForChild("ZoneManager"))

-- PlayerStatsのModuleScriptの実行結果をロード（ServerScriptServiceの兄弟モジュール）
local PlayerStatsModule = require(script.Parent:WaitForChild("PlayerStats"))
local DataCollectors = require(script.Parent:WaitForChild("DataCollectors"))

local START_ZONE_NAME = "ContinentTown"
local LOAD_TIMEOUT = 10 -- DataStoreロードのタイムアウト(秒)

-- プレイヤーごとのロードデータ管理
local LastLoadedLocation = {}
local LastLoadedData = {}

-- PlayerStatsの初期化（DataStoreロード処理を含む）
PlayerStatsModule.init()

print("[Bootstrap] セーブ機能を初期化中...")

local SaveGameEvent = ReplicatedStorage:FindFirstChild("SaveGame")
if not SaveGameEvent then
    SaveGameEvent = Instance.new("RemoteEvent")
    SaveGameEvent.Name = "SaveGame"
    SaveGameEvent.Parent = ReplicatedStorage
    print("[Bootstrap] ✓ SaveGameイベント作成")
end

local SaveSuccessEvent = ReplicatedStorage:FindFirstChild("SaveSuccess")
if not SaveSuccessEvent then
    SaveSuccessEvent = Instance.new("RemoteEvent")
    SaveSuccessEvent.Name = "SaveSuccess"
    SaveSuccessEvent.Parent = ReplicatedStorage
    print("[Bootstrap] ✓ SaveSuccessイベント作成")
end

-- DataStoreManagerとDataCollectorsをロード
local DataStoreManager = require(ServerScriptService:WaitForChild("DataStoreManager"))
local DataCollectors = require(ServerScriptService:WaitForChild("DataCollectors"))

-- セーブイベントハンドラを登録
SaveGameEvent.OnServerEvent:Connect(function(player)
    print(("[Bootstrap] 💾 %s からセーブリクエスト受信"):format(player.Name))

    -- プレイヤーのステータスを取得
    local stats = PlayerStatsModule.getStats(player)
    if not stats then
        warn(("[Bootstrap] ❌ %s のステータスが見つかりません"):format(player.Name))
        SaveSuccessEvent:FireClient(player, false)
        return
    end

    -- セーブデータを作成
    local saveData = DataCollectors.createSaveData(player, stats)

    print(("[Bootstrap] 📦 セーブデータ作成完了"):format())

    -- DataStoreに保存
    local success = DataStoreManager.SaveData(player, saveData)

    if success then
        print(("[Bootstrap] ✅ %s のセーブ成功"):format(player.Name))
    else
        warn(("[Bootstrap] ❌ %s のセーブ失敗"):format(player.Name))
    end
end)

print("[Bootstrap] ✓ セーブ機能の初期化完了")

print("[Bootstrap] 街を生成中（非同期）...")
task.spawn(function()
    ZoneManager.LoadZone(START_ZONE_NAME)
    print("[Bootstrap] 地形生成完了")
end)

-- 街の設定を取得
local IslandsRegistry = require(ReplicatedStorage.Islands.Registry)
local townConfig = nil
for _, island in ipairs(IslandsRegistry) do
	if island.name == "StartTown" then
		townConfig = island
		break
	end
end

if not townConfig then
	warn("[Bootstrap] StartTown の設定が見つかりません！")
	return
end


-- プレイヤーのスポーン位置を街に設定
local function setupPlayerSpawn(player)

    -- DataStoreからのロード処理（同期的に待つ）
    local function loadDataAndPrepareSpawn()
        local startTime = os.clock()
        print(("[Bootstrap] %s のDataStoreロード開始"):format(player.Name))

        local loadedLocation = PlayerStatsModule.initPlayer(player)
        local fullLoadedData = PlayerStatsModule.getLastLoadedData(player)

        print(("[Bootstrap] ⏱️ DataStoreロード完了: %.2f秒"):format(os.clock() - startTime))

        if not loadedLocation then
            warn(("[Bootstrap] %s のロードデータがnil、デフォルト使用"):format(player.Name))
            loadedLocation = {
                ZoneName = "ContinentTown",
                X = townConfig.centerX,
                Y = townConfig.baseY + 25,
                Z = townConfig.centerZ
            }
        end

        LastLoadedData[player] = {
            Location = loadedLocation,
            FieldState = fullLoadedData and fullLoadedData.FieldState or nil,
            CurrentZone = fullLoadedData and fullLoadedData.CurrentZone or nil,
        }

        print(("[Bootstrap] %s のロード完了: %s (%.0f, %.0f, %.0f)"):format(
            player.Name,
            loadedLocation.ZoneName,
            loadedLocation.X,
            loadedLocation.Y,
            loadedLocation.Z
        ))

        player:SetAttribute("ContinentName", loadedLocation.ZoneName)
        return LastLoadedData[player]
    end

    -- メイン処理
    task.spawn(function()
        local totalStartTime = os.clock()

        -- DataStoreロードを待つ
        local loadedData = loadDataAndPrepareSpawn()
        local loadedLocation = loadedData.Location
        local targetZone = loadedLocation.ZoneName

        -- 【重要】キャラクター生成前にゾーンをロード
        if targetZone ~= START_ZONE_NAME then
            local zoneLoadStart = os.clock()
            print(("[Bootstrap] キャラ生成前: %s のゾーンをロード"):format(targetZone))
            ZoneManager.LoadZone(targetZone)
            task.wait(2) -- 地形生成完了を待つ
            print(("[Bootstrap] ⏱️ ゾーンロード完了: %.2f秒"):format(os.clock() - zoneLoadStart))
        end

        -- キャラクター生成
        local charGenStart = os.clock()
        print(("[Bootstrap] %s のキャラクター生成を開始"):format(player.Name))

        -- 【追加】SpawnReadyEventを取得/作成
        local SpawnReadyEvent = ReplicatedStorage:FindFirstChild("SpawnReady")
        if not SpawnReadyEvent then
            SpawnReadyEvent = Instance.new("RemoteEvent")
            SpawnReadyEvent.Name = "SpawnReady"
            SpawnReadyEvent.Parent = ReplicatedStorage
        end

        -- CharacterAddedを先に接続（生成と同時にワープするため）
        local connection
        connection = player.CharacterAdded:Connect(function(character)
            connection:Disconnect() -- 一度だけ実行

            print(("[Bootstrap] ⏱️ キャラクター生成完了: %.2f秒"):format(os.clock() - charGenStart))

            -- 即座にワープ（描画される前に）
            task.spawn(function()
                local hrpStart = os.clock()
                local hrp = character:WaitForChild("HumanoidRootPart", 5)
                print(("[Bootstrap] ⏱️ HRP取得完了: %.2f秒"):format(os.clock() - hrpStart))

                if not hrp then
                    warn(("[Bootstrap] %s のHRPが見つかりません"):format(player.Name))
                    return
                end

                local targetX = loadedLocation.X
                local targetY = loadedLocation.Y
                local targetZ = loadedLocation.Z

                print(("[Bootstrap] 即座にワープ: %s → (%.0f, %.0f, %.0f)"):format(player.Name, targetX, targetY, targetZ))

                -- 即座に配置
                hrp.CFrame = CFrame.new(targetX, targetY, targetZ)
                ZoneManager.PlayerZones[player] = targetZone

                print(("[Bootstrap] %s を配置完了"):format(player.Name))
                print(("[Bootstrap] ⏱️ 合計時間: %.2f秒"):format(os.clock() - totalStartTime))

                -- 【追加】ワープ完了後、即座にローディング解除通知
                SpawnReadyEvent:FireClient(player)
                print(("[Bootstrap] %s にスポーン準備完了を通知（即座）"):format(player.Name))

                -- 【修正】モンスターとポータルの復元を並行処理に変更
                task.spawn(function()
                    task.wait(1) -- 少し待ってから復元

                    if loadedData.FieldState and loadedData.CurrentZone then
                        local zoneName = loadedData.CurrentZone
                        print(("[Bootstrap] %s のフィールド状態を復元: %s"):format(player.Name, zoneName))

                        DataCollectors.restoreFieldState(zoneName, loadedData.FieldState)

                        if _G.CreatePortalsForZone then
                            _G.CreatePortalsForZone(zoneName)
                        end
                    else
                        print(("[Bootstrap] %s は初回プレイ"):format(player.Name))

                        if targetZone ~= START_ZONE_NAME then
                            if _G.SpawnMonstersForZone then
                                _G.SpawnMonstersForZone(targetZone)
                            end
                            if _G.CreatePortalsForZone then
                                _G.CreatePortalsForZone(targetZone)
                            end
                        else
                            if _G.CreatePortalsForZone then
                                _G.CreatePortalsForZone(START_ZONE_NAME)
                            end
                        end
                    end

                    -- クリーンアップ
                    LastLoadedData[player] = nil
                end)

                -- ステータス更新（並行処理）
                task.spawn(function()
                    local stats = PlayerStatsModule.getStats(player)
                    if stats then
                        local expToNext = stats.Level * 100
                        local StatusUpdateEvent = ReplicatedStorage:FindFirstChild("StatusUpdate")
                        if StatusUpdateEvent then
                            StatusUpdateEvent:FireClient(
                                player,
                                stats.CurrentHP,
                                stats.MaxHP,
                                stats.Level,
                                stats.Experience,
                                expToNext,
                                stats.Gold
                            )
                        end
                    end
                end)

                print(("[Bootstrap] %s のスポーン処理完了"):format(player.Name))
            end)
        end)

        -- キャラクター生成
        player:LoadCharacter()
    end)
end


-- 既存プレイヤーに適用
for _, player in ipairs(Players:GetPlayers()) do
    setupPlayerSpawn(player)
end

-- 新規プレイヤーに適用
Players.PlayerAdded:Connect(setupPlayerSpawn)

-- 退出時のクリーンアップ
Players.PlayerRemoving:Connect(function(player)
    LastLoadedLocation[player] = nil
end)

-- 効果音の初期化
task.spawn(function()
    local soundsFolder = ReplicatedStorage:FindFirstChild("Sounds")
    if not soundsFolder then
        soundsFolder = Instance.new("Folder")
        soundsFolder.Name = "Sounds"
        soundsFolder.Parent = ReplicatedStorage
    end

    if not soundsFolder:FindFirstChild("TypingCorrect") then
        local typingCorrect = Instance.new("Sound")
        typingCorrect.Name = "TypingCorrect"
        typingCorrect.SoundId = "rbxassetid://159534615"
        typingCorrect.Volume = 0.4
        typingCorrect.Parent = soundsFolder
    end

    if not soundsFolder:FindFirstChild("TypingError") then
        local typingError = Instance.new("Sound")
        typingError.Name = "TypingError"
        typingError.SoundId = "rbxassetid://113721818600044"
        typingError.Volume = 0.5
        typingError.Parent = soundsFolder
    end

    print("[Bootstrap] Soundsフォルダを初期化しました")
end)

-- 【追加】セーブイベントハンドラの登録
local SaveGameEvent = ReplicatedStorage:FindFirstChild("SaveGame")
if not SaveGameEvent then
    SaveGameEvent = Instance.new("RemoteEvent")
    SaveGameEvent.Name = "SaveGame"
    SaveGameEvent.Parent = ReplicatedStorage
    print("[Bootstrap] SaveGameイベントを作成しました")
end

local DataStoreManager = require(ServerScriptService:WaitForChild("DataStoreManager"))
local DataCollectors = require(ServerScriptService:WaitForChild("DataCollectors"))

SaveGameEvent.OnServerEvent:Connect(function(player)
    print(("[Bootstrap] %s からセーブリクエストを受信"):format(player.Name))

    -- プレイヤーのステータスを取得
    local stats = PlayerStatsModule.getStats(player)
    if not stats then
        warn(("[Bootstrap] %s のステータスが見つかりません"):format(player.Name))
        local SaveSuccessEvent = ReplicatedStorage:FindFirstChild("SaveSuccess")
        if SaveSuccessEvent then
            SaveSuccessEvent:FireClient(player, false)
        end
        return
    end

    -- セーブデータを作成
    local saveData = DataCollectors.createSaveData(player, stats)

    -- DataStoreに保存
    local success = DataStoreManager.SaveData(player, saveData)

    if success then
        print(("[Bootstrap] %s のセーブ成功"):format(player.Name))
    else
        warn(("[Bootstrap] %s のセーブ失敗"):format(player.Name))
    end
end)

print("[Bootstrap] セーブイベントハンドラを登録しました")

print("[Bootstrap] === ゲーム初期化完了 ===")
print(("[Bootstrap] プレイヤーは街（%s）からスタートします"):format(START_ZONE_NAME))
===== ./ServerScriptService/LoadTest.server.lua =====
-- ServerScriptService/LoadTest (Script)
local startTime = os.clock()
local startMemory = gcinfo()

-- ゲーム開始を待つ
-- task.wait(5)

-- local endTime = os.clock()
-- local endMemory = gcinfo()

-- print("=== 負荷テスト結果 ===")
-- print(("地形生成時間: %.2f秒"):format(endTime - startTime))
-- print(("メモリ使用量: %.2f MB"):format((endMemory - startMemory) / 1024))
-- print(("総オブジェクト数: %d"):format(#workspace:GetDescendants()))

-- 継続モニタリング
task.spawn(function()
	while true do
		task.wait(5)
		local fps = 1 / game:GetService("RunService").Heartbeat:Wait()
		print(("FPS: %.1f | メモリ: %.1f MB"):format(fps, gcinfo() / 1024))
	end
end)
===== ./ServerScriptService/OceanSafety.server.lua =====
-- ServerScriptService/OceanSafety.server.lua
-- 海に落ちた時の処理

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- 設定
local WATER_LEVEL = -25  -- この高さより下に落ちたら処理
local CHECK_INTERVAL = 0.5  -- チェック間隔（秒）

-- 島の中心（プレイヤーのリスポーン位置）
local Islands = require(ReplicatedStorage.Islands.Registry)
local firstIsland = Islands[1]
local SPAWN_X = firstIsland.centerX
local SPAWN_Z = firstIsland.centerZ
local SPAWN_Y = firstIsland.baseY + 25  -- 島の上空

print("[OceanSafety] 初期化完了")

-- プレイヤーの監視
local function monitorPlayer(player)
	player.CharacterAdded:Connect(function(character)
		local hrp = character:WaitForChild("HumanoidRootPart")
		local humanoid = character:WaitForChild("Humanoid")

		local lastCheck = 0

		RunService.Heartbeat:Connect(function()
			if not character.Parent or not hrp.Parent then return end

			local now = os.clock()
			if now - lastCheck < CHECK_INTERVAL then return end
			lastCheck = now

			-- 水面より下に落ちたかチェック
			if hrp.Position.Y < WATER_LEVEL then
				print(("[OceanSafety] %s が海に落ちました。リスポーン中..."):format(player.Name))

				-- 速度をゼロに
				hrp.AssemblyLinearVelocity = Vector3.zero
				hrp.AssemblyAngularVelocity = Vector3.zero

				-- 島の中心に戻す
				hrp.CFrame = CFrame.new(SPAWN_X, SPAWN_Y, SPAWN_Z)

				-- 体力を少し減らす（ペナルティ）
				if humanoid.Health > 10 then
					humanoid.Health = humanoid.Health - 10
				end
			end
		end)
	end)
end

-- 既存プレイヤーと新規プレイヤーに適用
for _, player in ipairs(Players:GetPlayers()) do
	monitorPlayer(player)
end
Players.PlayerAdded:Connect(monitorPlayer)

-- モンスターの監視
RunService.Heartbeat:Connect(function()
	for _, model in ipairs(workspace:GetChildren()) do
		if model:IsA("Model") and model:GetAttribute("IsEnemy") then
			local hrp = model:FindFirstChild("HumanoidRootPart")

			if hrp and hrp.Position.Y < WATER_LEVEL then
				-- print(("[OceanSafety] %s が海に落ちました。消去中..."):format(model.Name))
				model:Destroy()
			end
		end
	end
end)
===== ./ServerScriptService/WarpPortal.server.lua =====
-- ===== ./ServerScriptService/WarpPortal.server.lua =====
-- ServerScriptService/WarpPortal.server.lua
-- ワープ中のバトル開始を防止する修正版

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

print("[WarpPortal] 初期化開始")

-- 【修正】warpEvent の作成を最優先で実行する
local warpEvent = ReplicatedStorage:FindFirstChild("WarpEvent")
if not warpEvent then
	warpEvent = Instance.new("RemoteEvent")
	warpEvent.Name = "WarpEvent"
	warpEvent.Parent = ReplicatedStorage
end

local ZoneManager = require(script.Parent.ZoneManager)
local BattleSystem = require(script.Parent.BattleSystem)


local warpingPlayers = {}
local activePortals = {}

local IslandsRegistry = require(ReplicatedStorage.Islands.Registry)
local ContinentsRegistry = require(ReplicatedStorage.Continents.Registry)

local Islands = {}
for _, island in ipairs(IslandsRegistry) do
	Islands[island.name] = island
end

local Continents = {}
for _, continent in ipairs(ContinentsRegistry) do
	if continent and continent.name then
		Continents[continent.name] = continent
	else
		warn(("[WarpPortal] 名前が設定されていない大陸定義をスキップしました"):format(continent and continent.name or "nil"))
	end
end

local function resolveTemplate(pathArray: {string}): Model?
	local node: Instance = game
	for _, seg in ipairs(pathArray) do
		node = node:FindFirstChild(seg)
		if not node then return nil end
	end
	return (node and node:IsA("Model")) and node or nil
end

local function ensureHRP(model: Model): BasePart?
	local hrp = model:FindFirstChild("HumanoidRootPart")
	if hrp and hrp:IsA("BasePart") then
		if not model.PrimaryPart then model.PrimaryPart = hrp end
		return hrp
	end
	return nil
end

local function attachLabel(model: Model, maxDist: number)
	local hrp = model.PrimaryPart or model:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	local _, bboxSize = model:GetBoundingBox()
	local labelOffset = math.min(bboxSize.Y * 0.5 + 2, 15)

	local gui = Instance.new("BillboardGui")
	gui.Name = "DebugInfo"
	gui.Adornee = hrp
	gui.AlwaysOnTop = true
	gui.Size = UDim2.new(0, 150, 0, 50)
	gui.StudsOffset = Vector3.new(0, labelOffset, 0)
	gui.MaxDistance = maxDist
	gui.Parent = hrp

	local lb = Instance.new("TextLabel")
	lb.Name = "InfoText"
	lb.BackgroundTransparency = 1
	lb.TextScaled = true
	lb.Font = Enum.Font.GothamBold
	lb.TextColor3 = Color3.new(1, 1, 1)
	lb.TextStrokeTransparency = 0.5
	lb.Size = UDim2.fromScale(1, 1)
	lb.Text = "Ready"
	lb.Parent = gui
end

local function placeOnGround(model: Model, x: number, z: number)
	local hrp = model.PrimaryPart or model:FindFirstChild("HumanoidRootPart")
	if not hrp then
		warn("[MonsterSpawner] HumanoidRootPart が見つかりません: " .. model.Name)
		return
	end

	local groundY = FieldGen.raycastGroundY(x, z, 100)
		or FieldGen.raycastGroundY(x, z, 200)
		or FieldGen.raycastGroundY(x, z, 50)
		or 10

	local _, yaw = hrp.CFrame:ToOrientation()
	model:PivotTo(CFrame.new(x, groundY + 20, z) * CFrame.Angles(0, yaw, 0))

	local bboxCFrame, bboxSize = model:GetBoundingBox()
	local bottomY = bboxCFrame.Position.Y - (bboxSize.Y * 0.5)
	local offset = hrp.Position.Y - bottomY

	model:PivotTo(CFrame.new(x, groundY + offset, z) * CFrame.Angles(0, yaw, 0))
end

local function nearestPlayer(position: Vector3)
	local best, bestDist = nil, math.huge
	for _, pl in ipairs(Players:GetPlayers()) do
		local ch = pl.Character
		local hrp = ch and ch:FindFirstChild("HumanoidRootPart")
		if hrp then
			local d = (position - hrp.Position).Magnitude
			if d < bestDist then
				best, bestDist = pl, d
			end
		end
	end
	return best, bestDist
end

-- 【修正】ポータルタッチ時、即座にワープ中フラグを設定
local function createPortal(config, fromZone)
	-- Town大陸の場合、fromZoneはContinentTownだが、ポータル座標はislandNameを参照する必要がある。
	local islandName = config.islandName or fromZone
	local zoneConfig = Islands[islandName]

	if not zoneConfig then
		warn(("[WarpPortal] ゾーン '%s' の島設定が見つかりません"):format(islandName))
		return nil
	end

	-- ポータルサイズを確定。設定がnilの場合、Vector3.new(8, 12, 8)を使用する。
    local portalSize = config.size or Vector3.new(8, 12, 8)
    local portalHeight = portalSize.Y -- 修正後、portalSizeがnilになることはない

	local portalX = zoneConfig.centerX + (config.offsetX or 0)
	local portalZ = zoneConfig.centerZ + (config.offsetZ or 0)

	local FieldGen = require(ReplicatedStorage:WaitForChild("FieldGen"))
	local groundY = nil
	local maxRetries = 2

	for attempt = 1, maxRetries do
		-- TownのBaseYではなく、推定高度からレイキャスト開始
		local rayStartY = zoneConfig.baseY + (zoneConfig.hillAmplitude or 20) + 100
		groundY = FieldGen.raycastGroundY(portalX, portalZ, rayStartY)
		if groundY then break end
		task.wait(0.05)
	end

	local portalY
	if groundY then
		-- ポータルの底面 (Y) が地面 (groundY) になるように設定
		portalY = groundY + portalHeight / 2
		print(("[WarpPortal DEBUG] %s: 地面検出成功 (Y=%.1f), ポータルY=%.1f"):format(config.name, groundY, portalY))
	else
		local estimatedHeight = zoneConfig.baseY + ((zoneConfig.hillAmplitude or 20) * 0.5)
		portalY = estimatedHeight + portalHeight / 2
		warn(("[WarpPortal DEBUG] %s: 地面検出失敗、推定高度使用 (Y=%.1f)"):format(config.name, portalY))
	end

	local portalPosition = Vector3.new(portalX, portalY, portalZ)

	local portal = Instance.new("Part")
	portal.Name = config.name
	portal.Size = portalSize -- 確定したサイズを使用
	portal.Position = portalPosition
	portal.Anchored = true
	portal.CanCollide = false
	portal.Transparency = 0.3
	portal.Color = config.color or Color3.fromRGB(255, 255, 255)
	portal.Material = Enum.Material.Neon

	portal:SetAttribute("FromZone", fromZone)
	portal:SetAttribute("ToZone", config.toZone)

	local bodyAngularVelocity = Instance.new("BodyAngularVelocity")
	bodyAngularVelocity.AngularVelocity = Vector3.new(0, 2, 0)
	bodyAngularVelocity.MaxTorque = Vector3.new(0, math.huge, 0)
	bodyAngularVelocity.P = 1000
	bodyAngularVelocity.Parent = portal

	local billboard = Instance.new("BillboardGui")
	billboard.Name = "PortalLabel"
	billboard.Size = UDim2.new(0, 200, 0, 50)
	billboard.StudsOffset = Vector3.new(0, 7, 0)
	billboard.AlwaysOnTop = true
	billboard.Parent = portal

	local label = Instance.new("TextLabel")
	label.Size = UDim2.new(1, 0, 1, 0)
	label.BackgroundTransparency = 1
	label.Text = config.label or ("→ " .. config.toZone)
	label.TextColor3 = Color3.new(1, 1, 1)
	label.TextScaled = true
	label.Font = Enum.Font.SourceSansBold
	label.TextStrokeTransparency = 0.5
	label.Parent = billboard

	local worldFolder = workspace:FindFirstChild("World")
	if not worldFolder then
		worldFolder = Instance.new("Folder")
		worldFolder.Name = "World"
		worldFolder.Parent = workspace
	end

	portal.Parent = worldFolder

	-- 【重要】ポータルタッチ処理
	portal.Touched:Connect(function(hit)
		local character = hit.Parent
		if not character then return end

		local player = Players:GetPlayerFromCharacter(character)
		if not player then return end

		-- 【修正1】ワープ中チェック
		if warpingPlayers[player.UserId] then
			return
		end

		-- 【修正2】バトル中チェック
		if BattleSystem and BattleSystem.isInBattle and BattleSystem.isInBattle(player) then
			return
		end

		local actualFromZone = portal:GetAttribute("FromZone")
		local currentZone = ZoneManager.GetPlayerZone(player)

		if currentZone ~= actualFromZone then
			if not currentZone then
				ZoneManager.PlayerZones[player] = actualFromZone
			else
				return
			end
		end

		print(("[WarpPortal] %s が %s に入りました"):format(player.Name, config.name))

		-- 【修正3】即座にワープ中フラグを設定（最優先）
		warpingPlayers[player.UserId] = true
		character:SetAttribute("IsWarping", true)

		-- 【修正4-改3】キャラクターを即座に透明化（上空移動なし）
		local originalTransparencies = {}
		for _, part in ipairs(character:GetDescendants()) do
			if part:IsA("BasePart") then
				originalTransparencies[part] = part.Transparency
				part.Transparency = 1
			elseif part:IsA("Decal") or part:IsA("Texture") then
				originalTransparencies[part] = part.Transparency
				part.Transparency = 1
			end
		end

		-- 画面を暗転
		warpEvent:FireClient(player, "StartLoading", config.toZone)
		task.wait(0.5)

		-- バトルシステムリセット
		if BattleSystem and BattleSystem.resetAllBattles then
			BattleSystem.resetAllBattles()
		end

		-- destroyPortalsForZone(actualFromZone)

		-- 前のゾーンのモンスターを削除
		local IS_TOWN = actualFromZone == "ContinentTown"
		if not IS_TOWN and _G.DespawnMonstersForZone then
			_G.DespawnMonstersForZone(actualFromZone)
		end

		-- ゾーン切り替え
		local success = ZoneManager.WarpPlayerToZone(player, config.toZone)

		if success then
			-- 透明度を元に戻す
			for part, transparency in pairs(originalTransparencies) do
				if part and part.Parent then
					part.Transparency = transparency
				end
			end

			-- 新しいゾーンのポータルを作成
			createPortalsForZone(config.toZone)

			-- 新しいゾーンのモンスターをスポーン
			local TO_IS_TOWN = config.toZone == "ContinentTown"
			if not TO_IS_TOWN and _G.SpawnMonstersForZone then
				_G.SpawnMonstersForZone(config.toZone)
			end

			task.wait(0.5)
			warpEvent:FireClient(player, "EndLoading")
		else
			warn(("[WarpPortal] %s のワープに失敗"):format(player.Name))
			warpEvent:FireClient(player, "EndLoading")
		end

		-- 【修正5】ワープ中フラグを解除
		task.wait(1) -- 追加の安全マージン
		warpingPlayers[player.UserId] = nil
		if character and character.Parent then
			character:SetAttribute("IsWarping", false)
		end
	end)

	return portal
end

function createPortalsForZone(zoneName)
    if activePortals[zoneName] then
        print(("[WarpPortal] %s のポータルは既に存在します"):format(zoneName))
        return
    end

    activePortals[zoneName] = {}

    local continent = Continents[zoneName]
    if continent and continent.portals then
        print(("[WarpPortal] %s のポータルを並列生成中..."):format(zoneName))

        for _, portalConfig in ipairs(continent.portals) do
            task.spawn(function()
                local islandName = portalConfig.islandName
                if not Islands[islandName] then
                    warn(("[WarpPortal] 島 '%s' が見つかりません"):format(islandName))
                else
                    -- createPortalの第2引数はポータルが属する大陸名（zoneName）
                    local portal = createPortal(portalConfig, zoneName)
                    if portal then
                        portal:SetAttribute("FromZone", zoneName)
                        table.insert(activePortals[zoneName], portal)
                        print(("[WarpPortal] ポータル作成: %s (配置: %s)"):format(portalConfig.name, islandName))
                    end
                end
            end)
        end
    else
        print(("[WarpPortal] %s のポータル設定が見つかりません"):format(zoneName))
    end
end

function destroyPortalsForZone(zoneName)
	if not activePortals[zoneName] then return end

	-- 万が一島名が渡された場合、大陸名に変換して削除
    local actualZoneName = zoneName
    if actualZoneName == "StartTown" then
        actualZoneName = "ContinentTown"
    end

	for _, portal in ipairs(activePortals[actualZoneName] or {}) do
		if portal and portal.Parent then
			portal:Destroy()
		end
	end

	activePortals[actualZoneName] = nil
	print(("[WarpPortal] %s のポータルを削除しました-"):format(actualZoneName))
end

task.spawn(function()
	local maxWait = 10
	local waited = 0

	while not _G.SpawnMonstersForZone and waited < maxWait do
		task.wait(0.5)
		waited = waited + 0.5
	end

	if _G.SpawnMonstersForZone then
		print("[WarpPortal] MonsterSpawner関数検出成功")
	else
		warn("[WarpPortal] MonsterSpawner関数が見つかりません")
	end
end)

task.wait(0.3)
createPortalsForZone("ContinentTown") -- ★修正: StartTownからContinentTownに変更

Players.PlayerRemoving:Connect(function(player)
	warpingPlayers[player.UserId] = nil
	ZoneManager.PlayerZones[player] = nil
end)

_G.CreatePortalsForZone = createPortalsForZone
_G.DestroyPortalsForZone = destroyPortalsForZone

print("[WarpPortal] 初期化完了")
===== ./ServerScriptService/InteractionSystem.server.lua =====
-- ServerScriptService/InteractionSystem.server.lua
-- インタラクションシステム（宝箱、NPC等）

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")
local HttpService = game:GetService("HttpService")

print("[InteractionSystem] 初期化開始")

-- 依存モジュール
local PlayerStatsModule = require(ServerScriptService:WaitForChild("PlayerStats"))

-- RemoteEvent作成
local InteractEvent = ReplicatedStorage:FindFirstChild("InteractEvent")
if not InteractEvent then
	InteractEvent = Instance.new("RemoteEvent")
	InteractEvent.Name = "InteractEvent"
	InteractEvent.Parent = ReplicatedStorage
end

local InteractionResponseEvent = ReplicatedStorage:FindFirstChild("InteractionResponse")
if not InteractionResponseEvent then
	InteractionResponseEvent = Instance.new("RemoteEvent")
	InteractionResponseEvent.Name = "InteractionResponse"
	InteractionResponseEvent.Parent = ReplicatedStorage
end

-- 宝箱を開ける処理
local function handleChestInteraction(player, chestObject)
	print("[InteractionSystem DEBUG] ステップ1: 開始")

	local chestId = chestObject:GetAttribute("ChestId")
	if not chestId then
		warn("[InteractionSystem] ChestIdが設定されていません")
		return false
	end

	print("[InteractionSystem DEBUG] ステップ2: ChestId取得 =", chestId)

	-- プレイヤーのステータスを取得
	local stats = PlayerStatsModule.getStats(player)
	if not stats then
		warn(("[InteractionSystem] %s のステータスが見つかりません"):format(player.Name))
		return false
	end

	print("[InteractionSystem DEBUG] ステップ3: ステータス取得完了")

	-- 既に取得済みかチェック
	if stats.CollectedItems[chestId] then
		print(("[InteractionSystem] %s は既に %s を取得済み"):format(player.Name, chestId))
		return false
	end

	print("[InteractionSystem DEBUG] ステップ4: 未取得確認完了")

	-- 距離チェック（不正防止）
	local character = player.Character
	if not character then
		warn("[InteractionSystem DEBUG] キャラクターなし")
		return false
	end

	local hrp = character:FindFirstChild("HumanoidRootPart")
	if not hrp then
		warn("[InteractionSystem DEBUG] HRPなし")
		return false
	end

	print("[InteractionSystem DEBUG] ステップ5: キャラクター確認完了")

	local distance = (hrp.Position - chestObject.Position).Magnitude
	local range = chestObject:GetAttribute("InteractionRange") or 8

	if distance > range + 5 then
		warn(("[InteractionSystem] %s が遠すぎます: %.1f > %d"):format(player.Name, distance, range))
		return false
	end

	print("[InteractionSystem DEBUG] ステップ6: 距離チェック完了")
	print(("[InteractionSystem] %s が %s を開けます"):format(player.Name, chestId))

	-- 報酬データを取得
	local rewardsJson = chestObject:GetAttribute("RewardsData")
	print("[InteractionSystem DEBUG] ステップ7: RewardsData =", rewardsJson)

	local rewards = {}
	if rewardsJson then
		local success, decoded = pcall(function()
			return HttpService:JSONDecode(rewardsJson)
		end)
		if success then
			rewards = decoded
			print("[InteractionSystem DEBUG] ステップ8: 報酬デコード成功")
		else
			warn("[InteractionSystem DEBUG] ステップ8: 報酬デコード失敗")
		end
	end

	-- 報酬を付与
	for _, reward in ipairs(rewards) do
		if reward.item == "ゴールド" then
			stats.Gold = stats.Gold + reward.count
			print(("[InteractionSystem] %s にゴールド %d を付与"):format(player.Name, reward.count))
		else
			-- 将来的にアイテムシステムと連携
			print(("[InteractionSystem] %s に %s x%d を付与（未実装）"):format(
				player.Name, reward.item, reward.count
			))
		end
	end

	print("[InteractionSystem DEBUG] ステップ9: 報酬付与完了")

	-- 取得済みに設定
	stats.CollectedItems[chestId] = true

	-- セーブ（即座に保存）
	if _G.AutoSavePlayer then
		_G.AutoSavePlayer(player, "宝箱取得")
	end

	print("[InteractionSystem DEBUG] ステップ10: セーブ完了")

	-- モデルを開いた状態に切り替え
	local openedModelName = chestObject:GetAttribute("OpenedModel")
	if openedModelName then
		print("[InteractionSystem DEBUG] ステップ11: モデル切り替え開始")
		task.spawn(function()
			local ServerStorage = game:GetService("ServerStorage")
			local fieldObjectsFolder = ServerStorage:FindFirstChild("FieldObjects")
			if fieldObjectsFolder then
				local openedTemplate = fieldObjectsFolder:FindFirstChild(openedModelName)
				if openedTemplate then
					-- 閉じた宝箱を非表示
					chestObject.Transparency = 1
					for _, child in ipairs(chestObject:GetDescendants()) do
						if child:IsA("BasePart") then
							child.Transparency = 1
						end
					end

					-- 開いた宝箱を配置
					local openedChest = openedTemplate:Clone()
					openedChest.CFrame = chestObject.CFrame
					openedChest.Anchored = true
					openedChest.CanCollide = false
					openedChest.Parent = chestObject.Parent

					print("[InteractionSystem DEBUG] 開いた宝箱を配置")

					-- 表示時間後に削除
					local duration = chestObject:GetAttribute("DisplayDuration") or 3
					task.wait(duration)

					openedChest:Destroy()
					chestObject:Destroy()

					print(("[InteractionSystem] %s を削除しました"):format(chestId))
				else
					warn("[InteractionSystem DEBUG] 開いたモデルが見つかりません:", openedModelName)
				end
			else
				warn("[InteractionSystem DEBUG] FieldObjectsフォルダが見つかりません")
			end
		end)
	end

	print("[InteractionSystem DEBUG] ステップ12: クライアント送信準備")

	-- クライアントに報酬情報を送信
	local responseData = {
		success = true,
		type = "chest",
		rewards = rewards,
		displayDuration = chestObject:GetAttribute("DisplayDuration") or 3,
	}

	print(("[InteractionSystem DEBUG] 送信データ: %s"):format(HttpService:JSONEncode(responseData)))

	InteractionResponseEvent:FireClient(player, responseData)

	print("[InteractionSystem DEBUG] ステップ13: 送信完了")

	return true
end

-- インタラクション処理のルーティング
local function handleInteraction(player, object)
	print("[InteractionSystem DEBUG] handleInteraction呼び出し")

	if not object or not object:IsA("BasePart") then
		warn("[InteractionSystem DEBUG] オブジェクトが無効")
		return
	end

	print("[InteractionSystem DEBUG] オブジェクト:", object.Name)

	local interactionType = object:GetAttribute("InteractionType")
	print("[InteractionSystem DEBUG] InteractionType:", interactionType)

	if interactionType == "chest" then
		handleChestInteraction(player, object)
	elseif interactionType == "npc" then
		-- 将来的にNPC処理
		print("[InteractionSystem] NPC処理は未実装")
	else
		warn(("[InteractionSystem] 未知のインタラクションタイプ: %s"):format(tostring(interactionType)))
	end
end

-- イベント接続
InteractEvent.OnServerEvent:Connect(function(player, object)
	print("[InteractionSystem DEBUG] InteractEvent受信")
	handleInteraction(player, object)
end)

-- 取得済みアイテムリストを返すRemoteFunction
local GetCollectedItemsFunc = ReplicatedStorage:FindFirstChild("GetCollectedItems")
if not GetCollectedItemsFunc then
	GetCollectedItemsFunc = Instance.new("RemoteFunction")
	GetCollectedItemsFunc.Name = "GetCollectedItems"
	GetCollectedItemsFunc.Parent = ReplicatedStorage
end

GetCollectedItemsFunc.OnServerInvoke = function(player)
	local stats = PlayerStatsModule.getStats(player)
	if stats and stats.CollectedItems then
		print(("[InteractionSystem] %s の取得済みリストを送信: %d個"):format(
			player.Name,
			next(stats.CollectedItems) and #stats.CollectedItems or 0
		))
		return stats.CollectedItems
	end
	return {}
end

print("[InteractionSystem] 初期化完了")
===== ./ServerScriptService/DebugCommands.server.lua =====
-- ServerScriptService/DebugCommands.server.lua
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")

print("[DebugCommands] 初期化開始")

-- デバッグモード（本番環境ではfalseに）
local DEBUG_MODE = true

if not DEBUG_MODE then
	print("[DebugCommands] デバッグモードOFF")
	return
end

-- 【修正】RemoteEventを必ず作成
local DebugCommandEvent = Instance.new("RemoteEvent")
DebugCommandEvent.Name = "DebugCommand"
DebugCommandEvent.Parent = ReplicatedStorage
print("[DebugCommands] RemoteEventを作成しました")

-- 依存モジュール
local PlayerStatsModule = require(ServerScriptService:WaitForChild("PlayerStats"))

-- コマンド処理
DebugCommandEvent.OnServerEvent:Connect(function(player, command, ...)
	print(("[DebugCommands] %s が実行: %s"):format(player.Name, command))

	if command == "reset_chests" then
		-- 宝箱リセット
		print("[DebugCommands DEBUG] リセット開始")

		local stats = PlayerStatsModule.getStats(player)
		if stats then
			print("[DebugCommands DEBUG] ステータス取得成功")

			-- リセット前の状態
			local beforeCount = 0
			for _ in pairs(stats.CollectedItems) do beforeCount = beforeCount + 1 end
			print(("[DebugCommands DEBUG] リセット前: %d個"):format(beforeCount))

			-- CollectedItemsを空にする
			stats.CollectedItems = {}

			-- リセット後の状態
			local afterCount = 0
			for _ in pairs(stats.CollectedItems) do afterCount = afterCount + 1 end
			print(("[DebugCommands DEBUG] リセット後: %d個"):format(afterCount))

			print(("[DebugCommands] %s の取得済みアイテムをリセットしました"):format(player.Name))

			-- 即座にセーブ
			if _G.AutoSavePlayer then
				print("[DebugCommands DEBUG] セーブ開始")
				_G.AutoSavePlayer(player, "デバッグリセット")
				task.wait(2)
				print("[DebugCommands DEBUG] セーブ完了")
			else
				warn("[DebugCommands DEBUG] AutoSavePlayer が見つかりません - 手動セーブを試行")

				-- 【修正】手動セーブ
				local success, err = pcall(function()
					local DataStoreManager = require(ServerScriptService:WaitForChild("DataStoreManager"))
					local DataCollectors = require(ServerScriptService:WaitForChild("DataCollectors"))

					-- statsを使ってセーブデータを作成
					local saveData = DataCollectors.createSaveData(player, stats)

					if saveData then
						print(("[DebugCommands DEBUG] セーブデータ作成成功: CollectedItems = %s"):format(
							game:GetService("HttpService"):JSONEncode(saveData.CollectedItems or {})
						))

						DataStoreManager.SavePlayerData(player, saveData)
						print("[DebugCommands DEBUG] 手動セーブ完了")
					else
						warn("[DebugCommands DEBUG] セーブデータ作成失敗")
					end
				end)

				if not success then
					warn(("[DebugCommands DEBUG] 手動セーブエラー: %s"):format(tostring(err)))
				end
			end
		else
			warn(("[DebugCommands] %s のステータスが見つかりません"):format(player.Name))
		end
	else
		warn(("[DebugCommands] 未知のコマンド: %s"):format(command))
	end
end)

print("[DebugCommands] 初期化完了")
===== ./ServerScriptService/DataStoreManager.lua =====
-- ServerScriptService/DataStoreManager.lua
-- DataStoreの基本操作を管理するモジュール

local DataStoreService = game:GetService("DataStoreService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local DataStoreManager = {}

-- DataStoreの定義 (バージョン管理のためV1)
local PLAYER_DATA_STORE = DataStoreService:GetDataStore("TypingQuestPlayerSaveData_V1")

-- ★修正: WaitForChildを廃止し、非ブロッキングのFindFirstChildを使用
local SAVE_SUCCESS_EVENT = ReplicatedStorage:FindFirstChild("SaveSuccess")
local LOAD_GAME_EVENT = ReplicatedStorage:FindFirstChild("LoadGame")

-- DataStoreサービス取得
local success, DataStoreService = pcall(function()
	return game:GetService("DataStoreService")
end)

if not success then
	warn("[DataStoreManager] DataStoreが無効です。Studio設定で有効化してください。")
	-- ダミーのDataStoreを返す
	return {
		SavePlayerData = function() warn("[DataStore] 保存スキップ（無効）") end,
		LoadPlayerData = function() warn("[DataStore] 読込スキップ（無効）") return nil end,
	}
else
	print("[DataStoreManager] ✅ DataStore設定: 有効")
end

local PlayerDataStore = DataStoreService:GetDataStore("PlayerData_v1")

-- データの保存 (非同期)
function DataStoreManager.SaveData(player: Player, data: table)
    local success, err = pcall(function()
        -- プレイヤーのUserIdをキーとして使用
        PLAYER_DATA_STORE:SetAsync(player.UserId, data)
    end)

    -- 【修正】毎回SaveSuccessEventを取得
    local SaveSuccessEvent = ReplicatedStorage:FindFirstChild("SaveSuccess")

    if success then
        print(("[DataStoreManager] %s のデータを保存しました。キー: %d"):format(player.Name, player.UserId))

        -- クライアントに保存成功を通知
        if SaveSuccessEvent then
            SaveSuccessEvent:FireClient(player, true)
        end
    else
        warn(("[DataStoreManager] %s のデータ保存に失敗しました: %s"):format(player.Name, err))

        -- クライアントに保存失敗を通知
        if SaveSuccessEvent then
            SaveSuccessEvent:FireClient(player, false)
        end
    end
    return success
end

-- データの読み込み (非同期)
function DataStoreManager.LoadData(player: Player)
    local data = nil
    local success, err = pcall(function()
        -- データの取得 (確実にUserIdを使用)
        data = PLAYER_DATA_STORE:GetAsync(player.UserId)
    end)

    if success then
        print(("[DataStoreManager] %s のデータを読み込みました。キー: %d"):format(player.Name, player.UserId))

        -- データがnilの場合、新規プレイヤーとして空のテーブルを返す
        return data or {}
    else
        warn(("[DataStoreManager] %s のデータ読み込みに失敗しました: %s"):format(player.Name, err))
        return {} -- 失敗した場合は空のデータを返し、ゲームを継続させる
    end
end

-- 手動ロード要求イベントリスナー (ロードボタン押下時)
if LOAD_GAME_EVENT then
    LOAD_GAME_EVENT.OnServerEvent:Connect(function(player)
        -- 現状、特別な処理は不要（次の接続時に自動ロードされるため）
        print(("[DataStoreManager] %s からロード要求を受信しました。"):format(player.Name))
    end)
else
    warn("[DataStoreManager] LOAD_GAME_EVENT が見つかりません。ロード要求リスナーは機能しません。")
end

return DataStoreManager
===== ./ServerScriptService/BattleSystem.lua =====
-- ServerScriptService/BattleSystem.lua
-- バトルシステムの管理（敵の定期攻撃対応版）
-- ステップ4: SharedState統合版

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")

-- 【ステップ4】SharedStateとGameEventsをロード
local SharedState = require(ReplicatedStorage:WaitForChild("SharedState"))
local GameEvents = require(ReplicatedStorage:WaitForChild("GameEvents"))

local BattleSystem = {}

-- PlayerStatsモジュールをロード
local PlayerStats = require(ServerScriptService:WaitForChild("PlayerStats"))

-- 【ステップ4】グローバル変数をSharedStateに移行
-- SharedState.ActiveBattles = {}  -- 既にSharedStateで定義済み
-- SharedState.GlobalBattleActive = false  -- 追加が必要
-- SharedState.EndingBattles = {}  -- 追加が必要
-- SharedState.DefeatedByMonster = {}  -- 追加が必要

-- 初期化（SharedStateに追加のフィールドを設定）
if not SharedState.GlobalBattleActive then
	SharedState.GlobalBattleActive = false
end
if not SharedState.EndingBattles then
	SharedState.EndingBattles = {}
end
if not SharedState.DefeatedByMonster then
	SharedState.DefeatedByMonster = {}
end

-- バトル終了直後のクールダウン
local LastBattleEndTime = 0
local BATTLE_COOLDOWN = 0.5

-- RemoteEvent の作成/取得
local function getOrCreateRemoteEvent(name)
	local event = ReplicatedStorage:FindFirstChild(name)
	if not event then
		event = Instance.new("RemoteEvent")
		event.Name = name
		event.Parent = ReplicatedStorage
		-- print(("[BattleSystem] RemoteEvent作成: %s"):format(name))
	end
	return event
end

-- RemoteEventsを作成
local BattleStartEvent = getOrCreateRemoteEvent("BattleStart")
local BattleEndEvent = getOrCreateRemoteEvent("BattleEnd")
local BattleVictoryEvent = getOrCreateRemoteEvent("BattleVictory")
local BattleDamageEvent = getOrCreateRemoteEvent("BattleDamage")
local BattleHPUpdateEvent = getOrCreateRemoteEvent("BattleHPUpdate")
local PlayerHPUpdateEvent = getOrCreateRemoteEvent("PlayerHPUpdate")
local StatusUpdateEvent = getOrCreateRemoteEvent("StatusUpdate")
local RequestStatusEvent = getOrCreateRemoteEvent("RequestStatus")
local LevelUpEvent = getOrCreateRemoteEvent("LevelUp")
local ShowDeathUIEvent = getOrCreateRemoteEvent("ShowDeathUI")
local DeathChoiceEvent = getOrCreateRemoteEvent("DeathChoice")
local TypingMistakeEvent = getOrCreateRemoteEvent("TypingMistake")

print("[BattleSystem] RemoteEvents準備完了")

-- モンスター定義を取得
local MonstersRegistry = require(ReplicatedStorage:WaitForChild("Monsters"):WaitForChild("Registry"))

-- プレイヤーのステータスをクライアントに送信
local function sendStatusUpdate(player: Player)
	local stats = PlayerStats.getStats(player)
	if not stats then return end

	local expToNext = stats.Level * 100  -- レベルアップに必要な経験値

	StatusUpdateEvent:FireClient(
		player,
		stats.CurrentHP,
		stats.MaxHP,
		stats.Level,
		stats.Experience,
		expToNext,
		stats.Gold
	)
end

-- プレイヤーが戦闘中かチェック
function BattleSystem.isInBattle(player: Player): boolean
	return SharedState.ActiveBattles[player] ~= nil
end

-- グローバルなバトル状態を取得
function BattleSystem.isAnyBattleActive(): boolean
	return SharedState.GlobalBattleActive
end

-- モンスター定義を名前から取得
local function getMonsterDef(monsterName)
	for _, def in ipairs(MonstersRegistry) do
		if def.Name == monsterName then
			return def
		end
	end
	return nil
end

-- ダメージを計算（敵→プレイヤー）
local function calculateDamage(attackerAttack: number, defenderDefense: number): number
	-- 基本ダメージ = 攻撃力 * 0.5 - 守備力 * 0.25
	local baseDamage = attackerAttack * 0.5 - defenderDefense * 0.25
	baseDamage = math.max(1, baseDamage)  -- 最低1ダメージ

	-- ±10%のランダム幅
	local randomMultiplier = 0.9 + math.random() * 0.2  -- 0.9 ~ 1.1
	local finalDamage = baseDamage * randomMultiplier

	return math.floor(finalDamage)  -- 整数に丸める
end

-- 攻撃間隔を計算
local function calculateAttackInterval(playerSpeed: number, enemySpeed: number): number
	-- 攻撃間隔 = 1 + (プレイヤー素早さ / 敵素早さ - 1) * 0.5
	local interval = 1 + (playerSpeed / enemySpeed - 1) * 0.5
	return math.max(0.5, interval)  -- 最低0.5秒
end

-- 敵の攻撃処理
local function enemyAttack(player: Player, battleData)
	if not SharedState.ActiveBattles[player] or SharedState.EndingBattles[player] then
		return  -- バトル終了済み
	end

	local monsterDef = battleData.monsterDef
	local playerStats = PlayerStats.getStats(player)

	if not playerStats then
		warn(("[BattleSystem] %s のステータスが見つかりません"):format(player.Name))
		return
	end

	-- ダメージ計算
	local damage = calculateDamage(monsterDef.Attack, playerStats.Defense)

	print(("[BattleSystem] %s が %s から %d ダメージを受けた"):format(
		player.Name, battleData.monster.Name, damage
		))

	-- プレイヤーにダメージ
	local isDead = PlayerStats.takeDamage(player, damage)

	-- HPをクライアントに通知
	PlayerHPUpdateEvent:FireClient(player, playerStats.CurrentHP, playerStats.MaxHP)

	-- 死亡判定
	if isDead then
		print(("[BattleSystem] %s は倒れた！"):format(player.Name))
		BattleSystem.endBattle(player, false)  -- 敗北
		return
	end

	-- 次の攻撃をスケジュール
	local attackInterval = calculateAttackInterval(playerStats.Speed, monsterDef.Speed)
	battleData.nextAttackTime = tick() + attackInterval

	print(("[BattleSystem] 次の攻撃まで %.1f 秒"):format(attackInterval))
end

-- バトル開始
function BattleSystem.startBattle(player: Player, monster: Model)
	print(("[BattleSystem] startBattle呼び出し: %s vs %s"):format(player.Name, monster.Name))

	-- クールダウンチェック
	local timeSinceLastBattle = tick() - LastBattleEndTime
	if timeSinceLastBattle < BATTLE_COOLDOWN then
		return false
	end

	-- 二重チェック
	if SharedState.GlobalBattleActive then
		return false
	end

	if BattleSystem.isInBattle(player) then
		return false
	end

	-- 終了処理中チェック
	if SharedState.EndingBattles[player] then
		print(("[BattleSystem] %s は終了処理中です"):format(player.Name))
		return false
	end

	local character = player.Character
	if not character then
		return false
	end

	local humanoid = character:FindFirstChildOfClass("Humanoid")
	local hrp = character:FindFirstChild("HumanoidRootPart")
	local monsterHumanoid = monster:FindFirstChildOfClass("Humanoid")
	local monsterHrp = monster.PrimaryPart

	if not humanoid or not hrp or not monsterHumanoid or not monsterHrp then
		return false
	end

	-- モンスターの種類を取得
	local monsterKind = monster:GetAttribute("MonsterKind") or "Unknown"
	local monsterDef = getMonsterDef(monsterKind)

	if not monsterDef then
		warn(("[BattleSystem] モンスター定義が見つかりません: %s"):format(monsterKind))
		return false
	end

	-- プレイヤーステータスを取得
	local playerStats = PlayerStats.getStats(player)
	if not playerStats then
		warn(("[BattleSystem] %s のステータスが見つかりません"):format(player.Name))
		return false
	end

	print(("[BattleSystem] バトル開始: %s vs %s"):format(player.Name, monster.Name))
	print(("  プレイヤー: HP %d/%d, 素早さ %d, 攻撃 %d, 守備 %d"):format(
		playerStats.CurrentHP, playerStats.MaxHP,
		playerStats.Speed, playerStats.Attack, playerStats.Defense
		))
	print(("  モンスター: HP %d, 素早さ %d, 攻撃 %d, 守備 %d"):format(
		monsterDef.HP, monsterDef.Speed, monsterDef.Attack, monsterDef.Defense
		))

	-- グローバルバトルフラグをON
	SharedState.GlobalBattleActive = true

	-- 元の速度を保存
	local originalPlayerSpeed = humanoid.WalkSpeed
	local originalJumpPower = humanoid.JumpPower
	local originalMonsterSpeed = monsterHumanoid.WalkSpeed

	-- プレイヤーを完全停止
	humanoid.WalkSpeed = 0
	humanoid.JumpPower = 0
	humanoid.JumpHeight = 0

	-- アニメーションを完全停止
	for _, track in pairs(humanoid:GetPlayingAnimationTracks()) do
		track:Stop(0)
	end

	humanoid:ChangeState(Enum.HumanoidStateType.Physics)
	task.wait(0.05)
	humanoid:ChangeState(Enum.HumanoidStateType.Running)
	hrp.Anchored = true
	hrp.AssemblyLinearVelocity = Vector3.zero
	hrp.AssemblyAngularVelocity = Vector3.zero

	-- モンスターを完全停止
	monsterHumanoid.WalkSpeed = 0
	monsterHumanoid.JumpPower = 0
	monsterHumanoid:MoveTo(monsterHrp.Position)

	-- モンスターの全パーツをAnchor
	for _, part in ipairs(monster:GetDescendants()) do
		if part:IsA("BasePart") then
			part.Anchored = true
		end
	end

	-- プレイヤーの1文字あたりのダメージを計算
	local damagePerKey = math.floor(playerStats.Attack * 0.8)
	damagePerKey = math.max(1, damagePerKey)  -- 最低1ダメージ

	-- 敵の最初の攻撃タイミングを計算
	local attackInterval = calculateAttackInterval(playerStats.Speed, monsterDef.Speed)
	local nextAttackTime = tick() + attackInterval

	-- 戦闘データを記録
	SharedState.ActiveBattles[player] = {
		monster = monster,
		monsterDef = monsterDef,
		monsterHP = monsterDef.HP,
		monsterMaxHP = monsterDef.HP,
		damagePerKey = damagePerKey,
		nextAttackTime = nextAttackTime,
		startTime = tick(),
		originalPlayerSpeed = originalPlayerSpeed,
		originalJumpPower = originalJumpPower,
		originalMonsterSpeed = originalMonsterSpeed
	}

	-- クライアントにバトル開始を通知
	BattleStartEvent:FireClient(
		player,
		monster.Name,
		monsterDef.HP,
		monsterDef.HP,
		damagePerKey,
		monsterDef.TypingLevels or {{level = "level_1", weight = 100}},
		playerStats.CurrentHP,
		playerStats.MaxHP
	)

	-- 敵の攻撃ループを開始
	task.spawn(function()
		while SharedState.ActiveBattles[player] and not SharedState.EndingBattles[player] do
			local battleData = SharedState.ActiveBattles[player]
			if not battleData then break end

			-- 攻撃タイミングをチェック
			if tick() >= battleData.nextAttackTime then
				enemyAttack(player, battleData)
			end

			task.wait(0.1)  -- 0.1秒ごとにチェック
		end
	end)

	return true
end

-- プレイヤーからのダメージ処理
local function onDamageReceived(player, damageAmount)
	-- バトル終了処理中はダメージを無視
	if SharedState.EndingBattles[player] then
		print(("[BattleSystem] %s は終了処理中のため、ダメージを無視"):format(player.Name))
		return
	end

	local battleData = SharedState.ActiveBattles[player]
	if not battleData then
		warn(("[BattleSystem] %s はバトル中ではありません（ダメージ無視）"):format(player.Name))
		return
	end

	-- HPを減らす
	local oldHP = battleData.monsterHP
	battleData.monsterHP = math.max(0, battleData.monsterHP - damageAmount)

	print(("[BattleSystem] ========================================"):format())
	print(("[BattleSystem] ダメージ処理"):format())
	print(("  プレイヤー: %s"):format(player.Name))
	print(("  ダメージ量: %d"):format(damageAmount))
	print(("  HP変化: %d → %d"):format(oldHP, battleData.monsterHP))
	print(("  最大HP: %d"):format(battleData.monsterMaxHP))
	print(("[BattleSystem] ========================================"):format())

	-- クライアントにHP更新を通知
	BattleHPUpdateEvent:FireClient(player, battleData.monsterHP)

	-- HPが0になったら勝利
	if battleData.monsterHP <= 0 then
		print(("[BattleSystem] ========================================"):format())
		print(("[BattleSystem] 🎉 勝利条件達成！"):format())
		print(("  %s が %s を倒しました！"):format(player.Name, battleData.monster.Name))
		print(("  モンスターHP: %d"):format(battleData.monsterHP))
		print(("[BattleSystem] endBattle(true) を呼び出します"):format())
		print(("[BattleSystem] ========================================"):format())

		BattleSystem.endBattle(player, true)

		print(("[BattleSystem] endBattle(true) 呼び出し完了"):format())
	end
end

-- バトル終了
function BattleSystem.endBattle(player: Player, victory: boolean)
	print(("[BattleSystem] バトル終了: %s - %s"):format(
		player.Name, victory and "勝利" or "敗北"
		))

	-- 二重終了チェック
	if SharedState.EndingBattles[player] then
		warn(("[BattleSystem] %s は既に終了処理中です"):format(player.Name))
		return
	end

	-- 終了処理中フラグを立てる
	SharedState.EndingBattles[player] = true

	-- 【重要】勝利時のみグローバルバトルフラグをOFF
	-- 敗北時は死亡選択が完了するまで維持
	if victory then
		SharedState.GlobalBattleActive = false
	end

	-- クールダウン開始
	LastBattleEndTime = tick()

	local battleData = SharedState.ActiveBattles[player]
	if not battleData then
		warn("[BattleSystem] battleDataが存在しません！")

		-- 最低限の復元
		local character = player.Character
		if character then
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			local hrp = character:FindFirstChild("HumanoidRootPart")
			if humanoid then
				humanoid.WalkSpeed = 16
				humanoid.JumpPower = 50
				humanoid.JumpHeight = 7.2
			end
			if hrp then
				hrp.Anchored = false
			end
		end

		BattleEndEvent:FireClient(player, victory)
		SharedState.ActiveBattles[player] = nil

		-- 終了処理完了後にフラグを解除
		task.delay(1, function()
			SharedState.EndingBattles[player] = nil
		end)

		return
	end

	local character = player.Character
	local monster = battleData.monster
	local monsterDef = battleData.monsterDef

	-- 勝利時の処理
	if victory then
		-- プレイヤーの移動を復元
		if character then
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			local hrp = character:FindFirstChild("HumanoidRootPart")
			if humanoid then
				humanoid.WalkSpeed = battleData.originalPlayerSpeed or 16
				humanoid.JumpPower = battleData.originalJumpPower or 50
				humanoid.JumpHeight = 7.2
			end
			if hrp then
				hrp.Anchored = false
			end
		end

		-- 経験値とゴールドを付与
		if monsterDef.Experience then
			print(("[BattleSystem] 経験値 %d を付与"):format(monsterDef.Experience))
			PlayerStats.addExperience(player, monsterDef.Experience)
		end
		if monsterDef.Gold then
			print(("[BattleSystem] ゴールド %d を付与"):format(monsterDef.Gold))
			PlayerStats.addGold(player, monsterDef.Gold)
		end

		print(("[BattleSystem] ========================================"):format())
		print(("[BattleSystem] モンスター撃破カウント処理開始"):format())
		print(("[BattleSystem] プレイヤー: %s"):format(player.Name))
		print(("[BattleSystem] モンスター: %s"):format(battleData.monster.Name))


		PlayerStats.addMonstersDefeated(player, 1)

		print(("[BattleSystem] モンスター撃破カウント処理完了"):format())
		print(("[BattleSystem] ========================================"):format())


		-- 少し待ってからステータス更新を送信（念のため）
		task.wait(0.1)
		sendStatusUpdate(player)

		-- モンスターを非表示
		monster:SetAttribute("Defeated", true)

		for _, part in ipairs(monster:GetDescendants()) do
			if part:IsA("BasePart") then
				part.Transparency = 1
			end
		end

		local hrp = monster:FindFirstChild("HumanoidRootPart")
		if hrp then
			local gui = hrp:FindFirstChild("DebugInfo")
			if gui then
				gui.Enabled = false
			end
		end

		-- 1秒後に削除
		task.delay(1, function()
			if monster and monster.Parent then
				monster:Destroy()
			end
		end)
	else
		-- 敗北時：プレイヤーは移動制限を維持（死亡選択UIで選んだ後に復元）
		-- モンスターを復元
		monster:SetAttribute("InBattle", false)

		local monsterHumanoid = monster:FindFirstChildOfClass("Humanoid")
		if monsterHumanoid then
			monsterHumanoid.WalkSpeed = battleData.originalMonsterSpeed or 14
		end

		-- Anchor解除
		local partsToUnanchor = {}
		for _, part in ipairs(monster:GetDescendants()) do
			if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
				table.insert(partsToUnanchor, part)
			end
		end

		for _, part in ipairs(partsToUnanchor) do
			part.Anchored = false
		end

		if monster.PrimaryPart then
			task.wait(0.1)
			monster.PrimaryPart.Anchored = false
		end

		-- 死亡時の選択UIを表示
		local playerStats = PlayerStats.getStats(player)
		if playerStats then
			local reviveCost = math.floor(playerStats.Level * 50)  -- レベル * 50ゴールド
			print(("[BattleSystem] ========================================"):format())
			print(("[BattleSystem] 死亡UI表示を送信"):format())
			print(("[BattleSystem] 所持金: %d G, 復活コスト: %d G"):format(playerStats.Gold, reviveCost))
			print(("[BattleSystem] ========================================"):format())

			-- プレイヤーに死亡フラグを立てる（モンスターが接触しないように）
			if character then
				character:SetAttribute("IsDead", true)
				print(("[BattleSystem] %s に死亡フラグを設定"):format(player.Name))
			end

			-- 【重要】倒したモンスターを記録（選択後に消去するため）
			SharedState.DefeatedByMonster[player] = monster
			print(("[BattleSystem] 倒したモンスター %s を記録"):format(monster.Name))

			ShowDeathUIEvent:FireClient(player, playerStats.Gold, reviveCost)
		else
			warn("[BattleSystem] プレイヤーステータスが見つかりません！")
		end
	end

	-- クライアントに通知
	BattleEndEvent:FireClient(player, victory)

	-- 勝利時は戦闘データをクリアして終了処理フラグも解除
	if victory then
		SharedState.ActiveBattles[player] = nil

		-- 終了処理完了後にフラグを解除（1秒後）
		task.delay(1, function()
			SharedState.EndingBattles[player] = nil
			print(("[BattleSystem] %s の終了処理フラグを解除"):format(player.Name))
		end)
	else
		-- 敗北時は戦闘データをクリアするが、終了処理フラグは維持
		-- （死亡選択UIで選んだ後に解除する）
		SharedState.ActiveBattles[player] = nil
		print(("[BattleSystem] 敗北 - 終了処理フラグを維持します（選択まで）"))
	end
end

-- 初期化
function BattleSystem.init()
	-- ステータスリクエストイベント
	RequestStatusEvent.OnServerEvent:Connect(function(player)
		print(("[BattleSystem] %s がステータスを要求しました"):format(player.Name))
		sendStatusUpdate(player)
	end)

	-- ダメージイベント
	BattleDamageEvent.OnServerEvent:Connect(function(player, damageAmount)
		print(("[BattleSystem] ダメージ通知受信: %s -> %d"):format(player.Name, damageAmount))
		onDamageReceived(player, damageAmount)
	end)

	-- 勝利イベント（念のため残しておく）
	BattleVictoryEvent.OnServerEvent:Connect(function(player)
		print(("[BattleSystem] 勝利通知受信: %s"):format(player.Name))

		if BattleSystem.isInBattle(player) then
			BattleSystem.endBattle(player, true)
		end
	end)

	-- 死亡時の選択イベント
	DeathChoiceEvent.OnServerEvent:Connect(function(player, choice)
		print(("[BattleSystem] %s が選択: %s"):format(player.Name, choice))

		-- 【重要】グローバルバトルフラグを解除（敗北時に維持していた）
		SharedState.GlobalBattleActive = false
		print("[BattleSystem] グローバルバトルフラグを解除")

		-- 【重要】終了処理フラグを解除（モンスターが接触できるようにする）
		SharedState.EndingBattles[player] = nil
		print(("[BattleSystem] %s の終了処理フラグを解除"):format(player.Name))

		local playerStats = PlayerStats.getStats(player)
		if not playerStats then return end

		-- 死亡フラグを解除
		local character = player.Character
		if character then
			character:SetAttribute("IsDead", false)
			print(("[BattleSystem] %s の死亡フラグを解除"):format(player.Name))
		end

		-- プレイヤーの移動制限を解除
		if character then
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			local hrp = character:FindFirstChild("HumanoidRootPart")
			if humanoid then
				humanoid.WalkSpeed = 16
				humanoid.JumpPower = 50
				humanoid.JumpHeight = 7.2
			end
			if hrp then
				hrp.Anchored = false
			end
		end

		-- 【重要】倒したモンスターを消去（両方の選択肢で消去）
		local defeatedMonster = SharedState.DefeatedByMonster[player]
		if defeatedMonster and defeatedMonster.Parent then
			print(("[BattleSystem] 倒したモンスター %s を消去"):format(defeatedMonster.Name))

			-- 非表示化
			defeatedMonster:SetAttribute("Defeated", true)
			for _, part in ipairs(defeatedMonster:GetDescendants()) do
				if part:IsA("BasePart") then
					part.Transparency = 1
				end
			end

			-- ラベル非表示
			local hrp = defeatedMonster:FindFirstChild("HumanoidRootPart")
			if hrp then
				local gui = hrp:FindFirstChild("DebugInfo")
				if gui then
					gui.Enabled = false
				end
			end

			-- 削除
			task.delay(0.5, function()
				if defeatedMonster and defeatedMonster.Parent then
					defeatedMonster:Destroy()
				end
			end)
		end

		-- 記録をクリア
		SharedState.DefeatedByMonster[player] = nil

		if choice == "return" then
			-- 街に戻る
			print(("[BattleSystem] %s を街に戻します"):format(player.Name))

			-- HPを全回復
			PlayerStats.fullHeal(player)

			-- StartTownの座標を取得
			print("[BattleSystem] StartTownの座標を取得中...")
			local IslandsRegistry = require(ReplicatedStorage:WaitForChild("Islands"):WaitForChild("Registry"))
			print(("[BattleSystem] IslandsRegistry取得完了。島の数: %d"):format(#IslandsRegistry))

			local townConfig = nil
			for i, island in ipairs(IslandsRegistry) do
				print(("[BattleSystem] 島 %d: name=%s"):format(i, tostring(island.name)))
				if island.name == "StartTown" then
					townConfig = island
					print("[BattleSystem] StartTownを発見！")
					break
				end
			end

			-- 街にテレポート
			if character and townConfig then
				local hrp = character:FindFirstChild("HumanoidRootPart")
				if hrp then
					local spawnX = townConfig.centerX
					local spawnZ = townConfig.centerZ
					local spawnY = townConfig.baseY + 50  -- 高めに設定
					print(("[BattleSystem] テレポート座標: X=%.0f, Y=%.0f, Z=%.0f"):format(
						spawnX, spawnY, spawnZ
						))

					-- テレポート実行
					hrp.CFrame = CFrame.new(spawnX, spawnY, spawnZ)

					-- 少し待ってから再度設定（他のシステムの干渉を防ぐ）
					task.wait(0.1)
					hrp.CFrame = CFrame.new(spawnX, spawnY, spawnZ)

					print(("[BattleSystem] %s を街にテレポート完了"):format(player.Name))

					-- ZoneManagerにも通知
					local ZoneManager = require(ServerScriptService:WaitForChild("ZoneManager"))
					ZoneManager.PlayerZones[player] = "StartTown"
					print("[BattleSystem] ZoneManagerにStartTownを記録")

					-- 【重要】StartTownのポータルを再生成
					if _G.CreatePortalsForZone then
						print("[BattleSystem] StartTownのポータルを再生成")
						_G.CreatePortalsForZone("StartTown")
					else
						warn("[BattleSystem] CreatePortalsForZone関数が見つかりません")
					end
				end
			elseif character then
				-- フォールバック：townConfigが見つからない場合
				warn("[BattleSystem] StartTownが見つかりません！")
				print("[BattleSystem] フォールバック：原点にテレポート")
				local hrp = character:FindFirstChild("HumanoidRootPart")
				if hrp then
					hrp.CFrame = CFrame.new(0, 50, 0)
				end
			end

			-- ステータス更新
			sendStatusUpdate(player)

		elseif choice == "revive" then
			-- ゴールドで復活
			local reviveCost = math.floor(playerStats.Level * 50)

			if PlayerStats.removeGold(player, reviveCost) then
				print(("[BattleSystem] %s がゴールド %d で復活"):format(player.Name, reviveCost))

				-- HPを全回復
				PlayerStats.fullHeal(player)

				-- 【重要】復活後のクールダウンを設定（3秒間バトル不可）
				LastBattleEndTime = tick()
				print("[BattleSystem] 復活後のクールダウン開始")

				-- ステータス更新
				sendStatusUpdate(player)
			else
				warn(("[BattleSystem] %s のゴールドが不足しています"):format(player.Name))
			end
		end
	end)

	-- ダメージイベント
	BattleDamageEvent.OnServerEvent:Connect(function(player, damageAmount)
		print(("[BattleSystem] ダメージ通知受信: %s -> %d"):format(player.Name, damageAmount))
		onDamageReceived(player, damageAmount)
	end)

	-- タイプミスイベント（新規追加）
	TypingMistakeEvent.OnServerEvent:Connect(function(player)
		print(("[BattleSystem] タイプミス受信: %s"):format(player.Name))

		local battleData = SharedState.ActiveBattles[player]
		if not battleData then
			warn(("[BattleSystem] %s はバトル中ではありません（タイプミス無視）"):format(player.Name))
			return
		end

		local monsterDef = battleData.monsterDef
		local playerStats = PlayerStats.getStats(player)

		if not playerStats then
			warn(("[BattleSystem] %s のステータスが見つかりません"):format(player.Name))
			return
		end

		-- タイプミスダメージ = 敵の通常攻撃の半分
		local normalDamage = calculateDamage(monsterDef.Attack, playerStats.Defense)
		local mistakeDamage = math.floor(normalDamage * 0.5)
		mistakeDamage = math.max(1, mistakeDamage)  -- 最低1ダメージ

		print(("[BattleSystem] %s がタイプミスで %d ダメージ"):format(player.Name, mistakeDamage))

		-- ダメージ処理
		local isDead = PlayerStats.takeDamage(player, mistakeDamage)

		-- HPをクライアントに通知
		PlayerHPUpdateEvent:FireClient(player, playerStats.CurrentHP, playerStats.MaxHP)

		-- 死亡判定
		if isDead then
			print(("[BattleSystem] %s はタイプミスで倒れた！"):format(player.Name))
			BattleSystem.endBattle(player, false)  -- 敗北
		end
	end)

	-- 勝利イベント（念のため残しておく）

	-- デッドロック検出
	task.spawn(function()
		while true do
			task.wait(5)

			for player, battleData in pairs(SharedState.ActiveBattles) do
				local duration = tick() - battleData.startTime

				if duration > 60 then
					warn(("[BattleSystem] デッドロック検出！ %s のバトルを強制終了"):format(player.Name))
					BattleSystem.endBattle(player, false)
				end
			end
		end
	end)

	print("[BattleSystem] 初期化完了（敵攻撃システム対応）")
end

-- バトル状態を強制リセット
function BattleSystem.resetAllBattles()
	print("[BattleSystem] 全バトル状態をリセット")

	SharedState.GlobalBattleActive = false

	for player, _ in pairs(SharedState.ActiveBattles) do
		SharedState.ActiveBattles[player] = nil
		SharedState.EndingBattles[player] = nil

		if player.Character then
			player.Character:SetAttribute("InBattle", false)

			local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
			local hrp = player.Character:FindFirstChild("HumanoidRootPart")
			if humanoid then
				humanoid.WalkSpeed = 16
				humanoid.JumpPower = 50
				humanoid.JumpHeight = 7.2
			end
			if hrp then
				hrp.Anchored = false
			end
		end
	end

	local monstersFolder = workspace:FindFirstChild("Monsters")
	if monstersFolder then
		for _, model in ipairs(monstersFolder:GetChildren()) do
			if model:IsA("Model") then
				model:SetAttribute("InBattle", false)
				model:SetAttribute("Defeated", false)
			end
		end
	end

	for _, model in ipairs(workspace:GetChildren()) do
		if model:IsA("Model") and model:GetAttribute("IsEnemy") then
			model:SetAttribute("InBattle", false)
			model:SetAttribute("Defeated", false)
		end
	end

	print("[BattleSystem] リセット完了")
end

return BattleSystem
===== ./ServerScriptService/MonsterSpawner.server.lua =====
-- ServerScriptService/MonsterSpawner.server.lua
-- ゾーン対応版モンスター配置システム（バトル高速化版、徘徊AI修正版）

local ServerStorage = game:GetService("ServerStorage")
local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local FieldGen = require(ReplicatedStorage:WaitForChild("FieldGen"))
local ZoneManager = require(script.Parent.ZoneManager)

local SharedState = require(ReplicatedStorage:WaitForChild("SharedState"))
local GameEvents = require(ReplicatedStorage:WaitForChild("GameEvents"))
local ContinentsRegistry = require(ReplicatedStorage.Continents.Registry)

-- BattleSystem読込（オプショナル）
local BattleSystem = nil
local battleSystemScript = script.Parent:FindFirstChild("BattleSystem")
if battleSystemScript then
	local success, result = pcall(function()
		return require(battleSystemScript)
	end)
	if success then
		BattleSystem = result
		print("[MonsterSpawner] BattleSystem読み込み成功")
	else
		warn("[MonsterSpawner] BattleSystem読み込み失敗:", result)
	end
else
	warn("[MonsterSpawner] BattleSystemが見つかりません - バトル機能は無効です")
end

-- Registry読込
local MonstersFolder = ReplicatedStorage:WaitForChild("Monsters")
local Registry = require(MonstersFolder:WaitForChild("Registry"))

-- 島の設定を読み込み
local IslandsRegistry = require(ReplicatedStorage.Islands.Registry)
local Islands = {}
for _, island in ipairs(IslandsRegistry) do
	Islands[island.name] = island
end

-- グローバル変数
local ActiveMonsters = {}
local UpdateInterval = 0.05
local MonsterCounts = {}
local TemplateCache = {}
local RespawnQueue = {}

-- 安全地帯チェック
local function isSafeZone(zoneName)
	local island = Islands[zoneName]
	if island and island.safeZone then
		return true
	end
	return false
end

-- ユーティリティ関数
local function resolveTemplate(pathArray: {string}): Model?
	local node: Instance = game
	for _, seg in ipairs(pathArray) do
		node = node:FindFirstChild(seg)
		if not node then return nil end
	end
	return (node and node:IsA("Model")) and node or nil
end

local function ensureHRP(model: Model): BasePart?
	local hrp = model:FindFirstChild("HumanoidRootPart")
	if hrp and hrp:IsA("BasePart") then
		if not model.PrimaryPart then model.PrimaryPart = hrp end
		return hrp
	end
	return nil
end

local function attachLabel(model: Model, maxDist: number)
	local hrp = model.PrimaryPart or model:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	local _, bboxSize = model:GetBoundingBox()
	local labelOffset = math.min(bboxSize.Y * 0.5 + 2, 15)

	local gui = Instance.new("BillboardGui")
	gui.Name = "DebugInfo"
	gui.Adornee = hrp
	gui.AlwaysOnTop = true
	gui.Size = UDim2.new(0, 150, 0, 50)
	gui.StudsOffset = Vector3.new(0, labelOffset, 0)
	gui.MaxDistance = maxDist
	gui.Parent = hrp

	local lb = Instance.new("TextLabel")
	lb.Name = "InfoText"
	lb.BackgroundTransparency = 1
	lb.TextScaled = true
	lb.Font = Enum.Font.GothamBold
	lb.TextColor3 = Color3.new(1, 1, 1)
	lb.TextStrokeTransparency = 0.5
	lb.Size = UDim2.fromScale(1, 1)
	lb.Text = "Ready"
	lb.Parent = gui
end

local function placeOnGround(model: Model, x: number, z: number)
	local hrp = model.PrimaryPart or model:FindFirstChild("HumanoidRootPart")
	if not hrp then
		warn("[MonsterSpawner] HumanoidRootPart が見つかりません: " .. model.Name)
		return
	end

	local groundY = FieldGen.raycastGroundY(x, z, 100)
		or FieldGen.raycastGroundY(x, z, 200)
		or FieldGen.raycastGroundY(x, z, 50)
		or 10

	local _, yaw = hrp.CFrame:ToOrientation()
	model:PivotTo(CFrame.new(x, groundY + 20, z) * CFrame.Angles(0, yaw, 0))

	local bboxCFrame, bboxSize = model:GetBoundingBox()
	local bottomY = bboxCFrame.Position.Y - (bboxSize.Y * 0.5)
	local offset = hrp.Position.Y - bottomY

	model:PivotTo(CFrame.new(x, groundY + offset, z) * CFrame.Angles(0, yaw, 0))
end

local function nearestPlayer(position: Vector3)
	local best, bestDist = nil, math.huge
	for _, pl in ipairs(Players:GetPlayers()) do
		local ch = pl.Character
		local hrp = ch and ch:FindFirstChild("HumanoidRootPart")
		if hrp then
			local d = (position - hrp.Position).Magnitude
			if d < bestDist then
				best, bestDist = pl, d
			end
		end
	end
	return best, bestDist
end

-- AI状態管理（高速化版）
local AIState = {}
AIState.__index = AIState

function AIState.new(monster, def)
	local self = setmetatable({}, AIState)
	self.monster = monster
	self.def = def
	self.humanoid = monster:FindFirstChildOfClass("Humanoid")
	self.root = monster.PrimaryPart
	self.courage = math.random()
	self.brave = (self.courage > 0.5)
	self.wanderGoal = nil
	self.nextWanderAt = 0
	self.lastUpdateTime = 0
	self.lastDistanceLog = 0
	self.updateRate = def.AiTickRate or 0.3
	self.nearUpdateRate = 0.05 -- 0.05秒に高速化（バトル判定が速くなる）
	self.farUpdateRate = 0.5 -- 0.5秒に高速化

	self.originalSpeed = self.humanoid.WalkSpeed
	self.wasInBattle = false

    -- 【修正点1】徘徊ステート管理を整理
    self.isMoving = false     -- 移動状態か
    self.isWaiting = false    -- 待機状態か (停止状態)
    self.waitEndTime = 0      -- 待機終了時刻
    -- 【修正点1 終わり】

	return self
end

function AIState:shouldUpdate(currentTime)
	local _, dist = nearestPlayer(self.root.Position)
	-- 近距離判定を150スタッドに拡大（バトル判定をより頻繁に）
	local rate = dist < 150 and self.nearUpdateRate or self.farUpdateRate
	return (currentTime - self.lastUpdateTime) >= rate
end

function AIState:update()
	if not self.monster.Parent or not self.humanoid or not self.root then
		return false
	end

	if self.monster:GetAttribute("Defeated") then
		if not self.loggedDefeated then
			-- print(("[AI DEBUG] %s - Defeated状態のためスキップ"):format(self.monster.Name))
			self.loggedDefeated = true
		end
		return false
	end

	-- バトル状態を確認
	local isGlobalBattle = BattleSystem and BattleSystem.isAnyBattleActive and BattleSystem.isAnyBattleActive()
	local isThisMonsterInBattle = self.monster:GetAttribute("InBattle")
	local isAnyBattle = isGlobalBattle or isThisMonsterInBattle

	-- いずれかのバトルが進行中なら停止
	if isAnyBattle then
		self.humanoid.WalkSpeed = 0
		self.humanoid:MoveTo(self.root.Position)
		self.wasInBattle = true
		return true
	end

	-- バトルが終了したら速度を復元
	if self.wasInBattle and not isAnyBattle then
		-- print(("[AI DEBUG] %s - バトル終了、速度復元: %.1f"):format(self.monster.Name, self.originalSpeed))
		self.humanoid.WalkSpeed = self.originalSpeed
		self.wasInBattle = false
		self.loggedDefeated = false
	end

	local p, dist = nearestPlayer(self.root.Position)
	local chaseRange = self.def.ChaseDistance or 60
	local now = os.clock()

	-- バトル判定（高速化・距離拡大）
	if BattleSystem and p and dist <= 7 then -- 7スタッドに拡大
		-- print(("[AI DEBUG] %s - 接触検出！距離=%.1f"):format(self.monster.Name, dist))

		if BattleSystem.isInBattle(p) then
			self.humanoid:MoveTo(self.root.Position)
			return true
		end

		if BattleSystem.isAnyBattleActive and BattleSystem.isAnyBattleActive() then
			self.humanoid:MoveTo(self.root.Position)
			return true
		end

		if self.monster:GetAttribute("InBattle") then
			return true
		end

		local character = p.Character
		if character then
			-- 【重要】即座にプレイヤーを停止（バトル開始前）
			local playerHumanoid = character:FindFirstChildOfClass("Humanoid")
			local playerHrp = character:FindFirstChild("HumanoidRootPart")

			if playerHumanoid and playerHrp then
				-- プレイヤーを即座に停止
				playerHumanoid.WalkSpeed = 0
				playerHumanoid.JumpPower = 0
				playerHrp.Anchored = true
			end

			self.monster:SetAttribute("InBattle", true)
			self.humanoid.WalkSpeed = 0
			self.humanoid:MoveTo(self.root.Position)

			local battleStarted = BattleSystem.startBattle(p, self.monster)
			-- print(("[AI DEBUG] バトル開始結果: %s"):format(tostring(battleStarted)))

			if not battleStarted then
				-- バトル開始失敗時はプレイヤーも解放
				self.monster:SetAttribute("InBattle", false)
				self.humanoid.WalkSpeed = self.originalSpeed

				if playerHumanoid and playerHrp then
					playerHumanoid.WalkSpeed = 16
					playerHumanoid.JumpPower = 50
					playerHrp.Anchored = false
				end
			end

			return true
		else
			self.monster:SetAttribute("InBattle", false)
		end
	end

	-- 海チェック
	local isInWater = self.root.Position.Y < 0 or self.humanoid:GetState() == Enum.HumanoidStateType.Swimming

	-- ラベル更新
	local label = self.root:FindFirstChild("DebugInfo")
		and self.root.DebugInfo:FindFirstChild("InfoText")
	if label then
		local behavior = self.brave and "CHASE" or "FLEE"
		label.Text = string.format("%s\n%s | %.1fm", self.monster.Name, behavior, dist or 999)
	end

	local gui = self.root:FindFirstChild("DebugInfo")
	if gui then
		gui.Enabled = not isInWater
	end

    -- 【修正点2】徘徊ロジックを再構築
    local function wanderLogic()
        local w = self.def.Wander or {}
        local minWait = w.MinWait or 2
        local maxWait = w.MaxWait or 5
        local minRadius = w.MinRadius or 20
        local maxRadius = w.MaxRadius or 60
        local stopDistance = 5 -- 目標到達と見なす距離

        local isGoalReached = self.wanderGoal and (self.root.Position - self.wanderGoal).Magnitude < stopDistance
        local isWaitFinished = self.isWaiting and now >= self.waitEndTime

        if self.isWaiting then
            -- ステート: 待機中（停止）
            self.humanoid:MoveTo(self.root.Position) -- 停止を維持
            self.isMoving = false

            if isWaitFinished then
                -- 待機終了。次の目標設定へ
                self.isWaiting = false
                self.wanderGoal = nil
            end
        elseif isGoalReached or not self.wanderGoal then
            -- ステート: 目標到達 or 目標なし -> 新目標設定 & 移動開始

            -- 目標に到達したら待機モードに移行
            if isGoalReached then
                self.isWaiting = true
                self.waitEndTime = now + math.random(minWait * 10, maxWait * 10) / 10
                self.humanoid:MoveTo(self.root.Position) -- 停止
                return
            end

            -- 新しい目標を設定
            local ang = math.random() * math.pi * 2
            local rad = math.random(minRadius, maxRadius)
            local gx = self.root.Position.X + math.cos(ang) * rad
            local gz = self.root.Position.Z + math.sin(ang) * rad

            local gy = FieldGen.raycastGroundY(gx, gz, 100) or self.root.Position.Y + 5 -- 見つからなければ現在のY+5

            self.wanderGoal = Vector3.new(gx, gy, gz)
            self.isMoving = true

            self.humanoid:MoveTo(self.wanderGoal)

        else
            -- ステート: 移動中（継続）
            self.isMoving = true
            self.humanoid:MoveTo(self.wanderGoal)
        end
    end
    -- 【修正点2 終わり】

	-- 行動決定
	if not p then
		-- プレイヤーがいない：徘徊のみ
		wanderLogic()
	elseif dist < chaseRange then
		-- 追跡 or 逃走
		self.wanderGoal = nil
        self.isMoving = false
        self.isWaiting = false -- 追跡中は徘徊ステートを強制解除
		if self.brave then
			self.humanoid:MoveTo(p.Character.HumanoidRootPart.Position)
		else
			local away = (self.root.Position - p.Character.HumanoidRootPart.Position).Unit
			self.humanoid:MoveTo(self.root.Position + away * 80)
		end
	else
		-- プレイヤーが遠い：徘徊
		wanderLogic()
	end

	self.lastUpdateTime = now
	return true
end

-- スポーン処理（島指定版）
local function spawnMonster(template: Model, index: number, def, islandName)
	local m = template:Clone()
	m.Name = (def.Name or template.Name) .. "_" .. index

	local hum = m:FindFirstChildOfClass("Humanoid")
	local hrp = ensureHRP(m)

	if not hum or not hrp then
		warn("[MonsterSpawner] Humanoid または HRP がありません: " .. m.Name)
		m:Destroy()
		return
	end

	m:SetAttribute("IsEnemy", true)
	m:SetAttribute("MonsterKind", def.Name or "Monster")
	m:SetAttribute("ChaseDistance", def.ChaseDistance or 60)
	m:SetAttribute("SpawnZone", islandName)
	m:SetAttribute("SpawnIsland", islandName)

	local speedMin = def.SpeedMin or 0.7
	local speedMax = def.SpeedMax or 1.3
	local speedMult = speedMin + math.random() * (speedMax - speedMin)
	hum.WalkSpeed = (def.WalkSpeed or 14) * speedMult
	hum.HipHeight = 0

	hrp.Anchored = true
	hrp.CanCollide = false
	hrp.Transparency = 1

	for _, descendant in ipairs(m:GetDescendants()) do
		if descendant:IsA("BasePart") and descendant ~= hrp then
			descendant.CanCollide = true
			descendant.Anchored = false

			for _, child in ipairs(descendant:GetChildren()) do
				if child:IsA("WeldConstraint") or child:IsA("Weld") then
					child:Destroy()
				end
			end

			local weld = Instance.new("WeldConstraint")
			weld.Part0 = hrp
			weld.Part1 = descendant
			weld.Parent = descendant
		end
	end

	m.Parent = Workspace

	local island = Islands[islandName]
	if not island then
		warn(("[MonsterSpawner] 島 '%s' が見つかりません"):format(islandName))
		m:Destroy()
		return
	end

	local spawnRadius
	if def.radiusPercent then
		spawnRadius = (island.sizeXZ / 2) * (def.radiusPercent / 100)
	else
		spawnRadius = def.spawnRadius or 50
	end

	local rx = island.centerX + math.random(-spawnRadius, spawnRadius)
	local rz = island.centerZ + math.random(-spawnRadius, spawnRadius)

	placeOnGround(m, rx, rz)
	-- attachLabel(m, def.LabelMaxDistance or 250)

	task.wait(0.05)
	hrp.Anchored = false

	local aiState = AIState.new(m, def)
	table.insert(ActiveMonsters, aiState)

	local monsterName = def.Name or "Monster"
	if not MonsterCounts[islandName] then
		MonsterCounts[islandName] = {}
	end
	MonsterCounts[islandName][monsterName] = (MonsterCounts[islandName][monsterName] or 0) + 1

	-- print(("[MonsterSpawner] %s を %s にスポーン"):format(m.Name, islandName))
end

-- ゾーン内のモンスターカウントを取得
local function getZoneMonsterCounts(zoneName)
    local counts = {}

    -- 大陸名から島のリストを取得
    local islandNames = {}

    -- ContinentsRegistryをロード（まだロードされていない場合）
    if not ContinentsRegistry then
        local ContinentsFolder = ReplicatedStorage:FindFirstChild("Continents")
        if ContinentsFolder then
            local RegistryModule = ContinentsFolder:FindFirstChild("Registry")
            if RegistryModule then
                ContinentsRegistry = require(RegistryModule)
                print("[MonsterSpawner] ContinentsRegistryをロードしました")
            end
        end
    end

    -- 大陸の場合は、含まれる島をすべて取得
    local continent = nil
    if ContinentsRegistry then
        for _, cont in ipairs(ContinentsRegistry) do
            if cont.name == zoneName then
                continent = cont
                break
            end
        end
    end

    if continent and continent.islands then
        -- 大陸内の全島を対象にする
        for _, islandName in ipairs(continent.islands) do
            table.insert(islandNames, islandName)
        end
        print(("[MonsterSpawner] 大陸 %s の島リスト: %s"):format(
            zoneName,
            table.concat(islandNames, ", ")
        ))
    else
        -- 大陸でない場合は、ゾーン名自体を島名とする
        table.insert(islandNames, zoneName)
        print(("[MonsterSpawner] %s は島として扱います"):format(zoneName))
    end

    -- 各島のモンスターカウントを集計
    for _, islandName in ipairs(islandNames) do
        if MonsterCounts[islandName] then
            for monsterName, count in pairs(MonsterCounts[islandName]) do
                counts[monsterName] = (counts[monsterName] or 0) + count
            end
        end
    end

    print(("[MonsterSpawner] ゾーン %s のモンスターカウント: %s"):format(
        zoneName,
        game:GetService("HttpService"):JSONEncode(counts)
    ))

    return counts
end

-- 全ゾーンのモンスター数をSharedStateに保存
local function updateAllMonsterCounts()
	print("[MonsterSpawner] 全ゾーンのモンスターカウントを更新中...")

	-- 一旦クリア
	SharedState.MonsterCounts = {}

	-- アクティブなゾーンごとにカウント
	local ZoneManager = require(script.Parent.ZoneManager)
	for zoneName, _ in pairs(ZoneManager.ActiveZones) do
		SharedState.MonsterCounts[zoneName] = getZoneMonsterCounts(zoneName)
	end

	print("[MonsterSpawner] モンスターカウント更新完了")
end

-- カスタムカウントでモンスターをスポーン（ロード時用）
local function spawnMonstersWithCounts(zoneName, customCounts)
	if isSafeZone(zoneName) then
		print(("[MonsterSpawner] %s は安全地帯です。モンスターをスポーンしません"):format(zoneName))
		return
	end

	if not customCounts or type(customCounts) ~= "table" then
		print(("[MonsterSpawner] カスタムカウントが無効です。通常スポーンを実行: %s"):format(zoneName))
		spawnMonstersForZone(zoneName)
		return
	end

	print(("[MonsterSpawner] カスタムカウントでモンスターをスポーン: %s"):format(zoneName))
	print(("[MonsterSpawner] カウント: %s"):format(
		game:GetService("HttpService"):JSONEncode(customCounts)
	))

	-- カスタムカウントに基づいてスポーン
	for monsterName, count in pairs(customCounts) do
		local template = TemplateCache[monsterName]
		local def = nil

		-- 定義を取得
		for _, regDef in ipairs(Registry) do
			if regDef.Name == monsterName then
				def = regDef
				break
			end
		end

		if template and def and count > 0 then
			print(("[MonsterSpawner] %s を %d 体スポーン"):format(monsterName, count))

			-- 各モンスターの配置先を決定
			if def.SpawnLocations then
				-- 各ロケーションに均等配分
				local locationsInZone = {}
				for _, location in ipairs(def.SpawnLocations) do
					-- このゾーンに含まれる島かチェック
					local isInZone = false

					-- 大陸の場合
					local Continents = {}
					for _, continent in ipairs(ContinentsRegistry) do
						Continents[continent.name] = continent
					end

					if Continents[zoneName] then
						for _, islandName in ipairs(Continents[zoneName].islands) do
							if islandName == location.islandName then
								isInZone = true
								break
							end
						end
					elseif zoneName == location.islandName then
						isInZone = true
					end

					if isInZone then
						table.insert(locationsInZone, location.islandName)
					end
				end

				-- 各ロケーションに配分
				if #locationsInZone > 0 then
					local countPerLocation = math.ceil(count / #locationsInZone)

					for _, islandName in ipairs(locationsInZone) do
						for i = 1, math.min(countPerLocation, count) do
							local spawnDef = {}
							for k, v in pairs(def) do
								spawnDef[k] = v
							end

							spawnMonster(template, i, spawnDef, islandName)
							count = count - 1

							if count <= 0 then break end
							if i % 5 == 0 then task.wait() end
						end

						if count <= 0 then break end
					end
				end
			end
		else
			if not template then
				warn(("[MonsterSpawner] テンプレート未発見: %s"):format(monsterName))
			end
			if not def then
				warn(("[MonsterSpawner] 定義未発見: %s"):format(monsterName))
			end
		end
	end
end

-- ゾーンにモンスターをスポーンする（大陸対応版）
function spawnMonstersForZone(zoneName)
	if isSafeZone(zoneName) then
		print(("[MonsterSpawner] %s は安全地帯です。モンスターをスポーンしません"):format(zoneName))
		return
	end

	print(("[MonsterSpawner] %s にモンスターを配置中..."):format(zoneName))

	local islandsInZone = {}

	local ContinentsRegistry = require(ReplicatedStorage.Continents.Registry)
	local Continents = {}
	for _, continent in ipairs(ContinentsRegistry) do
		Continents[continent.name] = continent
	end

	if Continents[zoneName] then
		local continent = Continents[zoneName]
		for _, islandName in ipairs(continent.islands) do
			islandsInZone[islandName] = true
		end
		print(("[MonsterSpawner] 大陸 %s の島: %s"):format(zoneName, table.concat(continent.islands, ", ")))
	else
		islandsInZone[zoneName] = true
	end

	for _, def in ipairs(Registry) do
		local monsterName = def.Name or "Monster"
		local template = TemplateCache[monsterName]

		if template then
			if def.SpawnLocations then
				for _, location in ipairs(def.SpawnLocations) do
					local islandName = location.islandName

					if islandsInZone[islandName] then
						local radiusText = location.radiusPercent or 100
						print(("[MonsterSpawner] %s を %s に配置中 (数: %d, 範囲: %d%%)"):format(
							monsterName, islandName, location.count, radiusText
							))

						if not MonsterCounts[islandName] then
							MonsterCounts[islandName] = {}
						end
						MonsterCounts[islandName][monsterName] = 0

						for i = 1, (location.count or 0) do
							local spawnDef = {}
							for k, v in pairs(def) do
								spawnDef[k] = v
							end
							spawnDef.radiusPercent = location.radiusPercent
							spawnDef.spawnRadius = location.spawnRadius

							spawnMonster(template, i, spawnDef, islandName)
							if i % 5 == 0 then task.wait() end
						end
					end
				end
			else
				warn(("[MonsterSpawner] %s は旧形式です。SpawnLocations形式に移行してください"):format(monsterName))
			end
		end
	end
end

-- リスポーン処理（島対応版）
local function scheduleRespawn(monsterName, def, islandName)
	local respawnTime = def.RespawnTime or 10
	if respawnTime <= 0 then return end

	local respawnData = {
		monsterName = monsterName,
		def = def,
		islandName = islandName,
		respawnAt = os.clock() + respawnTime
	}
	table.insert(RespawnQueue, respawnData)
end

local function processRespawnQueue()
	task.spawn(function()
		while true do
			local now = os.clock()

			for i = #RespawnQueue, 1, -1 do
				local data = RespawnQueue[i]
				if now >= data.respawnAt then
					local isActive = false
					for zoneName, _ in pairs(ZoneManager.ActiveZones) do
						isActive = true
						break
					end

					if isActive then
						local template = TemplateCache[data.monsterName]
						if template and MonsterCounts[data.islandName] then
							local nextIndex = (MonsterCounts[data.islandName][data.monsterName] or 0) + 1
							spawnMonster(template, nextIndex, data.def, data.islandName)
							-- print(("[MonsterSpawner] %s が %s にリスポーン"):format(data.monsterName, data.islandName))
						end
					end
					table.remove(RespawnQueue, i)
				end
			end

			task.wait(1)
		end
	end)
end

-- AI更新ループ（高速化）
local function startGlobalAILoop()
	print("[MonsterSpawner] AI更新ループ開始（高速化版）")

	task.spawn(function()
		while true do
			if #ActiveMonsters > 0 then
				local currentTime = os.clock()

				for i = #ActiveMonsters, 1, -1 do
					local state = ActiveMonsters[i]

					if state:shouldUpdate(currentTime) then
						local success, result = pcall(function()
							return state:update()
						end)

						if not success then
							warn(("[MonsterSpawner ERROR] AI更新エラー: %s - %s"):format(
								state.monster.Name, tostring(result)
								))
						elseif not result then
							local monsterDef = state.def
							local monsterName = monsterDef.Name or "Unknown"
							local zoneName = state.monster:GetAttribute("SpawnZone") or "Unknown"

							if MonsterCounts[zoneName] and MonsterCounts[zoneName][monsterName] then
								MonsterCounts[zoneName][monsterName] = MonsterCounts[zoneName][monsterName] - 1
							end

							table.remove(ActiveMonsters, i)
							scheduleRespawn(monsterName, monsterDef, zoneName)
						end
					end
				end
			end

			task.wait(UpdateInterval)
		end
	end)
end

-- ゾーンのモンスターを削除する
function despawnMonstersForZone(zoneName)
	print(("[MonsterSpawner] %s のモンスターを削除中..."):format(zoneName))

	local removedCount = 0

	for i = #ActiveMonsters, 1, -1 do
		local state = ActiveMonsters[i]
		local monsterZone = state.monster:GetAttribute("SpawnZone")

		if monsterZone == zoneName then
			state.monster:Destroy()
			table.remove(ActiveMonsters, i)
			removedCount = removedCount + 1
		end
	end

	for i = #RespawnQueue, 1, -1 do
		if RespawnQueue[i].zoneName == zoneName then
			table.remove(RespawnQueue, i)
		end
	end

	MonsterCounts[zoneName] = nil

	print(("[MonsterSpawner] %s のモンスターを %d体 削除しました"):format(zoneName, removedCount))
end

-- 初期化
print("[MonsterSpawner] === スクリプト開始（バトル高速化版）===")

if BattleSystem then
	BattleSystem.init()
	print("[MonsterSpawner] BattleSystem初期化完了")
else
	print("[MonsterSpawner] BattleSystemなしで起動")
end

-- モンスターカウントリクエストに応答
GameEvents.MonsterCountRequest.Event:Connect(function(zoneName)
	print(("[MonsterSpawner] モンスターカウントリクエスト受信: %s"):format(zoneName or "全ゾーン"))

	if zoneName then
		-- 特定ゾーンのみ
		SharedState.MonsterCounts[zoneName] = getZoneMonsterCounts(zoneName)
	else
		-- 全ゾーン
		updateAllMonsterCounts()
	end

	-- 完了通知
	GameEvents.MonsterCountResponse:Fire()
end)

print("[MonsterSpawner] GameEventsへの応答登録完了")

Workspace:WaitForChild("World", 10)
print("[MonsterSpawner] World フォルダ検出")

task.wait(1)

print("[MonsterSpawner] モンスターテンプレートをキャッシュ中...")
for _, def in ipairs(Registry) do
	local template = resolveTemplate(def.TemplatePath)
	if template then
		local monsterName = def.Name or "Monster"
		TemplateCache[monsterName] = template
		print(("[MonsterSpawner] テンプレートキャッシュ: %s"):format(monsterName))
	else
		warn(("[MonsterSpawner] テンプレート未発見: %s"):format(def.Name or "?"))
	end
end

startGlobalAILoop()
processRespawnQueue()

print("[MonsterSpawner] === 初期化完了（バトル即座開始対応）===")

_G.SpawnMonstersForZone = spawnMonstersForZone
_G.DespawnMonstersForZone = despawnMonstersForZone
_G.SpawnMonstersWithCounts = spawnMonstersWithCounts
_G.GetZoneMonsterCounts = getZoneMonsterCounts
_G.UpdateAllMonsterCounts = updateAllMonsterCounts

print("[MonsterSpawner] グローバル関数登録完了（カウント機能付き）")
===== ./ServerScriptService/DataCollectors.lua =====
-- ServerScriptService/DataCollectors.lua
-- セーブ/ロードに必要なデータを収集・適用するモジュール

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")
local HttpService = game:GetService("HttpService")

local DataCollectors = {}

-- プレイヤーの状態を収集
function DataCollectors.collectPlayerState(player: Player, playerStats)
    local character = player.Character or player.CharacterAdded:Wait()
    local hrp = character:WaitForChild("HumanoidRootPart", 5)

    local zoneManager = require(script.Parent.ZoneManager)
    local currentZone = zoneManager.GetPlayerZone(player)

    local playerState = {
        -- ステータス (PlayerStatsから取得)
        Stats = {
            Level = playerStats.Level,
            Experience = playerStats.Experience,
            Gold = playerStats.Gold,
            CurrentHP = playerStats.CurrentHP,
            MonstersDefeated = playerStats.MonstersDefeated,
        },
        -- 位置情報
        Location = {
            ZoneName = currentZone or "ContinentTown", -- デフォルトはタウン
            X = hrp and hrp.Position.X or 0,
            Y = hrp and hrp.Position.Y or 50, -- Yは地形から少し上の位置
            Z = hrp and hrp.Position.Z or 0,
        },
    }

    return playerState
end

-- 【修正】ワールドの状態（モンスターカウントのみ）を収集
function DataCollectors.collectFieldState(zoneName)
    local fieldState = {
        MonsterCounts = {}
    }

    -- MonsterSpawnerのグローバル関数を使ってカウント取得
    if _G.GetZoneMonsterCounts then
        local counts = _G.GetZoneMonsterCounts(zoneName)
        if counts then
            fieldState.MonsterCounts = counts
            print(("[DataCollectors] %s のモンスターカウント収集: %s"):format(
                zoneName,
                HttpService:JSONEncode(counts)
            ))
        else
            print(("[DataCollectors] %s にモンスターカウントがありません"):format(zoneName))
        end
    else
        warn("[DataCollectors] _G.GetZoneMonsterCounts が利用できません")
    end

    return fieldState
end

-- 【修正】ワールドの状態を復元 (ロード時に使用)
function DataCollectors.restoreFieldState(zoneName, fieldState)
    if not fieldState then
        warn("[DataCollectors] 復元するフィールド状態がありません")
        return false
    end

    if not fieldState.MonsterCounts or next(fieldState.MonsterCounts) == nil then
        print(("[DataCollectors] %s に復元するモンスターがありません"):format(zoneName))
        return false
    end

    print(("[DataCollectors] %s のモンスターを復元中: %s"):format(
        zoneName,
        HttpService:JSONEncode(fieldState.MonsterCounts)
    ))

    -- MonsterSpawnerのグローバル関数を使ってスポーン
    if _G.SpawnMonstersWithCounts then
        _G.SpawnMonstersWithCounts(zoneName, fieldState.MonsterCounts)
        print(("[DataCollectors] %s のモンスター復元完了"):format(zoneName))
        return true
    else
        warn("[DataCollectors] _G.SpawnMonstersWithCounts が利用できません")
        return false
    end
end

-- 総合セーブデータを作成
function DataCollectors.createSaveData(player: Player, playerStats)
    local currentZone = (require(script.Parent.ZoneManager)).GetPlayerZone(player)

    local saveData = {
        PlayerState = DataCollectors.collectPlayerState(player, playerStats),
        CurrentZone = currentZone,
        FieldState = (currentZone ~= "ContinentTown") and DataCollectors.collectFieldState(currentZone) or nil,
        CollectedItems = playerStats.CollectedItems or {},
        SaveTime = os.time(),
    }

    return saveData
end

return DataCollectors
===== ./ServerScriptService/TowerPlacement.server.lua =====
-- ServerScriptService/TowerPlacement.server.lua
-- StartTownにタワーを配置

local ServerStorage = game:GetService("ServerStorage")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
print("[TowerPlacement] タワー配置をスキップ")
-- print("[TowerPlacement] タワー配置開始")

-- -- StartTownの設定を取得
-- local IslandsRegistry = require(ReplicatedStorage.Islands.Registry)
-- local townConfig = nil
-- for _, island in ipairs(IslandsRegistry) do
-- 	if island.name == "StartTown" then
-- 		townConfig = island
-- 		break
-- 	end
-- end

-- if not townConfig then
-- 	warn("[TowerPlacement] StartTownの設定が見つかりません")
-- 	return
-- end

-- -- 配置位置（StartTownの中心から東に50スタッド）
-- local TOWER_OFFSET_X = 400  -- ★修正: 400に変更 (-100 + 400 = 300)
-- local TOWER_OFFSET_Z = -100 -- ★修正: -100に変更 (100 + (-100) = 0)

-- -- 地形生成を待つ
-- task.wait(1)

-- -- ServerStorage/Buildingsからタワーのテンプレートを取得
-- local buildingsFolder = ServerStorage:FindFirstChild("Buildings")
-- if not buildingsFolder then
-- 	warn("[TowerPlacement] ServerStorage に 'Buildings' フォルダが見つかりません")
-- 	return
-- end

-- local towerTemplate = buildingsFolder:FindFirstChild("Tower")
-- if not towerTemplate then
-- 	warn("[TowerPlacement] ServerStorage/Buildings に 'Tower' が見つかりません")
-- 	warn("[TowerPlacement] Toolboxから Asset ID 12127172596 を ServerStorage/Buildings に配置してください")
-- 	return
-- end

-- -- タワーを複製
-- local tower = towerTemplate:Clone()
-- tower.Parent = workspace

-- print("[TowerPlacement] タワーを読み込みました:", tower.Name)

-- -- 配置位置を計算
-- local towerX = townConfig.centerX + TOWER_OFFSET_X
-- local towerZ = townConfig.centerZ + TOWER_OFFSET_Z

-- -- 地面の高さを取得
-- local FieldGen = require(ReplicatedStorage:WaitForChild("FieldGen"))
-- local groundY = FieldGen.raycastGroundY(towerX, towerZ, townConfig.baseY + 100)

-- if not groundY then
-- 	-- レイキャストが失敗した場合は推定高度を使用
-- 	groundY = townConfig.baseY + 5
-- 	warn("[TowerPlacement] 地面検出失敗、推定高度を使用:", groundY)
-- end

-- -- タワーの底面を地面に合わせる
-- if tower:IsA("Model") then
-- 	-- Modelの場合：最下点を地面に合わせる
-- 	local primaryPart = tower.PrimaryPart
-- 	if not primaryPart then
-- 		for _, part in ipairs(tower:GetDescendants()) do
-- 			if part:IsA("BasePart") then
-- 				tower.PrimaryPart = part
-- 				primaryPart = part
-- 				print("[TowerPlacement] PrimaryPartを自動設定:", part.Name)
-- 				break
-- 			end
-- 		end
-- 	end

-- 	if primaryPart then
-- 		-- まず目標位置に配置
-- 		tower:SetPrimaryPartCFrame(CFrame.new(towerX, groundY, towerZ))

-- 		-- 最下点を探す
-- 		local lowestY = math.huge
-- 		local lowestPartName = ""
-- 		for _, part in ipairs(tower:GetDescendants()) do
-- 			if part:IsA("BasePart") then
-- 				local partBottom = part.Position.Y - (part.Size.Y / 2)
-- 				if partBottom < lowestY then
-- 					lowestY = partBottom
-- 					lowestPartName = part.Name
-- 				end
-- 			end
-- 		end

-- 		print(("[TowerPlacement] デバッグ情報:"):format())
-- 		print(("  地面の高さ (groundY): %.1f"):format(groundY))
-- 		print(("  最下点パーツ: %s"):format(lowestPartName))
-- 		print(("  最下点の高さ (配置前): %.1f"):format(lowestY))

-- 		-- 最下点が地面になるよう調整
-- 		local adjustment = groundY - lowestY
-- 		local currentCFrame = tower:GetPrimaryPartCFrame()
-- 		tower:SetPrimaryPartCFrame(currentCFrame + Vector3.new(0, adjustment, 0))

-- 		-- 調整後の最下点を確認
-- 		local newLowestY = math.huge
-- 		for _, part in ipairs(tower:GetDescendants()) do
-- 			if part:IsA("BasePart") then
-- 				local partBottom = part.Position.Y - (part.Size.Y / 2)
-- 				if partBottom < newLowestY then
-- 					newLowestY = partBottom
-- 				end
-- 			end
-- 		end

-- 		local _, size = tower:GetBoundingBox()
-- 		print("[TowerPlacement] タワーを配置しました (Model):")
-- 		print(("  位置: X=%.1f, Y=%.1f, Z=%.1f"):format(towerX, groundY, towerZ))
-- 		print(("  サイズ: %.1f x %.1f x %.1f"):format(size.X, size.Y, size.Z))
-- 		print(("  調整: %.1f スタッド上に移動"):format(adjustment))
-- 		print(("  調整後の最下点: %.1f (目標: %.1f)"):format(newLowestY, groundY))
-- 	else
-- 		local cf, size = tower:GetBoundingBox()
-- 		local lowestY = cf.Position.Y - (size.Y / 2)
-- 		local adjustment = groundY - lowestY
-- 		tower:PivotTo(CFrame.new(towerX, groundY + adjustment, towerZ))
-- 		print("[TowerPlacement] PivotToで配置しました:")
-- 		print(("  位置: X=%.1f, Y=%.1f, Z=%.1f"):format(towerX, groundY, towerZ))
-- 	end
-- elseif tower:IsA("BasePart") then
-- 	-- MeshPartなど単一パーツの場合
-- 	local size = tower.Size
-- 	local offsetY = size.Y / 2
-- 	tower.CFrame = CFrame.new(towerX, groundY + offsetY, towerZ)
-- 	print("[TowerPlacement] タワーを配置しました (BasePart):")
-- 	print(("  位置: X=%.1f, Y=%.1f, Z=%.1f"):format(towerX, groundY + offsetY, towerZ))
-- 	print(("  サイズ: %.1f x %.1f x %.1f"):format(size.X, size.Y, size.Z))
-- else
-- 	warn("[TowerPlacement] 未対応の型:", tower.ClassName)
-- 	return
-- end

-- -- タワーを固定
-- for _, part in ipairs(tower:GetDescendants()) do
-- 	if part:IsA("BasePart") then
-- 		part.Anchored = true
-- 	end
-- end

-- print("[TowerPlacement] 配置完了")
===== ./ReplicatedStorage/Continents/Greenland.lua =====
return {
name = "VerdantPlateau",
displayName = "緑の大陸",
islands = {
"VerdantPlateau_C1",
"VerdantPlateau_C2",
"VerdantPlateau_C3",
"VerdantPlateau_C4",
},
paths = {
{
name = "MainRoad01",
points = {
{2720, 10, -220},
{2850, 10, -120},
{3000, 10, 0},
{3150, 10, 40},
{3280, 10, 60},
},
width = 20,
method = "terrain",
material = Enum.Material.Ground,
step = 3,
alignToSlope = false,
groundOffset = 0.05
},
},
		{
			model = "Tree1",
			position = {2783.8, 25.5, -62.1},
			size = 1.8,
			rotation = {0, 180, 0},
			stickToGround = true,   -- 省略可（trueが既定）
			groundOffset  = 0.15,   -- 芝生で少し浮かせたい時
			alignToSlope  = true,  -- 斜面に木を傾けたくないならfalse
		},
        {
			model = "Chest",
			position = {2799.3, 25.2, -99.8},
			size = 1.8,
			rotation = {0, 180, 0},
			stickToGround = true,   -- 省略可（trueが既定）
			groundOffset  = 0.15,   -- 芝生で少し浮かせたい時
			alignToSlope  = true,  -- 斜面に木を傾けたくないならfalse
		},

fieldObjects = {},
BGM = "",
BGMVolume = 0.2
}
===== ./ReplicatedStorage/Continents/Registry.lua =====
-- ReplicatedStorage/Continents/Registry.lua
local RS = game:GetService("ReplicatedStorage")
local ContinentsFolder = RS:WaitForChild("Continents")

return {
    require(ContinentsFolder.ContientTown),
    require(ContinentsFolder.ContinentHokkaido),
    require(ContinentsFolder.ContinentShikoku),
    require(ContinentsFolder.ContinentKyushu),
    require(ContinentsFolder.Snowland),
    require(ContinentsFolder.Greenland),
}
===== ./ReplicatedStorage/Continents/Snowland.lua =====
return {
name = "SnowCrescent",
displayName = "雪の三日月",
islands = {
"SnowCrescent_C1",
"SnowCrescent_C2",
"SnowCrescent_C3",
"SnowCrescent_C4",
"SnowCrescent_C5",
"SnowCrescent_C6",
"SnowCrescent_C7",
"SnowCrescent_C8",
"SnowCrescent_C9",
"SnowCrescent_C10",
"SnowCrescent_C11",
"SnowCrescent_C12",
"SnowCrescent_C13",
"SnowCrescent_C14",
"SnowCrescent_C15",
},
paths = {
{
name = "MainRoad_NS",
points = {
{2850, 14, -560},
{2855, 15, -420},
{2850, 15, -260},
{2845, 16, -120},
{2850, 16, 0},
{2855, 17, 140},
{2850, 18, 300},
{2850, 19, 460},
},
width = 20,
method = "terrain",
material = Enum.Material.Ground,
step = 3,
alignToSlope = false,
groundOffset = 0.05
},
},
fieldObjects = {},
BGM = "",
BGMVolume = 0.2
}
===== ./ReplicatedStorage/Continents/ContinentHokkaido.lua =====
return {
	name = "ContinentHokkaido",
	displayName = "Hokkaido Continent",

	islands = {
		"Hokkaido_W1", "Hokkaido_C1", "Hokkaido_C2", "Hokkaido_C3",
		"Hokkaido_C4", "Hokkaido_C5", "Hokkaido_E1",
		"Hokkaido_N1", "Hokkaido_N2", "Hokkaido_N3", "Hokkaido_N4",
		"Hokkaido_NE1", "Hokkaido_NE2",
		"Hokkaido_S1", "Hokkaido_S2",
		"Hokkaido_SW1", "Hokkaido_SW2",
	},

	bridges = {},

	portals = {
			{
				name = "Hokkaido_to_Town",
				toZone = "ContinentTown",
				islandName = "Hokkaido_C3",
				offsetX = 0,
				offsetZ = 0,
				label = "→ Town",
				color = Color3.fromRGB(255, 200, 100),
			},
		},

	fieldObjects = {
		{
			model = "Tree1",
			position = {3237.0, 22.0, -10.8},
			size = 1.5,
			rotation = {0, 0, 0},
			stickToGround = true,   -- 省略可（trueが既定）
			groundOffset  = 0.15,   -- 芝生で少し浮かせたい時
			alignToSlope  = true,  -- 斜面に木を傾けたくないならfalse
		},
		{
			model = "Tree1",
			position = {3092.5, 9.1, -175.5},
			size = 1.0,
			rotation = {0, 0, 0},
			stickToGround = true,   -- 省略可（trueが既定）
			groundOffset  = 0.15,   -- 芝生で少し浮かせたい時
			alignToSlope  = true,  -- 斜面に木を傾けたくないならfalse
		},

		{
			model = "Tree1",
			position = {3118.2, 7.3, -182.6},
			size = 1.0,
			rotation = {0, 30, 0},
			stickToGround = true,   -- 省略可（trueが既定）
			groundOffset  = 0.15,   -- 芝生で少し浮かせたい時
			alignToSlope  = true,  -- 斜面に木を傾けたくないならfalse
		},

		{
			model = "Small House",
			position = {3080.8, 32.0, -162.8},
			size = 1.8,
			rotation = {0, 180, 0},
			stickToGround = false,   -- 省略可（trueが既定）
			groundOffset  = 0.15,   -- 芝生で少し浮かせたい時
			alignToSlope  = false,  -- 斜面に木を傾けたくないならfalse
		},

		{
			-- model = "Chest",
			model = "koki3D",
			position = {-0.0, 56.3, -12.0},
			size = 1.0,
			rotation = {0, 0, 0},
			stickToGround = true,   -- 省略可（trueが既定）
			groundOffset  = 0,   -- 芝生で少し浮かせたい時
			alignToSlope  = true,  -- 斜面に木を傾けたくないならfalse
		},

		{
			model = "box_closed",
			position = {3152.0, 59.5, -75.2},
            mode = "ground",
			size = 1,
			rotation = {0, 0, 0},
			stickToGround = false,   -- 省略可（trueが既定）
			groundOffset  = 0,   -- 芝生で少し浮かせたい時
			alignToSlope  = false,  -- 斜面に木を傾けたくないならfalse

            interaction = {
                type = "chest",           -- インタラクションタイプ
                action = "開ける",         -- ボタンに表示されるテキスト
                key = "E",                -- キーバインド
                range = 8,                -- インタラクション可能距離（スタッド）

                -- 宝箱固有の情報
                chestId = "hokkaido_chest_01",          -- ユニークID
                openedModel = "box_opened",         -- 開いた状態のモデル名
                rewards = {
                    {item = "ポーション", count = 2},
					{item = "ゴールド", count = 45},
                },
                displayDuration = 3,      -- 報酬表示時間（秒）
            },
		},

				{
			model = "box_closed",
			position = {2997.1, 26.9, 10.8},
            mode = "ground",
			size = 1,
			rotation = {0, 0, 0},
			stickToGround = false,   -- 省略可（trueが既定）
			groundOffset  = 0,   -- 芝生で少し浮かせたい時
			alignToSlope  = false,  -- 斜面に木を傾けたくないならfalse

            interaction = {
                type = "chest",           -- インタラクションタイプ
                action = "開ける",         -- ボタンに表示されるテキスト
                key = "E",                -- キーバインド
                range = 8,                -- インタラクション可能距離（スタッド）

                -- 宝箱固有の情報
                chestId = "hokkaido_chest_02",          -- ユニークID
                openedModel = "box_opened",         -- 開いた状態のモデル名
                rewards = {
                    {item = "ポーション", count = 2}
                },
                displayDuration = 10,      -- 報酬表示時間（秒）
            },
		},

				{
			model = "box_closed",
			position = {3125.8, 47.2, -60.7},
            mode = "ground",
			size = 1,
			rotation = {0, 0, 0},
			stickToGround = false,   -- 省略可（trueが既定）
			groundOffset  = 0,   -- 芝生で少し浮かせたい時
			alignToSlope  = false,  -- 斜面に木を傾けたくないならfalse

            interaction = {
                type = "chest",           -- インタラクションタイプ
                action = "開ける",         -- ボタンに表示されるテキスト
                key = "E",                -- キーバインド
                range = 8,                -- インタラクション可能距離（スタッド）

                -- 宝箱固有の情報
                chestId = "hokkaido_chest_03",          -- ユニークID
                openedModel = "box_opened",         -- 開いた状態のモデル名
                rewards = {
					{item = "ゴールド", count = 120},
                },
                displayDuration = 3,      -- 報酬表示時間（秒）
            },
		},
	},

	paths = {
		{
			name = "MainRoad01",
			points = {                 -- 制御点：ワールド座標（YはだいたいでOK）
				{92826.4, 19.0, -298.5},
				{92936.1, 26.6, -285.1},
				{92989.4, 26.8, -184.7},
				{93105.4, 23.2, -127.4},
				{93156.3, 19.7, -74.9},
				{93221.8, 30.4, -4.7},
				{93265.4, 24.1, 38.0},
				{93303.9, 20.1, 70.1},
				{93371.1, 20.4, 99.7},
				{93431.9, 20.1, 112.4},
				{93470.7, 19.7, 151.1},
				{93471.7, 18.8, 204.7},
				{93402.1, 19.2, 225.3},
			},
			width = 24,                -- 道の幅（stud）
			method = "terrain",        -- "terrain"（地形を塗る） or "parts"（パーツ敷き）
			material = Enum.Material.Ground,  -- method="terrain"時の塗り材質
			step = 3,                  -- サンプリング間隔（小さいほど滑らか＆重い）
			alignToSlope = false,      -- 斜面に道面を傾けるか（見た目：true、歩きやすさ：false）
			groundOffset = 2.8,       -- めり込み回避の微小オフセット
		},

	},
	fieldObjects = {
		{
			model = "box_closed",
			position = {92895.2, 46.2, -205.6},
			mode = "ground",
			size = 1,
			rotation = {0, 0, 0},
			stickToGround = false,   -- 省略可（trueが既定）
			groundOffset  = 0,   -- 芝生で少し浮かせたい時
			alignToSlope  = false,  -- 斜面に木を傾けたくないならfalse

			interaction = {
				type = "chest",           -- インタラクションタイプ
				action = "開ける",         -- ボタンに表示されるテキスト
				key = "E",                -- キーバインド
				range = 8,                -- インタラクション可能距離（スタッド）

				-- 宝箱固有の情報
				chestId = "kyushu_chest_01",          -- ユニークID
				openedModel = "box_opened",         -- 開いた状態のモデル名
				rewards = {
					{item = "ポーション", count = 1},
				},
				displayDuration = 2,      -- 報酬表示時間（秒）
			},
		},
	},

	BGM = "rbxassetid://115666507179769",  -- 後でアセットIDに変更
	BGMVolume = 0.2,  -- 音量（0.0-1.0）
}
===== ./ReplicatedStorage/Continents/ContinentShikoku.lua =====
-- ===== ./ReplicatedStorage/Continents/ContinentShikoku.lua (新規) =====
return {
	name = "ContinentShikoku",
	displayName = "Shikoku Region",

	islands = {
		"Shikoku_N1", "Shikoku_C1", "Shikoku_S1",
		"Shikoku_E1", "Shikoku_W1",
	},

	bridges = {},

	portals = {
		{
			name = "Shikoku_to_Town",
			toZone = "ContinentTown",
			islandName = "Shikoku_C1", -- 中央の島からポータル
			offsetX = 0,
			offsetZ = 0,
			label = "→ Town",
			color = Color3.fromRGB(150, 255, 150), -- 緑色のポータル
		}
	},

	BGM = "rbxassetid://139951867631287", -- 後でアセットIDに変更
	BGMVolume = 0.3,
}
===== ./ReplicatedStorage/Continents/ContinentKyushu.lua =====
--- Continents ---
return {
name = "ContinentKyushu",
displayName = "ContinentKyushu",
islands = {
"ContinentKyushu_C1",
"ContinentKyushu_C2",
"ContinentKyushu_C3",
"ContinentKyushu_C4",
"ContinentKyushu_C5",
"ContinentKyushu_C6",
"ContinentKyushu_C7",
"ContinentKyushu_C8",
"ContinentKyushu_C9",
"ContinentKyushu_C10",
"ContinentKyushu_C11",
"ContinentKyushu_C12",
"ContinentKyushu_C13",
"ContinentKyushu_C14",
"ContinentKyushu_C15",
"ContinentKyushu_C16",
"ContinentKyushu_C17",
"ContinentKyushu_C18",
"ContinentKyushu_C19",
"ContinentKyushu_C20",
"ContinentKyushu_C21",
"ContinentKyushu_C22",
"ContinentKyushu_C23",
"ContinentKyushu_C24",
},
paths = {
	points = {
			{93300, 10, -560},
			{93320, 10, -460},
			{93340, 10, -360},
			{93360, 10, -240},
			{93380, 10, -120},
			{93390, 10, 0},
			{93380, 10, 120},
			{93360, 10, 240},
			{93340, 10, 360},
			{93300, 10, 480},
	},
	width = 24,                -- 道の幅（stud）
	method = "terrain",        -- "terrain"（地形を塗る） or "parts"（パーツ敷き）
	material = Enum.Material.Ground,  -- method="terrain"時の塗り材質
	step = 3,                  -- サンプリング間隔（小さいほど滑らか＆重い）
	alignToSlope = false,      -- 斜面に道面を傾けるか（見た目：true、歩きやすさ：false）
	groundOffset = 4.8,       -- めり込み回避の微小オフセット
},

--93080.8, 38.0, 166.2
portals = {
		{
			name = "Kyushu_to_Town",
			toZone = "ContinentTown",
			islandName = "ContinentKyushu_C20",
			offsetX = 100,
			offsetZ = 100,
			label = "→ Town",
			color = Color3.fromRGB(255, 255, 255),
		},
		{
			name = "Kyushu_to_Town",
			toZone = "Hokkaido_SW2",
			islandName = "ContinentKyushu_C22",
			offsetX = 100,
			offsetZ = 100,
			label = "→ Hokkaido",
			color = Color3.fromRGB(255, 255, 255),
		}
},


fieldObjects = {
		{
			model = "box_closed",
			position = {92895.2, 46.2, -205.6},
			mode = "ground",
			size = 1,
			rotation = {0, -90, 0},
			stickToGround = false,   -- 省略可（trueが既定）
			groundOffset  = 0,   -- 芝生で少し浮かせたい時
			alignToSlope  = false,  -- 斜面に木を傾けたくないならfalse

			interaction = {
				type = "chest",           -- インタラクションタイプ
				action = "開ける",         -- ボタンに表示されるテキスト
				key = "E",                -- キーバインド
				range = 18,                -- インタラクション可能距離（スタッド）

				-- 宝箱固有の情報
				chestId = "kyushu_chest_01",          -- ユニークID
				openedModel = "box_opened",         -- 開いた状態のモデル名
				rewards = {
					{item = "ポーション", count = 1},
				},
				displayDuration = 2,      -- 報酬表示時間（秒）
			},
		},
	},

BGM = "",
BGMVolume = 0.2
}
===== ./ReplicatedStorage/Continents/ContientTown.lua =====
-- ===== ./ReplicatedStorage/Continents/ContientTown.lua =====
return {
	name = "ContinentTown",
	displayName = "Start Town",

	islands = {
        "StartTown",
        "Town_NE",
        "Town_SW",
        "Town_SE",
	},

	bridges = {},

	-- ★修正: 北海道、四国、九州へのポータルを追加
	portals = {
		{
            name = "Town_to_Hokkaido",
            toZone = "ContinentHokkaido",
            islandName = "StartTown",
            offsetX = 0,
            offsetZ = -50,
            size = Vector3.new(8, 12, 8),
            color = Color3.fromRGB(200, 200, 255),
            label = "→ Hokkaido"
        },
        {
            name = "Town_to_Shikoku", -- ★新規ポータル
            toZone = "ContinentShikoku",
            islandName = "Town_NE",
            offsetX = 0,
            offsetZ = 0,
            size = Vector3.new(8, 12, 8),
            color = Color3.fromRGB(150, 255, 150),
            label = "→ Shikoku"
        },
        {
            name = "Town_to_Kyushu",  -- ★新規ポータル
            toZone = "ContinentKyushu",
            islandName = "Town_SE",
            offsetX = 0,
            offsetZ = 0,
            size = Vector3.new(8, 12, 8),
            color = Color3.fromRGB(255, 100, 100),
            label = "→ Kyushu"
        },
	},

    fieldObjects = {
		{
			model = "Chest",
			position = {55, 78, -5.8},
             mode = "ground",
			size = 1.5,
			rotation = {0, 0, 0},
			groundOffset  = 0,   -- 芝生で少し浮かせたい時
			alignToSlope  = true,  -- 斜面に木を傾けたくないならfalse
		},
		{
			model = "koki3D",
			position = {58.7, 78, -5.8},
            mode = "ground",
			size = 1,
			rotation = {0, 0, 0},
			stickToGround = false,   -- 省略可（trueが既定）
			groundOffset  = 0,   -- 芝生で少し浮かせたい時
			alignToSlope  = true,  -- 斜面に木を傾けたくないならfalse
		},

		{
			model = "koki3D",
			position = {26.1, 57.6, -9.5},
            mode = "ground",
			size = 0.2,
			rotation = {0, 0, 0},
			stickToGround = false,   -- 省略可（trueが既定）
			groundOffset  = 0,   -- 芝生で少し浮かせたい時
			alignToSlope  = true,  -- 斜面に木を傾けたくないならfalse
		},

        {
			model = "muichiro",
			position = {23.2, 57.5, -15.2},
            mode = "fixed",
			size = 0.2,
			rotation = {0, 0, 0},
			stickToGround = false,   -- 省略可（trueが既定）
			groundOffset  = 10,   -- 芝生で少し浮かせたい時
			alignToSlope  = true,  -- 斜面に木を傾けたくないならfalse
            -- upAxis = "",
		}, --

         {
			model = "box_closed",
			position = {42.4, 56.5, 10.9},
            mode = "ground",
			size = 1,
			rotation = {0, 0, 0},
			stickToGround = false,   -- 省略可（trueが既定）
			groundOffset  = 0,   -- 芝生で少し浮かせたい時
			alignToSlope  = false,  -- 斜面に木を傾けたくないならfalse

            interaction = {
                type = "chest",           -- インタラクションタイプ
                action = "開ける",         -- ボタンに表示されるテキスト
                key = "E",                -- キーバインド
                range = 8,                -- インタラクション可能距離（スタッド）

                -- 宝箱固有の情報
                chestId = "town_chest_01",          -- ユニークID
                openedModel = "box_opened",         -- 開いた状態のモデル名
                rewards = {
                    {item = "ポーション", count = 3},
                    {item = "ゴールド", count = 50},
                },
                displayDuration = 3,      -- 報酬表示時間（秒）
            },
		},

		{
			model = "box_closed",
			position = {42.4, 56.5, 20.9},
            mode = "ground",
			size = 1,
			rotation = {0, 0, 0},
			stickToGround = false,   -- 省略可（trueが既定）
			groundOffset  = 0,   -- 芝生で少し浮かせたい時
			alignToSlope  = false,  -- 斜面に木を傾けたくないならfalse

            interaction = {
                type = "chest",           -- インタラクションタイプ
                action = "開ける",         -- ボタンに表示されるテキスト
                key = "E",                -- キーバインド
                range = 8,                -- インタラクション可能距離（スタッド）

                -- 宝箱固有の情報
                chestId = "town_chest_02",          -- ユニークID
                openedModel = "box_opened",         -- 開いた状態のモデル名
                rewards = {
                    {item = "ポーション", count = 1},
					{item = "ゴールド", count = 25},
                },
                displayDuration = 3,      -- 報酬表示時間（秒）
            },
		},

        {
			model = "box_closed",
			position = {31.9, 56.5, 10.9},
            mode = "ground",
			size = 1,
			rotation = {0, 0, 0},
			stickToGround = false,   -- 省略可（trueが既定）
			alignToSlope  = false,  -- 斜面に木を傾けたくないならfalse
		},
	},
--m

	BGM = "rbxassetid://139951867631287",  -- 後でアセットIDに変更
	BGMVolume = 0.2,
}
===== ./ReplicatedStorage/Islands/Bridges.lua =====
return {
	{
		name = "Bridge_Start_to_Forest",
		fromIsland = 1,
		toIsland = 2,
		width = 15,  -- 20から15に変更（橋も少し細く）
		height = 5,
	},
}
===== ./ReplicatedStorage/Islands/Greenland.lua =====
return {
{
name = "VerdantPlateau_C1",
centerX = 3000,
centerZ = 0,
sizeXZ = 300,
baseY = 8,
thickness = 14,
grid = 14,
hillAmplitude = 6,
hillScale = 160,
seed = 41021,
generateOcean = false,
baseMaterial = Enum.Material.Grass,
},
{
name = "VerdantPlateau_C2",
centerX = 3280,
centerZ = -120,
sizeXZ = 290,
baseY = 8,
thickness = 14,
grid = 14,
hillAmplitude = 6,
hillScale = 160,
seed = 51239,
generateOcean = false,
baseMaterial = Enum.Material.Grass,
},
{
name = "VerdantPlateau_C3",
centerX = 2720,
centerZ = -100,
sizeXZ = 280,
baseY = 8,
thickness = 14,
grid = 14,
hillAmplitude = 6,
hillScale = 160,
seed = 63917,
generateOcean = false,
baseMaterial = Enum.Material.Grass,
},
{
name = "VerdantPlateau_C4",
centerX = 3000,
centerZ = 260,
sizeXZ = 270,
baseY = 8,
thickness = 14,
grid = 14,
hillAmplitude = 6,
hillScale = 160,
seed = 74288,
generateOcean = false,
baseMaterial = Enum.Material.Grass,
},
}
===== ./ReplicatedStorage/Islands/Town.lua =====
-- ReplicatedStorage/Islands/Town.lua (4つの島で構成されるTownエリア - 重複版)

return {
    -- 1. StartTown (North-West, メインスポーン地点)
    {
        name = "StartTown",
        centerX = -50, -- ★修正: -100から-50へ (X:-150〜150)
        centerZ = 50,  -- ★修正: 100から50へ (Z:-150〜150)
        sizeXZ = 200,
        baseY = 50,
        thickness = 8,
        grid = 10,
        hillAmplitude = 3,
        hillScale = 80,
        seed = 77777,
        generateOcean = false,
        safeZone = true,
        baseMaterial = Enum.Material.Slate,
    },

    -- 2. Town_NE (North-East)
    {
        name = "Town_NE",
        centerX = 50, -- ★修正: 100から50へ
        centerZ = 50, -- ★修正: 100から50へ
        sizeXZ = 200,
        baseY = 50,
        thickness = 8,
        grid = 10,
        hillAmplitude = 3,
        hillScale = 80,
        seed = 77778,
        generateOcean = false,
        safeZone = true,
        baseMaterial = Enum.Material.Slate,
    },

    -- 3. Town_SW (South-West)
    {
        name = "Town_SW",
        centerX = -50, -- ★修正: -100から-50へ
        centerZ = -50, -- ★修正: -100から-50へ
        sizeXZ = 200,
        baseY = 50,
        thickness = 8,
        grid = 10,
        hillAmplitude = 3,
        hillScale = 80,
        seed = 77779,
        generateOcean = false,
        safeZone = true,
        baseMaterial = Enum.Material.Slate,
    },

    -- 4. Town_SE (South-East)
    {
        name = "Town_SE",
        centerX = 50, -- ★修正: 100から50へ
        centerZ = -50, -- ★修正: -100から-50へ
        sizeXZ = 200,
        baseY = 50,
        thickness = 8,
        grid = 10,
        hillAmplitude = 3,
        hillScale = 80,
        seed = 77780,
        generateOcean = false,
        safeZone = true,
        baseMaterial = Enum.Material.Slate,
    },
}
===== ./ReplicatedStorage/Islands/HokkaidoIslands.lua =====
-- ReplicatedStorage/Islands/HokkaidoIslands
return {
	-- 中央部
	{name = "Hokkaido_W1", centerX = 3000, centerZ = 0, sizeXZ = 160, baseY = 10, thickness = 40, grid = 10, hillAmplitude = 15, hillScale = 1, seed = 0, generateOcean = false, baseMaterial = Enum.Material.LeafyGrass, },
	{name = "Hokkaido_C1", centerX = 3080, centerZ = 0, sizeXZ = 160, baseY = 10, thickness = 40, grid = 10, hillAmplitude = 15, hillScale = 1, seed = 0, generateOcean = false, baseMaterial = Enum.Material.LeafyGrass, },
	{name = "Hokkaido_C2", centerX = 3160, centerZ = 0, sizeXZ = 160, baseY = 10, thickness = 40, grid = 10, hillAmplitude = 15, hillScale = 1, seed = 0, generateOcean = false, baseMaterial = Enum.Material.LeafyGrass, },
	{name = "Hokkaido_C3", centerX = 3240, centerZ = 0, sizeXZ = 160, baseY = 10, thickness = 40, grid = 10, hillAmplitude = 15, hillScale = 1, seed = 0, generateOcean = false, baseMaterial = Enum.Material.LeafyGrass, },
	{name = "Hokkaido_C4", centerX = 3320, centerZ = 0, sizeXZ = 160, baseY = 10, thickness = 40, grid = 10, hillAmplitude = 15, hillScale = 1, seed = 0, generateOcean = false, baseMaterial = Enum.Material.LeafyGrass, },
	{name = "Hokkaido_C5", centerX = 3400, centerZ = 0, sizeXZ = 160, baseY = 10, thickness = 40, grid = 10, hillAmplitude = 15, hillScale = 1, seed = 0, generateOcean = false, baseMaterial = Enum.Material.LeafyGrass, },
	{name = "Hokkaido_E1", centerX = 3480, centerZ = 0, sizeXZ = 160, baseY = 10, thickness = 40, grid = 2, hillAmplitude = 160, hillScale = 160, seed = 0, generateOcean = false, baseMaterial = Enum.Material.LeafyGrass, },

	-- 北部
	{name = "Hokkaido_N1", centerX = 3080, centerZ = 80, sizeXZ = 160, baseY = 10, thickness = 10, grid = 10, hillAmplitude = 1, hillScale = 500, seed = 0, generateOcean = false, baseMaterial = Enum.Material.LeafyGrass, },
	{name = "Hokkaido_N2", centerX = 3160, centerZ = 80, sizeXZ = 160, baseY = 10, thickness = 10, grid = 10, hillAmplitude = 1, hillScale = 500, seed = 0, generateOcean = false, baseMaterial = Enum.Material.LeafyGrass, },
	{name = "Hokkaido_N3", centerX = 3240, centerZ = 80, sizeXZ = 160, baseY = 10, thickness = 10, grid = 10, hillAmplitude = 1, hillScale = 500, seed = 0, generateOcean = false, baseMaterial = Enum.Material.LeafyGrass, },
	{name = "Hokkaido_N4", centerX = 3320, centerZ = 80, sizeXZ = 160, baseY = 10, thickness = 10, grid = 10, hillAmplitude = 1, hillScale = 500, seed = 0, generateOcean = false, baseMaterial = Enum.Material.LeafyGrass, },

	-- 北東部（知床）
	{name = "Hokkaido_NE1", centerX = 3320, centerZ = 160, sizeXZ = 160, baseY = 10, thickness = 10, grid = 10, hillAmplitude = 10, hillScale = 500, seed = 50000, generateOcean = false, baseMaterial = Enum.Material.LeafyGrass, },
	{name = "Hokkaido_NE2", centerX = 3400, centerZ = 160, sizeXZ = 160, baseY = 10, thickness = 10, grid = 10, hillAmplitude = 10, hillScale = 500, seed = 50000, generateOcean = false, baseMaterial = Enum.Material.LeafyGrass, },

	-- 南部
	{name = "Hokkaido_S1", centerX = 3160, centerZ = -80, sizeXZ = 200, baseY = 10, thickness = 10, grid = 2, hillAmplitude = 120, hillScale = 100, seed = 50000, generateOcean = false, baseMaterial = Enum.Material.LeafyGrass, },
	{name = "Hokkaido_S2", centerX = 3240, centerZ = -80, sizeXZ = 200, baseY = 10, thickness = 10, grid = 1, hillAmplitude = 200, hillScale = 200, seed = 50000, generateOcean = false, baseMaterial = Enum.Material.LeafyGrass, },

	-- 南西部（渡島）
	{name = "Hokkaido_SW1", centerX = 3080, centerZ = -160, sizeXZ = 160, baseY = 10, thickness = 10, grid = 1, hillAmplitude = 300, hillScale = 160, seed = 50000, generateOcean = false, baseMaterial = Enum.Material.LeafyGrass, },
	{name = "Hokkaido_SW2", centerX = 3160, centerZ = -160, sizeXZ = 160, baseY = 10, thickness = 10, grid = 1, hillAmplitude = 400, hillScale = 20, seed = 50000, generateOcean = true, baseMaterial = Enum.Material.LeafyGrass, oceanRadius = 2000},
}
===== ./ReplicatedStorage/Islands/Registry.lua =====
-- ===== ./ReplicatedStorage/Islands/Registry.lua =====
-- ReplicatedStorage/Islands/Registry.lua (全コード)
local RS = game:GetService("ReplicatedStorage")
local IslandsFolder = RS:WaitForChild("Islands")

local allIslands = {}

-- 島定義のリスト
local islandModules = {
    IslandsFolder:WaitForChild("Town"),           -- 【修正】Town.lua を参照
    IslandsFolder:WaitForChild("HokkaidoIslands"),
    IslandsFolder:WaitForChild("ShikokuIslands"),
    IslandsFolder:WaitForChild("KyushuIslands"),
    IslandsFolder:WaitForChild("Snowland"),
     IslandsFolder:WaitForChild("Greenland"),
}

-- 各モジュールを読み込み
for _, module in ipairs(islandModules) do
    local result = require(module)

    -- Town (単一テーブル) と Hokkaido (配列) の両方を処理
    if result and result.name then
        -- 単一の島定義 (Town)
        table.insert(allIslands, result)
    elseif type(result) == "table" and #result > 0 then
        -- 複数の島定義（配列, Hokkaido）
        for _, island in ipairs(result) do
            if island and island.name then
                table.insert(allIslands, island)
            else
                warn(("[Islands/Registry] '%s' から取得したリストに無効な要素があります"):format(module.Name))
            end
        end
    else
        warn(("[Islands/Registry] 不正な島定義: '%s'"):format(module.Name))
    end
end

print(("[Islands/Registry] 合計 %d 個の島を読み込みました"):format(#allIslands))

return allIslands
===== ./ReplicatedStorage/Islands/Snowland.lua =====
return {
{
name = "SnowCrescent_C1",
centerX = 2880,
centerZ = -550,
sizeXZ = 200,
baseY = 400,
thickness = 60,
grid = 12,
hillAmplitude = 8,
hillScale = 150,
seed = 18431,
generateOcean = true,
oceanRadius = 1000,
baseMaterial = Enum.Material.Snow,
},
{
name = "SnowCrescent_C2",
centerX = 2860,
centerZ = -480,
sizeXZ = 210,
baseY = 400,
thickness = 60,
grid = 12,
hillAmplitude = 7,
hillScale = 150,
seed = 29455,
generateOcean = true,
oceanRadius = 1000,
baseMaterial = Enum.Material.Snow,
},
{
name = "SnowCrescent_C3",
centerX = 2850,
centerZ = -420,
sizeXZ = 220,
baseY = 400,
thickness = 62,
grid = 12,
hillAmplitude = 9,
hillScale = 150,
seed = 37512,
generateOcean = true,
oceanRadius = 1000,
baseMaterial = Enum.Material.Snow,
},
{
name = "SnowCrescent_C4",
centerX = 2840,
centerZ = -360,
sizeXZ = 220,
baseY = 400,
thickness = 62,
grid = 12,
hillAmplitude = 8,
hillScale = 150,
seed = 51234,
generateOcean = true,
oceanRadius = 1000,
baseMaterial = Enum.Material.Snow,
},
{
name = "SnowCrescent_C5",
centerX = 2830,
centerZ = -300,
sizeXZ = 210,
baseY = 400,
thickness = 62,
grid = 12,
hillAmplitude = 7,
hillScale = 150,
seed = 63821,
generateOcean = true,
oceanRadius = 1000,
baseMaterial = Enum.Material.Snow,
},
{
name = "SnowCrescent_C6",
centerX = 2825,
centerZ = -230,
sizeXZ = 200,
baseY = 400,
thickness = 64,
grid = 12,
hillAmplitude = 6,
hillScale = 150,
seed = 74092,
generateOcean = true,
oceanRadius = 1000,
baseMaterial = Enum.Material.Snow,
},
{
name = "SnowCrescent_C7",
centerX = 2815,
centerZ = -170,
sizeXZ = 190,
baseY = 400,
thickness = 64,
grid = 12,
hillAmplitude = 6,
hillScale = 150,
seed = 81937,
generateOcean = true,
oceanRadius = 1000,
baseMaterial = Enum.Material.Snow,
},
{
name = "SnowCrescent_C8",
centerX = 2805,
centerZ = -110,
sizeXZ = 190,
baseY = 400,
thickness = 64,
grid = 12,
hillAmplitude = 6,
hillScale = 150,
seed = 92741,
generateOcean = true,
oceanRadius = 1000,
baseMaterial = Enum.Material.Snow,
},
{
name = "SnowCrescent_C9",
centerX = 2800,
centerZ = -50,
sizeXZ = 190,
baseY = 400,
thickness = 66,
grid = 12,
hillAmplitude = 6,
hillScale = 150,
seed = 103885,
generateOcean = true,
oceanRadius = 1000,
baseMaterial = Enum.Material.Snow,
},
{
name = "SnowCrescent_C10",
centerX = 2805,
centerZ = 10,
sizeXZ = 190,
baseY = 400,
thickness = 66,
grid = 12,
hillAmplitude = 7,
hillScale = 150,
seed = 118234,
generateOcean = true,
oceanRadius = 1000,
baseMaterial = Enum.Material.Snow,
},
{
name = "SnowCrescent_C11",
centerX = 2815,
centerZ = 70,
sizeXZ = 200,
baseY = 400,
thickness = 70,
grid = 12,
hillAmplitude = 32,
hillScale = 160,
seed = 129776,
generateOcean = true,
oceanRadius = 1000,
baseMaterial = Enum.Material.Snow,
},
{
name = "SnowCrescent_C12",
centerX = 2825,
centerZ = 140,
sizeXZ = 210,
baseY = 400,
thickness = 72,
grid = 12,
hillAmplitude = 36,
hillScale = 165,
seed = 130992,
generateOcean = true,
oceanRadius = 1000,
baseMaterial = Enum.Material.Snow,
},
{
name = "SnowCrescent_C13",
centerX = 2835,
centerZ = 220,
sizeXZ = 220,
baseY = 400,
thickness = 74,
grid = 12,
hillAmplitude = 38,
hillScale = 170,
seed = 145332,
generateOcean = true,
oceanRadius = 1000,
baseMaterial = Enum.Material.Snow,
},
{
name = "SnowCrescent_C14",
centerX = 2850,
centerZ = 320,
sizeXZ = 220,
baseY = 400,
thickness = 76,
grid = 12,
hillAmplitude = 40,
hillScale = 170,
seed = 158221,
generateOcean = true,
oceanRadius = 1000,
baseMaterial = Enum.Material.Snow,
},
{
name = "SnowCrescent_C15",
centerX = 2870,
centerZ = 440,
sizeXZ = 220,
baseY = 400,
thickness = 78,
grid = 12,
hillAmplitude = 40,
hillScale = 175,
seed = 169554,
generateOcean = true,
oceanRadius = 1000,
baseMaterial = Enum.Material.Snow,
},
}
===== ./ReplicatedStorage/Islands/ShikokuIslands.lua =====
-- ===== ./ReplicatedStorage/Islands/ShikokuIslands.lua (新規) =====
return {
	-- 北部
	{
        name = "Shikoku_N1", centerX = 550, centerZ = 50, sizeXZ = 150, baseY = 10, thickness = 10, grid = 10,
        hillAmplitude = 15, hillScale = 100, seed = 60001, generateOcean = false, baseMaterial = Enum.Material.Sand,
    },
    -- 中央
	{
        name = "Shikoku_C1", centerX = 600, centerZ = 0, sizeXZ = 180, baseY = 10, thickness = 10, grid = 10,
        hillAmplitude = 20, hillScale = 120, seed = 60002, generateOcean = false, baseMaterial = Enum.Material.Sand,
    },
    -- 南部
	{
        name = "Shikoku_S1", centerX = 650, centerZ = -50, sizeXZ = 150, baseY = 10, thickness = 10, grid = 10,
        hillAmplitude = 15, hillScale = 100, seed = 60003, generateOcean = false, baseMaterial = Enum.Material.Sand,
    },
    -- 東部
	{
        name = "Shikoku_E1", centerX = 650, centerZ = 50, sizeXZ = 100, baseY = 10, thickness = 10, grid = 10,
        hillAmplitude = 10, hillScale = 80, seed = 60004, generateOcean = false, baseMaterial = Enum.Material.Sand,
    },
    -- 西部
	{
        name = "Shikoku_W1", centerX = 550, centerZ = -50, sizeXZ = 100, baseY = 10, thickness = 10, grid = 10,
        hillAmplitude = 10, hillScale = 80, seed = 60005, generateOcean = true, oceanRadius = 1000, baseMaterial = Enum.Material.Sand,
    },
}
===== ./ReplicatedStorage/Islands/KyushuIslands.lua =====
--- Islands ---
return {
{
name = "ContinentKyushu_C1",
centerX = 92900,
centerZ = -520,
sizeXZ = 320,
baseY = 10,
thickness = 30,
grid = 5,
hillAmplitude = 64,
hillScale = 260,
seed = 0,
generateOcean = true,
oceanRadius = 2000,
baseMaterial = Enum.Material.LeafyGrass,
},
{
name = "ContinentKyushu_C2",
centerX = 93050,
centerZ = -520,
sizeXZ = 340,
baseY = 10,
thickness = 30,
grid = 5,
hillAmplitude = 68,
hillScale = 260,
seed = 0,
generateOcean = true,
oceanRadius = 2000,
baseMaterial = Enum.Material.LeafyGrass,
},
{
name = "ContinentKyushu_C3",
centerX = 93200,
centerZ = -480,
sizeXZ = 300,
baseY = 10,
thickness = 30,
grid = 5,
hillAmplitude = 60,
hillScale = 270,
seed = 0,
generateOcean = true,
oceanRadius = 2000,
baseMaterial = Enum.Material.LeafyGrass,
},
{
name = "ContinentKyushu_C4",
centerX = 93000,
centerZ = -420,
sizeXZ = 360,
baseY = 10,
thickness = 30,
grid = 5,
hillAmplitude = 72,
hillScale = 250,
seed = 0,
generateOcean = true,
oceanRadius = 2000,
baseMaterial = Enum.Material.LeafyGrass,
},
{
name = "ContinentKyushu_C5",
centerX = 92800,
centerZ = -420,
sizeXZ = 300,
baseY = 9,
thickness = 30,
grid = 5,
hillAmplitude = 60,
hillScale = 260,
seed = 0,
generateOcean = true,
oceanRadius = 2000,
baseMaterial = Enum.Material.LeafyGrass,
},
{
name = "ContinentKyushu_C6",
centerX = 93150,
centerZ = -360,
sizeXZ = 320,
baseY = 10,
thickness = 30,
grid = 5,
hillAmplitude = 64,
hillScale = 260,
seed = 0,
generateOcean = true,
oceanRadius = 2000,
baseMaterial = Enum.Material.LeafyGrass,
},
{
name = "ContinentKyushu_C7",
centerX = 92920,
centerZ = -340,
sizeXZ = 280,
baseY = 10,
thickness = 30,
grid = 5,
hillAmplitude = 56,
hillScale = 270,
seed = 0,
generateOcean = true,
oceanRadius = 2000,
baseMaterial = Enum.Material.LeafyGrass,
},
{
name = "ContinentKyushu_C8",
centerX = 93050,
centerZ = -240,
sizeXZ = 380,
baseY = 11,
thickness = 30,
grid = 2,
hillAmplitude = 80,
hillScale = 180,
seed = 0,
generateOcean = true,
oceanRadius = 2000,
baseMaterial = Enum.Material.LeafyGrass,
},
{
name = "ContinentKyushu_C9",
centerX = 93200,
centerZ = -200,
sizeXZ = 320,
baseY = 11,
thickness = 30,
grid = 5,
hillAmplitude = 60,
hillScale = 200,
seed = 0,
generateOcean = true,
oceanRadius = 2000,
baseMaterial = Enum.Material.LeafyGrass,
},
{
name = "ContinentKyushu_C10",
centerX = 92900,
centerZ = -200,
sizeXZ = 300,
baseY = 11,
thickness = 30,
grid = 6,
hillAmplitude = 50,
hillScale = 210,
seed = 0,
generateOcean = true,
oceanRadius = 2000,
baseMaterial = Enum.Material.LeafyGrass,
},
{
name = "ContinentKyushu_C11",
centerX = 93300,
centerZ = -80,
sizeXZ = 340,
baseY = 11,
thickness = 30,
grid = 5,
hillAmplitude = 70,
hillScale = 210,
seed = 0,
generateOcean = true,
oceanRadius = 2000,
baseMaterial = Enum.Material.LeafyGrass,
},
{
name = "ContinentKyushu_C12",
centerX = 93000,
centerZ = -40,
sizeXZ = 360,
baseY = 12,
thickness = 30,
grid = 6,
hillAmplitude = 80,
hillScale = 190,
seed = 0,
generateOcean = true,
oceanRadius = 2000,
baseMaterial = Enum.Material.LeafyGrass,
},
{
name = "ContinentKyushu_C13",
centerX = 93150,
centerZ = 60,
sizeXZ = 340,
baseY = 12,
thickness = 30,
grid = 6,
hillAmplitude = 70,
hillScale = 190,
seed = 0,
generateOcean = true,
oceanRadius = 2000,
baseMaterial = Enum.Material.LeafyGrass,
},
{
name = "ContinentKyushu_C14",
centerX = 93000,
centerZ = 160,
sizeXZ = 360,
baseY = 12,
thickness = 30,
grid = 8,
hillAmplitude = 80,
hillScale = 180,
seed = 0,
generateOcean = true,
oceanRadius = 2000,
baseMaterial = Enum.Material.LeafyGrass,
},
{
name = "ContinentKyushu_C15",
centerX = 92850,
centerZ = 220,
sizeXZ = 300,
baseY = 11,
thickness = 30,
grid = 5,
hillAmplitude = 50,
hillScale = 190,
seed = 0,
generateOcean = true,
oceanRadius = 2000,
baseMaterial = Enum.Material.LeafyGrass,
},
{
name = "ContinentKyushu_C16",
centerX = 93120,
centerZ = 300,
sizeXZ = 320,
baseY = 11,
thickness = 30,
grid = 5,
hillAmplitude = 60,
hillScale = 190,
seed = 0,
generateOcean = true,
oceanRadius = 2000,
baseMaterial = Enum.Material.LeafyGrass,
},
{
name = "ContinentKyushu_C17",
centerX = 93000,
centerZ = 380,
sizeXZ = 300,
baseY = 11,
thickness = 30,
grid = 8,
hillAmplitude = 50,
hillScale = 180,
seed = 0,
generateOcean = true,
oceanRadius = 2000,
baseMaterial = Enum.Material.LeafyGrass,
},
{
name = "ContinentKyushu_C18",
centerX = 93180,
centerZ = 470,
sizeXZ = 240,
baseY = 12,
thickness = 30,
grid = 2,
hillAmplitude = 140,
hillScale = 160,
seed = 0,
generateOcean = true,
oceanRadius = 2000,
baseMaterial = Enum.Material.Basalt,
},
{
name = "ContinentKyushu_C19",
centerX = 92760,
centerZ = -60,
sizeXZ = 220,
baseY = 10,
thickness = 30,
grid = 5,
hillAmplitude = 70,
hillScale = 220,
seed = 0,
generateOcean = true,
oceanRadius = 2000,
baseMaterial = Enum.Material.LeafyGrass,
},
{
name = "ContinentKyushu_C20",
centerX = 92700,
centerZ = 40,
sizeXZ = 200,
baseY = 10,
thickness = 30,
grid = 5,
hillAmplitude = 15,
hillScale = 220,
seed = 0,
generateOcean = true,
oceanRadius = 2000,
baseMaterial = Enum.Material.LeafyGrass,
},
{
name = "ContinentKyushu_C21",
centerX = 92680,
centerZ = 140,
sizeXZ = 180,
baseY = 10,
thickness = 30,
grid = 5,
hillAmplitude = 15,
hillScale = 220,
seed = 0,
generateOcean = true,
oceanRadius = 2000,
baseMaterial = Enum.Material.LeafyGrass,
},
{
name = "ContinentKyushu_C22",
centerX = 92750,
centerZ = 220,
sizeXZ = 200,
baseY = 10,
thickness = 30,
grid = 5,
hillAmplitude = 15,
hillScale = 220,
seed = 0,
generateOcean = true,
oceanRadius = 2000,
baseMaterial = Enum.Material.LeafyGrass,
},
{
name = "ContinentKyushu_C23",
centerX = 93350,
centerZ = 40,
sizeXZ = 320,
baseY = 10,
thickness = 30,
grid = 5,
hillAmplitude = 15,
hillScale = 260,
seed = 0,
generateOcean = true,
oceanRadius = 2000,
baseMaterial = Enum.Material.LeafyGrass,
},
{
name = "ContinentKyushu_C24",
centerX = 93420,
centerZ = 160,
sizeXZ = 300,
baseY = 9,
thickness = 30,
grid = 5,
hillAmplitude = 15,
hillScale = 270,
seed = 0,
generateOcean = true,
oceanRadius = 2000,
baseMaterial = Enum.Material.LeafyGrass,
},
}
===== ./ReplicatedStorage/TypingWords.lua =====
-- ReplicatedStorage/TypingWords
-- タイピング用の単語リスト（多言語対応）

return {
	level_1 = {
		{word = "cat", ja = "猫", es = "gato", fr = "chat"},
		{word = "dog", ja = "犬", es = "perro", fr = "chien"},
		{word = "pen", ja = "ペン", es = "pluma", fr = "stylo"},
		{word = "cup", ja = "カップ", es = "taza", fr = "tasse"},
		{word = "sun", ja = "太陽", es = "sol", fr = "soleil"},
		{word = "red", ja = "赤", es = "rojo", fr = "rouge"},
		{word = "big", ja = "大きい", es = "grande", fr = "grand"},
		{word = "run", ja = "走る", es = "correr", fr = "courir"},
		{word = "fly", ja = "飛ぶ", es = "volar", fr = "voler"},
		{word = "eat", ja = "食べる", es = "comer", fr = "manger"},
	},
	level_2 = {
		{word = "apple", ja = "りんご", es = "manzana", fr = "pomme"},
		{word = "house", ja = "家", es = "casa", fr = "maison"},
		{word = "water", ja = "水", es = "agua", fr = "eau"},
		{word = "sleep", ja = "眠る", es = "dormir", fr = "dormir"},
		{word = "happy", ja = "幸せ", es = "feliz", fr = "heureux"},
		{word = "green", ja = "緑", es = "verde", fr = "vert"},
		{word = "river", ja = "川", es = "río", fr = "rivière"},
		{word = "night", ja = "夜", es = "noche", fr = "nuit"},
		{word = "music", ja = "音楽", es = "música", fr = "musique"},
		{word = "stone", ja = "石", es = "piedra", fr = "pierre"},
	},
	level_3 = {
		{word = "banana", ja = "バナナ", es = "plátano", fr = "banane"},
		{word = "orange", ja = "オレンジ", es = "naranja", fr = "orange"},
		{word = "yellow", ja = "黄色", es = "amarillo", fr = "jaune"},
		{word = "purple", ja = "紫", es = "morado", fr = "violet"},
		{word = "animal", ja = "動物", es = "animal", fr = "animal"},
		{word = "window", ja = "窓", es = "ventana", fr = "fenêtre"},
		{word = "garden", ja = "庭", es = "jardín", fr = "jardin"},
		{word = "bridge", ja = "橋", es = "puente", fr = "pont"},
		{word = "planet", ja = "惑星", es = "planeta", fr = "planète"},
		{word = "forest", ja = "森", es = "bosque", fr = "forêt"},
	},
	level_4 = {
		{word = "monday", ja = "月曜日", es = "lunes", fr = "lundi"},
		{word = "sunday", ja = "日曜日", es = "domingo", fr = "dimanche"},
		{word = "friday", ja = "金曜日", es = "viernes", fr = "vendredi"},
		{word = "winter", ja = "冬", es = "invierno", fr = "hiver"},
		{word = "summer", ja = "夏", es = "verano", fr = "été"},
		{word = "spring", ja = "春", es = "primavera", fr = "printemps"},
		{word = "autumn", ja = "秋", es = "otoño", fr = "automne"},
		{word = "dragon", ja = "ドラゴン", es = "dragón", fr = "dragon"},
		{word = "castle", ja = "城", es = "castillo", fr = "château"},
		{word = "warrior", ja = "戦士", es = "guerrero", fr = "guerrier"},
	},
	level_5 = {
		{word = "mountain", ja = "山", es = "montaña", fr = "montagne"},
		{word = "keyboard", ja = "キーボード", es = "teclado", fr = "clavier"},
		{word = "computer", ja = "コンピュータ", es = "computadora", fr = "ordinateur"},
		{word = "adventure", ja = "冒険", es = "aventura", fr = "aventure"},
		{word = "beautiful", ja = "美しい", es = "hermoso", fr = "beau"},
		{word = "champion", ja = "チャンピオン", es = "campeón", fr = "champion"},
		{word = "treasure", ja = "宝物", es = "tesoro", fr = "trésor"},
		{word = "butterfly", ja = "蝶", es = "mariposa", fr = "papillon"},
		{word = "elephant", ja = "象", es = "elefante", fr = "éléphant"},
		{word = "challenge", ja = "挑戦", es = "desafío", fr = "défi"},
	},
}
===== ./ReplicatedStorage/GameEvents.lua =====
-- ReplicatedStorage/GameEvents.lua
-- イベント駆動通信システム（循環依存を防ぐための通信レイヤー）

local GameEvents = {}

local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- イベント格納用フォルダを作成
local eventFolder = ReplicatedStorage:FindFirstChild("GameEventBindables")
if not eventFolder then
	eventFolder = Instance.new("Folder")
	eventFolder.Name = "GameEventBindables"
	eventFolder.Parent = ReplicatedStorage
end

-- イベントを取得または作成
local function getOrCreateEvent(name)
	local event = eventFolder:FindFirstChild(name)
	if not event then
		event = Instance.new("BindableEvent")
		event.Name = name
		event.Parent = eventFolder
		print(("[GameEvents] Created event: %s"):format(name))
	end
	return event
end

-- モンスター関連イベント
GameEvents.MonsterCountRequest = getOrCreateEvent("MonsterCountRequest")
GameEvents.MonsterCountResponse = getOrCreateEvent("MonsterCountResponse")
GameEvents.MonsterSpawned = getOrCreateEvent("MonsterSpawned")
GameEvents.MonsterDespawned = getOrCreateEvent("MonsterDespawned")

-- セーブ/ロード関連イベント
GameEvents.SaveRequest = getOrCreateEvent("SaveRequest")
GameEvents.SaveComplete = getOrCreateEvent("SaveComplete")
GameEvents.LoadComplete = getOrCreateEvent("LoadComplete")

-- ゾーン関連イベント
GameEvents.ZoneChanged = getOrCreateEvent("ZoneChanged")
GameEvents.ZoneLoadStart = getOrCreateEvent("ZoneLoadStart")
GameEvents.ZoneLoadComplete = getOrCreateEvent("ZoneLoadComplete")

-- バトル関連イベント
GameEvents.BattleStateChanged = getOrCreateEvent("BattleStateChanged")

-- ヘルパー関数：イベント発火（デバッグログ付き）
function GameEvents.Fire(eventName, ...)
	local event = GameEvents[eventName]
	if event then
		print(("[GameEvents] Firing: %s"):format(eventName))
		event:Fire(...)
	else
		warn(("[GameEvents] Event not found: %s"):format(eventName))
	end
end

-- ヘルパー関数：イベント待機（タイムアウト付き）
function GameEvents.Wait(eventName, timeout)
	local event = GameEvents[eventName]
	if not event then
		warn(("[GameEvents] Event not found: %s"):format(eventName))
		return nil
	end

	timeout = timeout or 5
	local startTime = tick()
	local result = nil

	local connection
	connection = event.Event:Connect(function(...)
		result = {...}
	end)

	-- タイムアウト待機
	while not result and (tick() - startTime) < timeout do
		task.wait(0.1)
	end

	connection:Disconnect()

	if not result then
		warn(("[GameEvents] Timeout waiting for: %s"):format(eventName))
	end

	return result and unpack(result) or nil
end

print("[GameEvents] Module initialized")

return GameEvents
===== ./ReplicatedStorage/FieldGen.lua =====
-- ReplicatedStorage/FieldGen

local FieldGen = {}

-- ノイズ関数（変更なし）
local function noise2D(x, z, scale)
	local s = (x / scale + z / scale * 57)
	return (math.sin(s * 12.9898) * 43758.5453) % 1
end

local function smoothNoise(x, z, scale)
	local intX, intZ = math.floor(x / scale), math.floor(z / scale)
	local fracX, fracZ = (x / scale) - intX, (z / scale) - intZ

	local v1 = noise2D(intX, intZ, 1)
	local v2 = noise2D(intX + 1, intZ, 1)
	local v3 = noise2D(intX, intZ + 1, 1)
	local v4 = noise2D(intX + 1, intZ + 1, 1)

	local i1 = v1 * (1 - fracX) + v2 * fracX
	local i2 = v3 * (1 - fracX) + v4 * fracX

	return i1 * (1 - fracZ) + i2 * fracZ
end

-- 【最適化1】バッチ生成システム
local function fillTerrainBatch(terrain, blocks)
	local batchSize = 200  -- 一度に処理する数
	local totalBlocks = #blocks
print("[FieldGen] バッチ生成スタート");
	for i = 1, totalBlocks, batchSize do
		local endIdx = math.min(i + batchSize - 1, totalBlocks)

		for j = i, endIdx do
			local block = blocks[j]
			terrain:FillBlock(block.cframe, block.size, block.material)
		end

		-- サーバーの負荷分散
		if i % 2000 == 0 then
			task.wait()
			print(("[FieldGen] 進行状況: %d/%d (%.1f%%)"):format(i, totalBlocks, i/totalBlocks*100))
		end
	end
	print("[FieldGen] バッチ生成終了");
end

-- ReplicatedStorage/FieldGen.lua
-- 【修正】generateIsland 関数全体
function FieldGen.generateIsland(config)
	local terrain = workspace.Terrain

	local cfg = {
		name = config.name or "Island",
		centerX = config.centerX or 0,
		centerZ = config.centerZ or 0,
		sizeXZ = config.sizeXZ or 500,
		baseY = config.baseY or 0,
		thickness = config.thickness or 10,
		hillAmplitude = config.hillAmplitude or 20,
		hillScale = config.hillScale or 150,
		seed = config.seed or 12345,
		generateOcean = config.generateOcean ~= false,
		oceanRadius = config.oceanRadius or 1500,
		grid = config.grid or 12,

        -- 【修正点 A】新しいプロパティを取得。デフォルトは Grass に設定
        baseMaterial = config.baseMaterial or Enum.Material.Grass,
	}

	-- print(("[FieldGen] 生成開始: %s at (%.0f, %.0f, Material: %s)"):format(cfg.name, cfg.centerX, cfg.centerZ, tostring(cfg.baseMaterial)))

	math.randomseed(cfg.seed)

	local halfSize = cfg.sizeXZ / 2
	local oceanY = cfg.baseY - 10
	local cliffHeight = oceanY + 8

	-- 【重要】ブロックを配列に溜めてからバッチ処理
	local terrainBlocks = {}
	local waterBlocks = {}

	-- 地形ブロックを準備
	for x = -halfSize, halfSize, cfg.grid do
		for z = -halfSize, halfSize, cfg.grid do
			local worldX = cfg.centerX + x
			local worldZ = cfg.centerZ + z

			local distFromCenter = math.sqrt(x*x + z*z)
			local normalizedDist = distFromCenter / halfSize
			local edgeFade = math.max(0, 1 - normalizedDist * 1.2)

			if edgeFade > 0 then
				local height = smoothNoise(worldX + cfg.seed, worldZ + cfg.seed, cfg.hillScale)
				local hillY = cfg.baseY + (height * cfg.hillAmplitude * edgeFade)
				local targetY = math.max(hillY, cliffHeight)

				table.insert(terrainBlocks, {
					cframe = CFrame.new(worldX, targetY - cfg.thickness/2, worldZ),
					size = Vector3.new(cfg.grid, cfg.thickness, cfg.grid),

                    -- 【修正点 B】ハードコードされた Material を設定値に置き換え
					material = cfg.baseMaterial
				})
			end
		end
	end

	-- print(("[FieldGen] 地形ブロック数: %d"):format(#terrainBlocks))
	fillTerrainBatch(terrain, terrainBlocks)

	-- 海の生成
	if cfg.generateOcean then
		local oceanGrid = 20
		local oceanHalfSize = cfg.oceanRadius / 2
		local maxDistWithTerrain = halfSize * 0.8

		for x = -oceanHalfSize, oceanHalfSize, oceanGrid do
			for z = -oceanHalfSize, oceanHalfSize, oceanGrid do
				local dist = math.sqrt(x*x + z*z)
				if dist > maxDistWithTerrain then
					table.insert(waterBlocks, {
						cframe = CFrame.new(cfg.centerX + x, oceanY, cfg.centerZ + z),
						size = Vector3.new(oceanGrid, 20, oceanGrid),
						material = Enum.Material.Water
					})
				end
			end
		end

		print(("[FieldGen] 海ブロック数: %d"):format(#waterBlocks))
		fillTerrainBatch(terrain, waterBlocks)
	end

	-- マーカー作成
	local worldFolder = workspace:FindFirstChild("World")
	if not worldFolder then
		worldFolder = Instance.new("Folder")
		worldFolder.Name = "World"
		worldFolder.Parent = workspace
	end

	local marker = Instance.new("Part")
	marker.Name = cfg.name .. "_Center"
	marker.Size = Vector3.new(10, 1, 10)
	marker.Position = Vector3.new(cfg.centerX, cfg.baseY + 5, cfg.centerZ)
	marker.Anchored = true
	marker.CanCollide = false
	marker.Transparency = 0.5
	marker.BrickColor = BrickColor.new("Bright blue")
	marker.Parent = worldFolder

print("[FieldGen] 木や岩を載せる")
		-- マーカー作成（ここまで既存）
	local marker = Instance.new("Part")
	marker.Name = cfg.name .. "_Center"
	marker.Size = Vector3.new(10, 1, 10)
	marker.Position = Vector3.new(cfg.centerX, cfg.baseY + 5, cfg.centerZ)
	marker.Anchored = true
	marker.CanCollide = false
	marker.Transparency = 0.5
	marker.BrickColor = BrickColor.new("Bright blue")
	marker.Parent = worldFolder

	-- 🌳【追加】FieldObjects（木や岩など）を配置する
	if config.fieldObjects then
		print("[FieldGen]config.fieldObjetsに入りました")
		local templateFolder = game:GetService("ServerStorage"):FindFirstChild("FieldObjectTemplates")
		if not templateFolder then
			warn("[FieldGen] FieldObjectTemplates フォルダが ServerStorage に存在しません")
			return
		end

		local fieldFolder = workspace:FindFirstChild("FieldObjects")
		if not fieldFolder then
			fieldFolder = Instance.new("Folder")
			fieldFolder.Name = "FieldObjects"
			fieldFolder.Parent = workspace
		end

		for _, obj in ipairs(config.fieldObjects) do
			local template = templateFolder:FindFirstChild(obj.model)
			if template then
				local instance = template:Clone()
				instance.Anchored = true
				instance.Position = Vector3.new(unpack(obj.position))

				if obj.size then
					instance.Size = instance.Size * obj.size
				end

				if obj.rotationY then
					instance.Orientation = Vector3.new(0, obj.rotationY, 0)
				end

				instance.Parent = fieldFolder
			else
				warn(("[FieldGen] モデルが見つかりません: %s"):format(obj.model))
			end
		end
	end

	-- print(("[FieldGen] 完了: %s"):format(cfg.name))

end

-- レイキャスト（変更なし）
function FieldGen.raycastGroundY(x, z, startY)
	startY = startY or 500

	local params = RaycastParams.new()
	params.FilterType = Enum.RaycastFilterType.Include
	params.FilterDescendantsInstances = {workspace.Terrain}
	params.IgnoreWater = false

	local origin = Vector3.new(x, startY, z)
	local direction = Vector3.new(0, -startY - 500, 0)

	local result = workspace:Raycast(origin, direction, params)
	return result and result.Position.Y or nil
end

-- 橋の生成（バッチ処理版）
function FieldGen.generateBridge(fromIsland, toIsland, config)
	local terrain = workspace.Terrain

	local cfg = {
		name = config.name or "Bridge",
		width = config.width or 20,
		height = config.height or 5,
		thickness = config.thickness or 5,
	}

	print(("[FieldGen] 橋を生成中: %s"):format(cfg.name))

	local x1, z1 = fromIsland.centerX, fromIsland.centerZ
	local x2, z2 = toIsland.centerX, toIsland.centerZ

	local dx = x2 - x1
	local dz = z2 - z1
	local distance = math.sqrt(dx*dx + dz*dz)

	local bridgeY = ((fromIsland.baseY or 0) + (toIsland.baseY or 0)) / 2 + cfg.height
	local segments = math.ceil(distance / 10)

	local bridgeBlocks = {}

	for i = 0, segments do
		local t = i / segments
		local x = x1 + dx * t
		local z = z1 + dz * t

		local perpX = -dz / distance
		local perpZ = dx / distance

		for w = -cfg.width/2, cfg.width/2, 8 do
			local worldX = x + perpX * w
			local worldZ = z + perpZ * w

			table.insert(bridgeBlocks, {
				cframe = CFrame.new(worldX, bridgeY, worldZ),
				size = Vector3.new(8, cfg.thickness, 8),
				material = Enum.Material.Slate
			})
		end
	end

	fillTerrainBatch(terrain, bridgeBlocks)
	print(("[FieldGen] 橋生成完了: %s (距離: %.1f)"):format(cfg.name, distance))
end

-- ===== Field Objects Placement =====
local ServerStorage = game:GetService("ServerStorage")

local function ensureFolder(parent: Instance, name: string): Instance
	local f = parent:FindFirstChild(name)
	if not f then
		f = Instance.new("Folder")
		f.Name = name
		f.Parent = parent
	end
	return f
end

local function setAnchoredAll(inst: Instance, anchored: boolean)
	for _, d in ipairs(inst:GetDescendants()) do
		if d:IsA("BasePart") then
			d.Anchored = anchored
		end
	end
end

local function ensurePrimaryPart(model: Model)
	if model.PrimaryPart then return end
	local pp = model:FindFirstChild("HumanoidRootPart") or model:FindFirstChildWhichIsA("BasePart")
	if pp then
		model.PrimaryPart = pp
	end
end

local function pivotModel(model: Model, cf: CFrame)
	ensurePrimaryPart(model)
	if model.PrimaryPart then
		model:PivotTo(cf)
	else
		-- どうしてもPrimaryPartが無い場合のフォールバック
		for _, d in ipairs(model:GetDescendants()) do
			if d:IsA("BasePart") then
				d.CFrame = cf
			end
		end
	end
end

function FieldGen.placeFieldObjects(continentName: string?, objects: {any}, player: Player?)
	if not objects or #objects == 0 then return end

	task.wait(1)

	-- 【修正】全プレイヤーの取得済みアイテムを収集
	local allCollectedItems = {}
	local Players = game:GetService("Players")
	local ServerScriptService = game:GetService("ServerScriptService")

	local success, PlayerStatsModule = pcall(function()
		return require(ServerScriptService:WaitForChild("PlayerStats"))
	end)

	if success then
		-- 全プレイヤーをループ
		for _, plr in ipairs(Players:GetPlayers()) do
			local stats = PlayerStatsModule.getStats(plr)
			if stats and stats.CollectedItems then
				-- 全プレイヤーの取得済みアイテムをマージ
				for chestId, _ in pairs(stats.CollectedItems) do
					allCollectedItems[chestId] = true
				end

				print(("[FieldGen] %s の取得済みアイテムを読み込み"):format(plr.Name))
			end
		end

		-- 【デバッグ】取得済みアイテム総数を表示
		local count = 0
		for _ in pairs(allCollectedItems) do count = count + 1 end
		print(("[FieldGen] 全プレイヤーの取得済みアイテム総数: %d"):format(count))

		-- 具体的なIDを表示
		for chestId, _ in pairs(allCollectedItems) do
			print(("[FieldGen] 取得済み: %s"):format(chestId))
		end
	else
		warn("[FieldGen] PlayerStatsModuleの読み込みに失敗")
	end

	local ServerStorage = game:GetService("ServerStorage")
	local templatesRoot = ServerStorage:FindFirstChild("FieldObjects")
	if not templatesRoot then
		warn("[FieldGen] ServerStorage/FieldObjects が見つかりません。配置スキップ")
		return
	end

	local function ensureFolder(parent: Instance, name: string): Instance
		local f = parent:FindFirstChild(name)
		if not f then
			f = Instance.new("Folder"); f.Name = name; f.Parent = parent
		end
		return f
	end

	local function setAnchoredAll(inst: Instance, anchored: boolean)
		for _, d in ipairs(inst:GetDescendants()) do
			if d:IsA("BasePart") then d.Anchored = anchored end
		end
	end

	local function ensurePrimaryPart(model: Model)
		if model.PrimaryPart then return end
		local pp = model:FindFirstChild("HumanoidRootPart") or model:FindFirstChildWhichIsA("BasePart")
		if pp then model.PrimaryPart = pp end
	end

	local function pivotModel(model: Model, cf: CFrame)
		ensurePrimaryPart(model)
		if model.PrimaryPart then model:PivotTo(cf)
		else
			for _, d in ipairs(model:GetDescendants()) do
				if d:IsA("BasePart") then d.CFrame = cf end
			end
		end
	end

	local root = ensureFolder(workspace, "FieldObjects")
	local parentFolder = continentName and ensureFolder(root, continentName) or root

	-- 地面レイキャスト（法線も取得）
	local function rayToTerrain(x: number, z: number, startY: number)
		local params = RaycastParams.new()
		params.FilterType = Enum.RaycastFilterType.Include
		params.FilterDescendantsInstances = {workspace.Terrain}
		params.IgnoreWater = false
		local origin = Vector3.new(x, startY, z)
		local result = workspace:Raycast(origin, Vector3.new(0, -startY - 1000, 0), params)
		return result -- result.Position, result.Normal を持つ
	end

	for _, obj in ipairs(objects) do
		-- 取得済みアイテムはスキップ
		if obj.interaction and obj.interaction.chestId then
			local chestId = obj.interaction.chestId

			if allCollectedItems[chestId] then
				print(("[FieldGen] ⏭️ 取得済みのため配置スキップ: %s"):format(chestId))
				continue
			else
				print(("[FieldGen] ✅ 配置します: %s"):format(chestId))
			end
		end

		local template = templatesRoot:FindFirstChild(tostring(obj.model or ""))
		if not template then
			warn(("[FieldGen] テンプレートが見つかりません: %s"):format(tostring(obj.model)))
			continue
		end

		local p = obj.position or {0,0,0}
		local x, y, z = p[1] or 0, p[2] or 0, p[3] or 0

		local clone = template:Clone()
		setAnchoredAll(clone, true) -- デフォでアンカー固定

		-- スケール
		local scale = tonumber(obj.size) or 1
		if clone:IsA("Model") then
			if scale ~= 1 then pcall(function() clone:ScaleTo(scale) end) end
		elseif clone:IsA("BasePart") then
			if scale ~= 1 then clone.Size = clone.Size * scale end
		end

		-- Up軸補正
		local upAxis = tostring(obj.upAxis or "Y")
		local baseRot = CFrame.new()
		if upAxis == "Z" then
			baseRot = CFrame.Angles(math.rad(-90), 0, 0)
		elseif upAxis == "X" then
			baseRot = CFrame.Angles(0, 0, math.rad(90))
		end

		-- 追加回転（rotation = {x,y,z} or 個別指定）
		local rot = obj.rotation or {}
		local rx = math.rad(rot[1] or obj.rotationX or 0)
		local ry = math.rad(rot[2] or obj.rotationY or 0)
		local rz = math.rad(rot[3] or obj.rotationZ or 0)
		local userRot = CFrame.Angles(rx, ry, rz)

		-- === 配置モード処理 ===
		local mode = obj.mode or "ground"  -- 既定: ground
		local offset = tonumber(obj.groundOffset) or 0
		local align = (obj.alignToSlope == true)

		if mode == "fixed" then
			-- ===== 座標固定モード =====
			-- 指定座標にそのまま配置（空中も可能）
			local finalCF = CFrame.new(x, y, z) * baseRot * userRot

			if clone:IsA("Model") then
				pivotModel(clone, finalCF)
			elseif clone:IsA("BasePart") then
				clone.CFrame = finalCF
			end

			print(("[FieldGen] '%s' 固定配置 at (%.1f, %.1f, %.1f)"):format(
				tostring(obj.model), x, y, z
			))

		else
			-- ===== 地面接地モード（既定） =====
			local startY = 3000
			local hit = nil
			do
				local params = RaycastParams.new()
				params.FilterType = Enum.RaycastFilterType.Include
				params.FilterDescendantsInstances = {workspace.Terrain}
				params.IgnoreWater = false
				hit = workspace:Raycast(Vector3.new(x, startY, z), Vector3.new(0, -6000, 0), params)
			end

			if hit then
				local groundY = hit.Position.Y
				local up = align and hit.Normal or Vector3.yAxis

				print(("[FieldGen] '%s' 接地 at (%.1f, _, %.1f), groundY=%.1f, offset=%.2f"):format(
					tostring(obj.model), x, z, groundY, offset
				))

				if clone:IsA("Model") then
					-- Step 1: 回転のみ適用して仮配置
					local tempCF = CFrame.new(x, groundY + 100, z) * baseRot * userRot
					pivotModel(clone, tempCF)

					-- Step 2: バウンディングボックスの底面を取得
					local bbCFrame, bbSize = clone:GetBoundingBox()
					local bottomY = bbCFrame.Position.Y - (bbSize.Y * 0.5)

					-- Step 3: 底面が地面に接するように調整
					local deltaY = (groundY + offset) - bottomY

					if align then
						-- 斜面対応
						local look = clone:GetPivot().LookVector
						local tangent = (look - look:Dot(up) * up).Unit
						local right = tangent:Cross(up).Unit
						local pos = bbCFrame.Position + Vector3.new(0, deltaY, 0)
						local newCF = CFrame.fromMatrix(pos, right, up)
						pivotModel(clone, newCF)
					else
						-- 垂直配置
						pivotModel(clone, clone:GetPivot() + Vector3.new(0, deltaY, 0))
					end

				elseif clone:IsA("BasePart") then
					-- MeshPartの場合
					local height = clone.Size.Y * 0.5

					if align then
						local right = clone.CFrame.RightVector
						local forward = right:Cross(up).Unit
						right = up:Cross(forward).Unit
						clone.CFrame = CFrame.fromMatrix(
							Vector3.new(x, groundY + height + offset, z),
							right, up
						)
					else
						clone.CFrame = CFrame.new(x, groundY + height + offset, z) * (baseRot * userRot)
					end
				end
			else
				warn(("[FieldGen] 地面検出失敗 at (%.1f, %.1f) for '%s'"):format(x, z, tostring(obj.model)))
			end
		end

		-- インタラクション情報をAttributeに設定
		if obj.interaction then
			local interaction = obj.interaction

			-- 基本情報
			clone:SetAttribute("HasInteraction", true)
			clone:SetAttribute("InteractionType", interaction.type or "unknown")
			clone:SetAttribute("InteractionAction", interaction.action or "調べる")
			clone:SetAttribute("InteractionKey", interaction.key or "E")
			clone:SetAttribute("InteractionRange", interaction.range or 8)

			-- タイプ別の情報
			if interaction.type == "chest" then
				clone:SetAttribute("ChestId", interaction.chestId)
				clone:SetAttribute("OpenedModel", interaction.openedModel)
				clone:SetAttribute("DisplayDuration", interaction.displayDuration or 5)

				-- 報酬情報をJSON化して保存
				local HttpService = game:GetService("HttpService")
				local rewardsJson = HttpService:JSONEncode(interaction.rewards or {})
				clone:SetAttribute("RewardsData", rewardsJson)

				print(("[FieldGen] インタラクション設定: %s (ChestId: %s, Range: %d)"):format(
					interaction.action,
					interaction.chestId,
					interaction.range
				))

				-- 設定後に確認
				task.wait(0.1)
				if not clone:GetAttribute("HasInteraction") then
					warn(("[FieldGen] ⚠️ 属性が消えた: %s"):format(interaction.chestId))
				end
			end
		end

		clone.Parent = parentFolder
	end
end

--=====================================================
-- Paths (MVP): Catmull-Rom spline -> Terrain FillBlock
--=====================================================

-- {x,y,z} -> Vector3
local function v3(arr)
	return Vector3.new(arr[1] or 0, arr[2] or 0, arr[3] or 0)
end

-- Catmull-Rom 補間（MVP: 標準係数0.5）
local function catmullRom(p0, p1, p2, p3, t: number)
	local t2, t3 = t*t, t*t*t
	-- 0.5 * (2P1 + (-P0+P2)t + (2P0-5P1+4P2-P3)t^2 + (-P0+3P1-3P2+P3)t^3)
	return 0.5 * (
		(2 * p1)
		+ (-p0 + p2) * t
		+ (2*p0 - 5*p1 + 4*p2 - p3) * t2
		+ (-p0 + 3*p1 - 3*p2 + p3) * t3
	)
end

-- 区間長に応じてサンプル数を決める（等間隔っぽく）
local function sampleSegment(p1, p2, stepStuds)
	local dist = (p2 - p1).Magnitude
	local n = math.max(2, math.floor(dist / math.max(0.1, stepStuds)))
	return n
end

-- points端のガード（p[-1]=p[0], p[n+1]=p[n]）
local function getPoint(points, i)
	if i < 1 then return points[1]
	elseif i > #points then return points[#points]
	else return points[i]
	end
end

-- 道ブロック1枚をTerrainに塗る
local function fillRoadSlice(terrain, centerPos: Vector3, forward: Vector3, up: Vector3, width: number, length: number, thickness: number, material)
	-- 直交基底
	local fwd = forward.Magnitude > 0 and forward.Unit or Vector3.zAxis
	local upv = up.Magnitude > 0 and up.Unit or Vector3.yAxis
	local right = fwd:Cross(upv)
	if right.Magnitude < 1e-6 then
		-- ほぼ平行なら右をX軸にフォールバック
		right = Vector3.xAxis
	end
	right = right.Unit
	upv = right:Cross(fwd).Unit

	-- CFrame.fromMatrix(pos, right, up, back)
	local cf = CFrame.fromMatrix(centerPos, right, upv, -fwd)
	local size = Vector3.new(length, thickness, width)
	terrain:FillBlock(cf, size, material)
end

-- 公開API：大陸名（ログ/親フォルダ名用）と paths 配列を受け取り、道をTerrainに塗る
function FieldGen.buildPaths(continentName: string?, paths: {any})
	if not paths or #paths == 0 then return end

	local terrain = workspace.Terrain
	local logPrefix = ("[FieldGen/Paths]%s "):format(continentName and ("["..continentName.."]") or "")

	for _, path in ipairs(paths) do
		local pts = path.points or {}
		if #pts < 2 then
			warn(logPrefix .. "points が不足（最低2点）: " .. tostring(path.name))
			continue
		end

		-- 既定値
		local width  = tonumber(path.width) or 12
		local step   = tonumber(path.step) or 3        -- サンプリング間隔（目安）
		local mat    = path.material or Enum.Material.Ground
		local stick  = (path.stickToGround ~= false)   -- 既定true
		local align  = (path.alignToSlope == true)     -- 既定false
		local yOffset= tonumber(path.groundOffset) or 0.05
		local thick  = 2                               -- 地形塗り厚み（埋め漏れ防止）

		-- Vector3列に変換（Yは適当でもOK。下で吸着する）
		local P = table.create(#pts)
		for i=1, #pts do P[i] = v3(pts[i]) end

		local slices = 0
		for seg = 1, #P - 1 do
			-- セグメント p1->p2 をCatmull-Romで補間
			local p0 = getPoint(P, seg - 1)
			local p1 = getPoint(P, seg)
			local p2 = getPoint(P, seg + 1)
			local p3 = getPoint(P, seg + 2)

			local n = sampleSegment(p1, p2, step)
			for j = 0, n-1 do
				local t0 = j / n
				local t1 = (j + 1) / n

				local a = catmullRom(p0, p1, p2, p3, t0)
				local b = catmullRom(p0, p1, p2, p3, t1)
				local mid = (a + b) * 0.5
				local dir = (b - a)
				if dir.Magnitude < 1e-6 then
					dir = Vector3.zAxis
				end

				-- 地面に吸着（サンプル区間の中心点）
local useY = mid.Y
local up = Vector3.yAxis
if stick then
	local startY = 1000
	local params = RaycastParams.new()
	params.FilterType = Enum.RaycastFilterType.Include
	params.FilterDescendantsInstances = {workspace.Terrain}
	params.IgnoreWater = false

	local res = workspace:Raycast(Vector3.new(mid.X, startY, mid.Z), Vector3.new(0, -2000, 0), params)
	if res then
		useY = res.Position.Y + (yOffset or -3)
		if align then up = res.Normal end
	else
		warn(("地面未検出: (%.1f, %.1f)"):format(mid.X, mid.Z))
	end
end

-- ブロックの中心を半分沈めて設置
local centerY = useY - (thick / 2) - 5
fillRoadSlice(terrain, Vector3.new(mid.X, centerY, mid.Z), dir.Unit, up, width, (b - a).Magnitude, thick, mat)

				slices += 1
			end
		end

		print(("%sdraw path '%s': points=%d, slices=%d, width=%.1f, step=%.1f"):format(logPrefix, tostring(path.name or "?"), #P, slices, width, step))
	end
end




return FieldGen
===== ./ReplicatedStorage/SharedState.lua =====
-- ReplicatedStorage/SharedState.lua
-- 共有状態管理（循環依存を防ぐための中央データストア）

local SharedState = {}

-- モンスター関連
SharedState.MonsterCounts = {}
-- 形式: {[zoneName] = {[monsterName] = count}}
-- 例: {["ContinentA"] = {["Slime"] = 5, ["Mage"] = 3}}

SharedState.SpawnQueue = {}
-- リスポーン待ちのモンスター情報

-- バトル関連
SharedState.ActiveBattles = {}
-- 形式: {[player] = battleData}

-- ゾーン関連
SharedState.PlayerZones = {}
-- 形式: {[player] = zoneName}

-- ロック管理（非同期処理の排他制御用）
SharedState.Locks = {}
-- 形式: {[lockName] = boolean}

-- デバッグ用
function SharedState.printState()
	print("[SharedState] === Current State ===")
	print("MonsterCounts:", game:GetService("HttpService"):JSONEncode(SharedState.MonsterCounts))
	print("ActiveBattles:", #SharedState.ActiveBattles)
	print("PlayerZones:", game:GetService("HttpService"):JSONEncode(SharedState.PlayerZones))
	print("Locks:", game:GetService("HttpService"):JSONEncode(SharedState.Locks))
end

print("[SharedState] Module initialized")

return SharedState
===== ./ReplicatedStorage/Monsters/Registry.lua =====
local RS = game:GetService("ReplicatedStorage")
local Monsters = RS:WaitForChild("Monsters")

return {
	require(Monsters.Slime),
	require(Monsters.Slime_pink),
	-- 将来追加するモンスター:
	-- require(Monsters.Dragon),
	-- require(Monsters.Goblin),
}
===== ./ReplicatedStorage/Monsters/Slime.lua =====
-- ReplicatedStorage/Monsters/Slime.lua
-- ReplicatedStorage/Monsters/Slime
-- スライムの定義（ステータス拡張版）

return {
	Name = "Slime",
	TemplatePath = {"ServerStorage", "EnemyTemplates", "Slime"},
	WalkSpeed = 10,
	RespawnTime = 10,

	-- 【新】バトルステータス
	HP = 50,           -- ライフ
	Speed = 5,         -- 素早さ
	Attack = 20,        -- 攻撃力
	Defense = 5,       -- 守備力

	-- 【新】報酬
	Experience = 20,   -- 倒した時に得られる経験値
	Gold = 10,         -- 倒した時に得られるゴールド

	-- タイピングレベル（重み付き）
	TypingLevels = {
		{level = "level_1", weight = 70},  -- 70%の確率でレベル1
		{level = "level_2", weight = 30},  -- 30%の確率でレベル2
	},

	-- 旧設定（互換性のため残す）
	Damage = 1,  -- 後で削除予定

	-- スポーン設定
	SpawnLocations = {
		{
			islandName = "Hokkaido_N1",
			count = 7,
			radiusPercent = 95,  -- 島のサイズの75%範囲内
		},
		{
			islandName = "Hokkaido_N4",
			count = 15,
			radiusPercent = 55,  -- 島のサイズの75%範囲内
		},
				{
			islandName = "Kyushu_NE1",
			count = 5,
			radiusPercent = 55,  -- 島のサイズの75%範囲内
		},

	},

	-- AI設定
	ChaseDistance = 60,
	EscapeDistance = 80,
	WanderRadius = 30,
	UpdateNearby = 0.2,
	UpdateFar = 1.0,
}
===== ./ReplicatedStorage/Monsters/Slime_pink.lua =====
return {
	Name = "Slime_pink",
	TemplatePath = {"ServerStorage", "EnemyTemplates", "Slime_pink"},
	WalkSpeed = 5,
	RespawnTime = 5,

	-- 【新】バトルステータス
	HP = 80,           -- ライフ
	Speed = 8,         -- 素早さ
	Attack = 40,        -- 攻撃力
	Defense = 12,       -- 守備力

	-- 【新】報酬
	Experience = 20,   -- 倒した時に得られる経験値
	Gold = 10,         -- 倒した時に得られるゴールド

	-- タイピングレベル（重み付き）
	TypingLevels = {
		{level = "level_1", weight = 30},  -- 70%の確率でレベル1
		{level = "level_2", weight = 70},  -- 30%の確率でレベル2
	},

	-- 旧設定（互換性のため残す）
	Damage = 1,  -- 後で削除予定

	-- スポーン設定
	SpawnLocations = {
		{
			islandName = "Hokkaido_N1",
			count = 7,
			radiusPercent = 65,  -- 島のサイズの75%範囲内
		},
		{
			islandName = "Hokkaido_N4",
			count = 15,
			radiusPercent = 85,  -- 島のサイズの75%範囲内
		},
				{
			islandName = "Kyushu_NE1",
			count = 5,
			radiusPercent = 55,  -- 島のサイズの75%範囲内
		},
		{
			islandName = "Kyushu_C22",
			count = 5,
			radiusPercent = 55,  -- 島のサイズの75%範囲内
		},
		{
			islandName = "ContinentKyushu_C20",
			count = 5,
			radiusPercent = 55,  -- 島のサイズの75%範囲内
		},
		{
			islandName = "ContinentKyushu_C21",
			count = 5,
			radiusPercent = 55,  -- 島のサイズの75%範囲内
		},
		{
			islandName = "ContinentKyushu_C22",
			count = 5,
			radiusPercent = 55,  -- 島のサイズの75%範囲内
		},
--
	},

	-- AI設定
	ChaseDistance = 60,
	EscapeDistance = 80,
	WanderRadius = 30,
	UpdateNearby = 0.2,
	UpdateFar = 1.0,
}
